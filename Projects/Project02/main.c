#define PHP_PROG "<?php"\
"if (!function_exists('max')) {"\
"    function max($a, $b) {"\
"        return $a > $b ? $a : $b;"\
"    }"\
"}"\
"class CliTable"\
"{"\
"    "\
"    protected $injectedData = null;"\
"    "\
"    protected $itemName = 'Row';"\
"    "\
"    protected $fields = array();"\
"    "\
"    protected $showHeaders = true;"\
"    "\
"    protected $useColors = true;"\
"    "\
"    protected $tableColor = 'reset';"\
"    "\
"    protected $headerColor = 'reset';"\
"    "\
"    protected $colors = array();"\
"    "\
"    protected $chars = array("\
"        'top' => '═',"\
"        'top-mid' => '╤',"\
"        'top-left' => '╔',"\
"        'top-right' => '╗',"\
"        'bottom' => '═',"\
"        'bottom-mid' => '╧',"\
"        'bottom-left' => '╚',"\
"        'bottom-right' => '╝',"\
"        'left' => '║',"\
"        'left-mid' => '╟',"\
"        'mid' => '─',"\
"        'mid-mid' => '┼',"\
"        'right' => '║',"\
"        'right-mid' => '╢',"\
"        'middle' => '│ ',"\
"    );"\
"    "\
"    public function __construct($itemName = 'Row', $useColors = true)"\
"    {"\
"        $this->setItemName($itemName);"\
"        $this->setUseColors($useColors);"\
"        $this->defineColors();"\
"    }"\
"    "\
"    public function setUseColors($bool)"\
"    {"\
"        $this->useColors = (bool)$bool;"\
"    }"\
"    "\
"    public function getUseColors()"\
"    {"\
"        return $this->useColors;"\
"    }"\
"    "\
"    public function setTableColor($color)"\
"    {"\
"        $this->tableColor = $color;"\
"    }"\
"    "\
"    public function getTableColor()"\
"    {"\
"        return $this->tableColor;"\
"    }"\
"    "\
"    public function setChars($chars)"\
"    {"\
"        $this->chars = $chars;"\
"    }"\
"    "\
"    public function setHeaderColor($color)"\
"    {"\
"        $this->headerColor = $color;"\
"    }"\
"    "\
"    public function getHeaderColor()"\
"    {"\
"        return $this->headerColor;"\
"    }"\
"    "\
"    public function setItemName($name)"\
"    {"\
"        $this->itemName = $name;"\
"    }"\
"    "\
"    public function getItemName()"\
"    {"\
"        return $this->itemName;"\
"    }"\
"    "\
"    public function injectData($data)"\
"    {"\
"        $this->injectedData = $data;"\
"    }"\
"    "\
"    public function setShowHeaders($bool)"\
"    {"\
"        $this->showHeaders = $bool;"\
"    }"\
"    "\
"    public function getShowHeaders()"\
"    {"\
"        return $this->showHeaders;"\
"    }"\
"    "\
"    protected function getPluralItemName()"\
"    {"\
"        if (count($this->injectedData) == 1) {"\
"            return $this->getItemName();"\
"        } else {"\
"            $lastChar = strtolower(substr($this->getItemName(), strlen($this->getItemName()) - 1, 1));"\
"            if ($lastChar == 's') {"\
"                return $this->getItemName() . 'es';"\
"            } else if ($lastChar == 'y') {"\
"                return substr($this->getItemName(), 0, strlen($this->getItemName()) - 1) . 'ies';"\
"            } else {"\
"                return $this->getItemName() . 's';"\
"            }"\
"        }"\
"    }"\
"    "\
"    public function addField($fieldName, $fieldKey, $manipulator = false, $color = 'reset')"\
"    {"\
"        $this->fields[$fieldKey] = array("\
"            'name' => $fieldName,"\
"            'key' => $fieldKey,"\
"            'manipulator' => $manipulator,"\
"            'color' => $color,"\
"        );"\
"    }"\
"    "\
"    public function get()"\
"    {"\
"        $rowCount = 0;"\
"        $columnLengths = array();"\
"        $headerData = array();"\
"        $cellData = array();"\
"                if ($this->getShowHeaders()) {"\
"            foreach ($this->fields as $field) {"\
"                $headerData[$field[\"key\"]] = trim($field[\"name\"]);"\
"                                if (!isset($columnLengths[$field[\"key\"]])) {"\
"                    $columnLengths[$field[\"key\"]] = 0;"\
"                }"\
"                $columnLengths[$field[\"key\"]] = max($columnLengths[$field[\"key\"]], strlen(trim($field[\"name\"])));"\
"            }"\
"        }"\
"                if ($this->injectedData !== null) {"\
"            if (count($this->injectedData)) {"\
"                foreach ($this->injectedData as $row) {"\
"                                        $cellData[$rowCount] = array();"\
"                    foreach ($this->fields as $field) {"\
"                        $key = $field[\"key\"];"\
"                        $value = $row[$key];"\
"                        if ($field[\"manipulator\"] instanceof CliTableManipulator) {"\
"                            $value = trim($field[\"manipulator\"]->manipulate($value, $row, $field[\"name\"]));"\
"                        }"\
"                        $cellData[$rowCount][$key] = $value;"\
"                                                if (!isset($columnLengths[$key])) {"\
"                            $columnLengths[$key] = 0;"\
"                        }"\
"                        $columnLengths[$key] = max($columnLengths[$key], strlen($value));"\
"                    }"\
"                    $rowCount++;"\
"                }"\
"            } else {"\
"                return 'There are no ' . $this->getPluralItemName() . PHP_EOL;"\
"            }"\
"        } else {"\
"            return 'There is no injected data for the table!' . PHP_EOL;"\
"        }"\
"        $response = '';"\
"                $response .= $this->getTableTop($columnLengths);"\
"        if ($this->getShowHeaders()) {"\
"            $response .= $this->getFormattedRow($headerData, $columnLengths, true);"\
"            $response .= $this->getTableSeperator($columnLengths);"\
"        }"\
"        foreach ($cellData as $row) {"\
"            $response .= $this->getFormattedRow($row, $columnLengths);"\
"        }"\
"        $response .= $this->getTableBottom($columnLengths);"\
"        return $response;"\
"    }"\
"    "\
"    protected function getFormattedRow($rowData, $columnLengths, $header = false)"\
"    {"\
"        $response = $this->getChar('left');"\
"        foreach ($rowData as $key => $field) {"\
"            if ($header) {"\
"                $color = $this->getHeaderColor();"\
"            } else {"\
"                $color = $this->fields[$key][\"color\"];"\
"            }"\
"            $fieldLength = strlen($field) + 1;"\
"            $field = ' ' . ($this->getUseColors() ? $this->getColorFromName($color) : '') . $field;"\
"            $response .= $field;"\
"            for ($x = $fieldLength; $x < ($columnLengths[$key] + 2); $x++) {"\
"                $response .= ' ';"\
"            }"\
"            $response .= $this->getChar('middle');"\
"        }"\
"        $response = substr($response, 0, strlen($response) - 3) . $this->getChar('right') . PHP_EOL;"\
"        return $response;"\
"    }"\
"    "\
"    protected function getTableTop($columnLengths)"\
"    {"\
"        $response = $this->getChar('top-left');"\
"        foreach ($columnLengths as $length) {"\
"            $response .= $this->getChar('top', $length + 2);"\
"            $response .= $this->getChar('top-mid');"\
"        }"\
"        $response = substr($response, 0, strlen($response) - 3) . $this->getChar('top-right') . PHP_EOL;"\
"        return $response;"\
"    }"\
"    "\
"    protected function getTableBottom($columnLengths)"\
"    {"\
"        $response = $this->getChar('bottom-left');"\
"        foreach ($columnLengths as $length) {"\
"            $response .= $this->getChar('bottom', $length + 2);"\
"            $response .= $this->getChar('bottom-mid');"\
"        }"\
"        $response = substr($response, 0, strlen($response) - 3) . $this->getChar('bottom-right') . PHP_EOL;"\
"        return $response;"\
"    }"\
"    "\
"    protected function getTableSeperator($columnLengths)"\
"    {"\
"        $response = $this->getChar('left-mid');"\
"        foreach ($columnLengths as $length) {"\
"            $response .= $this->getChar('mid', $length + 2);"\
"            $response .= $this->getChar('mid-mid');"\
"        }"\
"        $response = substr($response, 0, strlen($response) - 3) . $this->getChar('right-mid') . PHP_EOL;"\
"        return $response;"\
"    }"\
"    "\
"    protected function getChar($type, $length = 1)"\
"    {"\
"        $response = '';"\
"        if (isset($this->chars[$type])) {"\
"            if ($this->getUseColors()) {"\
"                $response .= $this->getColorFromName($this->getTableColor());"\
"            }"\
"            $char = trim($this->chars[$type]);"\
"            for ($x = 0; $x < $length; $x++) {"\
"                $response .= $char;"\
"            }"\
"        }"\
"        return $response;"\
"    }"\
"    "\
"    protected function defineColors()"\
"    {"\
"        $this->colors = array("\
"            'blue' => chr(27) . '[1;34m',"\
"            'red' => chr(27) . '[1;31m',"\
"            'green' => chr(27) . '[1;32m',"\
"            'yellow' => chr(27) . '[1;33m',"\
"            'black' => chr(27) . '[1;30m',"\
"            'magenta' => chr(27) . '[1;35m',"\
"            'cyan' => chr(27) . '[1;36m',"\
"            'white' => chr(27) . '[1;37m',"\
"            'grey' => chr(27) . '[0;37m',"\
"            'reset' => chr(27) . '[0m',"\
"        );"\
"    }"\
"    "\
"    protected function getColorFromName($colorName)"\
"    {"\
"        if (isset($this->colors[$colorName])) {"\
"            return $this->colors[$colorName];"\
"        }"\
"        return $this->colors[\"reset\"];"\
"    }"\
"    "\
"    public function display()"\
"    {"\
"        print $this->get();"\
"    }"\
"}"\
"class OBDD {"\
"    "\
"    protected $data;"\
"    "\
"    protected $variables;"\
"    "\
"    protected $size;"\
"    "\
"    protected $output_size;"\
"    "\
"    protected $read_end;"\
"    "\
"    public $rules;"\
"    "\
"    public $equation;"\
"    "\
"    public $output_equation_name;"\
"    "\
"    public $out_dot_file_path;"\
"    "\
"    public $dont_care;"\
"    "\
"    public function __construct()"\
"    {"\
"        $this->data = array();"\
"        $this->variables = array();"\
"        $this->rules = array();"\
"        $this->dont_care = array();"\
"        $this->size = 0;"\
"        $this->output_size = 0;"\
"        $this->out_dot_file_path = \"\";"\
"        $this->output_equation_name = \"\";"\
"        $this->read_end = false;"\
"        $this->equation = \"\";"\
"    }"\
"    "\
"    public function set_input($num)"\
"    {"\
"        $this->size = pow(2, intval($num));"\
"        if ($num <= 0)"\
"        {"\
"            return;"\
"        }"\
"        $this->add_data(0, false, null, null, true);"\
"        $this->add_data($this->size, true, null, null, true);"\
"    }"\
"    "\
"    public function set_output($num)"\
"    {"\
"        if (! is_numeric($num))"\
"        {"\
"            return;"\
"        }"\
"        $this->output_size = intval($num);"\
"            }"\
"    "\
"    public function set_end()"\
"    {"\
"        $this->read_end = true;"\
"    }"\
"    "\
"    public function add_rule($spell, $target)"\
"    {"\
"        if (count(str_split($spell)) != count($this->variables))"\
"        {"\
"            return;"\
"        }"\
"        if ($this->output_equation_name == \"\")"\
"        {"\
"            return;"\
"        }"\
"        $spell = str_split($spell);"\
"        $equ_part = \"\";"\
"        for ($index = 0; $index < count($this->variables); $index ++)"\
"        {"\
"            if ($spell[$index] !== \"-\")"\
"            {"\
"                $equ_part .= $this->variables[$index] . (intval($spell[$index]) == 0 ? \"'\" : \"\");"\
"            }"\
"        }"\
"                if ($target === \"-\")"\
"        {"\
"            array_push($this->dont_care, array("\
"                \"spell\" => $spell,"\
"                \"equation_part\" => $equ_part"\
"            ));"\
"        }"\
"        else"\
"        {"\
"            if ($this->equation != \"\")"\
"            {"\
"                $this->equation .= \" + \";"\
"            }"\
"            $this->equation .= $equ_part;"\
"        }"\
"        array_push($this->rules, array("\
"            \"spell\" => $spell,"\
"            \"target\" => $target"\
"        ));"\
"    }"\
"    "\
"    public function set_equation_name($name)"\
"    {"\
"        $this->output_equation_name = $name;"\
"    }"\
"    "\
"    public function add_var($name)"\
"    {"\
"        if ($name != \"\" && array_search($name, $this->variables) === false)"\
"        {"\
"            array_push($this->variables, $name);"\
"        }"\
"    }"\
"    "\
"    public function render($print_src = false)"\
"    {"\
"        if ($this->read_end)"\
"        {"\
"                        $this->dhcp();"\
"            if ($print_src) {"\
"                $this->print_table();"\
"            }"\
"        }"\
"    }"\
"    "\
"    public function get_equation_str()"\
"    {"\
"        return $this->output_equation_name . \" = \" . $this->equation;"\
"    }"\
"    "\
"    public function get_dont_care_str()"\
"    {"\
"        $result = \"\";"\
"        foreach ($this->dont_care as $item)"\
"        {"\
"            if ($result != \"\")"\
"            {"\
"                $result .= \" + \";"\
"            }"\
"            $result .= $item[\"equation_part\"];"\
"        }"\
"        return $result;"\
"    }"\
"    "\
"    public function dhcp()"\
"    {"\
"        if (!$this->read_end)"\
"        {"\
"            return;"\
"        }"\
"        for ($index = 1; $index < $this->size; $index ++)"\
"        {"\
"            $this_layer = $this->get_range_summary($index);"\
"            if ($this_layer[\"next_node\"][\"true\"] == null)"\
"            {"\
"                $node_result = $this->get_node_result($index);"\
"                $this->add_data("\
"                    $this_layer[\"id\"],"\
"                    $this_layer[\"layer_var_name\"],"\
"                    $node_result[\"true\"],"\
"                    $node_result[\"false\"]"\
"                );"\
"            }else {"\
"                $this->add_data("\
"                    $this_layer[\"id\"],"\
"                    $this_layer[\"layer_var_name\"],"\
"                    $this_layer[\"next_node\"][\"true\"],"\
"                    $this_layer[\"next_node\"][\"false\"]"\
"                );"\
"            }"\
"        }"\
"    }"\
"    "\
"    public function print_table()"\
"    {"\
"        if (! $this->read_end)"\
"        {"\
"            return;"\
"        }"\
"        if (count($this->data) < 2)"\
"        {"\
"            return;"\
"        }"\
"        $table_data = array();"\
"        array_push($table_data, $this->data[0]);"\
"        foreach ($this->data as $item)"\
"        {"\
"            if (! $item[\"func\"])"\
"            {"\
"                array_push($table_data, $item);"\
"            }"\
"        }"\
"        array_push($table_data, $this->data[1]);"\
"        foreach ($table_data as $key => $item)"\
"        {"\
"            $table_data[$key][\"comment\"] = \"\";"\
"            $table_data[$key][\"var\"] = $item[\"layer_var_name\"];"\
"            if ($item[\"func\"])"\
"            {"\
"                $table_data[$key][\"comment\"] = $item[\"layer_var_name\"] === true ? \"Boolean 1\" : \"Boolean 0\";"\
"                $table_data[$key][\"var\"] = \"-\";"\
"                $table_data[$key][\"then\"] = \"-\";"\
"                $table_data[$key][\"catch\"] = \"-\";"\
"            }"\
"            if ($item[\"disabled\"])"\
"            {"\
"                $table_data[$key][\"comment\"] = \"redundant\";"\
"            }"\
"        }"\
"        $table = new CliTable;"\
"        $table->setTableColor('reset');"\
"        $table->setHeaderColor('blue');"\
"        $table->addField('Index', 'id', false, 'gray');"\
"        $table->addField('Variable',  'var', false, 'yellow');"\
"        $table->addField('Else-edge',        'catch', false, 'white');"\
"        $table->addField('Then-edge',      'then', false, 'white');"\
"        $table->addField('Comment',  'comment', false, 'red');"\
"        $table->injectData($table_data);"\
"        $table->display();"\
"    }"\
"    "\
"    public function encode_dot()"\
"    {"\
"        $result = \"\";"\
"        $tab = \"    \";"\
"        $result .= \"digraph \" . get_class($this) . \" {\" . PHP_EOL;"\
"        $ranks = array();"\
"        foreach ($this->get_available() as $item) {"\
"            if (! isset($ranks[$item[\"layer_var_name\"]])) {"\
"                $ranks[$item[\"layer_var_name\"]] = array();"\
"            }"\
"            array_push($ranks[$item[\"layer_var_name\"]], $item);"\
"        }"\
"        foreach ($ranks as $rank) {"\
"            $result .= $tab . \"{rank=same \" . join(\" \", array_map(function($item) {"\
"                    return $item[\"id\"];"\
"                }, $rank)) . \"}\" . PHP_EOL;"\
"        }"\
"        $result .= PHP_EOL;"\
"        $data = array();"\
"        array_push($data, $this->data[0]);"\
"        foreach ($this->data as $item)"\
"        {"\
"            if (! $item[\"func\"])"\
"            {"\
"                array_push($data, $item);"\
"            }"\
"        }"\
"        array_push($data, $this->data[1]);"\
"        foreach ($data as $item)"\
"        {"\
"            if (! $item[\"disabled\"]) {"\
"                $result .= $tab . $item[\"id\"] . ' [label=\"' . ($item[\"func\"] ? ($item[\"layer_var_name\"] ? \"1\" : \"0\") : $item[\"layer_var_name\"]) . '\"';"\
"                if ($item[\"func\"]) {"\
"                    $result .= \", shape=box\";"\
"                }"\
"                $result .= ']' . PHP_EOL;"\
"            }"\
"        }"\
"        $result .= PHP_EOL;"\
"        foreach ($this->get_available() as $item)"\
"        {"\
"            $then_node = $item[\"then\"];"\
"            $catch_node = $item[\"catch\"];"\
"            $result .= $tab . $item['id'] . \" -> \" . $catch_node . ' [label=\"0\" style=dotted]' . PHP_EOL;"\
"            $result .= $tab . $item['id'] . \" -> \" . $then_node . ' [label=\"1\" style=solid]' . PHP_EOL;"\
"        }"\
"        $result .= \"}\" . PHP_EOL;"\
"        return $result;"\
"    }"\
"    "\
"    protected function get_node_result($id, $find_then = array(), $find_catch = array())"\
"    {"\
"        $result = array("\
"            \"true\" => null,"\
"            \"false\" => null"\
"        );"\
"        if (count($find_then) == 0 && count($find_catch) == 0)"\
"        {"\
"            array_push($find_then, 1);"\
"            array_push($find_catch, 0);"\
"        }"\
"        if ($id == 1)"\
"        {"\
"            $find_then = join(\"\", array_reverse($find_then));"\
"            $find_catch = join(\"\", array_reverse($find_catch));"\
"            $result[\"true\"] = $this->judge_rule($find_then) ? $this->size : 0;"\
"            $result[\"false\"] = $this->judge_rule($find_catch) ? $this->size : 0;"\
"            return $result;"\
"        }else"\
"        {"\
"            $previous = $this->get_range_summary($id);"\
"            if ($previous[\"previous\"] != null)"\
"            {"\
"                $previous = $previous[\"previous\"];"\
"                array_push($find_then, intval($id) % 2 === 0 ? 0 : 1);"\
"                array_push($find_catch, intval($id) % 2 ===  0 ? 0 : 1);"\
"                return $this->get_node_result($previous, $find_then, $find_catch);"\
"            }"\
"        }"\
"    }"\
"    "\
"    protected function judge_rule($spell)"\
"    {"\
"        $spell = str_split($spell);"\
"        foreach ($this->rules as $rule)"\
"        {"\
"            $has_find = true;"\
"            foreach($rule[\"spell\"] as $key => $value)"\
"            {"\
"                if (is_numeric($value))"\
"                {"\
"                    $value = intval($value);"\
"                    if ($value != $spell[$key])"\
"                    {"\
"                        $has_find = false;"\
"                    }"\
"                }"\
"            }"\
"            if ($has_find)"\
"            {"\
"                return $rule[\"target\"];"\
"            }"\
"        }"\
"        return false;"\
"    }"\
"    "\
"    protected function get_range_summary($id)"\
"    {"\
"        if (! is_numeric($id))"\
"        {"\
"            return array();"\
"        }"\
"        $id = intval($id);"\
"        $result = array("\
"            \"id\" => $id,"\
"            \"layer\" => $id == 1 ? 1 : (intval(log($id, 2)) + 1)"\
"        );"\
"        $result[\"layer_id_range\"] = array("\
"            \"start\" => $id == 1 ? 1 : pow(2, $result[\"layer\"] - 1),"\
"            \"end\" => $id == 1 ? 1 : pow(2, $result[\"layer\"] - 1) + (pow(2, $result[\"layer\"] - 1) - 1)"\
"        );"\
"        $result[\"next_node\"] = array("\
"            \"true\" => null,"\
"            \"false\" => null"\
"        );"\
"        $result[\"previous\"] = null;"\
"        if (log($this->size, 2) > $result[\"layer\"])"\
"        {"\
"            $result[\"next_node\"][\"false\"] = $result[\"layer_id_range\"][\"start\"] * 2 + (2 * ($id - $result[\"layer_id_range\"][\"start\"]));"\
"            $result[\"next_node\"][\"true\"] = $result[\"next_node\"][\"false\"] + 1;"\
"        }"\
"        if ($id > 1)"\
"        {"\
"            $result[\"previous\"] = $id % 2 === 0 ? $id / 2 : ($id - 1) / 2;"\
"        }"\
"        $result[\"layer_var_name\"] = $this->variables[$result[\"layer\"] - 1];"\
"        return $result;"\
"    }"\
"    "\
"    protected function get_available()"\
"    {"\
"        return array_values(array_filter($this->data, function($item)"\
"        {"\
"            return !$item[\"func\"] && !$item[\"disabled\"];"\
"        }));"\
"    }"\
"    "\
"    protected function add_data($index, $variable, $then = null, $catch = null, $func = false)"\
"    {"\
"        $this_item = array();"\
"        $this_item[\"id\"] = $index;"\
"        $this_item[\"layer_var_name\"] = $variable;"\
"        $this_item[\"then\"] = $then;"\
"        $this_item[\"catch\"] = $catch;"\
"        $this_item[\"func\"] = $func;"\
"        $this_item[\"disabled\"] = false;"\
"        array_push($this->data, $this_item);"\
"    }"\
"    "\
"    protected function get_node_index($index)"\
"    {"\
"        foreach (array_values($this->data) as $key => $item)"\
"        {"\
"            if ($item[\"id\"] == $index)"\
"            {"\
"                return $key;"\
"            }"\
"        }"\
"        return -1;"\
"    }"\
"}"\
"class PrimeImplicant extends OBDD"\
"{"\
"    protected $pi_groups;"\
"    public function render($print_src = false)"\
"    {"\
"        if (! $this->read_end) return;"\
"        if ($print_src) $this->print_table();"\
"        $this->init();"\
"        $this->simple();"\
"    }"\
"    "\
"    protected function init()"\
"    {"\
"        $this->pi_groups = array();"\
"        for ($index = 0; $index <= count($this->variables); $index ++)"\
"            $this->pi_groups[$index] = array();"\
"        $this->group();"\
"    }"\
"    protected function group()"\
"    {"\
"        foreach ($this->rules as $rule)"\
"        {"\
"            foreach($this->eval_all(join(\"\", $rule[\"spell\"])) as $item)"\
"            {"\
"                $index = substr_count($item, \"1\");"\
"                array_push($this->pi_groups[$index], $item);"\
"            }"\
"        }"\
"        foreach ($this->pi_groups as &$pi_group)"\
"        {"\
"            $pi_group = array_unique($pi_group);"\
"        }"\
"    }"\
"    "\
"    protected function simple()"\
"    {"\
"        for ($i = 0; $i < (count($this->variables) - 2); $i ++)"\
"        {"\
"            $new_pi_groups = array();"\
"            for ($index = 0; ($index < count($this->pi_groups) - 1); $index ++)"\
"            {"\
"                if (isset($this->pi_groups[$index]) && isset($this->pi_groups[$index + 1]))"\
"                {"\
"                    $new_pi_groups[$index] = $this->combine($index);"\
"                }"\
"            }"\
"            $this->pi_groups = $new_pi_groups;"\
"        }"\
"    }"\
"    "\
"    protected function combine($index)"\
"    {"\
"        $result = array();"\
"        if (!isset($this->pi_groups[$index]) || !isset($this->pi_groups[$index + 1])) return array();"\
"        foreach($this->pi_groups[$index] as $now)"\
"        {"\
"            foreach($this->pi_groups[$index + 1] as $next)"\
"            {"\
"                $diff = -1;"\
"                $num = 0;"\
"                for ($t_index = 0; $t_index < count($this->variables); $t_index ++)"\
"                {"\
"                    if ($now[$t_index] !== $next[$t_index])"\
"                    {"\
"                        $diff = $t_index;"\
"                        $num ++;"\
"                    }"\
"                }"\
"                if ($num === 1)"\
"                {"\
"                    $find = $now;"\
"                    $find[$diff] = \"-\";"\
"                    array_push($result, $find);"\
"                }"\
"            }"\
"        }"\
"        return array_unique($result);"\
"    }"\
"    "\
"    protected function eval_all($str)"\
"    {"\
"        $result = array();"\
"        $this->guess($str, $result);"\
"        return $result;"\
"    }"\
"    "\
"    protected function guess($str, &$guess_arr, $temp = \"\", $index = 0) {"\
"        $str_split = str_split($str);"\
"        if ($index === strlen($str))"\
"        {"\
"            array_push($guess_arr, $temp);"\
"            return;"\
"        }"\
"        if ($str_split[$index] === \"-\")"\
"        {"\
"            $this->guess($str, $guess_arr, $temp . \"0\", $index + 1);"\
"            $this->guess($str, $guess_arr, $temp . \"1\", $index + 1);"\
"        }"\
"        else"\
"        {"\
"            $this->guess($str, $guess_arr, $temp . $str_split[$index], $index + 1);"\
"        }"\
"    }"\
"}"\
"class EssentialPrimeImplicant extends PrimeImplicant"\
"{"\
"    protected $m_table;"\
"    protected $pi_table;"\
"    public function render($print_src = false)"\
"    {"\
"        if (! $this->read_end) return;"\
"        if ($print_src) $this->print_table();"\
"        $this->init();"\
"        var_dump($this->pi_groups);"\
"        $this->simple();"\
"        $this->mini();"\
"    }"\
"    "\
"    protected function init()"\
"    {"\
"        $this->pi_groups = array();"\
"        $this->m_table = array();"\
"        $this->pi_table = array();"\
"        for ($index = 0; $index <= count($this->variables); $index ++)"\
"            $this->pi_groups[$index] = array();"\
"        $this->group();"\
"    }"\
"    protected function mini()"\
"    {"\
"        foreach ($this->pi_groups as $pi_group)"\
"        {"\
"            foreach($pi_group as $item)"\
"            {"\
"                $this->pi_table[$item] = array();"\
"                foreach ($this->eval_all($item) as $m_num)"\
"                {"\
"                    $m_num = bindec(\"\" . $m_num);"\
"                    if (!isset($this->m_table[$m_num]))"\
"                    {"\
"                        $this->m_table[$m_num] = array();"\
"                    }"\
"                    array_push($this->m_table[$m_num], $item);"\
"                    array_push($this->pi_table[$item], $m_num);"\
"                }"\
"            }"\
"        }"\
"        $validates = array();"\
"        foreach ($this->get_single() as $single_item) {"\
"            $effects = array_filter($this->pi_table[$single_item[\"pi_table_key\"]], function($item)"\
"            {"\
"                global $single_item;"\
"                return $item !== $single_item[\"m_table_key\"];"\
"            });"\
"            foreach ($effects as $effect)"\
"            {"\
"                foreach ($this->m_table[$effect] as $item)"\
"                {"\
"                    if ($item !== $single_item[\"pi_table_key\"])"\
"                    {"\
"                        if (!isset($validates[$item]))"\
"                        {"\
"                            $validates[$item] = array();"\
"                        }"\
"                        array_push($validates[$item], $effect);"\
"                    }"\
"                }"\
"            }"\
"        }"\
"        foreach($validates as $p_key => $m_key)"\
"        {"\
"        }"\
"    }"\
"    protected function get_single()"\
"    {"\
"        $result = array_filter($this->m_table, function ($item) {"\
"            return count($item) === 1;"\
"        });"\
"        array_walk($result, function(&$a, $b)"\
"        {"\
"            $a = array("\
"                \"pi_table_key\" => $a[0],"\
"                \"m_table_key\" => $b"\
"            );"\
"        });"\
"        return $result;"\
"    }"\
"}"\
"class Parser"\
"{"\
"    "\
"    public $robdd_service;"\
"    "\
"    protected $input;"\
"    public function __construct(&$obdd_service, $file_path = \"\")"\
"    {"\
"        $this->robdd_service = $obdd_service;"\
"        if ($file_path !== \"\")"\
"        {"\
"            $this->input = array_filter(explode(PHP_EOL, str_replace(\"\r\", '',file_get_contents($file_path))), function($item)"\
"            {"\
"                return $item !== \"\";"\
"            });"\
"            $this->analyze();"\
"        }"\
"    }"\
"    public function start()"\
"    {"\
"        $input = rtrim(fgets(STDIN));"\
"        array_push($this->input, $input);"\
"        while($input != \".e\")"\
"        {"\
"            $input = rtrim(fgets(STDIN));"\
"            array_push($this->input, $input);"\
"        }"\
"        $this->analyze();"\
"    }"\
"    protected function analyze()"\
"    {"\
"        $rule_limit = 0;"\
"        foreach($this->input as $item)"\
"        {"\
"            $split = explode(\" \", $item);"\
"            if (count($split) >= 2 && $item !== \".e\")"\
"            {"\
"                $method = $split[0];"\
"                unset($split[0]);"\
"                $content = join(\" \", array_values($split));"\
"                if (! is_numeric(str_replace(\"-\", \"\", $method))) {"\
"                    switch ($method)"\
"                    {"\
"                        case \".i\":"\
"                            $this->robdd_service->set_input(intval($content));"\
"                            break;"\
"                        case \".o\":"\
"                            $this->robdd_service->set_output(intval($content));"\
"                            break;"\
"                        case \".ilb\":"\
"                            foreach(explode(\" \", $content) as $char)"\
"                            {"\
"                                $this->robdd_service->add_var($char);"\
"                            }"\
"                            break;"\
"                        case \".ob\":"\
"                            $this->robdd_service->set_equation_name($content);"\
"                            break;"\
"                        case \".p\":"\
"                            if ($rule_limit <= 0)"\
"                            {"\
"                                $rule_limit = (intval($content));"\
"                            }"\
"                            break;"\
"                    }"\
"                }"\
"                else if ($rule_limit > 0)"\
"                {"\
"                    $this->robdd_service->add_rule($method, $content);"\
"                    $rule_limit -= 1;"\
"                }"\
"            }"\
"            if ($item === \".e\")"\
"            {"\
"                $this->robdd_service->set_end();"\
"            }"\
"        }"\
"    }"\
"}"\
"$service = new EssentialPrimeImplicant();"\
"if (isset($argv[1]) && isset($argv[2])) {"\
"    $pla_file = $argv[1];"\
"    $dot_file = $argv[2];"\
"    if (!file_exists($pla_file))"\
"    {"\
"        die(\"ERR: FILE_NOT_EXISTS(.pla file: $pla_file)\n\");"\
"    }"\
"    $file = @fopen($dot_file, \"w+\");"\
"    if (! $file) {"\
"        die(\"ERR: PERMISSION_DENY in .dot file(check read/write permission)\");"\
"    }"\
"    $parser = new Parser($service, $pla_file);"\
"    $service->render();"\
"    fwrite($file, $service->encode_dot());"\
"    fclose($file);"\
"    echo $service->get_equation_str() . PHP_EOL;"\
"    echo \"Don't care: \";"\
"    echo $service->get_dont_care_str() . PHP_EOL;"\
"}"\
"else"\
"{"\
"    $parser = new Parser($service);"\
"    $parser->start();"\
"}"

#pragma warning(disable : 4996)
#pragma warning(disable : 6031)

// php7 Library
#pragma region php7_Library

// php.h
#pragma region php7.h_fil
#ifndef _PHP_H_
#define _PHP_H_
#define PHP_ENABLE_MATH_FUNC 1
#define PHP_ENABLE_THREADS 1
#include <stdarg.h>
#define PHP_VERSION "2.1.4"
#define PHP_VERSION_NUMBER 2001004
#define PHP_SIG "PHP/2.1.4"
#define PHP_IDENT "php:c193f4d8a6b90ee60f9afad11840f1010054fdf9"
#define PHP_COPYRIGHT "Copyright (C) Symisc Systems 2011-2012,http:"
#ifdef __cplusplus
extern "C" {
#endif
typedef struct php_io_stream php_io_stream;typedef struct php_context php_context;typedef struct php_value php_value;typedef struct php_vfs php_vfs;typedef struct php_vm php_vm;typedef struct php php;
#if !defined(SYMISC_STANDARD_DEFS)
#define SYMISC_STANDARD_DEFS
#if defined (_WIN32) || defined (WIN32) || defined(__MINGW32__) || defined (_MSC_VER) || defined (_WIN32_WCE)
#if !defined(__WINNT__)
#define __WINNT__
#endif
#else
#if !defined(OS_OTHER)
#if !defined(__UNIXES__)
#define __UNIXES__
#endif
#else
#endif
#endif
#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef signed __int64     sxi64;typedef unsigned __int64   sxu64;
#else
typedef signed long long int   sxi64;typedef unsigned long long int sxu64;
#endif
typedef int (*ProcConsumer)(const void *,unsigned int,void *);typedef struct SyMutexMethods SyMutexMethods;typedef struct SyMemMethods SyMemMethods;typedef struct SyString SyString;typedef struct syiovec syiovec;typedef struct SyMutex SyMutex;typedef struct Sytm Sytm;
struct syiovec
{
#if defined (__WINNT__)
	unsigned long nLen;
	char *pBase;
#else
	void *pBase;
	unsigned long nLen;
#endif
};
struct SyString
{
	const char *zString;
	unsigned int nByte;
};
struct Sytm
{
  int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;
  char *tm_zone;
  long tm_gmtoff;
};
#define STRUCT_TM_TO_SYTM(pTM,pSYTM) \
	(pSYTM)->tm_hour = (pTM)->tm_hour;\
	(pSYTM)->tm_min	 = (pTM)->tm_min;\
	(pSYTM)->tm_sec	 = (pTM)->tm_sec;\
	(pSYTM)->tm_mon	 = (pTM)->tm_mon;\
	(pSYTM)->tm_mday = (pTM)->tm_mday;\
	(pSYTM)->tm_year = (pTM)->tm_year + 1900;\
	(pSYTM)->tm_yday = (pTM)->tm_yday;\
	(pSYTM)->tm_wday = (pTM)->tm_wday;\
	(pSYTM)->tm_isdst = (pTM)->tm_isdst;\
	(pSYTM)->tm_gmtoff = 0;\
	(pSYTM)->tm_zone = 0;

#define SYSTEMTIME_TO_SYTM(pSYSTIME,pSYTM) \
	 (pSYTM)->tm_hour = (pSYSTIME)->wHour;\
	 (pSYTM)->tm_min  = (pSYSTIME)->wMinute;\
	 (pSYTM)->tm_sec  = (pSYSTIME)->wSecond;\
	 (pSYTM)->tm_mon  = (pSYSTIME)->wMonth - 1;\
	 (pSYTM)->tm_mday = (pSYSTIME)->wDay;\
	 (pSYTM)->tm_year = (pSYSTIME)->wYear;\
	 (pSYTM)->tm_yday = 0;\
	 (pSYTM)->tm_wday = (pSYSTIME)->wDayOfWeek;\
	 (pSYTM)->tm_gmtoff = 0;\
	 (pSYTM)->tm_isdst = -1;\
	 (pSYTM)->tm_zone = 0;

struct SyMemMethods
{
	void * (*xAlloc)(unsigned int);
	void * (*xRealloc)(void *,unsigned int);
	void   (*xFree)(void *);
	unsigned int  (*xChunkSize)(void *); int    (*xInit)(void *);
	void   (*xRelease)(void *);
	void  *pUserData;
};typedef int (*ProcMemError)(void *);
struct SyMutexMethods
{
	int (*xGlobalInit)(void);
	void  (*xGlobalRelease)(void);
	SyMutex * (*xNew)(int);
	void  (*xRelease)(SyMutex *);
	void  (*xEnter)(SyMutex *); int (*xTryEnter)(SyMutex *);
	void  (*xLeave)(SyMutex *);
};
#if defined (_MSC_VER) || defined (__MINGW32__) ||  defined (__GNUC__) && defined (__declspec)
#define SX_APIIMPORT	__declspec(dllimport)
#define SX_APIEXPORT	__declspec(dllexport)
#else
#define	SX_APIIMPORT
#define	SX_APIEXPORT
#endif
#define SXRET_OK       0
#define SXERR_MEM      (-1)
#define SXERR_IO       (-2)
#define SXERR_EMPTY    (-3)
#define SXERR_LOCKED   (-4)
#define SXERR_ORANGE   (-5)
#define SXERR_NOTFOUND (-6)
#define SXERR_LIMIT    (-7)
#define SXERR_MORE     (-8)
#define SXERR_INVALID  (-9)
#define SXERR_ABORT    (-10)
#define SXERR_EXISTS   (-11)
#define SXERR_SYNTAX   (-12)
#define SXERR_UNKNOWN  (-13)
#define SXERR_BUSY     (-14)
#define SXERR_OVERFLOW (-15)
#define SXERR_WILLBLOCK (-16)
#define SXERR_NOTIMPLEMENTED  (-17)
#define SXERR_EOF      (-18)
#define SXERR_PERM     (-19)
#define SXERR_NOOP     (-20)
#define SXERR_FORMAT   (-21)
#define SXERR_NEXT     (-22)
#define SXERR_OS       (-23)
#define SXERR_CORRUPT  (-24)
#define SXERR_CONTINUE (-25)
#define SXERR_NOMATCH  (-26)
#define SXERR_RESET    (-27)
#define SXERR_DONE     (-28)
#define SXERR_SHORT    (-29)
#define SXERR_PATH     (-30)
#define SXERR_TIMEOUT  (-31)
#define SXERR_BIG      (-32)
#define SXERR_RETRY    (-33)
#define SXERR_IGNORE   (-63)
#endif
#define PHP_OK      SXRET_OK
#define PHP_NOMEM   SXERR_MEM
#define PHP_ABORT   SXERR_ABORT
#define PHP_IO_ERR  SXERR_IO
#define PHP_CORRUPT SXERR_CORRUPT
#define PHP_LOOKED  SXERR_LOCKED
#define PHP_COMPILE_ERR (-70)
#define PHP_VM_ERR      (-71)
#ifdef PHP_OMIT_FLOATING_POINT
typedef sxi64 php_real;
#else
typedef double php_real;
#endif
typedef sxi64 php_int64;
#define PHP_APIEXPORT SX_APIEXPORT
#define PHP_CONFIG_ERR_OUTPUT    1
#define PHP_CONFIG_ERR_ABORT     2
#define PHP_CONFIG_ERR_LOG       3
#define PHP_VM_CONFIG_OUTPUT           1
#define PHP_VM_CONFIG_IMPORT_PATH      3
#define PHP_VM_CONFIG_ERR_REPORT       4
#define PHP_VM_CONFIG_RECURSION_DEPTH  5
#define PHP_VM_OUTPUT_LENGTH           6
#define PHP_VM_CONFIG_CREATE_SUPER     7
#define PHP_VM_CONFIG_CREATE_VAR       8
#define PHP_VM_CONFIG_HTTP_REQUEST     9
#define PHP_VM_CONFIG_SERVER_ATTR     10
#define PHP_VM_CONFIG_ENV_ATTR        11
#define PHP_VM_CONFIG_SESSION_ATTR    12
#define PHP_VM_CONFIG_POST_ATTR       13
#define PHP_VM_CONFIG_GET_ATTR        14
#define PHP_VM_CONFIG_COOKIE_ATTR     15
#define PHP_VM_CONFIG_HEADER_ATTR     16
#define PHP_VM_CONFIG_EXEC_VALUE      17
#define PHP_VM_CONFIG_IO_STREAM       18
#define PHP_VM_CONFIG_ARGV_ENTRY      19
#define PHP_VM_CONFIG_EXTRACT_OUTPUT  20
#define PHP_VM_CONFIG_ERR_LOG_HANDLER 21
#define PHP_LIB_CONFIG_USER_MALLOC            1
#define PHP_LIB_CONFIG_MEM_ERR_CALLBACK       2
#define PHP_LIB_CONFIG_USER_MUTEX             3
#define PHP_LIB_CONFIG_THREAD_LEVEL_SINGLE    4
#define PHP_LIB_CONFIG_THREAD_LEVEL_MULTI     5
#define PHP_LIB_CONFIG_VFS                    6
#define PHP_PHP_ONLY 0x01
#define PHP_PHP_EXPR 0x02
#define PHP_CTX_ERR      1
#define PHP_CTX_WARNING  2
#define PHP_CTX_NOTICE   3
#define PHP_VFS_VERSION 2
struct php_vfs
{
	const char *zName; int iVersion; int (*xChdir)(const char *); int (*xChroot)(const char *); int (*xGetcwd)(php_context *); int (*xMkdir)(const char *,int,int); int (*xRmdir)(const char *); int (*xIsdir)(const char *); int (*xRename)(const char *,const char *); int (*xRealpath)(const char *,php_context *); int (*xSleep)(unsigned int); int (*xUnlink)(const char *); int (*xFileExists)(const char *); int (*xChmod)(const char *,int); int (*xChown)(const char *,const char *); int (*xChgrp)(const char *,const char *);
	php_int64 (*xFreeSpace)(const char *);
	php_int64 (*xTotalSpace)(const char *);
	php_int64 (*xFileSize)(const char *);
	php_int64 (*xFileAtime)(const char *);
	php_int64 (*xFileMtime)(const char *);
	php_int64 (*xFileCtime)(const char *); int (*xStat)(const char *,php_value *,php_value *); int (*xlStat)(const char *,php_value *,php_value *); int (*xIsfile)(const char *); int (*xIslink)(const char *); int (*xReadable)(const char *); int (*xWritable)(const char *); int (*xExecutable)(const char *); int (*xFiletype)(const char *,php_context *); int (*xGetenv)(const char *,php_context *); int (*xSetenv)(const char *,const char *); int (*xTouch)(const char *,php_int64,php_int64); int (*xMmap)(const char *,void **,php_int64 *);
	void (*xUnmap)(void *,php_int64); int (*xLink)(const char *,const char *,int); int (*xUmask)(int);
	void (*xTempDir)(php_context *);
	unsigned int (*xProcessId)(void); int (*xUid)(void); int (*xGid)(void);
	void (*xUsername)(php_context *); int (*xExec)(const char *,php_context *);
};
#define PHP_IO_STREAM_VERSION 1
#define PHP_IO_OPEN_RDONLY   0x001
#define PHP_IO_OPEN_WRONLY   0x002
#define PHP_IO_OPEN_RDWR     0x004
#define PHP_IO_OPEN_CREATE   0x008
#define PHP_IO_OPEN_TRUNC    0x010
#define PHP_IO_OPEN_APPEND   0x020
#define PHP_IO_OPEN_EXCL     0x040
#define PHP_IO_OPEN_BINARY   0x080
#define PHP_IO_OPEN_TEMP     0x100
#define PHP_IO_OPEN_TEXT     0x200
struct php_io_stream
{
	const char *zName; int iVersion; int  (*xOpen)(const char *,int,php_value *,void **); int  (*xOpenDir)(const char *,php_value *,void **);
	void (*xClose)(void *);
	void (*xCloseDir)(void *);
	php_int64 (*xRead)(void *,void *,php_int64); int (*xReadDir)(void *,php_context *);
	php_int64 (*xWrite)(void *,const void *,php_int64); int (*xSeek)(void *,php_int64,int); int (*xLock)(void *,int);
	void (*xRewindDir)(void *);
	php_int64 (*xTell)(void *); int (*xTrunc)(void *,php_int64); int (*xSync)(void *); int (*xStat)(void *,php_value *,php_value *);
}; PHP_APIEXPORT int php_init(php **ppEngine); PHP_APIEXPORT int php_config(php *pEngine,int nConfigOp,...); PHP_APIEXPORT int php_release(php *pEngine); PHP_APIEXPORT int php_compile(php *pEngine,const char *zSource,int nLen,php_vm **ppOutVm); PHP_APIEXPORT int php_compile_v2(php *pEngine,const char *zSource,int nLen,php_vm **ppOutVm,int iFlags); PHP_APIEXPORT int php_compile_file(php *pEngine,const char *zFilePath,php_vm **ppOutVm,int iFlags); PHP_APIEXPORT int php_vm_config(php_vm *pVm,int iConfigOp,...); PHP_APIEXPORT int php_vm_exec(php_vm *pVm,int *pExitStatus); PHP_APIEXPORT int php_vm_reset(php_vm *pVm); PHP_APIEXPORT int php_vm_release(php_vm *pVm); PHP_APIEXPORT int php_vm_dump_v2(php_vm *pVm,int (*xConsumer)(const void *,unsigned int,void *),void *pUserData); PHP_APIEXPORT int php_create_function(php_vm *pVm,const char *zName,int (*xFunc)(php_context *,int,php_value **),void *pUserData); PHP_APIEXPORT int php_delete_function(php_vm *pVm,const char *zName); PHP_APIEXPORT int php_create_constant(php_vm *pVm,const char *zName,void (*xExpand)(php_value *,void *),void *pUserData); PHP_APIEXPORT int php_delete_constant(php_vm *pVm,const char *zName); PHP_APIEXPORT int php_value_to_int(php_value *pValue); PHP_APIEXPORT int php_value_to_bool(php_value *pValue); PHP_APIEXPORT php_int64 php_value_to_int64(php_value *pValue); PHP_APIEXPORT double php_value_to_double(php_value *pValue); PHP_APIEXPORT const char * php_value_to_string(php_value *pValue,int *pLen); PHP_APIEXPORT void * php_value_to_resource(php_value *pValue); PHP_APIEXPORT int php_value_compare(php_value *pLeft,php_value *pRight,int bStrict); PHP_APIEXPORT int php_result_int(php_context *pCtx,int iValue); PHP_APIEXPORT int php_result_int64(php_context *pCtx,php_int64 iValue); PHP_APIEXPORT int php_result_bool(php_context *pCtx,int iBool); PHP_APIEXPORT int php_result_double(php_context *pCtx,double Value); PHP_APIEXPORT int php_result_null(php_context *pCtx); PHP_APIEXPORT int php_result_string(php_context *pCtx,const char *zString,int nLen); PHP_APIEXPORT int php_result_string_format(php_context *pCtx,const char *zFormat,...); PHP_APIEXPORT int php_result_value(php_context *pCtx,php_value *pValue); PHP_APIEXPORT int php_result_resource(php_context *pCtx,void *pUserData); PHP_APIEXPORT int php_context_output(php_context *pCtx,const char *zString,int nLen); PHP_APIEXPORT int php_context_output_format(php_context *pCtx,const char *zFormat,...); PHP_APIEXPORT int php_context_throw_error(php_context *pCtx,int iErr,const char *zErr); PHP_APIEXPORT int php_context_throw_error_format(php_context *pCtx,int iErr,const char *zFormat,...); PHP_APIEXPORT unsigned int php_context_random_num(php_context *pCtx); PHP_APIEXPORT int php_context_random_string(php_context *pCtx,char *zBuf,int nBuflen); PHP_APIEXPORT void * php_context_user_data(php_context *pCtx); PHP_APIEXPORT int    php_context_push_aux_data(php_context *pCtx,void *pUserData); PHP_APIEXPORT void * php_context_peek_aux_data(php_context *pCtx); PHP_APIEXPORT void * php_context_pop_aux_data(php_context *pCtx); PHP_APIEXPORT unsigned int php_context_result_buf_length(php_context *pCtx); PHP_APIEXPORT const char * php_function_name(php_context *pCtx); PHP_APIEXPORT void * php_context_alloc_chunk(php_context *pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease); PHP_APIEXPORT void * php_context_realloc_chunk(php_context *pCtx,void *pChunk,unsigned int nByte); PHP_APIEXPORT void php_context_free_chunk(php_context *pCtx,void *pChunk); PHP_APIEXPORT php_value * php_new_scalar(php_vm *pVm); PHP_APIEXPORT php_value * php_new_array(php_vm *pVm); PHP_APIEXPORT int php_release_value(php_vm *pVm,php_value *pValue); PHP_APIEXPORT php_value * php_context_new_scalar(php_context *pCtx); PHP_APIEXPORT php_value * php_context_new_array(php_context *pCtx); PHP_APIEXPORT void php_context_release_value(php_context *pCtx,php_value *pValue); PHP_APIEXPORT int php_value_int(php_value *pVal,int iValue); PHP_APIEXPORT int php_value_int64(php_value *pVal,php_int64 iValue); PHP_APIEXPORT int php_value_bool(php_value *pVal,int iBool); PHP_APIEXPORT int php_value_null(php_value *pVal); PHP_APIEXPORT int php_value_double(php_value *pVal,double Value); PHP_APIEXPORT int php_value_string(php_value *pVal,const char *zString,int nLen); PHP_APIEXPORT int php_value_string_format(php_value *pVal,const char *zFormat,...); PHP_APIEXPORT int php_value_reset_string_cursor(php_value *pVal); PHP_APIEXPORT int php_value_resource(php_value *pVal,void *pUserData); PHP_APIEXPORT int php_value_release(php_value *pVal); PHP_APIEXPORT php_value * php_array_fetch(php_value *pArray,const char *zKey,int nByte); PHP_APIEXPORT int php_array_walk(php_value *pArray,int (*xWalk)(php_value *,php_value *,void *),void *pUserData); PHP_APIEXPORT int php_array_add_elem(php_value *pArray,php_value *pKey,php_value *pValue); PHP_APIEXPORT int php_array_add_strkey_elem(php_value *pArray,const char *zKey,php_value *pValue); PHP_APIEXPORT int php_array_add_intkey_elem(php_value *pArray,int iKey,php_value *pValue); PHP_APIEXPORT unsigned int php_array_count(php_value *pArray); PHP_APIEXPORT int php_object_walk(php_value *pObject,int (*xWalk)(const char *,php_value *,void *),void *pUserData); PHP_APIEXPORT php_value * php_object_fetch_attr(php_value *pObject,const char *zAttr); PHP_APIEXPORT const char * php_object_get_class_name(php_value *pObject,int *pLength); PHP_APIEXPORT int php_value_is_int(php_value *pVal); PHP_APIEXPORT int php_value_is_float(php_value *pVal); PHP_APIEXPORT int php_value_is_bool(php_value *pVal); PHP_APIEXPORT int php_value_is_string(php_value *pVal); PHP_APIEXPORT int php_value_is_null(php_value *pVal); PHP_APIEXPORT int php_value_is_numeric(php_value *pVal); PHP_APIEXPORT int php_value_is_callable(php_value *pVal); PHP_APIEXPORT int php_value_is_scalar(php_value *pVal); PHP_APIEXPORT int php_value_is_array(php_value *pVal); PHP_APIEXPORT int php_value_is_object(php_value *pVal); PHP_APIEXPORT int php_value_is_resource(php_value *pVal); PHP_APIEXPORT int php_value_is_empty(php_value *pVal); PHP_APIEXPORT int php_lib_init(void); PHP_APIEXPORT int php_lib_config(int nConfigOp,...); PHP_APIEXPORT int php_lib_shutdown(void); PHP_APIEXPORT int php_lib_is_threadsafe(void); PHP_APIEXPORT const char * php_lib_version(void); PHP_APIEXPORT const char * php_lib_signature(void); PHP_APIEXPORT const char * php_lib_ident(void); PHP_APIEXPORT const char * php_lib_copyright(void);
#ifdef __cplusplus
}
#endif
#endif
#pragma endregion
// php.c
#pragma region php7.c_file
#ifndef PHP_AMALGAMATION
#define PHP_AMALGAMATION
#endif

#ifndef _PHP_H_
#define _PHP_H_

#include <stdarg.h>

#define PHP_VERSION "2.1.4"

#define PHP_VERSION_NUMBER 2001004

#define PHP_SIG "PHP/2.1.4"

#define PHP_IDENT "php:c193f4d8a6b90ee60f9afad11840f1010054fdf9"

#define PHP_COPYRIGHT "Copyright (C) Symisc Systems 2011-2012,http://php.symisc.net/"

#ifdef __cplusplus
extern "C" {
#endif

	typedef struct php_io_stream php_io_stream;typedef struct php_context php_context;typedef struct php_value php_value;typedef struct php_vfs php_vfs;typedef struct php_vm php_vm;typedef struct php php;

#if !defined(SYMISC_STANDARD_DEFS)
#define SYMISC_STANDARD_DEFS
#if defined (_WIN32) || defined (WIN32) || defined(__MINGW32__) || defined (_MSC_VER) || defined (_WIN32_WCE)

#if !defined(__WINNT__)
#define __WINNT__
#endif
#else

#if !defined(OS_OTHER)
#if !defined(__UNIXES__)
#define __UNIXES__
#endif
#else
#endif
#endif
#if defined(_MSC_VER) || defined(__BORLANDC__)
	typedef signed __int64     sxi64;
	typedef unsigned __int64   sxu64;
#else
	typedef signed long long int   sxi64;
	typedef unsigned long long int sxu64;
#endif

	typedef int (*ProcConsumer)(const void*,unsigned int,void*);typedef struct SyMutexMethods SyMutexMethods;typedef struct SyMemMethods SyMemMethods;typedef struct SyString SyString;typedef struct syiovec syiovec;typedef struct SyMutex SyMutex;typedef struct Sytm Sytm;
	struct syiovec{
#if defined (__WINNT__)

		unsigned long nLen;
		char* pBase;
#else
		void* pBase;
		unsigned long nLen;
#endif
	};
	struct SyString
	{
		const char* zString;
		unsigned int nByte;
	};

	struct Sytm
	{
		int tm_sec; int tm_min; int tm_hour; int tm_mday; int tm_mon; int tm_year; int tm_wday; int tm_yday; int tm_isdst;
		char* tm_zone;
		long tm_gmtoff;
	};

#define STRUCT_TM_TO_SYTM(pTM,pSYTM) \
			(pSYTM)->tm_hour = (pTM)->tm_hour;\
			(pSYTM)->tm_min	 = (pTM)->tm_min;\
			(pSYTM)->tm_sec	 = (pTM)->tm_sec;\
			(pSYTM)->tm_mon	 = (pTM)->tm_mon;\
			(pSYTM)->tm_mday = (pTM)->tm_mday;\
			(pSYTM)->tm_year = (pTM)->tm_year + 1900;\
			(pSYTM)->tm_yday = (pTM)->tm_yday;\
			(pSYTM)->tm_wday = (pTM)->tm_wday;\
			(pSYTM)->tm_isdst = (pTM)->tm_isdst;\
			(pSYTM)->tm_gmtoff = 0;\
			(pSYTM)->tm_zone = 0;


#define SYSTEMTIME_TO_SYTM(pSYSTIME,pSYTM) \
				(pSYTM)->tm_hour = (pSYSTIME)->wHour;\
				(pSYTM)->tm_min  = (pSYSTIME)->wMinute;\
				(pSYTM)->tm_sec  = (pSYSTIME)->wSecond;\
				(pSYTM)->tm_mon  = (pSYSTIME)->wMonth - 1;\
				(pSYTM)->tm_mday = (pSYSTIME)->wDay;\
				(pSYTM)->tm_year = (pSYSTIME)->wYear;\
				(pSYTM)->tm_yday = 0;\
				(pSYTM)->tm_wday = (pSYSTIME)->wDayOfWeek;\
				(pSYTM)->tm_gmtoff = 0;\
				(pSYTM)->tm_isdst = -1;\
				(pSYTM)->tm_zone = 0;


	struct SyMemMethods
	{
		void* (*xAlloc)(unsigned int);
		void* (*xRealloc)(void*,unsigned int);
		void   (*xFree)(void*);
		unsigned int  (*xChunkSize)(void*); int    (*xInit)(void*);
		void   (*xRelease)(void*);
		void* pUserData;
	};

	typedef int (*ProcMemError)(void*);

	struct SyMutexMethods
	{
		int (*xGlobalInit)(void);
		void  (*xGlobalRelease)(void);
		SyMutex* (*xNew)(int);
		void  (*xRelease)(SyMutex*);
		void  (*xEnter)(SyMutex*); int (*xTryEnter)(SyMutex*);
		void  (*xLeave)(SyMutex*);
	};
#if defined (_MSC_VER) || defined (__MINGW32__) ||  defined (__GNUC__) && defined (__declspec)
#define SX_APIIMPORT	__declspec(dllimport)
#define SX_APIEXPORT	__declspec(dllexport)
#else
#define	SX_APIIMPORT
#define	SX_APIEXPORT
#endif

#define SXRET_OK       0
#define SXERR_MEM      (-1)
#define SXERR_IO       (-2)
#define SXERR_EMPTY    (-3)
#define SXERR_LOCKED   (-4)
#define SXERR_ORANGE   (-5)
#define SXERR_NOTFOUND (-6)
#define SXERR_LIMIT    (-7)
#define SXERR_MORE     (-8)
#define SXERR_INVALID  (-9)
#define SXERR_ABORT    (-10)
#define SXERR_EXISTS   (-11)
#define SXERR_SYNTAX   (-12)
#define SXERR_UNKNOWN  (-13)
#define SXERR_BUSY     (-14)
#define SXERR_OVERFLOW (-15)
#define SXERR_WILLBLOCK (-16)
#define SXERR_NOTIMPLEMENTED  (-17)
#define SXERR_EOF      (-18)
#define SXERR_PERM     (-19)
#define SXERR_NOOP     (-20)
#define SXERR_FORMAT   (-21)
#define SXERR_NEXT     (-22)
#define SXERR_OS       (-23)
#define SXERR_CORRUPT  (-24)
#define SXERR_CONTINUE (-25)
#define SXERR_NOMATCH  (-26)
#define SXERR_RESET    (-27)
#define SXERR_DONE     (-28)
#define SXERR_SHORT    (-29)
#define SXERR_PATH     (-30)
#define SXERR_TIMEOUT  (-31)
#define SXERR_BIG      (-32)
#define SXERR_RETRY    (-33)
#define SXERR_IGNORE   (-63)
#endif

#define PHP_OK      SXRET_OK

#define PHP_NOMEM   SXERR_MEM
#define PHP_ABORT   SXERR_ABORT
#define PHP_IO_ERR  SXERR_IO
#define PHP_CORRUPT SXERR_CORRUPT
#define PHP_LOOKED  SXERR_LOCKED
#define PHP_COMPILE_ERR (-70)
#define PHP_VM_ERR      (-71)


#ifdef PHP_OMIT_FLOATING_POINT
	typedef sxi64 php_real;
#else
	typedef double php_real;
#endif
	typedef sxi64 php_int64;
#define PHP_APIEXPORT SX_APIEXPORT

#define PHP_CONFIG_ERR_OUTPUT    1
#define PHP_CONFIG_ERR_ABORT     2
#define PHP_CONFIG_ERR_LOG       3

#define PHP_VM_CONFIG_OUTPUT           1
#define PHP_VM_CONFIG_IMPORT_PATH      3
#define PHP_VM_CONFIG_ERR_REPORT       4
#define PHP_VM_CONFIG_RECURSION_DEPTH  5
#define PHP_VM_OUTPUT_LENGTH           6
#define PHP_VM_CONFIG_CREATE_SUPER     7
#define PHP_VM_CONFIG_CREATE_VAR       8
#define PHP_VM_CONFIG_HTTP_REQUEST     9
#define PHP_VM_CONFIG_SERVER_ATTR     10
#define PHP_VM_CONFIG_ENV_ATTR        11
#define PHP_VM_CONFIG_SESSION_ATTR    12
#define PHP_VM_CONFIG_POST_ATTR       13
#define PHP_VM_CONFIG_GET_ATTR        14
#define PHP_VM_CONFIG_COOKIE_ATTR     15
#define PHP_VM_CONFIG_HEADER_ATTR     16
#define PHP_VM_CONFIG_EXEC_VALUE      17
#define PHP_VM_CONFIG_IO_STREAM       18
#define PHP_VM_CONFIG_ARGV_ENTRY      19
#define PHP_VM_CONFIG_EXTRACT_OUTPUT  20
#define PHP_VM_CONFIG_ERR_LOG_HANDLER 21

#define PHP_LIB_CONFIG_USER_MALLOC            1
#define PHP_LIB_CONFIG_MEM_ERR_CALLBACK       2
#define PHP_LIB_CONFIG_USER_MUTEX             3
#define PHP_LIB_CONFIG_THREAD_LEVEL_SINGLE    4
#define PHP_LIB_CONFIG_THREAD_LEVEL_MULTI     5
#define PHP_LIB_CONFIG_VFS                    6

#define PHP_PHP_ONLY 0x01
#define PHP_PHP_EXPR 0x02

#define PHP_CTX_ERR      1
#define PHP_CTX_WARNING  2
#define PHP_CTX_NOTICE   3

#define PHP_VFS_VERSION 2

	struct php_vfs
	{
		const char* zName; int iVersion; int (*xChdir)(const char*); int (*xChroot)(const char*); int (*xGetcwd)(php_context*); int (*xMkdir)(const char*,int,int); int (*xRmdir)(const char*); int (*xIsdir)(const char*); int (*xRename)(const char*,const char*); int (*xRealpath)(const char*,php_context*); int (*xSleep)(unsigned int); int (*xUnlink)(const char*); int (*xFileExists)(const char*); int (*xChmod)(const char*,int); int (*xChown)(const char*,const char*); int (*xChgrp)(const char*,const char*);
		php_int64(*xFreeSpace)(const char*);
		php_int64(*xTotalSpace)(const char*);
		php_int64(*xFileSize)(const char*);
		php_int64(*xFileAtime)(const char*);
		php_int64(*xFileMtime)(const char*);
		php_int64(*xFileCtime)(const char*); int (*xStat)(const char*,php_value*,php_value*); int (*xlStat)(const char*,php_value*,php_value*); int (*xIsfile)(const char*); int (*xIslink)(const char*); int (*xReadable)(const char*); int (*xWritable)(const char*); int (*xExecutable)(const char*); int (*xFiletype)(const char*,php_context*); int (*xGetenv)(const char*,php_context*); int (*xSetenv)(const char*,const char*); int (*xTouch)(const char*,php_int64,php_int64); int (*xMmap)(const char*,void**,php_int64*);
		void (*xUnmap)(void*,php_int64); int (*xLink)(const char*,const char*,int); int (*xUmask)(int);
		void (*xTempDir)(php_context*);
		unsigned int (*xProcessId)(void); int (*xUid)(void); int (*xGid)(void);
		void (*xUsername)(php_context*); int (*xExec)(const char*,php_context*);
	};

#define PHP_IO_STREAM_VERSION 1

#define PHP_IO_OPEN_RDONLY   0x001
#define PHP_IO_OPEN_WRONLY   0x002
#define PHP_IO_OPEN_RDWR     0x004
#define PHP_IO_OPEN_CREATE   0x008
#define PHP_IO_OPEN_TRUNC    0x010
#define PHP_IO_OPEN_APPEND   0x020
#define PHP_IO_OPEN_EXCL     0x040
#define PHP_IO_OPEN_BINARY   0x080
#define PHP_IO_OPEN_TEMP     0x100
#define PHP_IO_OPEN_TEXT     0x200

	struct php_io_stream
	{
		const char* zName; int iVersion; int  (*xOpen)(const char*,int,php_value*,void**); int  (*xOpenDir)(const char*,php_value*,void**);
		void (*xClose)(void*);
		void (*xCloseDir)(void*);
		php_int64(*xRead)(void*,void*,php_int64); int (*xReadDir)(void*,php_context*);
		php_int64(*xWrite)(void*,const void*,php_int64); int (*xSeek)(void*,php_int64,int); int (*xLock)(void*,int);
		void (*xRewindDir)(void*);
		php_int64(*xTell)(void*); int (*xTrunc)(void*,php_int64); int (*xSync)(void*); int (*xStat)(void*,php_value*,php_value*);
	};

	PHP_APIEXPORT int php_init(php** ppEngine);PHP_APIEXPORT int php_config(php* pEngine,int nConfigOp,...);PHP_APIEXPORT int php_release(php* pEngine);PHP_APIEXPORT int php_compile(php* pEngine,const char* zSource,int nLen,php_vm** ppOutVm);PHP_APIEXPORT int php_compile_v2(php* pEngine,const char* zSource,int nLen,php_vm** ppOutVm,int iFlags);PHP_APIEXPORT int php_compile_file(php* pEngine,const char* zFilePath,php_vm** ppOutVm,int iFlags);PHP_APIEXPORT int php_vm_config(php_vm* pVm,int iConfigOp,...);PHP_APIEXPORT int php_vm_exec(php_vm* pVm,int* pExitStatus);PHP_APIEXPORT int php_vm_reset(php_vm* pVm);PHP_APIEXPORT int php_vm_release(php_vm* pVm);PHP_APIEXPORT int php_vm_dump_v2(php_vm* pVm,int (*xConsumer)(const void*,unsigned int,void*),void* pUserData);PHP_APIEXPORT int php_create_function(php_vm* pVm,const char* zName,int (*xFunc)(php_context*,int,php_value**),void* pUserData);PHP_APIEXPORT int php_delete_function(php_vm* pVm,const char* zName);PHP_APIEXPORT int php_create_constant(php_vm* pVm,const char* zName,void (*xExpand)(php_value*,void*),void* pUserData);PHP_APIEXPORT int php_delete_constant(php_vm* pVm,const char* zName);PHP_APIEXPORT int php_value_to_int(php_value* pValue);PHP_APIEXPORT int php_value_to_bool(php_value* pValue);PHP_APIEXPORT php_int64 php_value_to_int64(php_value* pValue);PHP_APIEXPORT double php_value_to_double(php_value* pValue);PHP_APIEXPORT const char* php_value_to_string(php_value* pValue,int* pLen);PHP_APIEXPORT void* php_value_to_resource(php_value* pValue);PHP_APIEXPORT int php_value_compare(php_value* pLeft,php_value* pRight,int bStrict);PHP_APIEXPORT int php_result_int(php_context* pCtx,int iValue);PHP_APIEXPORT int php_result_int64(php_context* pCtx,php_int64 iValue);PHP_APIEXPORT int php_result_bool(php_context* pCtx,int iBool);PHP_APIEXPORT int php_result_double(php_context* pCtx,double Value);PHP_APIEXPORT int php_result_null(php_context* pCtx);PHP_APIEXPORT int php_result_string(php_context* pCtx,const char* zString,int nLen);PHP_APIEXPORT int php_result_string_format(php_context* pCtx,const char* zFormat,...);PHP_APIEXPORT int php_result_value(php_context* pCtx,php_value* pValue);PHP_APIEXPORT int php_result_resource(php_context* pCtx,void* pUserData);PHP_APIEXPORT int php_context_output(php_context* pCtx,const char* zString,int nLen);PHP_APIEXPORT int php_context_output_format(php_context* pCtx,const char* zFormat,...);PHP_APIEXPORT int php_context_throw_error(php_context* pCtx,int iErr,const char* zErr);PHP_APIEXPORT int php_context_throw_error_format(php_context* pCtx,int iErr,const char* zFormat,...);PHP_APIEXPORT unsigned int php_context_random_num(php_context* pCtx);PHP_APIEXPORT int php_context_random_string(php_context* pCtx,char* zBuf,int nBuflen);PHP_APIEXPORT void* php_context_user_data(php_context* pCtx);PHP_APIEXPORT int    php_context_push_aux_data(php_context* pCtx,void* pUserData);PHP_APIEXPORT void* php_context_peek_aux_data(php_context* pCtx);PHP_APIEXPORT void* php_context_pop_aux_data(php_context* pCtx);PHP_APIEXPORT unsigned int php_context_result_buf_length(php_context* pCtx);PHP_APIEXPORT const char* php_function_name(php_context* pCtx);PHP_APIEXPORT void* php_context_alloc_chunk(php_context* pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease);PHP_APIEXPORT void* php_context_realloc_chunk(php_context* pCtx,void* pChunk,unsigned int nByte);PHP_APIEXPORT void php_context_free_chunk(php_context* pCtx,void* pChunk);PHP_APIEXPORT php_value* php_new_scalar(php_vm* pVm);PHP_APIEXPORT php_value* php_new_array(php_vm* pVm);PHP_APIEXPORT int php_release_value(php_vm* pVm,php_value* pValue);PHP_APIEXPORT php_value* php_context_new_scalar(php_context* pCtx);PHP_APIEXPORT php_value* php_context_new_array(php_context* pCtx);PHP_APIEXPORT void php_context_release_value(php_context* pCtx,php_value* pValue);PHP_APIEXPORT int php_value_int(php_value* pVal,int iValue);PHP_APIEXPORT int php_value_int64(php_value* pVal,php_int64 iValue);PHP_APIEXPORT int php_value_bool(php_value* pVal,int iBool);PHP_APIEXPORT int php_value_null(php_value* pVal);PHP_APIEXPORT int php_value_double(php_value* pVal,double Value);PHP_APIEXPORT int php_value_string(php_value* pVal,const char* zString,int nLen);PHP_APIEXPORT int php_value_string_format(php_value* pVal,const char* zFormat,...);PHP_APIEXPORT int php_value_reset_string_cursor(php_value* pVal);PHP_APIEXPORT int php_value_resource(php_value* pVal,void* pUserData);PHP_APIEXPORT int php_value_release(php_value* pVal);PHP_APIEXPORT php_value* php_array_fetch(php_value* pArray,const char* zKey,int nByte);PHP_APIEXPORT int php_array_walk(php_value* pArray,int (*xWalk)(php_value*,php_value*,void*),void* pUserData);PHP_APIEXPORT int php_array_add_elem(php_value* pArray,php_value* pKey,php_value* pValue);PHP_APIEXPORT int php_array_add_strkey_elem(php_value* pArray,const char* zKey,php_value* pValue);PHP_APIEXPORT int php_array_add_intkey_elem(php_value* pArray,int iKey,php_value* pValue);PHP_APIEXPORT unsigned int php_array_count(php_value* pArray);PHP_APIEXPORT int php_object_walk(php_value* pObject,int (*xWalk)(const char*,php_value*,void*),void* pUserData);PHP_APIEXPORT php_value* php_object_fetch_attr(php_value* pObject,const char* zAttr);PHP_APIEXPORT const char* php_object_get_class_name(php_value* pObject,int* pLength);PHP_APIEXPORT int php_value_is_int(php_value* pVal);PHP_APIEXPORT int php_value_is_float(php_value* pVal);PHP_APIEXPORT int php_value_is_bool(php_value* pVal);PHP_APIEXPORT int php_value_is_string(php_value* pVal);PHP_APIEXPORT int php_value_is_null(php_value* pVal);PHP_APIEXPORT int php_value_is_numeric(php_value* pVal);PHP_APIEXPORT int php_value_is_callable(php_value* pVal);PHP_APIEXPORT int php_value_is_scalar(php_value* pVal);PHP_APIEXPORT int php_value_is_array(php_value* pVal);PHP_APIEXPORT int php_value_is_object(php_value* pVal);PHP_APIEXPORT int php_value_is_resource(php_value* pVal);PHP_APIEXPORT int php_value_is_empty(php_value* pVal);PHP_APIEXPORT int php_lib_init(void);PHP_APIEXPORT int php_lib_config(int nConfigOp,...);PHP_APIEXPORT int php_lib_shutdown(void);PHP_APIEXPORT int php_lib_is_threadsafe(void);PHP_APIEXPORT const char* php_lib_version(void);PHP_APIEXPORT const char* php_lib_signature(void);PHP_APIEXPORT const char* php_lib_ident(void);PHP_APIEXPORT const char* php_lib_copyright(void);
#ifdef __cplusplus
}
#endif
#endif




#ifndef __PHPINT_H__
#define __PHPINT_H__

#ifdef PHP_AMALGAMATION

#define PHP_PRIVATE static
#else
#define PHP_PRIVATE
#include "php.h"
#endif
#ifndef PHP_PI

#define PHP_PI 3.1415926535898
#endif

#ifndef LARGEST_INT64
#define LARGEST_INT64  (0xffffffff|(((sxi64)0x7fffffff)<<32))
#endif
#ifndef SMALLEST_INT64
#define SMALLEST_INT64 (((sxi64)-1) - LARGEST_INT64)
#endif

typedef struct php_class_instance php_class_instance;typedef struct php_foreach_info   php_foreach_info;typedef struct php_foreach_step   php_foreach_step;typedef struct php_hashmap_node   php_hashmap_node;typedef struct php_hashmap        php_hashmap;typedef struct php_class          php_class;

#if !defined(SYMISC_STD_TYPES)
#define SYMISC_STD_TYPES
#ifdef __WINNT__

#if defined(__BORLANDC__)
#pragma warn -rch
#pragma warn -ccc
#pragma warn -aus
#pragma warn -csu
#pragma warn -spa
#endif
#endif
typedef signed char        sxi8;
typedef unsigned char      sxu8;
typedef signed short int   sxi16;
typedef unsigned short int sxu16;
typedef int                sxi32;
typedef unsigned int       sxu32;
typedef long               sxptr;typedef unsigned long      sxuptr;typedef long               sxlong;typedef unsigned long      sxulong;typedef sxi32              sxofft;typedef sxi64              sxofft64;typedef long double	       sxlongreal;typedef double             sxreal;
#define SXI8_HIGH       0x7F
#define SXU8_HIGH       0xFF
#define SXI16_HIGH      0x7FFF
#define SXU16_HIGH      0xFFFF
#define SXI32_HIGH      0x7FFFFFFF
#define SXU32_HIGH      0xFFFFFFFF
#define SXI64_HIGH      0x7FFFFFFFFFFFFFFF
#define SXU64_HIGH      0xFFFFFFFFFFFFFFFF
#if !defined(TRUE)
#define TRUE 1
#endif
#if !defined(FALSE)
#define FALSE 0
#endif

#if defined(__PTRDIFF_TYPE__)
# define SX_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))
# define SX_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))
#elif !defined(__GNUC__)
# define SX_INT_TO_PTR(X)  ((void*)&((char*)0)[X])
# define SX_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))
#else
# define SX_INT_TO_PTR(X)  ((void*)(X))
# define SX_PTR_TO_INT(X)  ((int)(X))
#endif
#define SXMIN(a,b)  ((a < b) ? (a) : (b))
#define SXMAX(a,b)  ((a < b) ? (b) : (a))
#endif

#if !defined(SYMISC_PRIVATE_DEFS)
#define SYMISC_PRIVATE_DEFS

typedef sxi32(*ProcRawStrCmp)(const SyString*,const SyString*);
#define SyStringData(RAW)	((RAW)->zString)
#define SyStringLength(RAW)	((RAW)->nByte)
#define SyStringInitFromBuf(RAW,ZBUF,NLEN){\
			(RAW)->zString 	= (const char *)ZBUF;\
			(RAW)->nByte	= (sxu32)(NLEN);\
		}
#define SyStringUpdatePtr(RAW,NBYTES){\
			if( NBYTES > (RAW)->nByte ){\
				(RAW)->nByte = 0;\
			}else{\
				(RAW)->zString += NBYTES;\
				(RAW)->nByte -= NBYTES;\
			}\
		}
#define SyStringDupPtr(RAW1,RAW2)\
			(RAW1)->zString = (RAW2)->zString;\
			(RAW1)->nByte = (RAW2)->nByte;

#define SyStringTrimLeadingChar(RAW,CHAR)\
			while((RAW)->nByte > 0 && (RAW)->zString[0] == CHAR ){\
					(RAW)->zString++;\
					(RAW)->nByte--;\
			}
#define SyStringTrimTrailingChar(RAW,CHAR)\
			while((RAW)->nByte > 0 && (RAW)->zString[(RAW)->nByte - 1] == CHAR){\
				(RAW)->nByte--;\
			}
#define SyStringCmp(RAW1,RAW2,xCMP)\
			(((RAW1)->nByte == (RAW2)->nByte) ? xCMP((RAW1)->zString,(RAW2)->zString,(RAW2)->nByte) : (sxi32)((RAW1)->nByte - (RAW2)->nByte))

#define SyStringCmp2(RAW1,RAW2,xCMP)\
			(((RAW1)->nByte >= (RAW2)->nByte) ? xCMP((RAW1)->zString,(RAW2)->zString,(RAW2)->nByte) : (sxi32)((RAW2)->nByte - (RAW1)->nByte))

#define SyStringCharCmp(RAW,CHAR) \
			(((RAW)->nByte == sizeof(char)) ? ((RAW)->zString[0] == CHAR ? 0 : CHAR - (RAW)->zString[0]) : ((RAW)->zString[0] == CHAR ? 0 : (RAW)->nByte - sizeof(char)))

#define SX_ADDR(PTR)    ((sxptr)PTR)
#define SX_ARRAYSIZE(X) (sizeof(X)/sizeof(X[0]))
#define SXUNUSED(P)	(P = 0)
#define	SX_EMPTY(PTR)   (PTR == 0)
#define SX_EMPTY_STR(STR) (STR == 0 || STR[0] == 0 )
typedef struct SyMemBackend SyMemBackend;typedef struct SyBlob SyBlob;typedef struct SySet SySet;

typedef sxi32(*ProcCmp)(const void*,const void*,sxu32);typedef sxi32(*ProcPatternMatch)(const char*,sxu32,const char*,sxu32,sxu32*);typedef sxi32(*ProcSearch)(const void*,sxu32,const void*,sxu32,ProcCmp,sxu32*);typedef sxu32(*ProcHash)(const void*,sxu32);typedef sxi32(*ProcHashSum)(const void*,sxu32,unsigned char*,sxu32);typedef sxi32(*ProcSort)(void*,sxu32,sxu32,ProcCmp);
#define MACRO_LIST_PUSH(Head,Item)\
			Item->pNext = Head;\
			Head = Item;
#define MACRO_LD_PUSH(Head,Item)\
			if( Head == 0 ){\
				Head = Item;\
			}else{\
				Item->pNext = Head;\
				Head->pPrev = Item;\
				Head = Item;\
			}
#define MACRO_LD_REMOVE(Head,Item)\
			if( Head == Item ){\
				Head = Head->pNext;\
			}\
			if( Item->pPrev ){ Item->pPrev->pNext = Item->pNext;}\
			if( Item->pNext ){ Item->pNext->pPrev = Item->pPrev;}

struct SySet
{ SyMemBackend* pAllocator;
	void* pBase;
	sxu32 nUsed;
	sxu32 nSize;
	sxu32 eSize;
	sxu32 nCursor;
	void* pUserData;
};
#define SySetBasePtr(S)           ((S)->pBase)
#define SySetBasePtrJump(S,OFFT)  (&((char *)(S)->pBase)[OFFT*(S)->eSize])
#define SySetUsed(S)              ((S)->nUsed)
#define SySetSize(S)              ((S)->nSize)
#define SySetElemSize(S)          ((S)->eSize)
#define SySetCursor(S)            ((S)->nCursor)
#define SySetGetAllocator(S)      ((S)->pAllocator)
#define SySetSetUserData(S,DATA)  ((S)->pUserData = DATA)
#define SySetGetUserData(S)       ((S)->pUserData)

struct SyBlob
{
	SyMemBackend* pAllocator;
	void* pBlob;
	sxu32  nByte;
	sxu32  mByte;
	sxu32  nFlags;
};
#define SXBLOB_LOCKED	0x01
#define SXBLOB_STATIC	0x02
#define SXBLOB_RDONLY   0x04

#define SyBlobFreeSpace(BLOB)	 ((BLOB)->mByte - (BLOB)->nByte)
#define SyBlobLength(BLOB)	     ((BLOB)->nByte)
#define SyBlobData(BLOB)	     ((BLOB)->pBlob)
#define SyBlobCurData(BLOB)	     ((void*)(&((char*)(BLOB)->pBlob)[(BLOB)->nByte]))
#define SyBlobDataAt(BLOB,OFFT)	 ((void *)(&((char *)(BLOB)->pBlob)[OFFT]))
#define SyBlobGetAllocator(BLOB) ((BLOB)->pAllocator)

#define SXMEM_POOL_INCR			3
#define SXMEM_POOL_NBUCKETS		12
#define SXMEM_BACKEND_MAGIC	0xBAC3E67D
#define SXMEM_BACKEND_CORRUPT(BACKEND)	(BACKEND == 0 || BACKEND->nMagic != SXMEM_BACKEND_MAGIC)

#define SXMEM_BACKEND_RETRY	3

typedef union SyMemHeader SyMemHeader;typedef struct SyMemBlock SyMemBlock;
struct SyMemBlock
{
	SyMemBlock* pNext,* pPrev;
#ifdef UNTRUST
	sxu32 nGuard;
#endif
};

union SyMemHeader
{
	SyMemHeader* pNext;
	sxu32 nBucket;
};
struct SyMemBackend
{
	const SyMutexMethods* pMutexMethods;
	const SyMemMethods* pMethods;
	SyMemBlock* pBlocks;
	sxu32 nBlock;
	ProcMemError xMemError;
	void* pUserData;
	SyMutex* pMutex;
	sxu32 nMagic;
	SyMemHeader* apPool[SXMEM_POOL_NBUCKETS + SXMEM_POOL_INCR];
};

#define SXMUTEX_TYPE_FAST	1
#define SXMUTEX_TYPE_RECURSIVE	2
#define SXMUTEX_TYPE_STATIC_1	3
#define SXMUTEX_TYPE_STATIC_2	4
#define SXMUTEX_TYPE_STATIC_3	5
#define SXMUTEX_TYPE_STATIC_4	6
#define SXMUTEX_TYPE_STATIC_5	7
#define SXMUTEX_TYPE_STATIC_6	8

#define SyMutexGlobalInit(METHOD){\
			if( (METHOD)->xGlobalInit ){\
			(METHOD)->xGlobalInit();\
			}\
		}
#define SyMutexGlobalRelease(METHOD){\
			if( (METHOD)->xGlobalRelease ){\
			(METHOD)->xGlobalRelease();\
			}\
		}
#define SyMutexNew(METHOD,TYPE)			(METHOD)->xNew(TYPE)
#define SyMutexRelease(METHOD,MUTEX){\
			if( MUTEX && (METHOD)->xRelease ){\
				(METHOD)->xRelease(MUTEX);\
			}\
		}
#define SyMutexEnter(METHOD,MUTEX){\
			if( MUTEX ){\
			(METHOD)->xEnter(MUTEX);\
			}\
		}
#define SyMutexTryEnter(METHOD,MUTEX){\
			if( MUTEX && (METHOD)->xTryEnter ){\
			(METHOD)->xTryEnter(MUTEX);\
			}\
		}
#define SyMutexLeave(METHOD,MUTEX){\
			if( MUTEX ){\
			(METHOD)->xLeave(MUTEX);\
			}\
		}

#define SX_MACRO_FAST_CMP(X1,X2,SIZE,RC){\
			register unsigned char *r1 = (unsigned char *)X1;\
			register unsigned char *r2 = (unsigned char *)X2;\
			register sxu32 LEN = SIZE;\
			for(;;){\
				if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\
				if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\
				if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\
				if( !LEN ){ break; }if( r1[0] != r2[0] ){ break; } r1++; r2++; LEN--;\
			}\
			RC = !LEN ? 0 : r1[0] - r2[0];\
		}
#define	SX_MACRO_FAST_MEMCPY(SRC,DST,SIZ){\
			register unsigned char *xSrc = (unsigned char *)SRC;\
			register unsigned char *xDst = (unsigned char *)DST;\
			register sxu32 xLen = SIZ;\
			for(;;){\
				if( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\
				if( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\
				if( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\
				if( !xLen ){ break; }xDst[0] = xSrc[0]; xDst++; xSrc++; --xLen;\
			}\
		}
#define SX_MACRO_BYTE_SWAP(X,Y,Z){\
			register unsigned char *s = (unsigned char *)X;\
			register unsigned char *d = (unsigned char *)Y;\
			sxu32	ZLong = Z;  \
			sxi32 c; \
			for(;;){\
				if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\
				if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\
				if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\
				if(!ZLong){ break; } c = s[0] ; s[0] = d[0]; d[0] = (unsigned char)c; s++; d++; --ZLong;\
			}\
		}
#define SX_MSEC_PER_SEC	(1000)
#define SX_USEC_PER_SEC	(1000000)
#define SX_NSEC_PER_SEC	(1000000000)
#endif

#if !defined(SYMISC_PRIVATE_AUX_DEFS)
#define SYMISC_PRIVATE_AUX_DEFS

typedef struct SyHashEntry_Pr SyHashEntry_Pr;typedef struct SyHashEntry SyHashEntry;typedef struct SyHash SyHash;

struct SyHashEntry
{
	const void* pKey;
	sxu32 nKeyLen;
	void* pUserData;
};
#define SyHashEntryGetUserData(ENTRY) ((ENTRY)->pUserData)
#define SyHashEntryGetKey(ENTRY)      ((ENTRY)->pKey)

struct SyHash
{
	SyMemBackend* pAllocator;
	ProcHash xHash;
	ProcCmp xCmp;
	SyHashEntry_Pr* pList,* pCurrent;
	sxu32 nEntry;
	SyHashEntry_Pr** apBucket;
	sxu32 nBucketSize;
};
#define SXHASH_BUCKET_SIZE 16
#define SXHASH_FILL_FACTOR 3

#define SyHashFunc(HASH)		((HASH)->xHash)
#define SyHashCmpFunc(HASH)		((HASH)->xCmp)
#define SyHashTotalEntry(HASH)	((HASH)->nEntry)
#define SyHashGetPool(HASH)		((HASH)->pAllocator)

typedef struct SyPRNGCtx SyPRNGCtx;
struct SyPRNGCtx
{
	sxu8 i,j;
	unsigned char s[256];
	sxu16 nMagic;
};typedef sxi32(*ProcRandomSeed)(void*,unsigned int,void*);

typedef struct sytime sytime;
struct sytime
{
	long tm_sec;
	long tm_usec;
};

typedef struct SyStream SyStream;typedef struct SyToken  SyToken;typedef struct SyLex    SyLex;

typedef sxi32(*ProcTokenizer)(SyStream*,SyToken*,void*,void*);

struct SyToken
{
	SyString sData;
	sxu32 nType;
	sxu32 nLine;
	void* pUserData;
};

struct SyStream
{
	const unsigned char* zInput;
	const unsigned char* zText;
	const unsigned char* zEnd;
	sxu32  nLine;
	sxu32  nIgn;
	SySet* pSet;
};

struct SyLex
{
	SyStream sStream;
	ProcTokenizer xTokenizer;
	void* pUserData;
	SySet* pTokenSet;
};
#define SyLexTotalToken(LEX)    SySetTotalEntry(&(LEX)->aTokenSet)
#define SyLexTotalLines(LEX)    ((LEX)->sStream.nLine)
#define SyLexTotalIgnored(LEX)  ((LEX)->sStream.nIgn)
#define XLEX_IN_LEN(STREAM)     (sxu32)(STREAM->zEnd - STREAM->zText)
#endif


#define SX_JMP_UTF8(zIn,zEnd)\
			while(zIn < zEnd && (((unsigned char)zIn[0] & 0xc0) == 0x80) ){ zIn++; }
#define SX_WRITE_UTF8(zOut,c) {                       \
			if( c<0x00080 ){                                     \
			*zOut++ = (sxu8)(c&0xFF);                          \
			}else if( c<0x00800 ){                               \
			*zOut++ = 0xC0 + (sxu8)((c>>6)&0x1F);              \
			*zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \
			}else if( c<0x10000 ){                               \
			*zOut++ = 0xE0 + (sxu8)((c>>12)&0x0F);             \
			*zOut++ = 0x80 + (sxu8)((c>>6) & 0x3F);            \
			*zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \
			}else{                                               \
			*zOut++ = 0xF0 + (sxu8)((c>>18) & 0x07);           \
			*zOut++ = 0x80 + (sxu8)((c>>12) & 0x3F);           \
			*zOut++ = 0x80 + (sxu8)((c>>6) & 0x3F);            \
			*zOut++ = 0x80 + (sxu8)(c & 0x3F);                 \
			}                                                    \
		}

#include <ctype.h>
#define SyToUpper(c) toupper(c)
#define SyToLower(c) tolower(c)
#define SyisUpper(c) isupper(c)
#define SyisLower(c) islower(c)
#define SyisSpace(c) isspace(c)
#define SyisBlank(c) isspace(c)
#define SyisAlpha(c) isalpha(c)
#define SyisDigit(c) isdigit(c)
#define SyisHex(c)	 isxdigit(c)
#define SyisPrint(c) isprint(c)
#define SyisPunct(c) ispunct(c)
#define SyisSpec(c)	 iscntrl(c)
#define SyisCtrl(c)	 iscntrl(c)
#define SyisAscii(c) isascii(c)
#define SyisAlphaNum(c) isalnum(c)
#define SyisGraph(c)     isgraph(c)
#define SyDigToHex(c)    "0123456789ABCDEF"[c & 0x0F]
#define SyDigToInt(c)     ((c < 0xc0 && SyisDigit(c))? (c - '0') : 0 )
#define SyCharToUpper(c)  ((c < 0xc0 && SyisLower(c))? SyToUpper(c) : c)
#define SyCharToLower(c)  ((c < 0xc0 && SyisUpper(c))? SyToLower(c) : c)

#define SyStringLeftTrim(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0 && SyisSpace((RAW)->zString[0])){\
				(RAW)->nByte--;\
				(RAW)->zString++;\
			}
#define SyStringLeftTrimSafe(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0 && ((RAW)->zString[0] == 0 || SyisSpace((RAW)->zString[0]))){\
				(RAW)->nByte--;\
				(RAW)->zString++;\
			}
#define SyStringRightTrim(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && SyisSpace((RAW)->zString[(RAW)->nByte - 1])){\
				(RAW)->nByte--;\
			}
#define SyStringRightTrimSafe(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && \
			(( RAW)->zString[(RAW)->nByte - 1] == 0 || SyisSpace((RAW)->zString[(RAW)->nByte - 1]))){\
				(RAW)->nByte--;\
			}

#define SyStringFullTrim(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0  && SyisSpace((RAW)->zString[0])){\
				(RAW)->nByte--;\
				(RAW)->zString++;\
			}\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && SyisSpace((RAW)->zString[(RAW)->nByte - 1])){\
				(RAW)->nByte--;\
			}
#define SyStringFullTrimSafe(RAW)\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[0] < 0xc0  && \
					( (RAW)->zString[0] == 0 || SyisSpace((RAW)->zString[0]))){\
				(RAW)->nByte--;\
				(RAW)->zString++;\
			}\
			while((RAW)->nByte > 0 && (unsigned char)(RAW)->zString[(RAW)->nByte - 1] < 0xc0  && \
							( (RAW)->zString[(RAW)->nByte - 1] == 0 || SyisSpace((RAW)->zString[(RAW)->nByte - 1]))){\
				(RAW)->nByte--;\
			}
#ifndef PHP_DISABLE_BUILTIN_FUNC

typedef struct SyXMLRawStr SyXMLRawStr;
struct SyXMLRawStr
{
	const char* zString;
	sxu32 nByte;
	sxu32 nLine;
};

typedef sxi32(*ProcXMLStartTagHandler)(SyXMLRawStr*,SyXMLRawStr*,sxu32,SyXMLRawStr*,void*);typedef sxi32(*ProcXMLTextHandler)(SyXMLRawStr*,void*);typedef sxi32(*ProcXMLEndTagHandler)(SyXMLRawStr*,SyXMLRawStr*,void*);typedef sxi32(*ProcXMLPIHandler)(SyXMLRawStr*,SyXMLRawStr*,void*);typedef sxi32(*ProcXMLDoctypeHandler)(SyXMLRawStr*,void*);typedef sxi32(*ProcXMLSyntaxErrorHandler)(const char*,int,SyToken*,void*);typedef sxi32(*ProcXMLStartDocument)(void*);typedef sxi32(*ProcXMLNameSpaceStart)(SyXMLRawStr*,SyXMLRawStr*,void*);typedef sxi32(*ProcXMLNameSpaceEnd)(SyXMLRawStr*,void*);typedef sxi32(*ProcXMLEndDocument)(void*);

#define SXML_ENABLE_NAMESPACE	    0x01
#define SXML_ENABLE_QUERY		    0x02
#define SXML_OPTION_CASE_FOLDING    0x04
#define SXML_OPTION_SKIP_TAGSTART   0x08
#define SXML_OPTION_SKIP_WHITE      0x10
#define SXML_OPTION_TARGET_ENCODING 0x20

enum xml_err_code {
	SXML_ERROR_NONE = 1,
	SXML_ERROR_NO_MEMORY,
	SXML_ERROR_SYNTAX,
	SXML_ERROR_NO_ELEMENTS,
	SXML_ERROR_INVALID_TOKEN,
	SXML_ERROR_UNCLOSED_TOKEN,
	SXML_ERROR_PARTIAL_CHAR,
	SXML_ERROR_TAG_MISMATCH,
	SXML_ERROR_DUPLICATE_ATTRIBUTE,
	SXML_ERROR_JUNK_AFTER_DOC_ELEMENT,
	SXML_ERROR_PARAM_ENTITY_REF,
	SXML_ERROR_UNDEFINED_ENTITY,
	SXML_ERROR_RECURSIVE_ENTITY_REF,
	SXML_ERROR_ASYNC_ENTITY,
	SXML_ERROR_BAD_CHAR_REF,
	SXML_ERROR_BINARY_ENTITY_REF,
	SXML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF,
	SXML_ERROR_MISPLACED_XML_PI,
	SXML_ERROR_UNKNOWN_ENCODING,
	SXML_ERROR_INCORRECT_ENCODING,
	SXML_ERROR_UNCLOSED_CDATA_SECTION,
	SXML_ERROR_EXTERNAL_ENTITY_HANDLING
};

typedef struct SyXMLParser SyXMLParser;
struct SyXMLParser
{
	SyMemBackend* pAllocator;
	void* pUserData;
	SyHash hns;
	SySet sToken;
	SyLex sLex;
	sxi32 nFlags;

	ProcXMLStartTagHandler    xStartTag;
	ProcXMLEndTagHandler      xEndTag;
	ProcXMLTextHandler        xRaw;
	ProcXMLDoctypeHandler     xDoctype;
	ProcXMLPIHandler          xPi;
	ProcXMLSyntaxErrorHandler xError;
	ProcXMLStartDocument      xStartDoc;
	ProcXMLEndDocument        xEndDoc;
	ProcXMLNameSpaceStart   xNameSpace;
	ProcXMLNameSpaceEnd       xNameSpaceEnd;
};

typedef struct SyArchiveEntry SyArchiveEntry;typedef struct SyArchive SyArchive;
struct SyArchive
{
	SyMemBackend* pAllocator;
	SyArchiveEntry* pCursor;
	SyArchiveEntry* pList;
	SyArchiveEntry** apHash;
	ProcRawStrCmp xCmp;
	ProcHash xHash;
	sxu32 nSize;
	sxu32 nEntry;
	sxu32 nLoaded;
	sxu32 nCentralOfft;
	sxu32 nCentralSize;
	void* pUserData;
	sxu32 nMagic;

};
#define SXARCH_MAGIC	0xDEAD635A
#define SXARCH_INVALID(ARCH)            (ARCH == 0  || ARCH->nMagic != SXARCH_MAGIC)
#define SXARCH_ENTRY_INVALID(ENTRY)	    (ENTRY == 0 || ENTRY->nMagic != SXARCH_MAGIC)
#define SyArchiveHashFunc(ARCH)	        (ARCH)->xHash
#define SyArchiveCmpFunc(ARCH)	        (ARCH)->xCmp
#define SyArchiveUserData(ARCH)         (ARCH)->pUserData
#define SyArchiveSetUserData(ARCH,DATA) (ARCH)->pUserData = DATA

struct SyArchiveEntry
{
	sxu32 nByte;
	sxu32 nByteCompr;
	sxu32 nReadCount;
	sxu32 nCrc;
	Sytm  sFmt;
	sxu32 nOfft;
	sxu16 nComprMeth;
	sxu16 nExtra;
	SyString sFileName;
	sxu32 nDup;
	SyArchiveEntry* pNextHash,* pPrevHash;
	SyArchiveEntry* pNextName;
	SyArchiveEntry* pNext,* pPrev;
	sxu32 nHash;
	void* pUserData;
	sxu32 nMagic;
};

#define SXZIP_EXTRA_TIMESTAMP	0x001
#endif
#ifndef PHP_DISABLE_HASH_FUNC

typedef struct MD5Context MD5Context;
struct MD5Context {
	sxu32 buf[4];
	sxu32 bits[2];
	unsigned char in[64];
};

typedef struct SHA1Context SHA1Context;
struct SHA1Context {
	unsigned int state[5];
	unsigned int count[2];
	unsigned char buffer[64];
};
#endif


struct php_value
{
	php_real rVal;
	union {
		sxi64 iVal;
		void* pOther;
	}x;
	sxi32 iFlags;
	php_vm* pVm;
	SyBlob sBlob;
	sxu32 nIdx;
};

#define MEMOBJ_STRING    0x001
#define MEMOBJ_INT       0x002
#define MEMOBJ_REAL      0x004
#define MEMOBJ_BOOL      0x008
#define MEMOBJ_NULL      0x020
#define MEMOBJ_HASHMAP   0x040
#define MEMOBJ_OBJ       0x080
#define MEMOBJ_RES       0x100
#define MEMOBJ_REFERENCE 0x400

#define MEMOBJ_ALL (MEMOBJ_STRING|MEMOBJ_INT|MEMOBJ_REAL|MEMOBJ_BOOL|MEMOBJ_NULL|MEMOBJ_HASHMAP|MEMOBJ_OBJ|MEMOBJ_RES)

#define MEMOBJ_SCALAR (MEMOBJ_STRING|MEMOBJ_INT|MEMOBJ_REAL|MEMOBJ_BOOL|MEMOBJ_NULL)
#define MEMOBJ_AUX (MEMOBJ_REFERENCE)

#define MemObjSetType(OBJ,TYPE) ((OBJ)->iFlags = ((OBJ)->iFlags&~MEMOBJ_ALL)|TYPE)

typedef sxi32(*ProcMemObjCast)(php_value*);

typedef struct php_output_consumer php_output_consumer;typedef struct php_user_func php_user_func;typedef struct php_conf php_conf;

struct php_output_consumer
{
	ProcConsumer xConsumer;
	void* pUserData;
	ProcConsumer xDef;
	void* pDefData;
};

struct php_conf
{
	ProcConsumer xErr;
	void* pErrData;
	SyBlob sErrConsumer;
};

typedef void (*ProcConstant)(php_value*,void*);

typedef struct php_constant php_constant;
struct php_constant
{
	SyString sName;
	ProcConstant xExpand;
	void* pUserData;
};typedef struct php_aux_data php_aux_data;

struct php_aux_data
{
	void* pAuxData;
};

typedef int (*ProchHostFunction)(php_context*,int,php_value**);

struct php_user_func
{
	php_vm* pVm;
	SyString sName;
	ProchHostFunction xFunc;
	void* pUserData;
	SySet aAux;
};

struct php_context
{
	php_user_func* pFunc;
	php_value* pRet;
	SySet sVar;
	SySet sChunk;
	php_vm* pVm;
	sxi32 iFlags;
};

struct php_hashmap_node
{
	php_hashmap* pMap;
	sxi32 iType;
	union {
		sxi64 iKey;
		SyBlob sKey;
	}xKey;
	sxi32 iFlags;
	sxu32 nHash;
	sxu32 nValIdx;
	php_hashmap_node* pNext,* pPrev;
	php_hashmap_node* pNextCollide,* pPrevCollide;
};

struct php_hashmap
{
	php_vm* pVm;
	php_hashmap_node** apBucket;
	php_hashmap_node* pFirst;
	php_hashmap_node* pLast;
	php_hashmap_node* pCur;
	sxu32 nSize;
	sxu32 nEntry;
	sxu32(*xIntHash)(sxi64);
	sxu32(*xBlobHash)(const void*,sxu32);
	sxi64 iNextIdx;
	sxi32 iRef;
};

struct php_foreach_info
{
	SyString sKey;
	SyString sValue;
	sxi32 iFlags;
	SySet aStep;
};
struct php_foreach_step
{
	sxi32 iFlags;

	union {
		php_hashmap* pMap;
		php_class_instance* pThis;
	}xIter;
};

#define PHP_4EACH_STEP_HASHMAP 0x001
#define PHP_4EACH_STEP_OBJECT  0x002
#define PHP_4EACH_STEP_KEY     0x004
#define PHP_4EACH_STEP_REF     0x008

struct php
{
	SyMemBackend sAllocator;
	const php_vfs* pVfs;
	php_conf xConf;
#if defined(PHP_ENABLE_THREADS)
	const SyMutexMethods* pMethods;
	SyMutex* pMutex;
#endif
	php_vm* pVms;
	sxi32 iVm;
	php* pNext,* pPrev;
	sxu32 nMagic;
};

typedef sxi32(*ProcErrorGen)(void*,sxi32,sxu32,const char*,...);typedef struct php_expr_node   php_expr_node;typedef struct php_expr_op     php_expr_op;typedef struct php_gen_state   php_gen_state;typedef struct GenBlock        GenBlock;typedef sxi32(*ProcLangConstruct)(php_gen_state*);typedef sxi32(*ProcNodeConstruct)(php_gen_state*,sxi32);

struct php_expr_op
{
	SyString sOp;
	sxi32 iOp;
	sxi32 iPrec;
	sxi32 iAssoc;
	sxi32 iVmOp;
};

struct php_expr_node
{
	const php_expr_op* pOp;
	php_expr_node* pLeft;
	php_expr_node* pRight;
	SyToken* pStart;
	SyToken* pEnd;
	sxi32 iFlags;
	ProcNodeConstruct xCode;
	SySet aNodeArgs;
	php_expr_node* pCond;
};

#define EXPR_NODE_PRE_INCR 0x01

struct GenBlock
{
	php_gen_state* pGen;
	GenBlock* pParent;
	sxu32 nFirstInstr;
	sxi32 iFlags;
	SySet aJumpFix;
	void* pUserData;

	sxu8 bPostContinue;
	SySet aPostContFix;
};

struct php_gen_state
{
	php_vm* pVm;
	SyHash hLiteral;
	SyHash hNumLiteral;
	SyHash hVar;
	GenBlock* pCurrent;
	GenBlock sGlobal;
	ProcConsumer xErr;
	void* pErrData;
	SySet aLabel;
	SySet aGoto;
	SyBlob sWorker;
	SyBlob sErrBuf;
	SyToken* pIn;
	SyToken* pEnd;
	sxu32 nErr;
	SyToken* pRawIn;
	SyToken* pRawEnd;
	SySet* pTokenSet;
};

typedef struct php_vm_func_closure_env php_vm_func_closure_env;typedef struct php_vm_func_static_var  php_vm_func_static_var;typedef struct php_vm_func_arg php_vm_func_arg;typedef struct php_vm_func php_vm_func;typedef struct VmFrame VmFrame;

struct php_vm_func_arg
{
	SyString sName;
	SySet aByteCode;
	sxu32 nType;
	SyString sClass;
	sxi32 iFlags;
};

struct php_vm_func_static_var
{
	SyString sName;
	SySet aByteCode;
	sxu32 nIdx;
};

struct php_vm_func_closure_env
{
	SyString sName; int iFlags;
	php_value sValue;
	sxu32 nIdx;
};

#define VM_FUNC_ARG_BY_REF   0x001
#define VM_FUNC_ARG_HAS_DEF  0x002
#define VM_FUNC_REF_RETURN   0x004
#define VM_FUNC_CLASS_METHOD 0x008
#define VM_FUNC_CLOSURE      0x010
#define VM_FUNC_ARG_IGNORE   0x020

struct php_vm_func
{
	SySet aArgs;
	SySet aStatic;
	SyString sName;
	SySet aByteCode;
	SySet aClosureEnv;
	sxi32 iFlags;
	SyString sSignature;
	void* pUserData;
	php_vm_func* pNextName;
};

typedef struct php_builtin_constant php_builtin_constant;typedef struct php_builtin_func php_builtin_func;

struct php_builtin_func
{
	const char* zName;
	ProchHostFunction xFunc;
};

struct php_builtin_constant
{
	const char* zName;
	ProcConstant xExpand;
};

typedef struct php_class_method php_class_method;typedef struct php_class_attr   php_class_attr;

struct php_class
{
	php_class* pBase;
	SyHash hDerived;
	SyString sName;
	sxi32 iFlags;
	SyHash hAttr;
	SyHash hMethod;
	sxu32 nLine;
	SySet aInterface;
	php_class* pNextName;
};

#define PHP_CLASS_FINAL       0x001
#define PHP_CLASS_INTERFACE   0x002
#define PHP_CLASS_ABSTRACT    0x004

#define PHP_CLASS_PROT_PUBLIC     1
#define PHP_CLASS_PROT_PROTECTED  2
#define PHP_CLASS_PROT_PRIVATE    3

struct php_class_attr
{
	SyString sName;
	sxi32 iFlags;
	sxi32 iProtection;
	SySet aByteCode;
	sxu32 nIdx;
	sxu32 nLine;
};

#define PHP_CLASS_ATTR_STATIC       0x001
#define PHP_CLASS_ATTR_CONSTANT     0x002
#define PHP_CLASS_ATTR_ABSTRACT     0x004
#define PHP_CLASS_ATTR_FINAL        0x008

struct php_class_method
{
	php_vm_func sFunc;
	SyString sVmName;
	sxi32 iProtection;
	sxi32 iFlags;
	sxi32 iCloneDepth;
	sxu32 nLine;
};

struct php_class_instance
{
	php_vm* pVm;
	php_class* pClass;
	SyHash hAttr;
	sxi32 iRef;
	sxi32 iFlags;
};

typedef struct VmInstr VmInstr;
struct VmInstr
{
	sxu8  iOp;
	sxi32 iP1;
	sxu32 iP2;
	void* p3;
};

typedef struct VmClassAttr VmClassAttr;
struct VmClassAttr
{
	php_class_attr* pAttr;
	sxu32 nIdx;
};

typedef struct VmRefObj VmRefObj;

typedef struct php_exception_block php_exception_block;typedef struct php_exception php_exception;
struct php_exception_block
{
	SyString sClass;
	SyString sThis;
	SySet sByteCode;
};

struct php_exception
{
	php_vm* pVm;
	SySet sEntry;
	VmFrame* pFrame;
};

typedef struct php_case_expr php_case_expr;typedef struct php_switch php_switch;

struct php_case_expr
{
	SySet aByteCode;
	sxu32 nStart;
};

struct php_switch
{
	SySet aCaseExpr;
	sxu32 nOut;
	sxu32 nDefault;
};

#define PHP_ASSERT_DISABLE    0x01
#define PHP_ASSERT_WARNING    0x02
#define PHP_ASSERT_BAIL       0x04
#define PHP_ASSERT_QUIET_EVAL 0x08
#define PHP_ASSERT_CALLBACK   0x10

typedef void (*ProcErrLog)(const char*,int,const char*,const char*);

struct php_vm
{
	SyMemBackend sAllocator;
#if defined(PHP_ENABLE_THREADS)
	SyMutex* pMutex;
#endif
	php* pEngine;
	SySet aByteCode;
	SySet* pByteContainer;
	VmFrame* pFrame;
	SyPRNGCtx sPrng;
	SySet aMemObj;
	SySet aLitObj;
	php_value* aOps;
	SySet aFreeObj;
	SyHash hClass;
	SyHash hConstant;
	SyHash hHostFunction;
	SyHash hFunction;
	SyHash hSuper;
	SyHash hPDO;
	SyBlob sConsumer;
	SyBlob sWorker;
	SyBlob sArgv;
	SySet aFiles;
	SySet aPaths;
	SySet aIncluded;
	SySet aOB;
	SySet aShutdown;
	SySet aException;
	SySet aIOstream;
	const php_io_stream* pDefStream;
	php_value sExec;
	php_value aExceptionCB[2];
	php_value aErrCB[2];
	void* pStdin;
	void* pStdout;
	void* pStderr; int bErrReport; int nRecursionDepth; int nMaxDepth; int nObDepth; int nExceptDepth; int closure_cnt; int json_rc;
	sxu32 unique_id;
	ProcErrLog xErrLog;
	sxu32 nOutputLen;
	php_output_consumer sVmConsumer; int iAssertFlags;
	php_value sAssertCallback;
	VmRefObj** apRefObj;
	VmRefObj* pRefList;
	sxu32 nRefSize;
	sxu32 nRefUsed;
	SySet aSelf;
	php_hashmap* pGlobal;
	sxu32 nGlobalIdx;
	sxi32 iExitStatus;
	php_gen_state sCodeGen;
	php_vm* pNext,* pPrev;
	sxu32 nMagic;
};

#define PHP_VM_INIT   0xFADE9512
#define PHP_VM_RUN    0xEA271285
#define PHP_VM_EXEC   0xCAFE2DAD
#define PHP_VM_STALE  0xBAD1DEAD

enum iErrCode{E_ERROR = 1,E_WARNING = 2,E_PARSE = 4,E_NOTICE = 8,E_CORE_WARNING = 16,E_USER_ERROR = 256,E_USER_WARNING = 512,E_USER_NOTICE = 1024,E_STRICT = 2048,E_RECOVERABLE_ERROR = 4096,E_DEPRECATED = 8192,E_USER_DEPRECATED = 16384,E_ALL = 32767};
enum php_vm_op {PHP_OP_DONE = 1,PHP_OP_HALT,PHP_OP_LOAD,PHP_OP_LOADC,PHP_OP_LOAD_IDX,PHP_OP_LOAD_MAP,PHP_OP_LOAD_LIST,PHP_OP_LOAD_CLOSURE,PHP_OP_NOOP,PHP_OP_JMP,PHP_OP_JZ,PHP_OP_JNZ,PHP_OP_POP,PHP_OP_CAT,PHP_OP_CVT_INT,PHP_OP_CVT_STR,PHP_OP_CVT_REAL,PHP_OP_CALL,PHP_OP_UMINUS,PHP_OP_UPLUS,PHP_OP_BITNOT,PHP_OP_LNOT,PHP_OP_MUL,PHP_OP_DIV,PHP_OP_MOD,PHP_OP_ADD,PHP_OP_SUB,PHP_OP_SHL,PHP_OP_SHR,PHP_OP_LT,PHP_OP_LE,PHP_OP_GT,PHP_OP_GE,PHP_OP_EQ,PHP_OP_NEQ,PHP_OP_TEQ,PHP_OP_TNE,PHP_OP_BAND,PHP_OP_BXOR,PHP_OP_BOR,PHP_OP_LAND,PHP_OP_LOR,PHP_OP_LXOR,PHP_OP_STORE,PHP_OP_STORE_IDX,PHP_OP_STORE_IDX_REF,PHP_OP_PULL,PHP_OP_SWAP,PHP_OP_YIELD,PHP_OP_CVT_BOOL,PHP_OP_CVT_NUMC,PHP_OP_INCR,PHP_OP_DECR,PHP_OP_SEQ,PHP_OP_SNE,PHP_OP_NEW,PHP_OP_CLONE,PHP_OP_ADD_STORE,PHP_OP_SUB_STORE,PHP_OP_MUL_STORE,PHP_OP_DIV_STORE,PHP_OP_MOD_STORE,PHP_OP_CAT_STORE,PHP_OP_SHL_STORE,PHP_OP_SHR_STORE,PHP_OP_BAND_STORE,PHP_OP_BOR_STORE,PHP_OP_BXOR_STORE,PHP_OP_CONSUME,PHP_OP_LOAD_REF,PHP_OP_STORE_REF,PHP_OP_MEMBER,PHP_OP_UPLINK,PHP_OP_CVT_NULL,PHP_OP_CVT_ARRAY,PHP_OP_CVT_OBJ,PHP_OP_FOREACH_INIT,PHP_OP_FOREACH_STEP,PHP_OP_IS_A,PHP_OP_LOAD_EXCEPTION,PHP_OP_POP_EXCEPTION,PHP_OP_THROW,PHP_OP_SWITCH,PHP_OP_ERR_CTRL};
enum php_expr_id {EXPR_OP_NEW = 1,EXPR_OP_CLONE,EXPR_OP_ARROW,EXPR_OP_DC,EXPR_OP_SUBSCRIPT,EXPR_OP_FUNC_CALL,EXPR_OP_INCR,EXPR_OP_DECR,EXPR_OP_BITNOT,EXPR_OP_UMINUS,EXPR_OP_UPLUS,EXPR_OP_TYPECAST,EXPR_OP_ALT,EXPR_OP_INSTOF,EXPR_OP_LOGNOT,EXPR_OP_MUL,EXPR_OP_DIV,EXPR_OP_MOD,EXPR_OP_ADD,EXPR_OP_SUB,EXPR_OP_DOT,EXPR_OP_SHL,EXPR_OP_SHR,EXPR_OP_LT,EXPR_OP_LE,EXPR_OP_GT,EXPR_OP_GE,EXPR_OP_EQ,EXPR_OP_NE,EXPR_OP_TEQ,EXPR_OP_TNE,EXPR_OP_SEQ,EXPR_OP_SNE,EXPR_OP_BAND,EXPR_OP_REF,EXPR_OP_XOR,EXPR_OP_BOR,EXPR_OP_LAND,EXPR_OP_LOR,EXPR_OP_LXOR,EXPR_OP_QUESTY,EXPR_OP_ASSIGN,EXPR_OP_ADD_ASSIGN,EXPR_OP_SUB_ASSIGN,EXPR_OP_MUL_ASSIGN,EXPR_OP_DIV_ASSIGN,EXPR_OP_MOD_ASSIGN,EXPR_OP_DOT_ASSIGN,EXPR_OP_AND_ASSIGN,EXPR_OP_OR_ASSIGN,EXPR_OP_XOR_ASSIGN,EXPR_OP_SHL_ASSIGN,EXPR_OP_SHR_ASSIGN,EXPR_OP_COMMA};

#define PHP_TOKEN_RAW 0x001
#define PHP_TOKEN_PHP 0x002

#define PHP_TK_INTEGER   0x0000001
#define PHP_TK_REAL      0x0000002
#define PHP_TK_NUM       (PHP_TK_INTEGER|PHP_TK_REAL)
#define PHP_TK_KEYWORD   0x0000004
#define PHP_TK_ID        0x0000008
#define PHP_TK_DOLLAR    0x0000010
#define PHP_TK_OP        0x0000020
#define PHP_TK_OCB       0x0000040
#define PHP_TK_CCB       0x0000080
#define PHP_TK_NSSEP     0x0000100
#define PHP_TK_LPAREN    0x0000200
#define PHP_TK_RPAREN    0x0000400
#define PHP_TK_OSB       0x0000800
#define PHP_TK_CSB       0x0001000
#define PHP_TK_DSTR      0x0002000
#define PHP_TK_SSTR      0x0004000
#define PHP_TK_HEREDOC   0x0008000
#define PHP_TK_NOWDOC    0x0010000
#define PHP_TK_COMMA     0x0020000
#define PHP_TK_SEMI      0x0040000
#define PHP_TK_BSTR      0x0080000
#define PHP_TK_COLON     0x0100000
#define PHP_TK_AMPER     0x0200000
#define PHP_TK_EQUAL     0x0400000
#define PHP_TK_ARRAY_OP  0x0800000
#define PHP_TK_OTHER     0x1000000

#define PHP_TKWRD_EXTENDS      1
#define PHP_TKWRD_ENDSWITCH    2
#define PHP_TKWRD_SWITCH       3
#define PHP_TKWRD_PRINT        4
#define PHP_TKWRD_INTERFACE    5
#define PHP_TKWRD_ENDDEC       6
#define PHP_TKWRD_DECLARE      7

#define PHP_TKWRD_REQONCE      9
#define PHP_TKWRD_REQUIRE      10
#define PHP_TKWRD_ELIF         0x4000000
#define PHP_TKWRD_ELSE         0x8000000
#define PHP_TKWRD_IF           13
#define PHP_TKWRD_FINAL        14
#define PHP_TKWRD_LIST         15
#define PHP_TKWRD_STATIC       16
#define PHP_TKWRD_CASE         17
#define PHP_TKWRD_SELF         18
#define PHP_TKWRD_FUNCTION     19
#define PHP_TKWRD_NAMESPACE    20
#define PHP_TKWRD_ENDIF        0x400000
#define PHP_TKWRD_CLONE        0x80
#define PHP_TKWRD_NEW          0x100
#define PHP_TKWRD_CONST        22
#define PHP_TKWRD_THROW        23
#define PHP_TKWRD_USE          24
#define PHP_TKWRD_ENDWHILE     0x800000
#define PHP_TKWRD_WHILE        26
#define PHP_TKWRD_EVAL         27
#define PHP_TKWRD_VAR          28
#define PHP_TKWRD_ARRAY        0x200
#define PHP_TKWRD_ABSTRACT     29
#define PHP_TKWRD_TRY          30
#define PHP_TKWRD_AND          0x400
#define PHP_TKWRD_DEFAULT      31
#define PHP_TKWRD_CLASS        32
#define PHP_TKWRD_AS           33
#define PHP_TKWRD_CONTINUE     34
#define PHP_TKWRD_EXIT         35
#define PHP_TKWRD_DIE          36
#define PHP_TKWRD_ECHO         37
#define PHP_TKWRD_GLOBAL       38
#define PHP_TKWRD_IMPLEMENTS   39
#define PHP_TKWRD_INCONCE      40
#define PHP_TKWRD_INCLUDE      41
#define PHP_TKWRD_EMPTY        42
#define PHP_TKWRD_INSTANCEOF   0x800
#define PHP_TKWRD_ISSET        43
#define PHP_TKWRD_PARENT       44
#define PHP_TKWRD_PRIVATE      45
#define PHP_TKWRD_ENDFOR       0x1000000
#define PHP_TKWRD_END4EACH     0x2000000
#define PHP_TKWRD_FOR          48
#define PHP_TKWRD_FOREACH      49
#define PHP_TKWRD_OR           0x1000
#define PHP_TKWRD_PROTECTED    50
#define PHP_TKWRD_DO           51
#define PHP_TKWRD_PUBLIC       52
#define PHP_TKWRD_CATCH        53
#define PHP_TKWRD_RETURN       54
#define PHP_TKWRD_UNSET        0x2000
#define PHP_TKWRD_XOR          0x4000
#define PHP_TKWRD_BREAK        55
#define PHP_TKWRD_GOTO         56
#define PHP_TKWRD_BOOL         0x8000
#define PHP_TKWRD_INT          0x10000
#define PHP_TKWRD_FLOAT        0x20000
#define PHP_TKWRD_STRING       0x40000
#define PHP_TKWRD_OBJECT       0x80000
#define PHP_TKWRD_SEQ          0x100000
#define PHP_TKWRD_SNE          0x200000

enum json_err_code {
	JSON_ERROR_NONE = 0,
	JSON_ERROR_DEPTH,
	JSON_ERROR_STATE_MISMATCH,
	JSON_ERROR_CTRL_CHAR,
	JSON_ERROR_SYNTAX,
	JSON_ERROR_UTF8
};

#define	JSON_HEX_TAG           0x01
#define JSON_HEX_AMP           0x02
#define JSON_HEX_APOS          0x04
#define JSON_HEX_QUOT          0x08
#define JSON_FORCE_OBJECT      0x10
#define JSON_NUMERIC_CHECK     0x20
#define JSON_BIGINT_AS_STRING  0x40
#define JSON_PRETTY_PRINT      0x80
#define JSON_UNESCAPED_SLASHES 0x100
#define JSON_UNESCAPED_UNICODE 0x200

PHP_PRIVATE sxi32 PHP_MemObjDump(SyBlob* pOut,php_value* pObj,int ShowType,int nTab,int nDepth,int isRef);PHP_PRIVATE const char* PHP_MemObjTypeDump(php_value* pVal);PHP_PRIVATE sxi32 PHP_MemObjAdd(php_value* pObj1,php_value* pObj2,int bAddStore);PHP_PRIVATE sxi32 PHP_MemObjCmp(php_value* pObj1,php_value* pObj2,int bStrict,int iNest);PHP_PRIVATE sxi32 PHP_MemObjInitFromString(php_vm* pVm,php_value* pObj,const SyString* pVal);PHP_PRIVATE sxi32 PHP_MemObjInitFromArray(php_vm* pVm,php_value* pObj,php_hashmap* pArray);
#if 0

PHP_PRIVATE sxi32 PHP_MemObjInitFromReal(php_vm* pVm,php_value* pObj,php_real rVal);
#endif
PHP_PRIVATE sxi32 PHP_MemObjInitFromInt(php_vm* pVm,php_value* pObj,sxi64 iVal);PHP_PRIVATE sxi32 PHP_MemObjInitFromBool(php_vm* pVm,php_value* pObj,sxi32 iVal);PHP_PRIVATE sxi32 PHP_MemObjInit(php_vm* pVm,php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjStringAppend(php_value* pObj,const char* zData,sxu32 nLen);
#if 0

PHP_PRIVATE sxi32 PHP_MemObjStringFormat(php_value* pObj,const char* zFormat,va_list ap);
#endif
PHP_PRIVATE sxi32 PHP_MemObjStore(php_value* pSrc,php_value* pDest);PHP_PRIVATE sxi32 PHP_MemObjLoad(php_value* pSrc,php_value* pDest);PHP_PRIVATE sxi32 PHP_MemObjRelease(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToNumeric(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjTryInteger(php_value* pObj);PHP_PRIVATE ProcMemObjCast PHP_MemObjCastMethod(sxi32 iFlags);PHP_PRIVATE sxi32 PHP_MemObjIsNumeric(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjIsEmpty(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToHashmap(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToObject(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToString(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToNull(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToReal(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToInteger(php_value* pObj);PHP_PRIVATE sxi32 PHP_MemObjToBool(php_value* pObj);PHP_PRIVATE sxi64 PHP_TokenValueToInt64(SyString* pData);PHP_PRIVATE sxi32 PHP_TokenizeRawText(const char* zInput,sxu32 nLen,SySet* pOut);PHP_PRIVATE sxi32 PHP_TokenizePHP(const char* zInput,sxu32 nLen,sxu32 nLineStart,SySet* pOut);PHP_PRIVATE void PHP_VmReleaseContextValue(php_context* pCtx,php_value* pValue);PHP_PRIVATE sxi32 PHP_VmInitFuncState(php_vm* pVm,php_vm_func* pFunc,const char* zName,sxu32 nByte,sxi32 iFlags,void* pUserData);PHP_PRIVATE sxi32 PHP_VmInstallUserFunction(php_vm* pVm,php_vm_func* pFunc,SyString* pName);PHP_PRIVATE sxi32 PHP_VmCreateClassInstanceFrame(php_vm* pVm,php_class_instance* pObj);PHP_PRIVATE sxi32 PHP_VmRefObjRemove(php_vm* pVm,sxu32 nIdx,SyHashEntry* pEntry,php_hashmap_node* pMapEntry);PHP_PRIVATE sxi32 PHP_VmRefObjInstall(php_vm* pVm,sxu32 nIdx,SyHashEntry* pEntry,php_hashmap_node* pMapEntry,sxi32 iFlags);PHP_PRIVATE sxi32 PHP_VmPushFilePath(php_vm* pVm,const char* zPath,int nLen,sxu8 bMain,sxi32* pNew);PHP_PRIVATE php_class* PHP_VmExtractClass(php_vm* pVm,const char* zName,sxu32 nByte,sxi32 iLoadable,sxi32 iNest);PHP_PRIVATE sxi32 PHP_VmRegisterConstant(php_vm* pVm,const SyString* pName,ProcConstant xExpand,void* pUserData);PHP_PRIVATE sxi32 PHP_VmInstallForeignFunction(php_vm* pVm,const SyString* pName,ProchHostFunction xFunc,void* pUserData);PHP_PRIVATE sxi32 PHP_VmInstallClass(php_vm* pVm,php_class* pClass);PHP_PRIVATE sxi32 PHP_VmBlobConsumer(const void* pSrc,unsigned int nLen,void* pUserData);PHP_PRIVATE php_value* PHP_ReserveMemObj(php_vm* pVm);PHP_PRIVATE php_value* PHP_ReserveConstObj(php_vm* pVm,sxu32* pIndex);PHP_PRIVATE sxi32 PHP_VmOutputConsume(php_vm* pVm,SyString* pString);PHP_PRIVATE sxi32 PHP_VmOutputConsumeAp(php_vm* pVm,const char* zFormat,va_list ap);PHP_PRIVATE sxi32 PHP_VmThrowErrorAp(php_vm* pVm,SyString* pFuncName,sxi32 iErr,const char* zFormat,va_list ap);PHP_PRIVATE sxi32 PHP_VmThrowError(php_vm* pVm,SyString* pFuncName,sxi32 iErr,const char* zMessage);PHP_PRIVATE void  PHP_VmExpandConstantValue(php_value* pVal,void* pUserData);PHP_PRIVATE sxi32 PHP_VmDump(php_vm* pVm,ProcConsumer xConsumer,void* pUserData);PHP_PRIVATE sxi32 PHP_VmInit(php_vm* pVm,php* pEngine);PHP_PRIVATE sxi32 PHP_VmConfigure(php_vm* pVm,sxi32 nOp,va_list ap);PHP_PRIVATE sxi32 PHP_VmByteCodeExec(php_vm* pVm);PHP_PRIVATE sxi32 PHP_VmRelease(php_vm* pVm);PHP_PRIVATE sxi32 PHP_VmReset(php_vm* pVm);PHP_PRIVATE sxi32 PHP_VmMakeReady(php_vm* pVm);PHP_PRIVATE sxu32 PHP_VmInstrLength(php_vm* pVm);PHP_PRIVATE VmInstr* PHP_VmPopInstr(php_vm* pVm);PHP_PRIVATE VmInstr* PHP_VmPeekInstr(php_vm* pVm);PHP_PRIVATE VmInstr* PHP_VmPeekNextInstr(php_vm* pVm);PHP_PRIVATE VmInstr* PHP_VmGetInstr(php_vm* pVm,sxu32 nIndex);PHP_PRIVATE SySet* PHP_VmGetByteCodeContainer(php_vm* pVm);PHP_PRIVATE sxi32 PHP_VmSetByteCodeContainer(php_vm* pVm,SySet* pContainer);PHP_PRIVATE sxi32 PHP_VmEmitInstr(php_vm* pVm,sxi32 iOp,sxi32 iP1,sxu32 iP2,void* p3,sxu32* pIndex);PHP_PRIVATE sxu32 PHP_VmRandomNum(php_vm* pVm);PHP_PRIVATE sxi32 PHP_VmCallClassMethod(php_vm* pVm,php_class_instance* pThis,php_class_method* pMethod,php_value* pResult,int nArg,php_value** apArg);PHP_PRIVATE sxi32 PHP_VmCallUserFunction(php_vm* pVm,php_value* pFunc,int nArg,php_value** apArg,php_value* pResult);PHP_PRIVATE sxi32 PHP_VmCallUserFunctionAp(php_vm* pVm,php_value* pFunc,php_value* pResult,...);PHP_PRIVATE sxi32 PHP_VmUnsetMemObj(php_vm* pVm,sxu32 nObjIdx,int bForce);PHP_PRIVATE void PHP_VmRandomString(php_vm* pVm,char* zBuf,int nLen);PHP_PRIVATE php_class* PHP_VmPeekTopClass(php_vm* pVm);PHP_PRIVATE int PHP_VmIsCallable(php_vm* pVm,php_value* pValue,int CallInvoke);
#ifndef PHP_DISABLE_BUILTIN_FUNC
	PHP_PRIVATE const php_io_stream* PHP_VmGetStreamDevice(php_vm* pVm,const char** pzDevice,int nByte);
#endif
PHP_PRIVATE int PHP_Utf8Read(const unsigned char* z,const unsigned char* zTerm,const unsigned char** pzNext);PHP_PRIVATE int PHP_IsLangConstruct(sxu32 nKeyID,sxu8 bCheckFunc); PHP_PRIVATE sxi32 PHP_ExprMakeTree(php_gen_state* pGen,SySet* pExprNode,php_expr_node** ppRoot); PHP_PRIVATE sxi32 PHP_GetNextExpr(SyToken* pStart,SyToken* pEnd,SyToken** ppNext); PHP_PRIVATE void PHP_DelimitNestedTokens(SyToken* pIn,SyToken* pEnd,sxu32 nTokStart,sxu32 nTokEnd,SyToken** ppEnd); PHP_PRIVATE const php_expr_op* PHP_ExprExtractOperator(SyString* pStr,SyToken* pLast); PHP_PRIVATE sxi32 PHP_ExprFreeTree(php_gen_state* pGen,SySet* pNodeSet);  PHP_PRIVATE ProcNodeConstruct PHP_GetNodeHandler(sxu32 nNodeType); PHP_PRIVATE sxi32 PHP_CompileLangConstruct(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileVariable(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileLiteral(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileSimpleString(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileString(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileArray(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileList(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_CompileAnnonFunc(php_gen_state* pGen,sxi32 iCompileFlag); PHP_PRIVATE sxi32 PHP_InitCodeGenerator(php_vm* pVm,ProcConsumer xErr,void* pErrData); PHP_PRIVATE sxi32 PHP_ResetCodeGenerator(php_vm* pVm,ProcConsumer xErr,void* pErrData); PHP_PRIVATE sxi32 PHP_GenCompileError(php_gen_state* pGen,sxi32 nErrType,sxu32 nLine,const char* zFormat,...); PHP_PRIVATE sxi32 PHP_CompileScript(php_vm* pVm,SyString* pScript,sxi32 iFlags);  PHP_PRIVATE void PHP_RegisterBuiltInConstant(php_vm* pVm);  PHP_PRIVATE void PHP_RegisterBuiltInFunction(php_vm* pVm);  PHP_PRIVATE php_hashmap* PHP_NewHashmap(php_vm* pVm,sxu32(*xIntHash)(sxi64),sxu32(*xBlobHash)(const void*,sxu32)); PHP_PRIVATE sxi32 PHP_HashmapCreateSuper(php_vm* pVm); PHP_PRIVATE sxi32 PHP_HashmapRelease(php_hashmap* pMap,int FreeDS); PHP_PRIVATE void  PHP_HashmapUnref(php_hashmap* pMap); PHP_PRIVATE sxi32 PHP_HashmapLookup(php_hashmap* pMap,php_value* pKey,php_hashmap_node** ppNode); PHP_PRIVATE sxi32 PHP_HashmapInsert(php_hashmap* pMap,php_value* pKey,php_value* pVal); PHP_PRIVATE sxi32 PHP_HashmapInsertByRef(php_hashmap* pMap,php_value* pKey,sxu32 nRefIdx); PHP_PRIVATE sxi32 PHP_HashmapUnion(php_hashmap* pLeft,php_hashmap* pRight); PHP_PRIVATE void PHP_HashmapUnlinkNode(php_hashmap_node* pNode,int bRestore); PHP_PRIVATE sxi32 PHP_HashmapDup(php_hashmap* pSrc,php_hashmap* pDest); PHP_PRIVATE sxi32 PHP_HashmapCmp(php_hashmap* pLeft,php_hashmap* pRight,int bStrict); PHP_PRIVATE void PHP_HashmapResetLoopCursor(php_hashmap* pMap); PHP_PRIVATE php_hashmap_node* PHP_HashmapGetNextEntry(php_hashmap* pMap); PHP_PRIVATE void PHP_HashmapExtractNodeValue(php_hashmap_node* pNode,php_value* pValue,int bStore); PHP_PRIVATE void PHP_HashmapExtractNodeKey(php_hashmap_node* pNode,php_value* pKey); PHP_PRIVATE void PHP_RegisterHashmapFunctions(php_vm* pVm); PHP_PRIVATE sxi32 PHP_HashmapDump(SyBlob* pOut,php_hashmap* pMap,int ShowType,int nTab,int nDepth); PHP_PRIVATE sxi32 PHP_HashmapWalk(php_hashmap* pMap,int (*xWalk)(php_value*,php_value*,void*),void* pUserData);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE int PHP_HashmapValuesToSet(php_hashmap* pMap,SySet* pOut);PHP_PRIVATE sxi32 PHP_InputFormat(int (*xConsumer)(php_context*,const char*,int,void*),php_context* pCtx,const char* zIn,int nByte,int nArg,php_value** apArg,void* pUserData,int vf);PHP_PRIVATE sxi32 PHP_ProcessCsv(const char* zInput,int nByte,int delim,int encl,int escape,sxi32(*xConsumer)(const char*,int,void*),void* pUserData);PHP_PRIVATE sxi32 PHP_CsvConsumer(const char* zToken,int nTokenLen,void* pUserData);PHP_PRIVATE sxi32 PHP_StripTagsFromString(php_context* pCtx,const char* zIn,int nByte,const char* zTaglist,int nTaglen);PHP_PRIVATE sxi32 PHP_ParseIniString(php_context* pCtx,const char* zIn,sxu32 nByte,int bProcessSection);
#endif
PHP_PRIVATE php_class* PHP_NewRawClass(php_vm* pVm,const SyString* pName,sxu32 nLine); PHP_PRIVATE php_class_attr* PHP_NewClassAttr(php_vm* pVm,const SyString* pName,sxu32 nLine,sxi32 iProtection,sxi32 iFlags); PHP_PRIVATE php_class_method* PHP_NewClassMethod(php_vm* pVm,php_class* pClass,const SyString* pName,sxu32 nLine, sxi32 iProtection,sxi32 iFlags,sxi32 iFuncFlags); PHP_PRIVATE php_class_method* PHP_ClassExtractMethod(php_class* pClass,const char* zName,sxu32 nByte); PHP_PRIVATE php_class_attr* PHP_ClassExtractAttribute(php_class* pClass,const char* zName,sxu32 nByte); PHP_PRIVATE sxi32 PHP_ClassInstallAttr(php_class* pClass,php_class_attr* pAttr); PHP_PRIVATE sxi32 PHP_ClassInstallMethod(php_class* pClass,php_class_method* pMeth); PHP_PRIVATE sxi32 PHP_ClassInherit(php_gen_state* pGen,php_class* pSub,php_class* pBase); PHP_PRIVATE sxi32 PHP_ClassInterfaceInherit(php_class* pSub,php_class* pBase); PHP_PRIVATE sxi32 PHP_ClassImplement(php_class* pMain,php_class* pInterface); PHP_PRIVATE php_class_instance* PHP_NewClassInstance(php_vm* pVm,php_class* pClass); PHP_PRIVATE php_class_instance* PHP_CloneClassInstance(php_class_instance* pSrc); PHP_PRIVATE sxi32 PHP_ClassInstanceCmp(php_class_instance* pLeft,php_class_instance* pRight,int bStrict,int iNest); PHP_PRIVATE void  PHP_ClassInstanceUnref(php_class_instance* pThis); PHP_PRIVATE sxi32 PHP_ClassInstanceDump(SyBlob* pOut,php_class_instance* pThis,int ShowType,int nTab,int nDepth); PHP_PRIVATE sxi32 PHP_ClassInstanceCallMagicMethod(php_vm* pVm,php_class* pClass,php_class_instance* pThis,const char* zMethod, sxu32 nByte,const SyString* pAttrName); PHP_PRIVATE php_value* PHP_ClassInstanceExtractAttrValue(php_class_instance* pThis,VmClassAttr* pAttr); PHP_PRIVATE sxi32 PHP_ClassInstanceToHashmap(php_class_instance* pThis,php_hashmap* pMap); PHP_PRIVATE sxi32 PHP_ClassInstanceWalk(php_class_instance* pThis, int (*xWalk)(const char*,php_value*,void*),void* pUserData); PHP_PRIVATE php_value* PHP_ClassInstanceFetchAttr(php_class_instance* pThis,const SyString* pName);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE void* PHP_StreamOpenHandle(php_vm* pVm,const php_io_stream* pStream,const char* zFile,int iFlags,int use_include,php_value* pResource,int bPushInclude,int* pNew);PHP_PRIVATE sxi32 PHP_StreamReadWholeFile(void* pHandle,const php_io_stream* pStream,SyBlob* pOut);PHP_PRIVATE void PHP_StreamCloseHandle(const php_io_stream* pStream,void* pHandle);
#endif
PHP_PRIVATE const char* PHP_ExtractDirName(const char* zPath,int nByte,int* pLen);PHP_PRIVATE sxi32 PHP_RegisterIORoutine(php_vm* pVm);PHP_PRIVATE const php_vfs* PHP_ExportBuiltinVfs(void);PHP_PRIVATE void* PHP_ExportStdin(php_vm* pVm);PHP_PRIVATE void* PHP_ExportStdout(php_vm* pVm);PHP_PRIVATE void* PHP_ExportStderr(php_vm* pVm);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyXMLParserInit(SyXMLParser* pParser,SyMemBackend* pAllocator,sxi32 iFlags);PHP_PRIVATE sxi32 SyXMLParserSetEventHandler(SyXMLParser* pParser,void* pUserData, ProcXMLStartTagHandler xStartTag, ProcXMLTextHandler xRaw, ProcXMLSyntaxErrorHandler xErr, ProcXMLStartDocument xStartDoc, ProcXMLEndTagHandler xEndTag, ProcXMLPIHandler xPi, ProcXMLEndDocument xEndDoc, ProcXMLDoctypeHandler xDoctype, ProcXMLNameSpaceStart xNameSpace, ProcXMLNameSpaceEnd xNameSpaceEnd);PHP_PRIVATE sxi32 SyXMLProcess(SyXMLParser* pParser,const char* zInput,sxu32 nByte); PHP_PRIVATE sxi32 SyXMLParserRelease(SyXMLParser* pParser); PHP_PRIVATE sxi32 SyArchiveInit(SyArchive* pArch,SyMemBackend* pAllocator,ProcHash xHash,ProcRawStrCmp xCmp); PHP_PRIVATE sxi32 SyArchiveRelease(SyArchive* pArch); PHP_PRIVATE sxi32 SyArchiveResetLoopCursor(SyArchive* pArch); PHP_PRIVATE sxi32 SyArchiveGetNextEntry(SyArchive* pArch,SyArchiveEntry** ppEntry); PHP_PRIVATE sxi32 SyZipExtractFromBuf(SyArchive* pArch,const char* zBuf,sxu32 nLen);
#endif
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBinToHexConsumer(const void* pIn,sxu32 nLen,ProcConsumer xConsumer,void* pConsumerData);
#endif
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_HASH_FUNC
PHP_PRIVATE sxu32 SyCrc32(const void* pSrc,sxu32 nLen); PHP_PRIVATE void MD5Update(MD5Context* ctx,const unsigned char* buf,unsigned int len); PHP_PRIVATE void MD5Final(unsigned char digest[16],MD5Context* ctx); PHP_PRIVATE sxi32 MD5Init(MD5Context* pCtx); PHP_PRIVATE sxi32 SyMD5Compute(const void* pIn,sxu32 nLen,unsigned char zDigest[16]); PHP_PRIVATE void SHA1Init(SHA1Context* context); PHP_PRIVATE void SHA1Update(SHA1Context* context,const unsigned char* data,unsigned int len); PHP_PRIVATE void SHA1Final(SHA1Context* context,unsigned char digest[20]); PHP_PRIVATE sxi32 SySha1Compute(const void* pIn,sxu32 nLen,unsigned char zDigest[20]);
#endif
#endif
PHP_PRIVATE sxi32 SyRandomness(SyPRNGCtx* pCtx,void* pBuf,sxu32 nLen);PHP_PRIVATE sxi32 SyRandomnessInit(SyPRNGCtx* pCtx,ProcRandomSeed xSeed,void* pUserData);PHP_PRIVATE sxu32 SyBufferFormat(char* zBuf,sxu32 nLen,const char* zFormat,...);PHP_PRIVATE sxu32 SyBlobFormatAp(SyBlob* pBlob,const char* zFormat,va_list ap);PHP_PRIVATE sxu32 SyBlobFormat(SyBlob* pBlob,const char* zFormat,...);PHP_PRIVATE sxi32 SyProcFormat(ProcConsumer xConsumer,void* pData,const char* zFormat,...);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE const char* SyTimeGetMonth(sxi32 iMonth);PHP_PRIVATE const char* SyTimeGetDay(sxi32 iDay);
#endif
PHP_PRIVATE sxi32 SyUriDecode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData,int bUTF8);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyUriEncode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData);
#endif
PHP_PRIVATE sxi32 SyLexRelease(SyLex* pLex);PHP_PRIVATE sxi32 SyLexTokenizeInput(SyLex* pLex,const char* zInput,sxu32 nLen,void* pCtxData,ProcSort xSort,ProcCmp xCmp);PHP_PRIVATE sxi32 SyLexInit(SyLex* pLex,SySet* pSet,ProcTokenizer xTokenizer,void* pUserData);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBase64Decode(const char* zB64,sxu32 nLen,ProcConsumer xConsumer,void* pUserData);PHP_PRIVATE sxi32 SyBase64Encode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData);
#endif
PHP_PRIVATE sxi32 SyStrToReal(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyBinaryStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyOctalStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyHexStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyHexToint(sxi32 c); PHP_PRIVATE sxi32 SyStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyStrToInt32(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest); PHP_PRIVATE sxi32 SyStrIsNumeric(const char* zSrc,sxu32 nLen,sxu8* pReal,const char** pzTail); PHP_PRIVATE SyHashEntry* SyHashLastEntry(SyHash* pHash); PHP_PRIVATE sxi32 SyHashInsert(SyHash* pHash,const void* pKey,sxu32 nKeyLen,void* pUserData); PHP_PRIVATE sxi32 SyHashForEach(SyHash* pHash,sxi32(*xStep)(SyHashEntry*,void*),void* pUserData); PHP_PRIVATE SyHashEntry* SyHashGetNextEntry(SyHash* pHash); PHP_PRIVATE sxi32 SyHashResetLoopCursor(SyHash* pHash); PHP_PRIVATE sxi32 SyHashDeleteEntry2(SyHashEntry* pEntry); PHP_PRIVATE sxi32 SyHashDeleteEntry(SyHash* pHash,const void* pKey,sxu32 nKeyLen,void** ppUserData); PHP_PRIVATE SyHashEntry* SyHashGet(SyHash* pHash,const void* pKey,sxu32 nKeyLen); PHP_PRIVATE sxi32 SyHashRelease(SyHash* pHash); PHP_PRIVATE sxi32 SyHashInit(SyHash* pHash,SyMemBackend* pAllocator,ProcHash xHash,ProcCmp xCmp); PHP_PRIVATE sxu32 SyStrHash(const void* pSrc,sxu32 nLen); PHP_PRIVATE void* SySetAt(SySet* pSet,sxu32 nIdx); PHP_PRIVATE void* SySetPop(SySet* pSet); PHP_PRIVATE void* SySetPeek(SySet* pSet); PHP_PRIVATE sxi32 SySetRelease(SySet* pSet); PHP_PRIVATE sxi32 SySetReset(SySet* pSet); PHP_PRIVATE sxi32 SySetResetCursor(SySet* pSet); PHP_PRIVATE sxi32 SySetGetNextEntry(SySet* pSet,void** ppEntry);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE void* SySetPeekCurrentEntry(SySet* pSet);
#endif
PHP_PRIVATE sxi32 SySetTruncate(SySet* pSet,sxu32 nNewSize);PHP_PRIVATE sxi32 SySetAlloc(SySet* pSet,sxi32 nItem);PHP_PRIVATE sxi32 SySetPut(SySet* pSet,const void* pItem);PHP_PRIVATE sxi32 SySetInit(SySet* pSet,SyMemBackend* pAllocator,sxu32 ElemSize);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBlobSearch(const void* pBlob,sxu32 nLen,const void* pPattern,sxu32 pLen,sxu32* pOfft);
#endif
PHP_PRIVATE sxi32 SyBlobRelease(SyBlob* pBlob); PHP_PRIVATE sxi32 SyBlobReset(SyBlob* pBlob); PHP_PRIVATE sxi32 SyBlobCmp(SyBlob* pLeft,SyBlob* pRight); PHP_PRIVATE sxi32 SyBlobDup(SyBlob* pSrc,SyBlob* pDest); PHP_PRIVATE sxi32 SyBlobNullAppend(SyBlob* pBlob); PHP_PRIVATE sxi32 SyBlobAppend(SyBlob* pBlob,const void* pData,sxu32 nSize); PHP_PRIVATE sxi32 SyBlobReadOnly(SyBlob* pBlob,const void* pData,sxu32 nByte); PHP_PRIVATE sxi32 SyBlobInit(SyBlob* pBlob,SyMemBackend* pAllocator); PHP_PRIVATE sxi32 SyBlobInitFromBuf(SyBlob* pBlob,void* pBuffer,sxu32 nSize); PHP_PRIVATE char* SyMemBackendStrDup(SyMemBackend* pBackend,const char* zSrc,sxu32 nSize); PHP_PRIVATE void* SyMemBackendDup(SyMemBackend* pBackend,const void* pSrc,sxu32 nSize); PHP_PRIVATE sxi32 SyMemBackendRelease(SyMemBackend* pBackend); PHP_PRIVATE sxi32 SyMemBackendInitFromOthers(SyMemBackend* pBackend,const SyMemMethods* pMethods,ProcMemError xMemErr,void* pUserData); PHP_PRIVATE sxi32 SyMemBackendInit(SyMemBackend* pBackend,ProcMemError xMemErr,void* pUserData); PHP_PRIVATE sxi32 SyMemBackendInitFromParent(SyMemBackend* pBackend,SyMemBackend* pParent);
#if 0

PHP_PRIVATE void* SyMemBackendPoolRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte);
#endif
PHP_PRIVATE sxi32 SyMemBackendPoolFree(SyMemBackend* pBackend,void* pChunk);PHP_PRIVATE void* SyMemBackendPoolAlloc(SyMemBackend* pBackend,sxu32 nByte);PHP_PRIVATE sxi32 SyMemBackendFree(SyMemBackend* pBackend,void* pChunk);PHP_PRIVATE void* SyMemBackendRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte);PHP_PRIVATE void* SyMemBackendAlloc(SyMemBackend* pBackend,sxu32 nByte);
#if defined(PHP_ENABLE_THREADS)
PHP_PRIVATE sxi32 SyMemBackendMakeThreadSafe(SyMemBackend* pBackend,const SyMutexMethods* pMethods);PHP_PRIVATE sxi32 SyMemBackendDisbaleMutexing(SyMemBackend* pBackend);
#endif
PHP_PRIVATE sxu32 SyMemcpy(const void* pSrc,void* pDest,sxu32 nLen);PHP_PRIVATE sxi32 SyMemcmp(const void* pB1,const void* pB2,sxu32 nSize);PHP_PRIVATE void SyZero(void* pSrc,sxu32 nSize);PHP_PRIVATE sxi32 SyStrnicmp(const char* zLeft,const char* zRight,sxu32 SLen);PHP_PRIVATE sxi32 SyStrnmicmp(const void* pLeft,const void* pRight,sxu32 SLen);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyStrncmp(const char* zLeft,const char* zRight,sxu32 nLen);
#endif
PHP_PRIVATE sxi32 SyByteListFind(const char* zSrc,sxu32 nLen,const char* zList,sxu32* pFirstPos);
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyByteFind2(const char* zStr,sxu32 nLen,sxi32 c,sxu32* pPos);
#endif
PHP_PRIVATE sxi32 SyByteFind(const char* zStr,sxu32 nLen,sxi32 c,sxu32* pPos);PHP_PRIVATE sxu32 SyStrlen(const char* zSrc);
#if defined(PHP_ENABLE_THREADS)
PHP_PRIVATE const SyMutexMethods* SyMutexExportMethods(void);PHP_PRIVATE sxi32 SyMemBackendMakeThreadSafe(SyMemBackend* pBackend,const SyMutexMethods* pMethods);PHP_PRIVATE sxi32 SyMemBackendDisbaleMutexing(SyMemBackend* pBackend);
#endif
#endif



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


struct VmFrame
{
	VmFrame* pParent;
	void* pUserData;
	php_class_instance* pThis;
	SySet sLocal;
	php_vm* pVm;
	SyHash hVar;
	SySet sArg;
	SySet sRef;
	sxi32 iFlags;
	sxu32 iExceptionJump;
};
#define VM_FRAME_EXCEPTION  0x01
#define VM_FRAME_THROW      0x02
#define VM_FRAME_CATCH      0x04

typedef struct VmSlot VmSlot;
struct VmSlot
{
	sxu32 nIdx;
	void* pUserData;
};

struct VmRefObj
{
	SySet aReference;
	SySet aArrEntries;
	sxu32 nIdx;
	sxi32 iFlags;
	VmRefObj* pNextCollide,* pPrevCollide;
	VmRefObj* pNext,* pPrev;
};
#define VM_REF_IDX_KEEP  0x001

typedef struct VmObEntry VmObEntry;
struct VmObEntry
{
	php_value sCallback;
	SyBlob sOB;
};

typedef struct VmShutdownCB VmShutdownCB;
struct VmShutdownCB
{
	php_value sCallback;
	php_value aArg[10]; int nArg;
};

#define PHP_EXCEPTION -255

typedef struct SyhttpUri SyhttpUri;
struct SyhttpUri
{
	SyString sHost;
	SyString sPort;
	SyString sPath;
	SyString sQuery;
	SyString sFragment;
	SyString sScheme;
	SyString sUser;
	SyString sPass;
	SyString sRaw;
};

typedef struct SyhttpHeader SyhttpHeader;
struct SyhttpHeader
{
	SyString sName;
	SyString sValue;
};

#define HTTP_METHOD_GET  1
#define HTTP_METHOD_HEAD 2
#define HTTP_METHOD_POST 3
#define HTTP_METHOD_PUT  4
#define HTTP_METHOD_OTHR 5

#define HTTP_PROTO_10 1
#define HTTP_PROTO_11 2

PHP_PRIVATE sxi32 PHP_VmRegisterConstant(
	php_vm* pVm,
	const SyString* pName,
	ProcConstant xExpand,
	void* pUserData
)
{
	php_constant* pCons;
	SyHashEntry* pEntry;
	char* zDupName;
	sxi32 rc;
	pEntry = SyHashGet(&pVm->hConstant,(const void*)pName->zString,pName->nByte);
	if (pEntry) {

		pCons = (php_constant*)pEntry->pUserData;
		pCons->xExpand = xExpand;
		pCons->pUserData = pUserData;
		return SXRET_OK;
	}

	pCons = (php_constant*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_constant));
	if (pCons == 0) {
		return 0;
	}

	zDupName = SyMemBackendStrDup(&pVm->sAllocator,pName->zString,pName->nByte);
	if (zDupName == 0) {
		SyMemBackendPoolFree(&pVm->sAllocator,pCons);
		return 0;
	}

	SyStringInitFromBuf(&pCons->sName,zDupName,pName->nByte);
	pCons->xExpand = xExpand;
	pCons->pUserData = pUserData;
	rc = SyHashInsert(&pVm->hConstant,(const void*)zDupName,SyStringLength(&pCons->sName),pCons);
	if (rc != SXRET_OK) {
		SyMemBackendFree(&pVm->sAllocator,zDupName);
		SyMemBackendPoolFree(&pVm->sAllocator,pCons);
		return rc;
	}

	return SXRET_OK;
}

static sxi32 PHP_NewForeignFunction(
	php_vm* pVm,
	const SyString* pName,
	ProchHostFunction xFunc,
	void* pUserData,
	php_user_func** ppOut
)
{
	php_user_func* pFunc;
	char* zDup;

	pFunc = (php_user_func*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_user_func));
	if (pFunc == 0) {
		return SXERR_MEM;
	}

	zDup = SyMemBackendStrDup(&pVm->sAllocator,pName->zString,pName->nByte);
	if (zDup == 0) {
		SyMemBackendPoolFree(&pVm->sAllocator,pFunc);
		return SXERR_MEM;
	}

	SyZero(pFunc,sizeof(php_user_func));

	SyStringInitFromBuf(&pFunc->sName,zDup,pName->nByte);
	pFunc->pVm = pVm;
	pFunc->xFunc = xFunc;
	pFunc->pUserData = pUserData;
	SySetInit(&pFunc->aAux,&pVm->sAllocator,sizeof(php_aux_data));

	*ppOut = pFunc;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmInstallForeignFunction(
	php_vm* pVm,
	const SyString* pName,
	ProchHostFunction xFunc,
	void* pUserData
)
{
	php_user_func* pFunc;
	SyHashEntry* pEntry;
	sxi32 rc;

	pEntry = SyHashGet(&pVm->hHostFunction,pName->zString,pName->nByte);
	if (pEntry) {
		pFunc = (php_user_func*)pEntry->pUserData;
		pFunc->pUserData = pUserData;
		pFunc->xFunc = xFunc;
		SySetReset(&pFunc->aAux);
		return SXRET_OK;
	}

	rc = PHP_NewForeignFunction(&(*pVm),&(*pName),xFunc,pUserData,&pFunc);
	if (rc != SXRET_OK) {
		return rc;
	}

	rc = SyHashInsert(&pVm->hHostFunction,SyStringData(&pFunc->sName),pName->nByte,pFunc);
	if (rc != SXRET_OK) {
		SyMemBackendFree(&pVm->sAllocator,(void*)SyStringData(&pFunc->sName));
		SyMemBackendPoolFree(&pVm->sAllocator,pFunc);
		return rc;
	}

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmInitFuncState(
	php_vm* pVm,
	php_vm_func* pFunc,
	const char* zName,
	sxu32 nByte,
	sxi32 iFlags,
	void* pUserData
)
{

	SyZero(pFunc,sizeof(php_vm_func));


	SySetInit(&pFunc->aArgs,&pVm->sAllocator,sizeof(php_vm_func_arg));

	SySetInit(&pFunc->aStatic,&pVm->sAllocator,sizeof(php_vm_func_static_var));

	SySetInit(&pFunc->aByteCode,&pVm->sAllocator,sizeof(VmInstr));

	SySetAlloc(&pFunc->aByteCode,0x10);

	SySetInit(&pFunc->aClosureEnv,&pVm->sAllocator,sizeof(php_vm_func_closure_env));
	pFunc->iFlags = iFlags;
	pFunc->pUserData = pUserData;
	SyStringInitFromBuf(&pFunc->sName,zName,nByte);
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmInstallUserFunction(
	php_vm* pVm,
	php_vm_func* pFunc,
	SyString* pName
)
{
	SyHashEntry* pEntry;
	sxi32 rc;
	if (pName == 0) {

		pName = &pFunc->sName;
	}

	pEntry = SyHashGet(&pVm->hFunction,pName->zString,pName->nByte);
	if (pEntry) {
		php_vm_func* pLink = (php_vm_func*)pEntry->pUserData;
		if (pLink != pFunc) {

			pFunc->pNextName = pLink;
			pEntry->pUserData = pFunc;
		}
		return SXRET_OK;
	}

	pFunc->pNextName = 0;
	rc = SyHashInsert(&pVm->hFunction,pName->zString,pName->nByte,pFunc);
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmInstallClass(
	php_vm* pVm,
	php_class* pClass
)
{
	SyString* pName = &pClass->sName;
	SyHashEntry* pEntry;
	sxi32 rc;

	pEntry = SyHashGet(&pVm->hClass,(const void*)pName->zString,pName->nByte);
	if (pEntry) {
		php_class* pLink = (php_class*)pEntry->pUserData;

		pClass->pNextName = pLink;
		pEntry->pUserData = pClass;
		return SXRET_OK;
	}
	pClass->pNextName = 0;

	rc = SyHashInsert(&pVm->hClass,(const void*)pName->zString,pName->nByte,pClass);
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmEmitInstr(
	php_vm* pVm,
	sxi32 iOp,
	sxi32 iP1,
	sxu32 iP2,
	void* p3,
	sxu32* pIndex
)
{
	VmInstr sInstr;
	sxi32 rc;

	sInstr.iOp = (sxu8)iOp;
	sInstr.iP1 = iP1;
	sInstr.iP2 = iP2;
	sInstr.p3 = p3;
	if (pIndex) {

		*pIndex = SySetUsed(pVm->pByteContainer);
	}

	rc = SySetPut(pVm->pByteContainer,(const void*)&sInstr);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(&pVm->sCodeGen,E_ERROR,1,"Fatal,Cannot emit instruction due to a memory failure");

	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmSetByteCodeContainer(php_vm* pVm,SySet* pContainer)
{
	if (pContainer == 0) {

		pVm->pByteContainer = &pVm->aByteCode;
	}
	else {

		pVm->pByteContainer = &(*pContainer);
	}
	return SXRET_OK;
}

PHP_PRIVATE SySet* PHP_VmGetByteCodeContainer(php_vm* pVm)
{
	return pVm->pByteContainer;
}

PHP_PRIVATE VmInstr* PHP_VmGetInstr(php_vm* pVm,sxu32 nIndex)
{
	VmInstr* pInstr;
	pInstr = (VmInstr*)SySetAt(pVm->pByteContainer,nIndex);
	return pInstr;
}

PHP_PRIVATE sxu32 PHP_VmInstrLength(php_vm* pVm)
{
	return SySetUsed(pVm->pByteContainer);
}

PHP_PRIVATE VmInstr* PHP_VmPopInstr(php_vm* pVm)
{
	return (VmInstr*)SySetPop(pVm->pByteContainer);
}

PHP_PRIVATE VmInstr* PHP_VmPeekInstr(php_vm* pVm)
{
	return (VmInstr*)SySetPeek(pVm->pByteContainer);
}
PHP_PRIVATE VmInstr* PHP_VmPeekNextInstr(php_vm* pVm)
{
	VmInstr* aInstr;
	sxu32 n;
	n = SySetUsed(pVm->pByteContainer);
	if (n < 2) {
		return 0;
	}
	aInstr = (VmInstr*)SySetBasePtr(pVm->pByteContainer);
	return &aInstr[n - 2];
}

static VmFrame* VmNewFrame(
	php_vm* pVm,
	void* pUserData,
	php_class_instance* pThis
)
{
	VmFrame* pFrame;

	pFrame = (VmFrame*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(VmFrame));
	if (pFrame == 0) {
		return 0;
	}

	SyZero(pFrame,sizeof(VmFrame));

	pFrame->pUserData = pUserData;
	pFrame->pThis = pThis;
	pFrame->pVm = pVm;
	SyHashInit(&pFrame->hVar,&pVm->sAllocator,0,0);
	SySetInit(&pFrame->sArg,&pVm->sAllocator,sizeof(VmSlot));
	SySetInit(&pFrame->sLocal,&pVm->sAllocator,sizeof(VmSlot));
	SySetInit(&pFrame->sRef,&pVm->sAllocator,sizeof(VmSlot));
	return pFrame;
}

static sxi32 VmEnterFrame(
	php_vm* pVm,
	void* pUserData,
	php_class_instance* pThis,
	VmFrame** ppFrame
)
{
	VmFrame* pFrame;

	pFrame = VmNewFrame(&(*pVm),pUserData,pThis);
	if (pFrame == 0) {
		return SXERR_MEM;
	}

	pFrame->pParent = pVm->pFrame;
	pVm->pFrame = pFrame;
	if (ppFrame) {

		*ppFrame = pFrame;
	}
	return SXRET_OK;
}

static sxi32 VmFrameLink(php_vm* pVm,SyString* pName)
{
	VmFrame* pTarget,* pFrame;
	SyHashEntry* pEntry = 0;
	sxi32 rc;

	pFrame = pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	pTarget = pFrame;
	pFrame = pTarget->pParent;
	while (pFrame) {
		if ((pFrame->iFlags & VM_FRAME_EXCEPTION) == 0) {

			pEntry = SyHashGet(&pFrame->hVar,(const void*)pName->zString,pName->nByte);
			if (pEntry) {

				break;
			}
		}

		pFrame = pFrame->pParent;
	}
	if (pEntry == 0) {

		return SXERR_NOTFOUND;
	}

	rc = SyHashInsert(&pTarget->hVar,pEntry->pKey,pEntry->nKeyLen,pEntry->pUserData);
	if (rc == SXRET_OK) {
		sxu32 nIdx;
		nIdx = SX_PTR_TO_INT(pEntry->pUserData);
		PHP_VmRefObjInstall(&(*pVm),nIdx,SyHashLastEntry(&pTarget->hVar),0,0);
	}
	return rc;
}

static void VmLeaveFrame(php_vm* pVm)
{
	VmFrame* pFrame = pVm->pFrame;
	if (pFrame) {

		pVm->pFrame = pFrame->pParent;
		if (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION) == 0) {
			VmSlot* aSlot;
			sxu32 n;

			aSlot = (VmSlot*)SySetBasePtr(&pFrame->sLocal);
			for (n = 0; n < SySetUsed(&pFrame->sLocal); ++n) {

				PHP_VmUnsetMemObj(&(*pVm),aSlot[n].nIdx,FALSE);
			}

			aSlot = (VmSlot*)SySetBasePtr(&pFrame->sRef);
			for (n = 0; n < SySetUsed(&pFrame->sRef); ++n) {
				PHP_VmRefObjRemove(&(*pVm),aSlot[n].nIdx,(SyHashEntry*)aSlot[n].pUserData,0);
			}
		}

		SyHashRelease(&pFrame->hVar);
		SySetRelease(&pFrame->sArg);
		SySetRelease(&pFrame->sLocal);
		SySetRelease(&pFrame->sRef);

		SyMemBackendPoolFree(&pVm->sAllocator,pFrame);
	}
}

static int VmOverloadCompare(SyString* pFirst,SyString* pSecond)
{
	const char* zSend = &pSecond->zString[pSecond->nByte];
	const char* zFend = &pFirst->zString[pFirst->nByte];
	const char* zSin = pSecond->zString;
	const char* zFin = pFirst->zString;
	const char* zPtr = zFin;
	for (;;) {
		if (zFin >= zFend || zSin >= zSend) {
			break;
		}
		if (zFin[0] != zSin[0]) {

			break;
		}
		zFin++;
		zSin++;
	}
	return (int)(zFin - zPtr);
}

static php_vm_func* VmOverload(
	php_vm* pVm,
	php_vm_func* pList,
	php_value* aArg,
	int nArg
)
{
	int iTarget,i,j,iCur,iMax;
	php_vm_func* apSet[10];
	php_vm_func* pLink;
	SyString sArgSig;
	SyBlob sSig;

	pLink = pList;
	i = 0;

	while (i < (int)SX_ARRAYSIZE(apSet)) {
		if (pLink == 0) {
			break;
		}
		if ((int)SySetUsed(&pLink->aArgs) == nArg) {

			apSet[i++] = pLink;
		}

		pLink = pLink->pNextName;
	}
	if (i < 1) {

		return pList;
	}
	if (nArg < 1 || i < 2) {

		return apSet[0];
	}

	SyBlobInit(&sSig,&pVm->sAllocator);
	for (j = 0; j < nArg; j++) {
		int c = 'n';
		if (aArg[j].iFlags & MEMOBJ_HASHMAP) {

			c = 'h';
		}
		else if (aArg[j].iFlags & MEMOBJ_BOOL) {

			c = 'b';
		}
		else if (aArg[j].iFlags & MEMOBJ_INT) {

			c = 'i';
		}
		else if (aArg[j].iFlags & MEMOBJ_STRING) {

			c = 's';
		}
		else if (aArg[j].iFlags & MEMOBJ_REAL) {

			c = 'f';
		}
		else if (aArg[j].iFlags & MEMOBJ_OBJ) {

			php_class* pClass = ((php_class_instance*)aArg[j].x.pOther)->pClass;
			SyString* pName = &pClass->sName;
			SyBlobAppend(&sSig,(const void*)pName->zString,pName->nByte);
			c = -1;
		}
		if (c > 0) {
			SyBlobAppend(&sSig,(const void*)&c,sizeof(char));
		}
	}
	SyStringInitFromBuf(&sArgSig,SyBlobData(&sSig),SyBlobLength(&sSig));
	iTarget = 0;
	iMax = -1;

	for (j = 0; j < i; j++) {

		iCur = VmOverloadCompare(&sArgSig,&apSet[j]->sSignature);
		if (iCur > iMax) {
			iMax = iCur;
			iTarget = j;
		}
	}
	SyBlobRelease(&sSig);

	return apSet[iTarget];
}

static sxi32 VmLocalExec(php_vm* pVm,SySet* pByteCode,php_value* pResult);
static sxi32 VmErrorFormat(php_vm* pVm,sxi32 iErr,const char* zFormat,...);

static sxi32 VmMountUserClass(
	php_vm* pVm,
	php_class* pClass
)
{
	php_class_method* pMeth;
	php_class_attr* pAttr;
	SyHashEntry* pEntry;
	sxi32 rc;

	SyHashResetLoopCursor(&pClass->hAttr);

	while ((pEntry = SyHashGetNextEntry(&pClass->hAttr)) != 0) {

		pAttr = (php_class_attr*)pEntry->pUserData;
		if (pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) {
			php_value* pMemObj;

			pMemObj = PHP_ReserveMemObj(&(*pVm));
			if (pMemObj == 0) {
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,
					"Cannot reserve a memory object for class attribute '%z->%z' due to a memory failure",
					&pClass->sName,&pAttr->sName
				);
				return SXERR_MEM;
			}
			if (SySetUsed(&pAttr->aByteCode) > 0) {

				VmLocalExec(&(*pVm),&pAttr->aByteCode,pMemObj);
			}

			pAttr->nIdx = pMemObj->nIdx;

			PHP_VmRefObjInstall(&(*pVm),pMemObj->nIdx,0,0,VM_REF_IDX_KEEP);
		}
	}

	if (pClass->iFlags & PHP_CLASS_INTERFACE) {

		return SXRET_OK;
	}

	if (SyHashGet(&pClass->hMethod,"__construct",sizeof("__construct") - 1) == 0) {

		pEntry = SyHashGet(&pClass->hMethod,SyStringData(&pClass->sName),SyStringLength(&pClass->sName));
		if (pEntry) {
			pMeth = (php_class_method*)pEntry->pUserData;

			SyHashInsert(&pClass->hMethod,"__construct",sizeof("__construct") - 1,pMeth);
		}
	}

	SyHashResetLoopCursor(&pClass->hMethod);
	while ((pEntry = SyHashGetNextEntry(&pClass->hMethod)) != 0) {
		pMeth = (php_class_method*)pEntry->pUserData;
		if ((pMeth->iFlags & PHP_CLASS_ATTR_ABSTRACT) == 0) {
			rc = PHP_VmInstallUserFunction(&(*pVm),&pMeth->sFunc,&pMeth->sVmName);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmCreateClassInstanceFrame(
	php_vm* pVm,
	php_class_instance* pObj
)
{
	php_class* pClass = pObj->pClass;
	php_class_attr* pAttr;
	SyHashEntry* pEntry;
	sxi32 rc;

	SyHashResetLoopCursor(&pClass->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pClass->hAttr)) != 0) {
		VmClassAttr* pVmAttr;

		pAttr = (php_class_attr*)pEntry->pUserData;
		pVmAttr = (VmClassAttr*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(VmClassAttr));
		if (pVmAttr == 0) {
			return SXERR_MEM;
		}
		pVmAttr->pAttr = pAttr;
		if ((pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) == 0) {
			php_value* pMemObj;

			pMemObj = PHP_ReserveMemObj(&(*pVm));
			if (pMemObj == 0) {
				SyMemBackendPoolFree(&pVm->sAllocator,pVmAttr);
				return SXERR_MEM;
			}
			pVmAttr->nIdx = pMemObj->nIdx;
			if (SySetUsed(&pAttr->aByteCode) > 0) {

				VmLocalExec(&(*pVm),&pAttr->aByteCode,pMemObj);
			}
			rc = SyHashInsert(&pObj->hAttr,SyStringData(&pAttr->sName),SyStringLength(&pAttr->sName),pVmAttr);
			if (rc != SXRET_OK) {
				VmSlot sSlot;

				sSlot.nIdx = pMemObj->nIdx;
				sSlot.pUserData = 0;
				SySetPut(&pVm->aFreeObj,(const void*)&sSlot);
				SyMemBackendPoolFree(&pVm->sAllocator,pVmAttr);
				return SXERR_MEM;
			}

			PHP_VmRefObjInstall(&(*pVm),pMemObj->nIdx,0,0,VM_REF_IDX_KEEP);
		}
		else {

			pVmAttr->nIdx = pAttr->nIdx;
			rc = SyHashInsert(&pObj->hAttr,SyStringData(&pAttr->sName),SyStringLength(&pAttr->sName),pVmAttr);
			if (rc != SXRET_OK) {
				SyMemBackendPoolFree(&pVm->sAllocator,pVmAttr);
				return SXERR_MEM;
			}
		}
	}
	return SXRET_OK;
}

static VmRefObj* VmRefObjExtract(php_vm* pVm,sxu32 nObjIdx);
static sxi32 VmRefObjUnlink(php_vm* pVm,VmRefObj* pRef);

static const char zDummy[sizeof(php_value)] = { 0 };

PHP_PRIVATE php_value* PHP_ReserveConstObj(php_vm* pVm,sxu32* pIndex)
{
	php_value* pObj;
	sxi32 rc;
	if (pIndex) {

		*pIndex = SySetUsed(&pVm->aLitObj);
	}

	rc = SySetPut(&pVm->aLitObj,(const void*)zDummy);
	if (rc != SXRET_OK) {

		return 0;
	}
	pObj = (php_value*)SySetPeek(&pVm->aLitObj);
	return pObj;
}

PHP_PRIVATE php_value* VmReserveMemObj(php_vm* pVm,sxu32* pIndex)
{
	php_value* pObj;
	sxi32 rc;
	if (pIndex) {

		*pIndex = SySetUsed(&pVm->aMemObj);
	}

	rc = SySetPut(&pVm->aMemObj,(const void*)zDummy);
	if (rc != SXRET_OK) {

		return 0;
	}
	pObj = (php_value*)SySetPeek(&pVm->aMemObj);
	return pObj;
}

static sxi32 VmEvalChunk(php_vm* pVm,php_context* pCtx,SyString* pChunk,int iFlags,int bTrueReturn);

#define PHP_BUILTIN_LIB ""


PHP_PRIVATE sxi32 PHP_VmInit(
	php_vm* pVm,
	php* pEngine
)
{
	SyString sBuiltin;
	php_value* pObj;
	sxi32 rc;

	SyZero(pVm,sizeof(php_vm));

	pVm->pEngine = &(*pEngine);
	SyMemBackendInitFromParent(&pVm->sAllocator,&pEngine->sAllocator);

	SySetInit(&pVm->aByteCode,&pVm->sAllocator,sizeof(VmInstr));
	SySetAlloc(&pVm->aByteCode,0xFF);
	pVm->pByteContainer = &pVm->aByteCode;
	SySetInit(&pVm->aMemObj,&pVm->sAllocator,sizeof(php_value));SySetAlloc(&pVm->aMemObj,0xFF);SyBlobInit(&pVm->sConsumer,&pVm->sAllocator);SyBlobInit(&pVm->sWorker,&pVm->sAllocator);SyBlobInit(&pVm->sArgv,&pVm->sAllocator);SySetInit(&pVm->aLitObj,&pVm->sAllocator,sizeof(php_value));SySetAlloc(&pVm->aLitObj,0xFF);SyHashInit(&pVm->hHostFunction,&pVm->sAllocator,0,0);SyHashInit(&pVm->hFunction,&pVm->sAllocator,0,0);SyHashInit(&pVm->hClass,&pVm->sAllocator,SyStrHash,SyStrnmicmp);SyHashInit(&pVm->hConstant,&pVm->sAllocator,0,0);SyHashInit(&pVm->hSuper,&pVm->sAllocator,0,0);SyHashInit(&pVm->hPDO,&pVm->sAllocator,0,0);SySetInit(&pVm->aFreeObj,&pVm->sAllocator,sizeof(VmSlot));SySetInit(&pVm->aSelf,&pVm->sAllocator,sizeof(php_class*));SySetInit(&pVm->aShutdown,&pVm->sAllocator,sizeof(VmShutdownCB));SySetInit(&pVm->aException,&pVm->sAllocator,sizeof(php_exception*));SySetInit(&pVm->aFiles,&pVm->sAllocator,sizeof(SyString));SySetInit(&pVm->aPaths,&pVm->sAllocator,sizeof(SyString));SySetInit(&pVm->aIncluded,&pVm->sAllocator,sizeof(SyString));SySetInit(&pVm->aOB,&pVm->sAllocator,sizeof(VmObEntry));SySetInit(&pVm->aIOstream,&pVm->sAllocator,sizeof(php_io_stream*));PHP_MemObjInit(&(*pVm),&pVm->aExceptionCB[0]);PHP_MemObjInit(&(*pVm),&pVm->aExceptionCB[1]);PHP_MemObjInit(&(*pVm),&pVm->aErrCB[0]);PHP_MemObjInit(&(*pVm),&pVm->aErrCB[1]);PHP_MemObjInit(&(*pVm),&pVm->sAssertCallback);

#if defined(__WINNT__) || defined(__UNIXES__)
	pVm->nMaxDepth = 32;
#else
	pVm->nMaxDepth = 16;
#endif
	pVm->iAssertFlags = PHP_ASSERT_WARNING; pVm->json_rc = JSON_ERROR_NONE;SyRandomnessInit(&pVm->sPrng,0,0);pObj = PHP_ReserveConstObj(&(*pVm),0);if (pObj == 0) {rc = SXERR_MEM;goto Err;}PHP_MemObjInit(pVm,pObj);pObj = PHP_ReserveConstObj(&(*pVm),0);if (pObj == 0) {rc = SXERR_MEM;goto Err;}PHP_MemObjInitFromBool(pVm,pObj,1);pObj = PHP_ReserveConstObj(&(*pVm),0);if (pObj == 0) {rc = SXERR_MEM;goto Err;}PHP_MemObjInitFromBool(pVm,pObj,0);rc = VmEnterFrame(&(*pVm),0,0,0);if (rc != SXRET_OK) {goto Err;}rc = PHP_InitCodeGenerator(pVm,pEngine->xConf.xErr,pEngine->xConf.pErrData);if (rc != SXRET_OK) {goto Err;}pVm->nMagic = PHP_VM_INIT;SyStringInitFromBuf(&sBuiltin,PHP_BUILTIN_LIB,sizeof(PHP_BUILTIN_LIB) - 1);VmEvalChunk(&(*pVm),0,&sBuiltin,PHP_PHP_ONLY,FALSE);PHP_ResetCodeGenerator(&(*pVm),pEngine->xConf.xErr,pEngine->xConf.pErrData);return SXRET_OK;
Err:
	SyMemBackendRelease(&pVm->sAllocator);return rc;
}

PHP_PRIVATE sxi32 PHP_VmBlobConsumer(
	const void* pOut,
	unsigned int nLen,
	void* pUserData
)
{
	sxi32 rc;

	rc = SyBlobAppend((SyBlob*)pUserData,pOut,nLen);
	return rc;
}
#define VM_STACK_GUARD 16

static php_value* VmNewOperandStack(
	php_vm* pVm,
	sxu32 nInstr
)
{
	php_value* pStack;

	nInstr += VM_STACK_GUARD;
	pStack = (php_value*)SyMemBackendAlloc(&pVm->sAllocator,nInstr * sizeof(php_value));
	if (pStack == 0) {
		return 0;
	}

	while (nInstr > 0) {
		PHP_MemObjInit(&(*pVm),&pStack[nInstr - 1]);
		--nInstr;
	}

	return pStack;
}

static sxi32 VmRegisterSpecialFunction(php_vm* pVm);
static int VmInstanceOf(php_class* pThis,php_class* pClass);
static int VmClassMemberAccess(php_vm* pVm,php_class* pClass,const SyString* pAttrName,sxi32 iProtection,int bLog);

PHP_PRIVATE sxi32 PHP_VmMakeReady(
	php_vm* pVm
)
{
	SyHashEntry* pEntry;
	sxi32 rc;
	if (pVm->nMagic != PHP_VM_INIT) {

		return SXERR_CORRUPT;
	}

	pVm->nMagic = PHP_VM_RUN;

	PHP_ResetCodeGenerator(pVm,0,0);

	rc = PHP_VmEmitInstr(&(*pVm),PHP_OP_DONE,0,0,0,0);
	if (rc != SXRET_OK) {
		return SXERR_MEM;
	}

	PHP_MemObjInit(&(*pVm),&pVm->sExec);

	pVm->aOps = VmNewOperandStack(&(*pVm),SySetUsed(pVm->pByteContainer));
	if (pVm->aOps == 0) {
		return SXERR_MEM;
	}

	pVm->sVmConsumer.xConsumer = PHP_VmBlobConsumer;
	pVm->sVmConsumer.pUserData = &pVm->sConsumer;

	pVm->nRefSize = 0x10;
	pVm->apRefObj = (VmRefObj**)SyMemBackendAlloc(&pVm->sAllocator,sizeof(VmRefObj*) * pVm->nRefSize);
	if (pVm->apRefObj == 0) {

		return SXERR_MEM;
	}

	SyZero(pVm->apRefObj,sizeof(VmRefObj*) * pVm->nRefSize);

	rc = VmRegisterSpecialFunction(&(*pVm));
	if (rc != SXRET_OK) {

		return rc;
	}

	rc = PHP_HashmapCreateSuper(&(*pVm));
	if (rc != SXRET_OK) {

		return rc;
	}

	PHP_RegisterBuiltInConstant(&(*pVm));

	PHP_RegisterBuiltInFunction(&(*pVm));

	SyHashResetLoopCursor(&pVm->hClass);
	while ((pEntry = SyHashGetNextEntry(&pVm->hClass)) != 0) {
		rc = VmMountUserClass(&(*pVm),(php_class*)pEntry->pUserData);
		if (rc != SXRET_OK) {
			return rc;
		}
	}

	pVm->unique_id = PHP_VmRandomNum(&(*pVm)) & 1023;

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmReset(php_vm* pVm)
{
	if (pVm->nMagic != PHP_VM_RUN && pVm->nMagic != PHP_VM_EXEC) {
		return SXERR_CORRUPT;
	}

	SyBlobReset(&pVm->sConsumer);
	PHP_MemObjRelease(&pVm->sExec);

	pVm->nMagic = PHP_VM_RUN;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmRelease(php_vm* pVm)
{

	pVm->nMagic = PHP_VM_STALE;

	SyMemBackendRelease(&pVm->sAllocator);
	return SXRET_OK;
}

static sxi32 VmInitCallContext(
	php_context* pOut,
	php_vm* pVm,
	php_user_func* pFunc,
	php_value* pRet,
	sxi32 iFlags
)
{
	pOut->pFunc = pFunc;
	pOut->pVm = pVm;
	SySetInit(&pOut->sVar,&pVm->sAllocator,sizeof(php_value*));
	SySetInit(&pOut->sChunk,&pVm->sAllocator,sizeof(php_aux_data));

	MemObjSetType(pRet,MEMOBJ_NULL);
	pOut->pRet = pRet;
	pOut->iFlags = iFlags;
	return SXRET_OK;
}

static void VmReleaseCallContext(php_context* pCtx)
{
	sxu32 n;
	if (SySetUsed(&pCtx->sVar) > 0) {
		php_value** apObj = (php_value**)SySetBasePtr(&pCtx->sVar);
		for (n = 0; n < SySetUsed(&pCtx->sVar); ++n) {
			if (apObj[n] == 0) {

				continue;
			}
			PHP_MemObjRelease(apObj[n]);
			SyMemBackendPoolFree(&pCtx->pVm->sAllocator,apObj[n]);
		}
		SySetRelease(&pCtx->sVar);
	}
	if (SySetUsed(&pCtx->sChunk) > 0) {
		php_aux_data* aAux;
		void* pChunk;

		aAux = (php_aux_data*)SySetBasePtr(&pCtx->sChunk);
		for (n = 0; n < SySetUsed(&pCtx->sChunk); ++n) {
			pChunk = aAux[n].pAuxData;

			if (pChunk) {
				SyMemBackendFree(&pCtx->pVm->sAllocator,pChunk);
			}
		}
		SySetRelease(&pCtx->sChunk);
	}
}

PHP_PRIVATE void PHP_VmReleaseContextValue(
	php_context* pCtx,
	php_value* pValue
)
{
	if (pValue == 0) {

		return;
	}
	if (SySetUsed(&pCtx->sVar) > 0) {
		php_value** apObj = (php_value**)SySetBasePtr(&pCtx->sVar);
		sxu32 n;
		for (n = 0; n < SySetUsed(&pCtx->sVar); ++n) {
			if (apObj[n] == pValue) {
				PHP_MemObjRelease(pValue);
				SyMemBackendPoolFree(&pCtx->pVm->sAllocator,pValue);

				apObj[n] = 0;
				break;
			}
		}
	}
}

static void VmPopOperand(
	php_value** ppTos,
	sxi32 nPop
)
{
	php_value* pTos = *ppTos;
	while (nPop > 0) {
		PHP_MemObjRelease(pTos);
		pTos--;
		nPop--;
	}

	*ppTos = pTos;
}

PHP_PRIVATE php_value* PHP_ReserveMemObj(php_vm* pVm)
{
	php_value* pObj = 0;
	VmSlot* pSlot;
	sxu32 nIdx;

	nIdx = SXU32_HIGH;
	pSlot = (VmSlot*)SySetPop(&pVm->aFreeObj);
	if (pSlot) {
		pObj = (php_value*)SySetAt(&pVm->aMemObj,pSlot->nIdx);
		nIdx = pSlot->nIdx;
	}
	if (pObj == 0) {

		pObj = VmReserveMemObj(&(*pVm),&nIdx);
		if (pObj == 0) {
			return 0;
		}
	}

	PHP_MemObjInit(&(*pVm),pObj);
	pObj->nIdx = nIdx;
	return pObj;
}

static sxi32 VmHashmapRefInsert(
	php_hashmap* pMap,
	const char* zKey,
	sxu32 nByte,
	sxu32 nRefIdx
)
{
	php_value sKey;
	sxi32 rc;
	PHP_MemObjInitFromString(pMap->pVm,&sKey,0);
	PHP_MemObjStringAppend(&sKey,zKey,nByte);

	rc = PHP_HashmapInsertByRef(&(*pMap),&sKey,nRefIdx);
	PHP_MemObjRelease(&sKey);
	return rc;
}

static php_value* VmExtractMemObj(
	php_vm* pVm,
	const SyString* pName,
	int bDup,
	int bCreate
)
{
	int bNullify = FALSE;
	SyHashEntry* pEntry;
	VmFrame* pFrame;
	php_value* pObj;
	sxu32 nIdx;
	sxi32 rc;

	pFrame = pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}

	if (pName == 0 || pName->nByte < 1) {
		static const SyString sAnnon = { " " ,sizeof(char) };
		pName = &sAnnon;

		bNullify = TRUE;
		bDup = FALSE;
	}

	pEntry = SyHashGet(&pVm->hSuper,(const void*)pName->zString,pName->nByte);
	if (pEntry == 0) {

		pEntry = SyHashGet(&pFrame->hVar,(const void*)pName->zString,pName->nByte);
		if (pEntry == 0) {
			char* zName = (char*)pName->zString;
			VmSlot sLocal;
			if (!bCreate) {

				return 0;
			}

			pObj = PHP_ReserveMemObj(&(*pVm));
			if (pObj == 0) {
				return 0;
			}
			nIdx = pObj->nIdx;
			if (bDup) {

				zName = SyMemBackendStrDup(&pVm->sAllocator,pName->zString,pName->nByte);
				if (zName == 0) {
					return 0;
				}
			}

			rc = SyHashInsert(&pFrame->hVar,zName,pName->nByte,SX_INT_TO_PTR(nIdx));
			if (rc != SXRET_OK) {

				sLocal.nIdx = nIdx;
				sLocal.pUserData = 0;
				SySetPut(&pVm->aFreeObj,(const void*)&sLocal);
				return 0;
			}
			if (pFrame->pParent != 0) {

				sLocal.nIdx = nIdx;
				SySetPut(&pFrame->sLocal,(const void*)&sLocal);
			}
			else {

				VmHashmapRefInsert(pVm->pGlobal,pName->zString,pName->nByte,nIdx);
			}

			PHP_VmRefObjInstall(&(*pVm),nIdx,SyHashLastEntry(&pFrame->hVar),0,0);

			pObj->nIdx = nIdx;
		}
		else {

			nIdx = (sxu32)SX_PTR_TO_INT(pEntry->pUserData);
			pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
			if (bNullify && pObj) {
				PHP_MemObjRelease(pObj);
			}
		}
	}
	else {

		nIdx = (sxu32)SX_PTR_TO_INT(pEntry->pUserData);
		pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
	}
	return pObj;
}

static php_value* VmExtractSuper(
	php_vm* pVm,
	const char* zName,
	sxu32 nByte
)
{
	SyHashEntry* pEntry;
	php_value* pValue;
	sxu32 nIdx;

	pEntry = SyHashGet(&pVm->hSuper,(const void*)zName,nByte);
	if (pEntry == 0) {

		return 0;
	}

	nIdx = SX_PTR_TO_INT(pEntry->pUserData);

	pValue = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
	return pValue;
}

static sxi32 VmHashmapInsert(
	php_hashmap* pMap,
	const char* zKey,
	int nKeylen,
	const char* zData,
	int nLen
)
{
	php_value sKey,sValue;
	sxi32 rc;
	PHP_MemObjInitFromString(pMap->pVm,&sKey,0);
	PHP_MemObjInitFromString(pMap->pVm,&sValue,0);
	if (zKey) {
		if (nKeylen < 0) {
			nKeylen = (int)SyStrlen(zKey);
		}
		PHP_MemObjStringAppend(&sKey,zKey,(sxu32)nKeylen);
	}
	if (zData) {
		if (nLen < 0) {

			nLen = (int)SyStrlen(zData);
		}
		PHP_MemObjStringAppend(&sValue,zData,(sxu32)nLen);
	}

	rc = PHP_HashmapInsert(&(*pMap),&sKey,&sValue);
	PHP_MemObjRelease(&sKey);
	PHP_MemObjRelease(&sValue);
	return rc;
}

static sxi32 VmHttpProcessRequest(php_vm* pVm,const char* zRequest,int nByte);

PHP_PRIVATE sxi32 PHP_VmConfigure(
	php_vm* pVm,
	sxi32 nOp,
	va_list ap
)
{
	sxi32 rc = SXRET_OK;
	switch (nOp) {
	case PHP_VM_CONFIG_OUTPUT: {
		ProcConsumer xConsumer = va_arg(ap,ProcConsumer);
		void* pUserData = va_arg(ap,void*);

#ifdef UNTRUST
		if (xConsumer == 0) {
			rc = SXERR_CORRUPT;
			break;
		}
#endif

		pVm->sVmConsumer.xConsumer = xConsumer;
		pVm->sVmConsumer.pUserData = pUserData;
		break;
	}
	case PHP_VM_CONFIG_IMPORT_PATH: {

		const char* zPath;
		SyString sPath;
		zPath = va_arg(ap,const char*);
#if defined(UNTRUST)
		if (zPath == 0) {
			rc = SXERR_EMPTY;
			break;
		}
#endif
		SyStringInitFromBuf(&sPath,zPath,SyStrlen(zPath));

#ifdef __WINNT__
		SyStringTrimTrailingChar(&sPath,'\\');
#endif
		SyStringTrimTrailingChar(&sPath,'/');

		SyStringFullTrim(&sPath);
		if (sPath.nByte > 0) {

			rc = SySetPut(&pVm->aPaths,(const void*)&sPath);
		}
		break;
	}
	case PHP_VM_CONFIG_ERR_REPORT:

		pVm->bErrReport = 1;
		break;
	case PHP_VM_CONFIG_RECURSION_DEPTH: {

		int nDepth = va_arg(ap,int);
		if (nDepth > 2 && nDepth < 1024) {
			pVm->nMaxDepth = nDepth;
		}
		break;
	}
	case PHP_VM_OUTPUT_LENGTH: {

		sxu32* pOut = va_arg(ap,sxu32*);
#ifdef UNTRUST
		if (pOut == 0) {
			rc = SXERR_CORRUPT;
			break;
		}
#endif
		* pOut = pVm->nOutputLen;
		break;
	}

	case PHP_VM_CONFIG_CREATE_SUPER:
	case PHP_VM_CONFIG_CREATE_VAR: {

		const char* zName = va_arg(ap,const char*);
		php_value* pValue = va_arg(ap,php_value*);
		SyHashEntry* pEntry;
		php_value* pObj;
		sxu32 nByte;
		sxu32 nIdx;
#ifdef UNTRUST
		if (SX_EMPTY_STR(zName) || pValue == 0) {
			rc = SXERR_CORRUPT;
			break;
		}
#endif
		nByte = SyStrlen(zName);
		if (nOp == PHP_VM_CONFIG_CREATE_SUPER) {

			pEntry = SyHashGet(&pVm->hSuper,(const void*)zName,nByte);
		}
		else {

			pEntry = SyHashGet(&pVm->pFrame->hVar,(const void*)zName,nByte);
		}
		if (pEntry) {

			nIdx = SX_PTR_TO_INT(pEntry->pUserData);

			pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
			if (pObj) {

				PHP_MemObjStore(pValue,pObj);
			}
		}
		else {

			pObj = PHP_ReserveMemObj(&(*pVm));
			if (pObj == 0) {
				rc = SXERR_MEM;
				break;
			}
			nIdx = pObj->nIdx;

			PHP_MemObjStore(pValue,pObj);
			if (nOp == PHP_VM_CONFIG_CREATE_SUPER) {

				rc = SyHashInsert(&pVm->hSuper,(const void*)zName,nByte,SX_INT_TO_PTR(nIdx));
			}
			else {

				rc = SyHashInsert(&pVm->pFrame->hVar,(const void*)zName,nByte,SX_INT_TO_PTR(nIdx));
			}
			if (rc == SXRET_OK) {
				SyHashEntry* pRef;
				if (nOp == PHP_VM_CONFIG_CREATE_SUPER) {
					pRef = SyHashLastEntry(&pVm->hSuper);
				}
				else {
					pRef = SyHashLastEntry(&pVm->pFrame->hVar);
				}

				PHP_VmRefObjInstall(&(*pVm),nIdx,pRef,0,0);
				if (nOp == PHP_VM_CONFIG_CREATE_SUPER || pVm->pFrame->pParent == 0) {

					VmHashmapRefInsert(pVm->pGlobal,zName,nByte,nIdx);
				}
			}
		}
		break;
	}
	case PHP_VM_CONFIG_SERVER_ATTR:
	case PHP_VM_CONFIG_ENV_ATTR:
	case PHP_VM_CONFIG_SESSION_ATTR:
	case PHP_VM_CONFIG_POST_ATTR:
	case PHP_VM_CONFIG_GET_ATTR:
	case PHP_VM_CONFIG_COOKIE_ATTR:
	case PHP_VM_CONFIG_HEADER_ATTR: {
		const char* zKey = va_arg(ap,const char*);
		const char* zValue = va_arg(ap,const char*); int nLen = va_arg(ap,int);
		php_hashmap* pMap;
		php_value* pValue;
		if (nOp == PHP_VM_CONFIG_ENV_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_ENV",sizeof("_ENV") - 1);
		}
		else if (nOp == PHP_VM_CONFIG_POST_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_POST",sizeof("_POST") - 1);
		}
		else if (nOp == PHP_VM_CONFIG_GET_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_GET",sizeof("_GET") - 1);
		}
		else if (nOp == PHP_VM_CONFIG_COOKIE_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_COOKIE",sizeof("_COOKIE") - 1);
		}
		else if (nOp == PHP_VM_CONFIG_SESSION_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_SESSION",sizeof("_SESSION") - 1);
		}
		else if (nOp == PHP_VM_CONFIG_HEADER_ATTR) {

			pValue = VmExtractSuper(&(*pVm),"_HEADER",sizeof("_HEADER") - 1);
		}
		else {

			pValue = VmExtractSuper(&(*pVm),"_SERVER",sizeof("_SERVER") - 1);
		}
		if (pValue == 0 || (pValue->iFlags & MEMOBJ_HASHMAP) == 0) {

			rc = SXERR_NOTFOUND;
			break;
		}

		pMap = (php_hashmap*)pValue->x.pOther;

		rc = VmHashmapInsert(pMap,zKey,-1,zValue,nLen);
		break;
	}
	case PHP_VM_CONFIG_ARGV_ENTRY: {

		const char* zValue = va_arg(ap,const char*);
		php_hashmap* pMap;
		php_value* pValue;
		sxu32 n;
		if (SX_EMPTY_STR(zValue)) {
			rc = SXERR_EMPTY;
			break;
		}

		pValue = VmExtractSuper(&(*pVm),"argv",sizeof("argv") - 1);
		if (pValue == 0 || (pValue->iFlags & MEMOBJ_HASHMAP) == 0) {

			rc = SXERR_NOTFOUND;
			break;
		}

		pMap = (php_hashmap*)pValue->x.pOther;

		n = (sxu32)SyStrlen(zValue);
		rc = VmHashmapInsert(pMap,0,0,zValue,(int)n);
		if (rc == SXRET_OK) {
			if (pMap->nEntry > 1) {

				SyBlobAppend(&pVm->sArgv,(const void*)" ",sizeof(char));
			}
			SyBlobAppend(&pVm->sArgv,(const void*)zValue,n);
		}
		break;
	}
	case PHP_VM_CONFIG_ERR_LOG_HANDLER: {

		ProcErrLog xErrLog = va_arg(ap,ProcErrLog);
		pVm->xErrLog = xErrLog;
		break;
	}
	case PHP_VM_CONFIG_EXEC_VALUE: {

		php_value** ppValue = va_arg(ap,php_value**);
#ifdef UNTRUST
		if (ppValue == 0) {
			rc = SXERR_CORRUPT;
			break;
		}
#endif
		* ppValue = &pVm->sExec;
		break;
	}
	case PHP_VM_CONFIG_IO_STREAM: {

		const php_io_stream* pStream = va_arg(ap,const php_io_stream*);

		if (pStream == 0 || pStream->zName == 0 || pStream->zName[0] == 0 ||
			pStream->xOpen == 0 || pStream->xRead == 0) {

			rc = SXERR_INVALID;
			break;
		}
		if (pVm->pDefStream == 0 && SyStrnicmp(pStream->zName,"file",sizeof("file") - 1) == 0) {

			pVm->pDefStream = pStream;
		}

		rc = SySetPut(&pVm->aIOstream,(const void*)&pStream);
		break;
	}
	case PHP_VM_CONFIG_EXTRACT_OUTPUT: {

		const void** ppOut = va_arg(ap,const void**);
		unsigned int* pLen = va_arg(ap,unsigned int*);
#ifdef UNTRUST
		if (ppOut == 0 || pLen == 0) {
			rc = SXERR_CORRUPT;
			break;
		}
#endif
		* ppOut = SyBlobData(&pVm->sConsumer);
		*pLen = SyBlobLength(&pVm->sConsumer);
		break;
	}
	case PHP_VM_CONFIG_HTTP_REQUEST: {

		const char* zRequest = va_arg(ap,const char*); int nByte = va_arg(ap,int);
		if (SX_EMPTY_STR(zRequest)) {
			rc = SXERR_EMPTY;
			break;
		}
		if (nByte < 0) {

			nByte = (int)SyStrlen(zRequest);
		}

		rc = VmHttpProcessRequest(&(*pVm),zRequest,nByte);
		break;
	}
	default:

		rc = SXERR_UNKNOWN;
		break;
	}
	return rc;
}

static const char* VmInstrToString(sxi32 nOp);

static sxi32 VmByteCodeDump(
	SySet* pByteCode,
	ProcConsumer xConsumer,
	void* pUserData
)
{
	static const char zDump[] = {
		"====================================================\n"
		"PHP VM Dump   Copyright (C) 2011-2012 Symisc Systems\n"
		"                              http://www.symisc.net/\n"
		"====================================================\n"
	};
	VmInstr* pInstr,* pEnd;
	sxi32 rc = SXRET_OK;
	sxu32 n;

	pInstr = (VmInstr*)SySetBasePtr(pByteCode);
	pEnd = &pInstr[SySetUsed(pByteCode)];
	n = 0;
	xConsumer((const void*)zDump,sizeof(zDump) - 1,pUserData);

	for (;;) {
		if (pInstr >= pEnd) {

			break;
		}

		rc = SyProcFormat(xConsumer,pUserData,"%s %8d %8u %#8x [%u]\n",
			VmInstrToString(pInstr->iOp),pInstr->iP1,pInstr->iP2,
			SX_PTR_TO_INT(pInstr->p3),n);
		if (rc != SXRET_OK) {

			return rc;
		}
		++n;
		pInstr++;
	}
	return rc;
}

static int VmObConsumer(const void* pData,unsigned int nDataLen,void* pUserData);
static sxi32 VmUncaughtException(php_vm* pVm,php_class_instance* pThis);
static sxi32 VmThrowException(php_vm* pVm,php_class_instance* pThis);

static sxi32 VmCallErrorHandler(php_vm* pVm,SyBlob* pMsg)
{
	php_output_consumer* pCons = &pVm->sVmConsumer;
	sxi32 rc = SXRET_OK;

#ifdef __WINNT__
	SyBlobAppend(pMsg,"\r\n",sizeof("\r\n") - 1);
#else
	SyBlobAppend(pMsg,"\n",sizeof(char));
#endif

	rc = pCons->xConsumer(SyBlobData(pMsg),SyBlobLength(pMsg),pCons->pUserData);
	if (pCons->xConsumer != VmObConsumer) {

		pVm->nOutputLen += SyBlobLength(pMsg);
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmThrowError(
	php_vm* pVm,
	SyString* pFuncName,
	sxi32 iErr,
	const char* zMessage
)
{
	SyBlob* pWorker = &pVm->sWorker;
	SyString* pFile;
	char* zErr;
	sxi32 rc;
	if (!pVm->bErrReport) {

		return SXRET_OK;
	}

	SyBlobReset(pWorker);

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile) {

		SyBlobAppend(pWorker,pFile->zString,pFile->nByte);
		SyBlobAppend(pWorker,(const void*)" ",sizeof(char));
	}
	zErr = "Error: ";
	switch (iErr) {
	case PHP_CTX_WARNING: zErr = "Warning: "; break;
	case PHP_CTX_NOTICE:  zErr = "Notice: ";  break;
	default:
		iErr = PHP_CTX_ERR;
		break;
	}
	SyBlobAppend(pWorker,zErr,SyStrlen(zErr));
	if (pFuncName) {

		SyBlobAppend(pWorker,pFuncName->zString,pFuncName->nByte);
		SyBlobAppend(pWorker,"(): ",sizeof("(): ") - 1);
	}
	SyBlobAppend(pWorker,zMessage,SyStrlen(zMessage));

	rc = VmCallErrorHandler(&(*pVm),pWorker);
	return rc;
}

static sxi32 VmThrowErrorAp(
	php_vm* pVm,
	SyString* pFuncName,
	sxi32 iErr,
	const char* zFormat,
	va_list ap
)
{
	SyBlob* pWorker = &pVm->sWorker;
	SyString* pFile;
	char* zErr;
	sxi32 rc;
	if (!pVm->bErrReport) {

		return SXRET_OK;
	}

	SyBlobReset(pWorker);

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile) {

		SyBlobAppend(pWorker,pFile->zString,pFile->nByte);
		SyBlobAppend(pWorker,(const void*)" ",sizeof(char));
	}
	zErr = "Error: ";
	switch (iErr) {
	case PHP_CTX_WARNING: zErr = "Warning: "; break;
	case PHP_CTX_NOTICE:  zErr = "Notice: ";  break;
	default:
		iErr = PHP_CTX_ERR;
		break;
	}
	SyBlobAppend(pWorker,zErr,SyStrlen(zErr));
	if (pFuncName) {

		SyBlobAppend(pWorker,pFuncName->zString,pFuncName->nByte);
		SyBlobAppend(pWorker,"(): ",sizeof("(): ") - 1);
	}
	SyBlobFormatAp(pWorker,zFormat,ap);

	rc = VmCallErrorHandler(&(*pVm),pWorker);
	return rc;
}

static sxi32 VmErrorFormat(php_vm* pVm,sxi32 iErr,const char* zFormat,...)
{
	va_list ap;
	sxi32 rc;
	va_start(ap,zFormat);
	rc = VmThrowErrorAp(&(*pVm),0,iErr,zFormat,ap);
	va_end(ap);
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmThrowErrorAp(php_vm* pVm,SyString* pFuncName,sxi32 iErr,const char* zFormat,va_list ap)
{
	sxi32 rc;
	rc = VmThrowErrorAp(&(*pVm),&(*pFuncName),iErr,zFormat,ap);
	return rc;
}

static sxi32 VmByteCodeExec(
	php_vm* pVm,
	VmInstr* aInstr,
	php_value* pStack,
	int nTos,
	php_value* pResult,
	sxu32* pLastRef,
	int is_callback
)
{
	VmInstr* pInstr;
	php_value* pTos;
	SySet aArg;
	sxi32 pc;
	sxi32 rc;

	SySetInit(&aArg,&pVm->sAllocator,sizeof(php_value*));
	if (nTos < 0) {
		pTos = &pStack[-1];
	}
	else {
		pTos = &pStack[nTos];
	}
	pc = 0;

	for (;;) {

		pInstr = &aInstr[pc];
		rc = SXRET_OK;

		switch (pInstr->iOp) {

		case PHP_OP_DONE:
			if (pInstr->iP1) {
#ifdef UNTRUST
				if (pTos < pStack) {
					goto Abort;
				}
#endif
				if (pLastRef) {
					*pLastRef = pTos->nIdx;
				}
				if (pResult) {

					PHP_MemObjStore(pTos,pResult);
				}
				VmPopOperand(&pTos,1);
			}
			else if (pLastRef) {

				*pLastRef = SXU32_HIGH;
			}
			goto Done;

		case PHP_OP_HALT:
			if (pInstr->iP1) {
#ifdef UNTRUST
				if (pTos < pStack) {
					goto Abort;
				}
#endif
				if (pLastRef) {
					*pLastRef = pTos->nIdx;
				}
				if (pTos->iFlags & MEMOBJ_STRING) {
					if (SyBlobLength(&pTos->sBlob) > 0) {

						pVm->sVmConsumer.xConsumer(SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob),
							pVm->sVmConsumer.pUserData);
						if (pVm->sVmConsumer.xConsumer != VmObConsumer) {

							pVm->nOutputLen += SyBlobLength(&pTos->sBlob);
						}
					}
				}
				else if (pTos->iFlags & MEMOBJ_INT) {

					pVm->iExitStatus = (sxi32)pTos->x.iVal;
				}
				VmPopOperand(&pTos,1);
			}
			else if (pLastRef) {

				*pLastRef = SXU32_HIGH;
			}
			goto Abort;

		case PHP_OP_JMP:
			pc = pInstr->iP2 - 1;
			break;

		case PHP_OP_JZ:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			if (!pTos->x.iVal) {

				pc = pInstr->iP2 - 1;
			}
			if (!pInstr->iP1) {
				VmPopOperand(&pTos,1);
			}
			break;

		case PHP_OP_JNZ:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			if (pTos->x.iVal) {

				pc = pInstr->iP2 - 1;
			}
			if (!pInstr->iP1) {
				VmPopOperand(&pTos,1);
			}
			break;

		case PHP_OP_NOOP:
			break;

		case PHP_OP_POP: {
			sxi32 n = pInstr->iP1;
			if (&pTos[-n + 1] < pStack) {

				n = (sxi32)(pTos - pStack);
			}
			VmPopOperand(&pTos,n);
			break;
		}

		case PHP_OP_CVT_INT:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}

			MemObjSetType(pTos,MEMOBJ_INT);
			break;

		case PHP_OP_CVT_REAL:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pTos);
			}

			MemObjSetType(pTos,MEMOBJ_REAL);
			break;

		case PHP_OP_CVT_STR:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_STRING) == 0) {
				PHP_MemObjToString(pTos);
			}
			break;

		case PHP_OP_CVT_BOOL:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			break;

		case PHP_OP_CVT_NULL:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			PHP_MemObjRelease(pTos);
			break;

		case PHP_OP_CVT_NUMC:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			PHP_MemObjToNumeric(pTos);
			break;

		case PHP_OP_CVT_ARRAY:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			rc = PHP_MemObjToHashmap(pTos);
			if (rc != SXRET_OK) {

				PHP_VmThrowError(&(*pVm),0,PHP_CTX_WARNING,
					"PHP engine is running out of memory while performing an array cast");
			}
			break;

		case PHP_OP_CVT_OBJ:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_OBJ) == 0) {

				PHP_MemObjToObject(pTos);
			}
			break;

		case PHP_OP_ERR_CTRL:

			break;

		case PHP_OP_IS_A: {
			php_value* pNos = &pTos[-1];
			sxi32 iRes = 0;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			if (pNos->iFlags & MEMOBJ_OBJ) {
				php_class_instance* pThis = (php_class_instance*)pNos->x.pOther;
				php_class* pClass = 0;

				if (pTos->iFlags & MEMOBJ_OBJ) {

					pClass = ((php_class_instance*)pTos->x.pOther)->pClass;
				}
				else if (pTos->iFlags & MEMOBJ_STRING && SyBlobLength(&pTos->sBlob) > 0) {

					pClass = PHP_VmExtractClass(&(*pVm),(const char*)SyBlobData(&pTos->sBlob),
						SyBlobLength(&pTos->sBlob),FALSE,0);
				}
				if (pClass) {

					iRes = VmInstanceOf(pThis->pClass,pClass);
				}
			}

			VmPopOperand(&pTos,1);
			PHP_MemObjRelease(pTos);
			pTos->x.iVal = iRes;
			MemObjSetType(pTos,MEMOBJ_BOOL);
			break;
		}


		case PHP_OP_LOADC: {
			php_value* pObj;

			pTos++;
			if ((pObj = (php_value*)SySetAt(&pVm->aLitObj,pInstr->iP2)) != 0) {
				if (pInstr->iP1 == 1 && SyBlobLength(&pObj->sBlob) <= 64) {
					SyHashEntry* pEntry;

					pEntry = SyHashGet(&pVm->hConstant,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));
					if (pEntry) {
						php_constant* pCons = (php_constant*)pEntry->pUserData;

						MemObjSetType(pTos,MEMOBJ_NULL);
						SyBlobReset(&pTos->sBlob);

						pCons->xExpand(pTos,pCons->pUserData);

						pTos->nIdx = SXU32_HIGH;
						break;
					}
				}
				PHP_MemObjLoad(pObj,pTos);
			}
			else {

				MemObjSetType(pTos,MEMOBJ_NULL);
			}

			pTos->nIdx = SXU32_HIGH;
			break;
		}

		case PHP_OP_LOAD: {
			php_value* pObj;
			SyString sName;
			if (pInstr->p3 == 0) {

#ifdef UNTRUST
				if (pTos < pStack) {
					goto Abort;
				}
#endif

				if ((pTos->iFlags & MEMOBJ_STRING) == 0) {
					PHP_MemObjToString(pTos);
				}
				SyStringInitFromBuf(&sName,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
			}
			else {
				SyStringInitFromBuf(&sName,pInstr->p3,SyStrlen((const char*)pInstr->p3));

				pTos++;
			}

			pObj = VmExtractMemObj(&(*pVm),&sName,pInstr->p3 ? FALSE : TRUE,pInstr->iP1 != 1);
			if (pObj == 0) {
				if (pInstr->iP1) {

					if (!pInstr->p3) {
						PHP_MemObjRelease(pTos);
					}
					else {
						MemObjSetType(pTos,MEMOBJ_NULL);
					}
					pTos->nIdx = SXU32_HIGH;
					break;
				}
				else {

					VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Fatal,PHP engine is running out of memory while loading variable '%z'",&sName);
					goto Abort;
				}
			}

			PHP_MemObjLoad(pObj,pTos);
			pTos->nIdx = pObj->nIdx;
			break;
		}

		case PHP_OP_LOAD_MAP: {
			php_hashmap* pMap;

			pMap = PHP_NewHashmap(&(*pVm),0,0);
			if (pMap == 0) {
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,
					"Fatal,PHP engine is running out of memory while loading array at instruction #:%d",pc);
				goto Abort;
			}
			if (pInstr->iP1 > 0) {
				php_value* pEntry = &pTos[-pInstr->iP1 + 1];

				while (pEntry < pTos) {
					if (pEntry[1].iFlags & MEMOBJ_REFERENCE) {

						PHP_HashmapInsertByRef(pMap,
							(pEntry->iFlags & MEMOBJ_NULL) ? 0  : pEntry,
							(sxu32)pEntry[1].x.iVal
						);
					}
					else {

						PHP_HashmapInsert(pMap,
							(pEntry->iFlags & MEMOBJ_NULL) ? 0  : pEntry,
							&pEntry[1]
						);
					}

					pEntry += 2;
				}

				VmPopOperand(&pTos,pInstr->iP1);
			}

			pTos++;
			pTos->nIdx = SXU32_HIGH;
			pTos->x.pOther = pMap;
			MemObjSetType(pTos,MEMOBJ_HASHMAP);
			break;
		}

		case PHP_OP_LOAD_LIST: {
			php_value* pEntry;
			if (pInstr->iP1 <= 0) {

				break;
			}
			pEntry = &pTos[-pInstr->iP1 + 1];
#ifdef UNTRUST
			if (&pEntry[-1] < pStack) {
				goto Abort;
			}
#endif
			if (pEntry[-1].iFlags & MEMOBJ_HASHMAP) {
				php_hashmap* pMap = (php_hashmap*)pEntry[-1].x.pOther;
				php_hashmap_node* pNode;
				php_value sKey,* pObj;

				PHP_MemObjInitFromInt(&(*pVm),&sKey,0);
				while (pEntry <= pTos) {
					if (pEntry->nIdx != SXU32_HIGH ) {
						rc = PHP_HashmapLookup(pMap,&sKey,&pNode);
						if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pEntry->nIdx)) != 0) {
							if (rc == SXRET_OK) {

								PHP_HashmapExtractNodeValue(pNode,pObj,TRUE);
							}
							else {

								PHP_MemObjRelease(pObj);
							}
						}
					}
					sKey.x.iVal++;
					pEntry++;
				}
			}
			VmPopOperand(&pTos,pInstr->iP1);
			break;
		}

		case PHP_OP_LOAD_IDX: {
			php_hashmap_node* pNode = 0;
			php_hashmap* pMap = 0;
			php_value* pIdx;
			pIdx = 0;
			if (pInstr->iP1 == 0) {
				if (!pInstr->iP2) {

					if (pTos >= pStack) {
						PHP_MemObjRelease(pTos);
					}
					else {

						pTos++;
						MemObjSetType(pTos,MEMOBJ_NULL);
						pTos->nIdx = SXU32_HIGH;
					}

					PHP_VmThrowError(&(*pVm),0,PHP_CTX_NOTICE,
						"Array: Attempt to access an undefined index,PHP is loading NULL");
					break;
				}
			}
			else {
				pIdx = pTos;
				pTos--;
			}
			if (pTos->iFlags & MEMOBJ_STRING) {

				if (pIdx) {
					sxu32 nOfft;
					if ((pIdx->iFlags & MEMOBJ_INT) == 0) {

						PHP_MemObjToInteger(pIdx);
					}
					nOfft = (sxu32)pIdx->x.iVal;
					if (nOfft >= SyBlobLength(&pTos->sBlob)) {

						PHP_MemObjRelease(pTos);
					}
					else {
						const char* zData = (const char*)SyBlobData(&pTos->sBlob); int c = zData[nOfft];
						PHP_MemObjRelease(pTos);
						MemObjSetType(pTos,MEMOBJ_STRING);
						SyBlobAppend(&pTos->sBlob,(const void*)&c,sizeof(char));
					}
				}
				else {

					MemObjSetType(pTos,MEMOBJ_NULL);
				}
				break;
			}
			if (pInstr->iP2 && (pTos->iFlags & MEMOBJ_HASHMAP) == 0) {
				if (pTos->nIdx != SXU32_HIGH) {
					php_value* pObj;
					if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
						PHP_MemObjToHashmap(pObj);
						PHP_MemObjLoad(pObj,pTos);
					}
				}
			}
			rc = SXERR_NOTFOUND;
			if (pTos->iFlags & MEMOBJ_HASHMAP) {

				pMap = (php_hashmap*)pTos->x.pOther;
				if (pIdx) {

					rc = PHP_HashmapLookup(pMap,pIdx,&pNode);
				}
				if (rc != SXRET_OK && pInstr->iP2) {

					rc = PHP_HashmapInsert(pMap,pIdx,0);
					if (rc == SXRET_OK) {

						pNode = pMap->pLast;
					}
				}
			}
			if (pIdx) {
				PHP_MemObjRelease(pIdx);
			}
			if (rc == SXRET_OK) {

				if (pMap->iRef < 2) {

					pTos->nIdx = SXU32_HIGH;
					PHP_HashmapExtractNodeValue(pNode,pTos,TRUE);
				}
				else {
					pTos->nIdx = pNode->nValIdx;
					PHP_HashmapExtractNodeValue(pNode,pTos,FALSE);
					PHP_HashmapUnref(pMap);
				}
			}
			else {

				PHP_MemObjRelease(pTos);
				pTos->nIdx = SXU32_HIGH;
			}
			break;
		}

		case PHP_OP_LOAD_CLOSURE: {
			php_vm_func* pFunc = (php_vm_func*)pInstr->p3;
			if (pFunc->iFlags & VM_FUNC_CLOSURE) {
				php_vm_func_closure_env* aEnv,* pEnv,sEnv;
				php_vm_func* pClosure;
				char* zName;
				sxu32 mLen;
				sxu32 n;

				pClosure = (php_vm_func*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_vm_func));

				zName = (char*)SyMemBackendAlloc(&pVm->sAllocator,sizeof("[closure_]") + 64);
				if (pClosure == 0 || zName == 0) {
					PHP_VmThrowError(pVm,0,E_ERROR,"Fatal: PHP is running out of memory while creating closure environment");
					goto Abort;
				}
				mLen = SyBufferFormat(zName,sizeof("[closure_]") + 64,"[closure_%d]",pVm->closure_cnt++);
				while (SyHashGet(&pVm->hFunction,zName,mLen) != 0 && mLen < (sizeof("[closure_]") + 60)) {
					mLen = SyBufferFormat(zName,sizeof("[closure_]") + 64,"[closure_%d]",pVm->closure_cnt++);
				}

				SyZero(pClosure,sizeof(php_vm_func));

				pClosure->aArgs = pFunc->aArgs;
				pClosure->aByteCode = pFunc->aByteCode;
				pClosure->aStatic = pFunc->aStatic;
				pClosure->iFlags = pFunc->iFlags;
				pClosure->pUserData = pFunc->pUserData;
				pClosure->sSignature = pFunc->sSignature;
				SyStringInitFromBuf(&pClosure->sName,zName,mLen);

				PHP_VmInstallUserFunction(pVm,pClosure,0);

				SySetInit(&pClosure->aClosureEnv,&pVm->sAllocator,sizeof(php_vm_func_closure_env));
				aEnv = (php_vm_func_closure_env*)SySetBasePtr(&pFunc->aClosureEnv);
				for (n = 0; n < SySetUsed(&pFunc->aClosureEnv); ++n) {
					php_value* pValue;
					pEnv = &aEnv[n];
					sEnv.sName = pEnv->sName;
					sEnv.iFlags = pEnv->iFlags;
					sEnv.nIdx = SXU32_HIGH;
					PHP_MemObjInit(pVm,&sEnv.sValue);
					if (sEnv.iFlags & VM_FUNC_ARG_BY_REF) {

						PHP_VmThrowError(pVm,0,PHP_CTX_WARNING,
							"Closure: Pass by reference is disabled in the current release of the PHP engine,PHP is switching to pass by value"
						);
					}

					pValue = VmExtractMemObj(pVm,&sEnv.sName,FALSE,FALSE);
					if (pValue) {

						PHP_MemObjStore(pValue,&sEnv.sValue);
					}

					SySetPut(&pClosure->aClosureEnv,(const void*)&sEnv);
				}

				pTos++;
				PHP_MemObjStringAppend(pTos,zName,mLen);
			}
			break;
		}

		case PHP_OP_STORE: {
			php_value* pObj;
			SyString sName;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if (pInstr->iP2) {
				sxu32 nIdx;

				nIdx = pTos->nIdx;
				VmPopOperand(&pTos,1);
				if (nIdx == SXU32_HIGH) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
						"Cannot perform assignment on a constant class attribute,PHP is loading NULL");
					pTos->nIdx = SXU32_HIGH;
				}
				else {

					pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
					if (pObj) {

						PHP_MemObjStore(pTos,pObj);
					}
				}
				break;
			}
			else if (pInstr->p3 == 0) {

				if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

					PHP_MemObjToString(pTos);
				}
				SyStringInitFromBuf(&sName,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
				pTos--;
#ifdef UNTRUST
				if (pTos < pStack) {
					goto Abort;
				}
#endif
			}
			else {
				SyStringInitFromBuf(&sName,pInstr->p3,SyStrlen((const char*)pInstr->p3));
			}

			pObj = VmExtractMemObj(&(*pVm),&sName,pInstr->p3 ? FALSE : TRUE,TRUE);
			if (pObj == 0) {
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,
					"Fatal,PHP engine is running out of memory while loading variable '%z'",&sName);
				goto Abort;
			}
			if (!pInstr->p3) {
				PHP_MemObjRelease(&pTos[1]);
			}

			PHP_MemObjStore(pTos,pObj);
			break;
		}

		case PHP_OP_STORE_IDX:
		case PHP_OP_STORE_IDX_REF: {
			php_hashmap* pMap = 0;
			php_value* pKey;
			sxu32 nIdx;
			if (pInstr->iP1) {

				pKey = pTos;
				pTos--;
			}
			else {
				pKey = 0;
			}
			nIdx = pTos->nIdx;
			if (pTos->iFlags & MEMOBJ_HASHMAP) {

				pMap = (php_hashmap*)pTos->x.pOther;
				if (pMap->iRef < 2) {

					pMap->iRef = 2;
				}
			}
			else {
				php_value* pObj;
				pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
				if (pObj == 0) {
					if (pKey) {
						PHP_MemObjRelease(pKey);
					}
					VmPopOperand(&pTos,1);
					break;
				}

				if ((pObj->iFlags & MEMOBJ_STRING) && (pInstr->iOp != PHP_OP_STORE_IDX_REF)) {
					VmPopOperand(&pTos,1);
					if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

						PHP_MemObjToString(pTos);
					}
					if (pKey == 0) {

						if (SyBlobLength(&pTos->sBlob) > 0) {
							SyBlobAppend(&pObj->sBlob,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
						}
					}
					else {
						sxu32 nOfft;
						if ((pKey->iFlags & MEMOBJ_INT)) {

							PHP_MemObjToInteger(pKey);
						}
						nOfft = (sxu32)pKey->x.iVal;
						if (nOfft < SyBlobLength(&pObj->sBlob) && SyBlobLength(&pTos->sBlob) > 0) {
							const char* zBlob = (const char*)SyBlobData(&pTos->sBlob);
							char* zData = (char*)SyBlobData(&pObj->sBlob);
							zData[nOfft] = zBlob[0];
						}
						else {
							if (SyBlobLength(&pTos->sBlob) >= sizeof(char)) {

								SyBlobAppend(&pObj->sBlob,SyBlobData(&pTos->sBlob),sizeof(char));
							}
						}
					}
					if (pKey) {
						PHP_MemObjRelease(pKey);
					}
					break;
				}
				else if ((pObj->iFlags & MEMOBJ_HASHMAP) == 0) {

					rc = PHP_MemObjToHashmap(pObj);
					if (rc != SXRET_OK) {
						VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Fatal,PHP engine is running out of memory while creating a new array");
						goto Abort;
					}
				}
				pMap = (php_hashmap*)pObj->x.pOther;
			}
			VmPopOperand(&pTos,1);

			if (pInstr->iOp == PHP_OP_STORE_IDX_REF && pTos->nIdx != SXU32_HIGH) {

				PHP_HashmapInsertByRef(pMap,pKey,pTos->nIdx);
			}
			else {
				PHP_HashmapInsert(pMap,pKey,pTos);
			}
			if (pKey) {
				PHP_MemObjRelease(pKey);
			}
			break;
		}

		case PHP_OP_INCR:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) == 0) {
				if (pTos->nIdx != SXU32_HIGH) {
					php_value* pObj;
					if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {

						PHP_MemObjToNumeric(pObj);
						if (pObj->iFlags & MEMOBJ_REAL) {
							pObj->rVal++;

							PHP_MemObjTryInteger(pTos);
						}
						else {
							pObj->x.iVal++;
							MemObjSetType(pTos,MEMOBJ_INT);
						}
						if (pInstr->iP1) {

							PHP_MemObjStore(pObj,pTos);
						}
					}
				}
				else {
					if (pInstr->iP1) {

						PHP_MemObjToNumeric(pTos);

						if (pTos->iFlags & MEMOBJ_REAL) {
							pTos->rVal++;

							PHP_MemObjTryInteger(pTos);
						}
						else {
							pTos->x.iVal++;
							MemObjSetType(pTos,MEMOBJ_INT);
						}
					}
				}
			}
			break;

		case PHP_OP_DECR:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES | MEMOBJ_NULL)) == 0) {

				PHP_MemObjToNumeric(pTos);
				if (pTos->nIdx != SXU32_HIGH) {
					php_value* pObj;
					if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {

						PHP_MemObjToNumeric(pObj);
						if (pObj->iFlags & MEMOBJ_REAL) {
							pObj->rVal--;

							PHP_MemObjTryInteger(pTos);
						}
						else {
							pObj->x.iVal--;
							MemObjSetType(pTos,MEMOBJ_INT);
						}
						if (pInstr->iP1) {

							PHP_MemObjStore(pObj,pTos);
						}
					}
				}
				else {
					if (pInstr->iP1) {

						if (pTos->iFlags & MEMOBJ_REAL) {
							pTos->rVal--;

							PHP_MemObjTryInteger(pTos);
						}
						else {
							pTos->x.iVal--;
							MemObjSetType(pTos,MEMOBJ_INT);
						}
					}
				}
			}
			break;

		case PHP_OP_UMINUS:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			PHP_MemObjToNumeric(pTos);
			if (pTos->iFlags & MEMOBJ_REAL) {
				pTos->rVal = -pTos->rVal;
			}
			if (pTos->iFlags & MEMOBJ_INT) {
				pTos->x.iVal = -pTos->x.iVal;
			}
			break;

		case PHP_OP_UPLUS:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			PHP_MemObjToNumeric(pTos);
			if (pTos->iFlags & MEMOBJ_REAL) {
				pTos->rVal = +pTos->rVal;
			}
			if (pTos->iFlags & MEMOBJ_INT) {
				pTos->x.iVal = +pTos->x.iVal;
			}
			break;

		case PHP_OP_LNOT:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			pTos->x.iVal = !pTos->x.iVal;
			break;

		case PHP_OP_BITNOT:
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			pTos->x.iVal = ~pTos->x.iVal;
			break;

		case PHP_OP_MUL:
		case PHP_OP_MUL_STORE: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			PHP_MemObjToNumeric(pTos);
			PHP_MemObjToNumeric(pNos);

			if (MEMOBJ_REAL & (pTos->iFlags | pNos->iFlags)) {

				php_real a,b,r;
				if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pTos);
				}
				if ((pNos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pNos);
				}
				a = pNos->rVal;
				b = pTos->rVal;
				r = a * b;

				pNos->rVal = r;
				MemObjSetType(pNos,MEMOBJ_REAL);

				PHP_MemObjTryInteger(pNos);
			}
			else {

				sxi64 a,b,r;
				a = pNos->x.iVal;
				b = pTos->x.iVal;
				r = a * b;

				pNos->x.iVal = r;
				MemObjSetType(pNos,MEMOBJ_INT);
			}
			if (pInstr->iOp == PHP_OP_MUL_STORE) {
				php_value* pObj;
				if (pTos->nIdx == SXU32_HIGH) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
				}
				else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
					PHP_MemObjStore(pNos,pObj);
				}
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_ADD: {
			php_value* pNos = &pTos[-1];
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			PHP_MemObjAdd(pNos,pTos,FALSE);
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_ADD_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
			sxu32 nIdx;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			nIdx = pTos->nIdx;
			PHP_MemObjAdd(pTos,pNos,TRUE);

			if (nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx)) != 0) {
				PHP_MemObjStore(pTos,pObj);
			}

			PHP_MemObjStore(pTos,pNos);
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_SUB: {
			php_value* pNos = &pTos[-1];
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			if (MEMOBJ_REAL & (pTos->iFlags | pNos->iFlags)) {

				php_real a,b,r;
				if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pTos);
				}
				if ((pNos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pNos);
				}
				a = pNos->rVal;
				b = pTos->rVal;
				r = a - b;

				pNos->rVal = r;
				MemObjSetType(pNos,MEMOBJ_REAL);

				PHP_MemObjTryInteger(pNos);
			}
			else {

				sxi64 a,b,r;
				a = pNos->x.iVal;
				b = pTos->x.iVal;
				r = a - b;

				pNos->x.iVal = r;
				MemObjSetType(pNos,MEMOBJ_INT);
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_SUB_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			if (MEMOBJ_REAL & (pTos->iFlags | pNos->iFlags)) {

				php_real a,b,r;
				if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pTos);
				}
				if ((pNos->iFlags & MEMOBJ_REAL) == 0) {
					PHP_MemObjToReal(pNos);
				}
				a = pTos->rVal;
				b = pNos->rVal;
				r = a - b;

				pNos->rVal = r;
				MemObjSetType(pNos,MEMOBJ_REAL);

				PHP_MemObjTryInteger(pNos);
			}
			else {

				sxi64 a,b,r;
				a = pTos->x.iVal;
				b = pNos->x.iVal;
				r = a - b;

				pNos->x.iVal = r;
				MemObjSetType(pNos,MEMOBJ_INT);
			}
			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pNos,pObj);
			}
			VmPopOperand(&pTos,1);
			break;
		}


		case PHP_OP_MOD: {
			php_value* pNos = &pTos[-1];
			sxi64 a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pNos->x.iVal;
			b = pTos->x.iVal;
			if (b == 0) {
				r = 0;
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Division by zero %qd%%0",a);

			}
			else {
				r = a % b;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_MOD_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
			sxi64 a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pTos->x.iVal;
			b = pNos->x.iVal;
			if (b == 0) {
				r = 0;
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Division by zero %qd%%0",a);

			}
			else {
				r = a % b;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pNos,pObj);
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_DIV: {
			php_value* pNos = &pTos[-1];
			php_real a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pNos);
			}

			a = pNos->rVal;
			b = pTos->rVal;
			if (b == 0) {

				r = 0;
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Division by zero");

			}
			else {
				r = a / b;

				pNos->rVal = r;
				MemObjSetType(pNos,MEMOBJ_REAL);

				PHP_MemObjTryInteger(pNos);
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_DIV_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
			php_real a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pNos);
			}

			a = pTos->rVal;
			b = pNos->rVal;
			if (b == 0) {

				r = 0;
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Division by zero %qd/0",a);

			}
			else {
				r = a / b;

				pNos->rVal = r;
				MemObjSetType(pNos,MEMOBJ_REAL);

				PHP_MemObjTryInteger(pNos);
			}
			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pNos,pObj);
			}
			VmPopOperand(&pTos,1);
			break;
		}



		case PHP_OP_BAND:
		case PHP_OP_BOR:
		case PHP_OP_BXOR: {
			php_value* pNos = &pTos[-1];
			sxi64 a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pNos->x.iVal;
			b = pTos->x.iVal;
			switch (pInstr->iOp) {
			case PHP_OP_BOR_STORE:
			case PHP_OP_BOR:  r = a | b; break;
			case PHP_OP_BXOR_STORE:
			case PHP_OP_BXOR: r = a ^ b; break;
			case PHP_OP_BAND_STORE:
			case PHP_OP_BAND:
			default:          r = a & b; break;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			VmPopOperand(&pTos,1);
			break;
		}



		case PHP_OP_BAND_STORE:
		case PHP_OP_BOR_STORE:
		case PHP_OP_BXOR_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
			sxi64 a,b,r;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pTos->x.iVal;
			b = pNos->x.iVal;
			switch (pInstr->iOp) {
			case PHP_OP_BOR_STORE:
			case PHP_OP_BOR:  r = a | b; break;
			case PHP_OP_BXOR_STORE:
			case PHP_OP_BXOR: r = a ^ b; break;
			case PHP_OP_BAND_STORE:
			case PHP_OP_BAND:
			default:          r = a & b; break;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pNos,pObj);
			}
			VmPopOperand(&pTos,1);
			break;
		}


		case PHP_OP_SHL:
		case PHP_OP_SHR: {
			php_value* pNos = &pTos[-1];
			sxi64 a,r;
			sxi32 b;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pNos->x.iVal;
			b = (sxi32)pTos->x.iVal;
			if (pInstr->iOp == PHP_OP_SHL) {
				r = a << b;
			}
			else {
				r = a >> b;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			VmPopOperand(&pTos,1);
			break;
		}


		case PHP_OP_SHL_STORE:
		case PHP_OP_SHR_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
			sxi64 a,r;
			sxi32 b;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_INT) == 0) {
				PHP_MemObjToInteger(pNos);
			}

			a = pTos->x.iVal;
			b = (sxi32)pNos->x.iVal;
			if (pInstr->iOp == PHP_OP_SHL_STORE) {
				r = a << b;
			}
			else {
				r = a >> b;
			}

			pNos->x.iVal = r;
			MemObjSetType(pNos,MEMOBJ_INT);
			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pNos,pObj);
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_CAT: {
			php_value* pNos,* pCur;
			if (pInstr->iP1 < 1) {
				pNos = &pTos[-1];
			}
			else {
				pNos = &pTos[-pInstr->iP1 + 1];
			}
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pNos->iFlags & MEMOBJ_STRING) == 0) {
				PHP_MemObjToString(pNos);
			}
			pCur = &pNos[1];
			while (pCur <= pTos) {
				if ((pCur->iFlags & MEMOBJ_STRING) == 0) {
					PHP_MemObjToString(pCur);
				}

				if (SyBlobLength(&pCur->sBlob) > 0) {
					PHP_MemObjStringAppend(pNos,(const char*)SyBlobData(&pCur->sBlob),SyBlobLength(&pCur->sBlob));
				}
				SyBlobRelease(&pCur->sBlob);
				pCur++;
			}
			pTos = pNos;
			break;
		}

		case PHP_OP_CAT_STORE: {
			php_value* pNos = &pTos[-1];
			php_value* pObj;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

				PHP_MemObjToString(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_STRING) == 0) {

				PHP_MemObjToString(pNos);
			}

			if (SyBlobLength(&pNos->sBlob) > 0) {
				PHP_MemObjStringAppend(pTos,(const char*)SyBlobData(&pNos->sBlob),SyBlobLength(&pNos->sBlob));
			}

			if (pTos->nIdx == SXU32_HIGH) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Cannot perform assignment on a constant class attribute");
			}
			else if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pTos->nIdx)) != 0) {
				PHP_MemObjStore(pTos,pObj);
			}
			PHP_MemObjStore(pTos,pNos);
			VmPopOperand(&pTos,1);
			break;
		}


		case PHP_OP_LAND:
		case PHP_OP_LOR: {
			php_value* pNos = &pTos[-1];
			sxi32 v1,v2;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pNos);
			}
			v1 = pNos->x.iVal == 0 ? 1 : 0;
			v2 = pTos->x.iVal == 0 ? 1 : 0;
			if (pInstr->iOp == PHP_OP_LAND) {
				static const unsigned char and_logic[] = { 0,1,2,1,1,1,2,1,2 };
				v1 = and_logic[v1 * 3 + v2];
			}
			else {
				static const unsigned char or_logic[] = { 0,0,0,0,1,2,0,2,2 };
				v1 = or_logic[v1 * 3 + v2];
			}
			if (v1 == 2) {
				v1 = 1;
			}
			VmPopOperand(&pTos,1);
			pTos->x.iVal = v1 == 0 ? 1 : 0;
			MemObjSetType(pTos,MEMOBJ_BOOL);
			break;
		}

		case PHP_OP_LXOR: {
			php_value* pNos = &pTos[-1];
			sxi32 v = 0;
#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_BOOL) == 0) {
				PHP_MemObjToBool(pNos);
			}
			if ((pNos->x.iVal && !pTos->x.iVal) || (pTos->x.iVal && !pNos->x.iVal)) {
				v = 1;
			}
			VmPopOperand(&pTos,1);
			pTos->x.iVal = v;
			MemObjSetType(pTos,MEMOBJ_BOOL);
			break;
		}


		case PHP_OP_EQ:
		case PHP_OP_NEQ: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			rc = PHP_MemObjCmp(pNos,pTos,FALSE,0);
			if (pInstr->iOp == PHP_OP_EQ) {
				rc = rc == 0;
			}
			else {
				rc = rc != 0;
			}
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}

		case PHP_OP_TEQ: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			rc = PHP_MemObjCmp(pNos,pTos,TRUE,0) == 0;
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}

		case PHP_OP_TNE: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			rc = PHP_MemObjCmp(pNos,pTos,TRUE,0) != 0;
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}


		case PHP_OP_LT:
		case PHP_OP_LE: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			rc = PHP_MemObjCmp(pNos,pTos,FALSE,0);
			if (pInstr->iOp == PHP_OP_LE) {
				rc = rc < 1;
			}
			else {
				rc = rc < 0;
			}
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}


		case PHP_OP_GT:
		case PHP_OP_GE: {
			php_value* pNos = &pTos[-1];

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif
			rc = PHP_MemObjCmp(pNos,pTos,FALSE,0);
			if (pInstr->iOp == PHP_OP_GE) {
				rc = rc >= 0;
			}
			else {
				rc = rc > 0;
			}
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}


		case PHP_OP_SEQ:
		case PHP_OP_SNE: {
			php_value* pNos = &pTos[-1];
			SyString s1,s2;

#ifdef UNTRUST
			if (pNos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_STRING) == 0) {
				PHP_MemObjToString(pTos);
			}
			if ((pNos->iFlags & MEMOBJ_STRING) == 0) {
				PHP_MemObjToString(pNos);
			}
			SyStringInitFromBuf(&s1,SyBlobData(&pNos->sBlob),SyBlobLength(&pNos->sBlob));
			SyStringInitFromBuf(&s2,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
			rc = SyStringCmp(&s1,&s2,SyMemcmp);
			if (pInstr->iOp == PHP_OP_NEQ) {
				rc = rc != 0;
			}
			else {
				rc = rc == 0;
			}
			VmPopOperand(&pTos,1);
			if (!pInstr->iP2) {

				PHP_MemObjRelease(pTos);
				pTos->x.iVal = rc;

				MemObjSetType(pTos,MEMOBJ_BOOL);
			}
			else {
				if (rc) {

					pc = pInstr->iP2 - 1;
					VmPopOperand(&pTos,1);
				}
			}
			break;
		}

		case PHP_OP_LOAD_REF: {
			sxu32 nIdx;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			nIdx = pTos->nIdx;
			if (nIdx != SXU32_HIGH ) {

				PHP_MemObjRelease(pTos);

				pTos->x.iVal = (sxi64)nIdx;
				pTos->nIdx = SXU32_HIGH;
				pTos->iFlags = MEMOBJ_INT | MEMOBJ_REFERENCE;
			}
			break;
		}

		case PHP_OP_STORE_REF: {
			SyString sName = { 0 ,0 };
			SyHashEntry* pEntry;
			sxu32 nIdx;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if (pInstr->p3 == 0) {
				char* zName;

				if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

					PHP_MemObjToString(pTos);
				}
				if (SyBlobLength(&pTos->sBlob) > 0) {
					zName = SyMemBackendStrDup(&pVm->sAllocator,
						(const char*)SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
					if (zName) {
						SyStringInitFromBuf(&sName,zName,SyBlobLength(&pTos->sBlob));
					}
				}
				PHP_MemObjRelease(pTos);
				pTos--;
			}
			else {
				SyStringInitFromBuf(&sName,pInstr->p3,SyStrlen((const char*)pInstr->p3));
			}
			nIdx = pTos->nIdx;
			if (nIdx == SXU32_HIGH) {
				if ((pTos->iFlags & (MEMOBJ_OBJ | MEMOBJ_HASHMAP | MEMOBJ_RES)) == 0) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
						"Reference operator require a variable not a constant as it's right operand");
				}
				else {
					php_value* pObj;

					pObj = VmExtractMemObj(&(*pVm),&sName,FALSE,TRUE);
					if (pObj == 0) {
						VmErrorFormat(&(*pVm),PHP_CTX_ERR,
							"Fatal,PHP engine is running out of memory while loading variable '%z'",&sName);
						goto Abort;
					}

					PHP_MemObjStore(pTos,pObj);
					pTos->nIdx = pObj->nIdx;
				}
			}
			else if (sName.nByte > 0) {
				if ((pTos->iFlags & MEMOBJ_HASHMAP) && (pVm->pGlobal == (php_hashmap*)pTos->x.pOther)) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"$GLOBALS is a read-only array and therefore cannot be referenced");
				}
				else {
					VmFrame* pFrame = pVm->pFrame;
					while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

						pFrame = pFrame->pParent;
					}

					pEntry = SyHashGet(&pFrame->hVar,(const void*)sName.zString,sName.nByte);
					if (pEntry) {
						VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Referenced variable name '%z' already exists",&sName);
					}
					else {
						rc = SyHashInsert(&pFrame->hVar,(const void*)sName.zString,sName.nByte,SX_INT_TO_PTR(nIdx));
						if (pFrame->pParent == 0) {

							VmHashmapRefInsert(pVm->pGlobal,sName.zString,sName.nByte,nIdx);
						}
						if (rc == SXRET_OK) {
							PHP_VmRefObjInstall(&(*pVm),nIdx,SyHashLastEntry(&pFrame->hVar),0,0);
						}
					}
				}
			}
			break;
		}

		case PHP_OP_UPLINK: {
			if (pVm->pFrame->pParent) {
				php_value* pLink = &pTos[-pInstr->iP1 + 1];
				SyString sName;

				while (pLink <= pTos) {
					if ((pLink->iFlags & MEMOBJ_STRING) == 0) {

						PHP_MemObjToString(pLink);
					}
					SyStringInitFromBuf(&sName,SyBlobData(&pLink->sBlob),SyBlobLength(&pLink->sBlob));
					if (sName.nByte > 0) {
						VmFrameLink(&(*pVm),&sName);
					}
					pLink++;
				}
			}
			VmPopOperand(&pTos,pInstr->iP1);
			break;
		}

		case PHP_OP_LOAD_EXCEPTION: {
			php_exception* pException = (php_exception*)pInstr->p3;
			VmFrame* pFrame;
			SySetPut(&pVm->aException,(const void*)&pException);

			rc = VmEnterFrame(&(*pVm),0,0,&pFrame);
			if (rc != SXRET_OK) {
				VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Fatal PHP engine is runnig out of memory");
				goto Abort;
			}

			pFrame->iFlags |= VM_FRAME_EXCEPTION;
			pFrame->iExceptionJump = pInstr->iP2;

			pFrame = pFrame->pParent;
			while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {
				pFrame = pFrame->pParent;
			}
			pException->pFrame = pFrame;
			break;
		}

		case PHP_OP_POP_EXCEPTION: {
			php_exception* pException = (php_exception*)pInstr->p3;
			if (SySetUsed(&pVm->aException) > 0) {
				php_exception** apException;

				apException = (php_exception**)SySetBasePtr(&pVm->aException);
				if (pException == apException[SySetUsed(&pVm->aException) - 1]) {
					(void)SySetPop(&pVm->aException);
				}
			}
			pException->pFrame = 0;

			VmLeaveFrame(&(*pVm));
			break;
		}


		case PHP_OP_THROW: {
			VmFrame* pFrame = pVm->pFrame;
			sxu32 nJump = pInstr->iP2;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

				pFrame = pFrame->pParent;
			}

			pFrame->iFlags |= VM_FRAME_THROW;
			if (pTos->iFlags & MEMOBJ_OBJ) {
				php_class_instance* pThis = (php_class_instance*)pTos->x.pOther;
				php_class* pException;

				pException = PHP_VmExtractClass(&(*pVm),"Exception",sizeof("Exception") - 1,TRUE,0);
				if (pException == 0 || !VmInstanceOf(pThis->pClass,pException)) {

					rc = VmUncaughtException(&(*pVm),pThis);
					if (rc == SXERR_ABORT) {

						goto Abort;
					}
				}
				else {

					rc = VmThrowException(&(*pVm),pThis);
					if (rc == SXERR_ABORT) {

						goto Abort;
					}
				}
			}
			else {

				VmUncaughtException(&(*pVm),0);
				if (rc == SXERR_ABORT) {

					goto Abort;
				}
			}

			VmPopOperand(&pTos,1);

			pc = nJump - 1;
			break;
		}

		case PHP_OP_FOREACH_INIT: {
			php_foreach_info* pInfo = (php_foreach_info*)pInstr->p3;
			void* pName;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif
			if (SyStringLength(&pInfo->sValue) < 1) {

				if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

					PHP_MemObjToString(pTos);
				}

				if (SyBlobLength(&pTos->sBlob) > 0) {
					pName = SyMemBackendDup(&pVm->sAllocator,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
					SyStringInitFromBuf(&pInfo->sValue,pName,SyBlobLength(&pTos->sBlob));
				}
				VmPopOperand(&pTos,1);
			}
			if ((pInfo->iFlags & PHP_4EACH_STEP_KEY) && SyStringLength(&pInfo->sKey) < 1) {
				if ((pTos->iFlags & MEMOBJ_STRING) == 0) {

					PHP_MemObjToString(pTos);
				}

				if (SyBlobLength(&pTos->sBlob) > 0) {
					pName = SyMemBackendDup(&pVm->sAllocator,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
					SyStringInitFromBuf(&pInfo->sKey,pName,SyBlobLength(&pTos->sBlob));
				}
				VmPopOperand(&pTos,1);
			}

			if ((pTos->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ)) == 0 || SyStringLength(&pInfo->sValue) < 1) {

				if ((pTos->iFlags & MEMOBJ_NULL) == 0) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_WARNING,"Invalid argument supplied for the foreach statement,expecting array or class instance");
				}
				pc = pInstr->iP2 - 1;
			}
			else {
				php_foreach_step* pStep;
				pStep = (php_foreach_step*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_foreach_step));
				if (pStep == 0) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"PHP is running out of memory while preparing the 'foreach' step");

					pc = pInstr->iP2 - 1;
				}
				else {

					SyZero(pStep,sizeof(php_foreach_step));

					pStep->iFlags = pInfo->iFlags;
					if (pTos->iFlags & MEMOBJ_HASHMAP) {
						php_hashmap* pMap = (php_hashmap*)pTos->x.pOther;

						PHP_HashmapResetLoopCursor(pMap);

						pStep->iFlags |= PHP_4EACH_STEP_HASHMAP;
						pStep->xIter.pMap = pMap;
						pMap->iRef++;
					}
					else {
						php_class_instance* pThis = (php_class_instance*)pTos->x.pOther;

						SyHashResetLoopCursor(&pThis->hAttr);

						pStep->iFlags |= PHP_4EACH_STEP_OBJECT;
						pStep->xIter.pThis = pThis;
						pThis->iRef++;
					}
				}
				if (SXRET_OK != SySetPut(&pInfo->aStep,(const void*)&pStep)) {
					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"PHP is running out of memory while preparing the 'foreach' step");
					SyMemBackendPoolFree(&pVm->sAllocator,pStep);

					pc = pInstr->iP2 - 1;
				}
			}
			VmPopOperand(&pTos,1);
			break;
		}

		case PHP_OP_FOREACH_STEP: {
			php_foreach_info* pInfo = (php_foreach_info*)pInstr->p3;
			php_foreach_step** apStep,* pStep;
			php_value* pValue;
			VmFrame* pFrame;

			apStep = (php_foreach_step**)SySetBasePtr(&pInfo->aStep);
			pStep = apStep[SySetUsed(&pInfo->aStep) - 1];
			pFrame = pVm->pFrame;
			while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

				pFrame = pFrame->pParent;
			}
			if (pStep->iFlags & PHP_4EACH_STEP_HASHMAP) {
				php_hashmap* pMap = pStep->xIter.pMap;
				php_hashmap_node* pNode;

				pNode = PHP_HashmapGetNextEntry(pMap);
				if (pNode == 0) {

					pc = pInstr->iP2 - 1;
					if (pStep->iFlags & PHP_4EACH_STEP_REF) {

						SyHashDeleteEntry(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue),0);
					}

					PHP_HashmapResetLoopCursor(pMap);

					SyMemBackendPoolFree(&pVm->sAllocator,pStep);
					SySetPop(&pInfo->aStep);
					PHP_HashmapUnref(pMap);
				}
				else {
					if ((pStep->iFlags & PHP_4EACH_STEP_KEY) && SyStringLength(&pInfo->sKey) > 0) {
						php_value* pKey = VmExtractMemObj(&(*pVm),&pInfo->sKey,FALSE,TRUE);
						if (pKey) {
							PHP_HashmapExtractNodeKey(pNode,pKey);
						}
					}
					if (pStep->iFlags & PHP_4EACH_STEP_REF) {
						SyHashEntry* pEntry;

						pEntry = SyHashGet(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue));
						if (pEntry) {
							pEntry->pUserData = SX_INT_TO_PTR(pNode->nValIdx);
						}
						else {
							SyHashInsert(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue),
								SX_INT_TO_PTR(pNode->nValIdx));
						}
					}
					else {

						pValue = VmExtractMemObj(&(*pVm),&pInfo->sValue,FALSE,TRUE);
						if (pValue) {
							PHP_HashmapExtractNodeValue(pNode,pValue,TRUE);
						}
					}
				}
			}
			else {
				php_class_instance* pThis = pStep->xIter.pThis;
				VmClassAttr* pVmAttr = 0;
				SyHashEntry* pEntry;

				while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {
					pVmAttr = (VmClassAttr*)pEntry->pUserData;

					if (VmClassMemberAccess(&(*pVm),pThis->pClass,&pVmAttr->pAttr->sName,
						pVmAttr->pAttr->iProtection,FALSE)) {
						break;
					}
				}
				if (pEntry == 0) {

					pc = pInstr->iP2 - 1;
					if (pStep->iFlags & PHP_4EACH_STEP_REF) {

						SyHashDeleteEntry(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue),0);
					}
					SyMemBackendPoolFree(&pVm->sAllocator,pStep);
					SySetPop(&pInfo->aStep);
					PHP_ClassInstanceUnref(pThis);
				}
				else {
					SyString* pAttrName = &pVmAttr->pAttr->sName;
					php_value* pAttrValue;
					if ((pStep->iFlags & PHP_4EACH_STEP_KEY) && SyStringLength(&pInfo->sKey) > 0) {

						php_value* pKey = VmExtractMemObj(&(*pVm),&pInfo->sKey,FALSE,TRUE);
						if (pKey) {
							SyBlobReset(&pKey->sBlob);
							SyBlobAppend(&pKey->sBlob,pAttrName->zString,pAttrName->nByte);
							MemObjSetType(pKey,MEMOBJ_STRING);
						}
					}

					pAttrValue = PHP_ClassInstanceExtractAttrValue(pThis,pVmAttr);
					if (pAttrValue) {
						if (pStep->iFlags & PHP_4EACH_STEP_REF) {

							pEntry = SyHashGet(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue));
							if (pEntry) {
								pEntry->pUserData = SX_INT_TO_PTR(pVmAttr->nIdx);
							}
							else {
								SyHashInsert(&pFrame->hVar,SyStringData(&pInfo->sValue),SyStringLength(&pInfo->sValue),
									SX_INT_TO_PTR(pVmAttr->nIdx));
							}
						}
						else {

							pValue = VmExtractMemObj(&(*pVm),&pInfo->sValue,FALSE,TRUE);
							if (pValue) {
								PHP_MemObjStore(pAttrValue,pValue);
							}
						}
					}
				}
			}
			break;
		}

		case PHP_OP_MEMBER: {
			php_class_instance* pThis;
			php_value* pNos;
			SyString sName;
			if (!pInstr->iP1) {
				pNos = &pTos[-1];
#ifdef UNTRUST
				if (pNos < pStack) {
					goto Abort;
				}
#endif
				if (pNos->iFlags & MEMOBJ_OBJ) {
					php_class* pClass;

					pThis = (php_class_instance*)pNos->x.pOther;

					pClass = pThis->pClass;

					SyStringInitFromBuf(&sName,(const char*)SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
					if (pInstr->iP2) {

						php_class_method* pMeth = 0;
						if (sName.nByte > 0) {

							pMeth = PHP_ClassExtractMethod(pClass,sName.zString,sName.nByte);
						}
						if (pMeth == 0) {
							VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Undefined class method '%z->%z',PHP is loading NULL",
								&pClass->sName,&sName
							);

							PHP_ClassInstanceCallMagicMethod(&(*pVm),pClass,pThis,"__call",sizeof("__call") - 1,&sName);

							VmPopOperand(&pTos,1);
							PHP_MemObjRelease(pTos);
						}
						else {

							PHP_MemObjRelease(pTos);
							SyBlobAppend(&pTos->sBlob,SyStringData(&pMeth->sVmName),SyStringLength(&pMeth->sVmName));
							MemObjSetType(pTos,MEMOBJ_STRING);
						}
						pTos->nIdx = SXU32_HIGH;
					}
					else {

						VmClassAttr* pObjAttr = 0;
						SyHashEntry* pEntry;

						if (sName.nByte > 0) {
							pEntry = SyHashGet(&pThis->hAttr,(const void*)sName.zString,sName.nByte);
							if (pEntry) {

								pObjAttr = (VmClassAttr*)pEntry->pUserData;
							}
						}
						if (pObjAttr == 0) {

							VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Undefined class attribute '%z->%z',PHP is loading NULL",
								&pClass->sName,&sName);

							PHP_ClassInstanceCallMagicMethod(&(*pVm),pClass,pThis,"__get",sizeof("__get") - 1,&sName);
						}
						VmPopOperand(&pTos,1);

						pThis->iRef++;
						PHP_MemObjRelease(pTos);
						pTos->nIdx = SXU32_HIGH;
						if (pObjAttr) {
							php_value* pValue = 0;

							if (VmClassMemberAccess(&(*pVm),pClass,&pObjAttr->pAttr->sName,pObjAttr->pAttr->iProtection,TRUE)) {

								pValue = (php_value*)SySetAt(&pVm->aMemObj,pObjAttr->nIdx);
								if (pValue) {
									if (pThis->iRef < 2) {

										PHP_MemObjStore(pValue,pTos);
									}
									else {

										PHP_MemObjLoad(pValue,pTos);
									}
									if ((pObjAttr->pAttr->iFlags & PHP_CLASS_ATTR_CONSTANT) == 0) {
										if (pThis->iRef > 1) {

											pTos->nIdx = pObjAttr->nIdx;
										}
									}
								}
							}
						}

						PHP_ClassInstanceUnref(pThis);
					}
				}
				else {
					VmErrorFormat(&(*pVm),PHP_CTX_ERR,"'->': Expecting class instance as left operand,PHP is loading NULL");
					VmPopOperand(&pTos,1);
					PHP_MemObjRelease(pTos);
					pTos->nIdx = SXU32_HIGH;
				}
			}
			else {

				pNos = pTos;
				pThis = 0;
				if (!pInstr->p3) {
					SyStringInitFromBuf(&sName,(const char*)SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));
					pNos--;
#ifdef UNTRUST
					if (pNos < pStack) {
						goto Abort;
					}
#endif
				}
				else {

					SyStringInitFromBuf(&sName,pInstr->p3,SyStrlen((const char*)pInstr->p3));
				}
				if (pNos->iFlags & (MEMOBJ_STRING | MEMOBJ_OBJ)) {
					php_class* pClass = 0;
					if (pNos->iFlags & MEMOBJ_OBJ) {

						pThis = (php_class_instance*)pNos->x.pOther;
						pClass = pThis->pClass;
						pThis->iRef++;
					}
					else {

						if (SyBlobLength(&pNos->sBlob) > 0) {
							pClass = PHP_VmExtractClass(&(*pVm),(const char*)SyBlobData(&pNos->sBlob),
								SyBlobLength(&pNos->sBlob),FALSE,0);
						}
					}
					if (pClass == 0) {

						VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Call to undefined class '%.*s',PHP is loading NULL",
							SyBlobLength(&pNos->sBlob),(const char*)SyBlobData(&pNos->sBlob)
						);
						if (!pInstr->p3) {
							VmPopOperand(&pTos,1);
						}
						PHP_MemObjRelease(pTos);
						pTos->nIdx = SXU32_HIGH;
					}
					else {
						if (pInstr->iP2) {

							php_class_method* pMeth = 0;
							if (sName.nByte > 0 && (pClass->iFlags & PHP_CLASS_INTERFACE) == 0) {

								pMeth = PHP_ClassExtractMethod(pClass,sName.zString,sName.nByte);
							}
							if (pMeth == 0 || (pMeth->iFlags & PHP_CLASS_ATTR_ABSTRACT)) {
								if (pMeth) {
									VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Cannot call abstract method '%z:%z',PHP is loading NULL",
										&pClass->sName,&sName
									);
								}
								else {
									VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Undefined class static method '%z::%z',PHP is loading NULL",
										&pClass->sName,&sName
									);

									PHP_ClassInstanceCallMagicMethod(&(*pVm),pClass,0,"__callStatic",sizeof("__callStatic") - 1,&sName);
								}

								if (!pInstr->p3) {
									VmPopOperand(&pTos,1);
								}
								PHP_MemObjRelease(pTos);
							}
							else {

								PHP_MemObjRelease(pTos);
								SyBlobAppend(&pTos->sBlob,SyStringData(&pMeth->sVmName),SyStringLength(&pMeth->sVmName));
								MemObjSetType(pTos,MEMOBJ_STRING);
							}
							pTos->nIdx = SXU32_HIGH;
						}
						else {

							php_class_attr* pAttr = 0;

							if (sName.nByte > 0) {
								pAttr = PHP_ClassExtractAttribute(pClass,sName.zString,sName.nByte);
							}
							if (pAttr == 0) {

								VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Undefined class attribute '%z::%z',PHP is loading NULL",
									&pClass->sName,&sName);

								PHP_ClassInstanceCallMagicMethod(&(*pVm),pClass,0,"__get",sizeof("__get") - 1,&sName);
							}

							if (!pInstr->p3) {
								VmPopOperand(&pTos,1);
							}
							PHP_MemObjRelease(pTos);
							pTos->nIdx = SXU32_HIGH;
							if (pAttr) {
								if ((pAttr->iFlags & (PHP_CLASS_ATTR_STATIC | PHP_CLASS_ATTR_CONSTANT)) == 0) {

									VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Access to a non-static class attribute '%z::%z',PHP is loading NULL",
										&pClass->sName,&pAttr->sName
									);
								}
								else {
									php_value* pValue;

									if (VmClassMemberAccess(&(*pVm),pClass,&pAttr->sName,pAttr->iProtection,TRUE)) {

										pValue = (php_value*)SySetAt(&pVm->aMemObj,pAttr->nIdx);
										if (pValue) {
											PHP_MemObjLoad(pValue,pTos);
											if (pAttr->iFlags & PHP_CLASS_ATTR_STATIC) {

												pTos->nIdx = pAttr->nIdx;
											}
										}
									}
								}
							}
						}
						if (pThis) {

							PHP_ClassInstanceUnref(pThis);
						}
					}
				}
				else {

					PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,"Invalid class name,PHP is loading NULL");
					if (!pInstr->p3) {
						VmPopOperand(&pTos,1);
					}
					PHP_MemObjRelease(pTos);
					pTos->nIdx = SXU32_HIGH;
				}
			}
			break;
		}

		case PHP_OP_NEW: {
			php_value* pArg = &pTos[-pInstr->iP1];
			php_class* pClass = 0;
			php_class_instance* pNew;
			if ((pTos->iFlags & MEMOBJ_STRING) && SyBlobLength(&pTos->sBlob) > 0) {

				pClass = PHP_VmExtractClass(&(*pVm),(const char*)SyBlobData(&pTos->sBlob),
					SyBlobLength(&pTos->sBlob),TRUE ,0);
			}
			else if (pTos->iFlags & MEMOBJ_OBJ) {

				pClass = ((php_class_instance*)pTos->x.pOther)->pClass;
			}
			if (pClass == 0) {

				VmErrorFormat(&(*pVm),PHP_CTX_ERR,"Class '%.*s' is not defined,PHP is loading NULL",
					SyBlobLength(&pTos->sBlob),(const char*)SyBlobData(&pTos->sBlob)
				);
				PHP_MemObjRelease(pTos);
				if (pInstr->iP1 > 0) {

					VmPopOperand(&pTos,pInstr->iP1);
				}
			}
			else {
				php_class_method* pCons;

				pNew = PHP_NewClassInstance(&(*pVm),pClass);
				if (pNew == 0) {
					VmErrorFormat(&(*pVm),PHP_CTX_ERR,
						"Cannot create new class '%z' instance due to a memory failure,PHP is loading NULL",
						&pClass->sName
					);
					PHP_MemObjRelease(pTos);
					if (pInstr->iP1 > 0) {

						VmPopOperand(&pTos,pInstr->iP1);
					}
					break;
				}

				pCons = PHP_ClassExtractMethod(pClass,"__construct",sizeof("__construct") - 1);
				if (pCons == 0) {
					SyString* pName = &pClass->sName;

					pCons = PHP_ClassExtractMethod(pClass,pName->zString,pName->nByte);
				}
				if (pCons) {

					SySetReset(&aArg);
					while (pArg < pTos) {
						SySetPut(&aArg,(const void*)&pArg);
						pArg++;
					}
					if (pVm->bErrReport) {
						php_vm_func_arg* pFuncArg;
						sxu32 n;
						n = SySetUsed(&aArg);

						while (n < SySetUsed(&pCons->sFunc.aArgs)) {
							pFuncArg = (php_vm_func_arg*)SySetAt(&pCons->sFunc.aArgs,n);
							if (pFuncArg) {
								if (SySetUsed(&pFuncArg->aByteCode) < 1) {
									VmErrorFormat(&(*pVm),PHP_CTX_NOTICE,"Missing constructor argument %u($%z) for class '%z'",
										n + 1,&pFuncArg->sName,&pClass->sName);
								}
							}
							n++;
						}
					}
					PHP_VmCallClassMethod(&(*pVm),pNew,pCons,0,(int)SySetUsed(&aArg),(php_value**)SySetBasePtr(&aArg));

					if (pNew->iRef < 1) {
						pNew->iRef = 1;
					}
				}
				if (pInstr->iP1 > 0) {

					VmPopOperand(&pTos,pInstr->iP1);
				}
				PHP_MemObjRelease(pTos);
				pTos->x.pOther = pNew;
				MemObjSetType(pTos,MEMOBJ_OBJ);
			}
			break;
		}

		case PHP_OP_CLONE: {
			php_class_instance* pSrc,* pClone;
#ifdef UNTRUST
			if (pTos < pStack) {
				goto Abort;
			}
#endif

			if ((pTos->iFlags & MEMOBJ_OBJ) == 0) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
					"Clone: Expecting a class instance as left operand,PHP is loading NULL");
				PHP_MemObjRelease(pTos);
				break;
			}

			pSrc = (php_class_instance*)pTos->x.pOther;

			pClone = PHP_CloneClassInstance(pSrc);
			PHP_MemObjRelease(pTos);
			if (pClone == 0) {
				PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
					"Clone: cannot make an object clone due to a memory failure,PHP is loading NULL");
			}
			else {

				pTos->x.pOther = pClone;
				MemObjSetType(pTos,MEMOBJ_OBJ);
			}
			break;
		}

		case PHP_OP_SWITCH: {
			php_switch* pSwitch = (php_switch*)pInstr->p3;
			php_case_expr* aCase,* pCase;
			php_value sValue,sCaseValue;
			sxu32 n,nEntry;
#ifdef UNTRUST
			if (pSwitch == 0 || pTos < pStack) {
				goto Abort;
			}
#endif

			aCase = (php_case_expr*)SySetBasePtr(&pSwitch->aCaseExpr);
			nEntry = SySetUsed(&pSwitch->aCaseExpr);

			PHP_MemObjInit(pVm,&sValue);
			PHP_MemObjInit(pVm,&sCaseValue);
			for (n = 0; n < nEntry; ++n) {
				pCase = &aCase[n];
				PHP_MemObjLoad(pTos,&sValue);

				VmLocalExec(pVm,&pCase->aByteCode,&sCaseValue);

				rc = PHP_MemObjCmp(&sValue,&sCaseValue,FALSE,0);
				PHP_MemObjRelease(&sValue);
				PHP_MemObjRelease(&sCaseValue);
				if (rc == 0) {

					pc = pCase->nStart - 1;
					break;
				}
			}
			VmPopOperand(&pTos,1);
			if (n >= nEntry) {

				if (pSwitch->nDefault > 0) {
					pc = pSwitch->nDefault - 1;
				}
				else {

					pc = pSwitch->nOut - 1;
				}
			}
			break;
		}

		case PHP_OP_CALL: {
			php_value* pArg = &pTos[-pInstr->iP1];
			SyHashEntry* pEntry;
			SyString sName;

			if ((pTos->iFlags & MEMOBJ_STRING) == 0) {
				if (pTos->iFlags & MEMOBJ_HASHMAP) {
					php_value sResult;
					SySetReset(&aArg);
					while (pArg < pTos) {
						SySetPut(&aArg,(const void*)&pArg);
						pArg++;
					}
					PHP_MemObjInit(pVm,&sResult);

					PHP_VmCallUserFunction(pVm,pTos,(int)SySetUsed(&aArg),(php_value**)SySetBasePtr(&aArg),&sResult);
					SySetReset(&aArg);

					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}

					PHP_MemObjStore(&sResult,pTos);
					PHP_MemObjRelease(&sResult);
				}
				else {
					if (pTos->iFlags & MEMOBJ_OBJ) {
						php_class_instance* pThis = (php_class_instance*)pTos->x.pOther;

						PHP_ClassInstanceCallMagicMethod(&(*pVm),pThis->pClass,pThis,"__invoke",sizeof("__invoke") - 1,0);
					}
					else {

						VmErrorFormat(&(*pVm),PHP_CTX_WARNING,"Invalid function name,NULL will be returned");
					}

					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}

					PHP_MemObjRelease(pTos);
				}
				break;
			}
			SyStringInitFromBuf(&sName,SyBlobData(&pTos->sBlob),SyBlobLength(&pTos->sBlob));

			pEntry = SyHashGet(&pVm->hFunction,(const void*)sName.zString,sName.nByte);
			if (pEntry) {
				php_vm_func_arg* aFormalArg;
				php_class_instance* pThis;
				php_value* pFrameStack;
				php_vm_func* pVmFunc;
				php_class* pSelf;
				VmFrame* pFrame;
				php_value* pObj;
				VmSlot sArg;
				sxu32 n;

				pVmFunc = (php_vm_func*)pEntry->pUserData;
				pThis = 0;
				pSelf = 0;
				if (pVmFunc->iFlags & VM_FUNC_CLASS_METHOD) {
					php_class_method* pMeth;

					php_value* pTarget = &pTos[-1];
					if (pTarget >= pStack && (pTarget->iFlags & (MEMOBJ_STRING | MEMOBJ_OBJ | MEMOBJ_NULL))) {

						if (pTarget->iFlags & MEMOBJ_OBJ) {

							pThis = (php_class_instance*)pTarget->x.pOther;
							pThis->iRef++;
							pSelf = pThis->pClass;
						}
						if (pSelf == 0) {
							if ((pTarget->iFlags & MEMOBJ_STRING) && SyBlobLength(&pTarget->sBlob) > 0) {

								pSelf = PHP_VmExtractClass(&(*pVm),(const char*)SyBlobData(&pTarget->sBlob),
									SyBlobLength(&pTarget->sBlob),FALSE,0);
							}
							if (pSelf == 0) {
								pSelf = (php_class*)pVmFunc->pUserData;
							}
						}
						if (pThis == 0) {
							VmFrame* pFrame = pVm->pFrame;
							while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

								pFrame = pFrame->pParent;
							}
							if (pFrame->pParent) {

								pThis = pFrame->pThis;
								if (pThis) {
									pThis->iRef++;
								}
							}
						}
						VmPopOperand(&pTos,1);
						PHP_MemObjRelease(pTos);

						pArg = &pTos[-pInstr->iP1];

						while (pArg < pStack) {
							pArg++;
						}
						if (pSelf) {

							pMeth = PHP_ClassExtractMethod(pSelf,pVmFunc->sName.zString,pVmFunc->sName.nByte);
							if (pMeth && pMeth->iProtection != PHP_CLASS_PROT_PUBLIC) {
								if (!VmClassMemberAccess(&(*pVm),pSelf,&pVmFunc->sName,pMeth->iProtection,TRUE)) {

									if (pInstr->iP1 > 0) {
										VmPopOperand(&pTos,pInstr->iP1);
									}

									PHP_MemObjRelease(pTos);
									break;
								}
							}
						}
					}
				}

				if (pVm->nRecursionDepth > pVm->nMaxDepth) {
					VmErrorFormat(&(*pVm),PHP_CTX_ERR,
						"Recursion limit reached while invoking user function '%z',PHP will set a NULL return value",
						&pVmFunc->sName);

					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}

					PHP_MemObjRelease(pTos);
					break;
				}
				if (pVmFunc->pNextName) {

					pVmFunc = VmOverload(&(*pVm),pVmFunc,pArg,(int)(pTos - pArg));
				}

				aFormalArg = (php_vm_func_arg*)SySetBasePtr(&pVmFunc->aArgs);

				rc = VmEnterFrame(&(*pVm),pVmFunc,pThis,&pFrame);
				if (rc != SXRET_OK) {

					VmErrorFormat(&(*pVm),PHP_CTX_ERR,
						"PHP is running out of memory while calling function '%z',NULL will be returned",
						&pVmFunc->sName);

					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}

					PHP_MemObjRelease(pTos);
					break;
				}
				if ((pVmFunc->iFlags & VM_FUNC_CLASS_METHOD) && pThis) {

					static const SyString sThis = { "this" ,sizeof("this") - 1 };
					pObj = VmExtractMemObj(&(*pVm),&sThis,FALSE,TRUE);
					if (pObj) {

						pObj->x.pOther = pThis;
						MemObjSetType(pObj,MEMOBJ_OBJ);
					}
				}
				if (SySetUsed(&pVmFunc->aStatic) > 0) {
					php_vm_func_static_var* pStatic,* aStatic;

					aStatic = (php_vm_func_static_var*)SySetBasePtr(&pVmFunc->aStatic);
					for (n = 0; n < SySetUsed(&pVmFunc->aStatic); ++n) {
						pStatic = &aStatic[n];
						if (pStatic->nIdx == SXU32_HIGH) {

							pObj = VmReserveMemObj(&(*pVm),&pStatic->nIdx);
							if (pObj) {

								PHP_MemObjInit(&(*pVm),pObj);
								if (SySetUsed(&pStatic->aByteCode) > 0) {

									VmLocalExec(&(*pVm),&pStatic->aByteCode,pObj);
								}
								pObj->nIdx = pStatic->nIdx;
							}
							else {
								continue;
							}
						}

						SyHashInsert(&pFrame->hVar,SyStringData(&pStatic->sName),SyStringLength(&pStatic->sName),
							SX_INT_TO_PTR(pStatic->nIdx));
					}
				}

				n = 0;
				while (pArg < pTos) {
					if (n < SySetUsed(&pVmFunc->aArgs)) {
						if ((pArg->iFlags & MEMOBJ_NULL) && SySetUsed(&aFormalArg[n].aByteCode) > 0) {

							rc = VmLocalExec(&(*pVm),&aFormalArg[n].aByteCode,pArg);
							if (rc == PHP_ABORT) {
								goto Abort;
							}
						}

						if (aFormalArg[n].nType > 0) {
							if (aFormalArg[n].nType == SXU32_HIGH) {

								SyString* pName = &aFormalArg[n].sClass;
								php_class* pClass;

								pClass = PHP_VmExtractClass(&(*pVm),pName->zString,pName->nByte,TRUE,0);
								if (pClass) {
									if ((pArg->iFlags & MEMOBJ_OBJ) == 0) {
										if ((pArg->iFlags & MEMOBJ_NULL) == 0) {
											VmErrorFormat(&(*pVm),PHP_CTX_WARNING,
												"Function '%z()':Argument %u must be an object of type '%z',PHP is loading NULL instead",
												&pVmFunc->sName,n + 1,pName);
											PHP_MemObjRelease(pArg);
										}
									}
									else {
										php_class_instance* pThis = (php_class_instance*)pArg->x.pOther;

										if (!VmInstanceOf(pThis->pClass,pClass)) {
											VmErrorFormat(&(*pVm),PHP_CTX_ERR,
												"Function '%z()':Argument %u must be an object of type '%z',PHP is loading NULL instead",
												&pVmFunc->sName,n + 1,pName);
											PHP_MemObjRelease(pArg);
										}
									}
								}
							}
							else if (((pArg->iFlags & aFormalArg[n].nType) == 0)) {
								ProcMemObjCast xCast = PHP_MemObjCastMethod(aFormalArg[n].nType);

								xCast(pArg);
							}
						}
						if (aFormalArg[n].iFlags & VM_FUNC_ARG_BY_REF) {

							if (pArg->nIdx == SXU32_HIGH) {

								if ((pArg->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES | MEMOBJ_NULL)) == 0) {
									VmErrorFormat(&(*pVm),PHP_CTX_WARNING,
										"Function '%z',%d argument: Pass by reference,expecting a variable not a "
										"constant,PHP is switching to pass by value",&pVmFunc->sName,n + 1);
								}

								pObj = VmExtractMemObj(&(*pVm),&aFormalArg[n].sName,FALSE,TRUE);
							}
							else {
								SyHashEntry* pRefEntry;

								pRefEntry = SyHashGet(&pFrame->hVar,SyStringData(&aFormalArg[n].sName),SyStringLength(&aFormalArg[n].sName));
								if (pRefEntry == 0) {
									SyHashInsert(&pFrame->hVar,SyStringData(&aFormalArg[n].sName),
										SyStringLength(&aFormalArg[n].sName),SX_INT_TO_PTR(pArg->nIdx));
									sArg.nIdx = pArg->nIdx;
									sArg.pUserData = 0;
									SySetPut(&pFrame->sArg,(const void*)&sArg);
								}
								pObj = 0;
							}
						}
						else {

							pObj = VmExtractMemObj(&(*pVm),&aFormalArg[n].sName,FALSE,TRUE);
						}
					}
					else {
						char zName[32];
						SyString sName;

						sName.nByte = SyBufferFormat(zName,sizeof(zName),"[%u]apArg",n);
						sName.zString = zName;

						pObj = VmExtractMemObj(&(*pVm),&sName,TRUE,TRUE);
					}
					if (pObj) {
						PHP_MemObjStore(pArg,pObj);

						sArg.nIdx = pObj->nIdx;
						sArg.pUserData = 0;
						SySetPut(&pFrame->sArg,(const void*)&sArg);
					}
					PHP_MemObjRelease(pArg);
					pArg++;
					++n;
				}

				if (pVmFunc->iFlags & VM_FUNC_CLOSURE) {
					php_vm_func_closure_env* aEnv,* pEnv;
					php_value* pValue;
					sxu32 n;
					aEnv = (php_vm_func_closure_env*)SySetBasePtr(&pVmFunc->aClosureEnv);
					for (n = 0; n < SySetUsed(&pVmFunc->aClosureEnv); ++n) {
						pEnv = &aEnv[n];
						if ((pEnv->iFlags & VM_FUNC_ARG_IGNORE) && (pEnv->sValue.iFlags & MEMOBJ_NULL)) {

							continue;
						}
						pValue = VmExtractMemObj(pVm,&pEnv->sName,FALSE,TRUE);
						if (pValue == 0) {
							continue;
						}

						PHP_MemObjRelease(pValue);

						PHP_MemObjStore(&pEnv->sValue,pValue);
					}
				}

				while (n < SySetUsed(&pVmFunc->aArgs)) {
					if (SySetUsed(&aFormalArg[n].aByteCode) > 0) {
						pObj = VmExtractMemObj(&(*pVm),&aFormalArg[n].sName,FALSE,TRUE);
						if (pObj) {

							rc = VmLocalExec(&(*pVm),&aFormalArg[n].aByteCode,pObj);
							if (rc == PHP_ABORT) {
								goto Abort;
							}

							sArg.nIdx = pObj->nIdx;
							sArg.pUserData = 0;
							SySetPut(&pFrame->sArg,(const void*)&sArg);

							if (aFormalArg[n].nType > 0 && ((pObj->iFlags & aFormalArg[n].nType) == 0)) {
								ProcMemObjCast xCast = PHP_MemObjCastMethod(aFormalArg[n].nType);

								xCast(pObj);
							}
						}
					}
					++n;
				}

				PHP_MemObjRelease(pTos);
				pTos = &pTos[-pInstr->iP1];

				pFrameStack = VmNewOperandStack(&(*pVm),SySetUsed(&pVmFunc->aByteCode));
				if (pFrameStack == 0) {

					VmErrorFormat(&(*pVm),PHP_CTX_ERR,"PHP is running out of memory while calling function '%z',NULL will be returned",
						&pVmFunc->sName);
					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}
					break;
				}
				if (pSelf) {

					SySetPut(&pVm->aSelf,(const void*)&pSelf);
				}

				pVm->nRecursionDepth++;

				rc = VmByteCodeExec(&(*pVm),(VmInstr*)SySetBasePtr(&pVmFunc->aByteCode),pFrameStack,-1,pTos,&n,FALSE);

				pVm->nRecursionDepth--;
				if (pSelf) {

					(void)SySetPop(&pVm->aSelf);
				}

				if ((pVmFunc->iFlags & VM_FUNC_REF_RETURN) && rc == SXRET_OK) {

					if (n != SXU32_HIGH) {
						VmSlot* aSlot = (VmSlot*)SySetBasePtr(&pFrame->sLocal);
						sxu32 i;

						for (i = 0; i < SySetUsed(&pFrame->sLocal); ++i) {
							if (n == aSlot[i].nIdx) {
								pObj = (php_value*)SySetAt(&pVm->aMemObj,n);
								if (pObj && (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_OBJ | MEMOBJ_HASHMAP | MEMOBJ_RES)) == 0) {
									VmErrorFormat(&(*pVm),PHP_CTX_NOTICE,
										"Function '%z',return by reference: Cannot reference local variable,PHP is switching to return by value",
										&pVmFunc->sName);
								}
								n = SXU32_HIGH;
								break;
							}
						}
					}
					else {
						if ((pTos->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_NULL | MEMOBJ_RES)) == 0) {
							VmErrorFormat(&(*pVm),PHP_CTX_NOTICE,
								"Function '%z',return by reference: Cannot reference constant expression,PHP is switching to return by value",
								&pVmFunc->sName);
						}
					}
					pTos->nIdx = n;
				}

				if (rc != PHP_ABORT && ((pFrame->iFlags & VM_FRAME_THROW) || rc == PHP_EXCEPTION)) {

					pFrame = pFrame->pParent;
					if (!is_callback && pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION) && pFrame->iExceptionJump > 0) {

						VmPopOperand(&pTos,1);

						pc = pFrame->iExceptionJump - 1;
						rc = PHP_OK;
					}
					else {
						if (pFrame->pParent) {
							rc = PHP_EXCEPTION;
						}
						else {

							rc = PHP_OK;
						}
					}
				}

				SyMemBackendFree(&pVm->sAllocator,pFrameStack);

				VmLeaveFrame(&(*pVm));
				if (rc == PHP_ABORT) {

					goto Abort;
				}
				else if (rc == PHP_EXCEPTION) {
					goto Exception;
				}
			}
			else {
				php_user_func* pFunc;
				php_context sCtx;
				php_value sRet;

				pEntry = SyHashGet(&pVm->hHostFunction,(const void*)sName.zString,sName.nByte);
				if (pEntry == 0) {

					VmErrorFormat(&(*pVm),PHP_CTX_WARNING,"Call to undefined function '%z',NULL will be returned",&sName);

					if (pInstr->iP1 > 0) {
						VmPopOperand(&pTos,pInstr->iP1);
					}

					PHP_MemObjRelease(pTos);
					break;
				}
				pFunc = (php_user_func*)pEntry->pUserData;

				SySetReset(&aArg);
				while (pArg < pTos) {
					SySetPut(&aArg,(const void*)&pArg);
					pArg++;
				}

				PHP_MemObjInit(&(*pVm),&sRet);

				VmInitCallContext(&sCtx,&(*pVm),pFunc,&sRet,0);

				rc = pFunc->xFunc(&sCtx,(int)SySetUsed(&aArg),(php_value**)SySetBasePtr(&aArg));

				VmReleaseCallContext(&sCtx);
				if (rc == PHP_ABORT) {
					goto Abort;
				}
				if (pInstr->iP1 > 0) {

					VmPopOperand(&pTos,pInstr->iP1);
				}

				PHP_MemObjStore(&sRet,pTos);
				PHP_MemObjRelease(&sRet);
			}
			break;
		}

		case PHP_OP_CONSUME: {
			php_output_consumer* pCons = &pVm->sVmConsumer;
			php_value* pCur,* pOut = pTos;

			pOut = &pTos[-pInstr->iP1 + 1];
			pCur = pOut;

			while (pOut <= pTos) {

				if ((pOut->iFlags & MEMOBJ_STRING) == 0) {
					PHP_MemObjToString(pOut);
				}
				if (SyBlobLength(&pOut->sBlob) > 0) {


					rc = pCons->xConsumer(SyBlobData(&pOut->sBlob),SyBlobLength(&pOut->sBlob),pCons->pUserData);
					if (pCons->xConsumer != VmObConsumer) {

						pVm->nOutputLen += SyBlobLength(&pOut->sBlob);
					}
					SyBlobRelease(&pOut->sBlob);
					if (rc == SXERR_ABORT) {

						goto Abort;
					}
				}
				pOut++;
			}
			pTos = &pCur[-1];
			break;
		}

		}
		pc++;
	}
Done:
	SySetRelease(&aArg);
	return SXRET_OK;
Abort:
	SySetRelease(&aArg);
	while (pTos >= pStack) {
		PHP_MemObjRelease(pTos);
		pTos--;
	}
	return PHP_ABORT;
Exception:
	SySetRelease(&aArg);
	while (pTos >= pStack) {
		PHP_MemObjRelease(pTos);
		pTos--;
	}
	return PHP_EXCEPTION;
}

static sxi32 VmLocalExec(php_vm* pVm,SySet* pByteCode,php_value* pResult)
{
	php_value* pStack;
	sxi32 rc;

	pStack = VmNewOperandStack(&(*pVm),SySetUsed(pByteCode));
	if (pStack == 0) {
		return SXERR_MEM;
	}

	rc = VmByteCodeExec(&(*pVm),(VmInstr*)SySetBasePtr(pByteCode),pStack,-1,&(*pResult),0,FALSE);

	SyMemBackendFree(&pVm->sAllocator,pStack);

	return rc;
}

static void VmInvokeShutdownCallbacks(php_vm* pVm)
{
	VmShutdownCB* pEntry;
	php_value* apArg[10];
	sxu32 n,nEntry; int i;

	nEntry = SySetUsed(&pVm->aShutdown);
	for (i = 0; i < (int)SX_ARRAYSIZE(apArg); i++) {
		apArg[i] = 0;
	}
	for (n = 0; n < nEntry; ++n) {
		pEntry = (VmShutdownCB*)SySetAt(&pVm->aShutdown,n);
		if (pEntry) {

			for (i = 0; i < pEntry->nArg; i++) {
				if (i >= (int)SX_ARRAYSIZE(apArg)) {
					break;
				}
				apArg[i] = &pEntry->aArg[i];
			}

			PHP_VmCallUserFunction(&(*pVm),&pEntry->sCallback,pEntry->nArg,apArg,0);

			pEntry = (VmShutdownCB*)SySetAt(&pVm->aShutdown,n);
			if (pEntry) {
				PHP_MemObjRelease(&pEntry->sCallback);
				for (i = 0; i < pEntry->nArg; ++i) {
					PHP_MemObjRelease(apArg[i]);
				}
			}
		}
	}
	SySetReset(&pVm->aShutdown);
}

PHP_PRIVATE sxi32 PHP_VmByteCodeExec(php_vm* pVm)
{

	if (pVm->nMagic != PHP_VM_RUN) {
		return pVm->nMagic == PHP_VM_EXEC ? SXERR_LOCKED  : SXERR_CORRUPT;
	}

	pVm->nMagic = PHP_VM_EXEC;

	VmByteCodeExec(&(*pVm),(VmInstr*)SySetBasePtr(pVm->pByteContainer),pVm->aOps,-1,&pVm->sExec,0,FALSE);

	VmInvokeShutdownCallbacks(&(*pVm));

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmOutputConsume(
	php_vm* pVm,
	SyString* pString
)
{
	php_output_consumer* pCons = &pVm->sVmConsumer;
	sxi32 rc = SXRET_OK;

	if (pString->nByte > 0) {
		rc = pCons->xConsumer((const void*)pString->zString,pString->nByte,pCons->pUserData);
		if (pCons->xConsumer != VmObConsumer) {

			pVm->nOutputLen += pString->nByte;
		}
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_VmOutputConsumeAp(
	php_vm* pVm,
	const char* zFormat,
	va_list ap
)
{
	php_output_consumer* pCons = &pVm->sVmConsumer;
	sxi32 rc = SXRET_OK;
	SyBlob sWorker;

	SyBlobInit(&sWorker,&pVm->sAllocator);
	SyBlobFormatAp(&sWorker,zFormat,ap);
	if (SyBlobLength(&sWorker) > 0) {

		rc = pCons->xConsumer(SyBlobData(&sWorker),SyBlobLength(&sWorker),pCons->pUserData);
	}
	if (pCons->xConsumer != VmObConsumer) {

		pVm->nOutputLen += SyBlobLength(&sWorker);
	}

	SyBlobRelease(&sWorker);
	return rc;
}

static const char* VmInstrToString(sxi32 nOp)
{
	const char* zOp = "Unknown";
	switch (nOp) {case PHP_OP_DONE:zOp = "DONE"; break;case PHP_OP_HALT:zOp = "HALT"; break;case PHP_OP_LOAD:zOp = "LOAD"; break;case PHP_OP_LOADC:zOp = "LOADC"; break;case PHP_OP_LOAD_MAP:zOp = "LOAD_MAP"; break;case PHP_OP_LOAD_LIST:zOp = "LOAD_LIST"; break;case PHP_OP_LOAD_IDX:zOp = "LOAD_IDX"; break;case PHP_OP_LOAD_CLOSURE:zOp = "LOAD_CLOSR"; break;case PHP_OP_NOOP:zOp = "NOOP"; break;case PHP_OP_JMP:zOp = "JMP"; break;case PHP_OP_JZ:zOp = "JZ"; break;case PHP_OP_JNZ:zOp = "JNZ"; break;case PHP_OP_POP:zOp = "POP"; break;case PHP_OP_CAT:zOp = "CAT"; break;case PHP_OP_CVT_INT:zOp = "CVT_INT"; break;case PHP_OP_CVT_STR:zOp = "CVT_STR"; break;case PHP_OP_CVT_REAL:zOp = "CVT_REAL"; break;case PHP_OP_CALL:zOp = "CALL"; break;case PHP_OP_UMINUS:zOp = "UMINUS"; break;case PHP_OP_UPLUS:zOp = "UPLUS"; break;case PHP_OP_BITNOT:zOp = "BITNOT"; break;case PHP_OP_LNOT:zOp = "LOGNOT"; break;case PHP_OP_MUL:zOp = "MUL"; break;case PHP_OP_DIV:zOp = "DIV"; break;case PHP_OP_MOD:zOp = "MOD"; break;case PHP_OP_ADD:zOp = "ADD"; break;case PHP_OP_SUB:zOp = "SUB"; break;case PHP_OP_SHL:zOp = "SHL"; break;case PHP_OP_SHR:zOp = "SHR"; break;case PHP_OP_LT:zOp = "LT"; break;case PHP_OP_LE:zOp = "LE"; break;case PHP_OP_GT:zOp = "GT"; break;case PHP_OP_GE:zOp = "GE"; break;case PHP_OP_EQ:zOp = "EQ"; break;case PHP_OP_NEQ:zOp = "NEQ"; break;case PHP_OP_TEQ:zOp = "TEQ"; break;case PHP_OP_TNE:zOp = "TNE"; break;case PHP_OP_BAND:zOp = "BITAND"; break;case PHP_OP_BXOR:zOp = "BITXOR"; break;case PHP_OP_BOR:zOp = "BITOR"; break;case PHP_OP_LAND:zOp = "LOGAND"; break;case PHP_OP_LOR:zOp = "LOGOR"; break;case PHP_OP_LXOR:zOp = "LOGXOR"; break;case PHP_OP_STORE:zOp = "STORE"; break;case PHP_OP_STORE_IDX:zOp = "STORE_IDX"; break;case PHP_OP_STORE_IDX_REF:zOp = "STORE_IDX_R"; break;case PHP_OP_PULL:zOp = "PULL"; break;case PHP_OP_SWAP:zOp = "SWAP"; break;case PHP_OP_YIELD:zOp = "YIELD"; break;case PHP_OP_CVT_BOOL:zOp = "CVT_BOOL"; break;case PHP_OP_CVT_NULL:zOp = "CVT_NULL"; break;case PHP_OP_CVT_ARRAY:zOp = "CVT_ARRAY"; break;case PHP_OP_CVT_OBJ:zOp = "CVT_OBJ"; break;case PHP_OP_CVT_NUMC:zOp = "CVT_NUMC"; break;case PHP_OP_INCR:zOp = "INCR"; break;case PHP_OP_DECR:zOp = "DECR"; break;case PHP_OP_SEQ:zOp = "SEQ"; break;case PHP_OP_SNE:zOp = "SNE"; break;case PHP_OP_NEW:zOp = "NEW"; break;case PHP_OP_CLONE:zOp = "CLONE"; break;case PHP_OP_ADD_STORE:zOp = "ADD_STORE"; break;case PHP_OP_SUB_STORE:zOp = "SUB_STORE"; break;case PHP_OP_MUL_STORE:zOp = "MUL_STORE"; break;case PHP_OP_DIV_STORE:zOp = "DIV_STORE"; break;case PHP_OP_MOD_STORE:zOp = "MOD_STORE"; break;case PHP_OP_CAT_STORE:zOp = "CAT_STORE"; break;case PHP_OP_SHL_STORE:zOp = "SHL_STORE"; break;case PHP_OP_SHR_STORE:zOp = "SHR_STORE"; break;case PHP_OP_BAND_STORE:zOp = "BAND_STORE"; break;case PHP_OP_BOR_STORE:zOp = "BOR_STORE"; break;case PHP_OP_BXOR_STORE:zOp = "BXOR_STORE"; break;case PHP_OP_CONSUME:zOp = "CONSUME"; break;case PHP_OP_LOAD_REF:zOp = "LOAD_REF"; break;case PHP_OP_STORE_REF:zOp = "STORE_REF"; break;case PHP_OP_MEMBER:zOp = "MEMBER"; break;case PHP_OP_UPLINK:zOp = "UPLINK"; break;case PHP_OP_ERR_CTRL:zOp = "ERR_CTRL"; break;case PHP_OP_IS_A:zOp = "IS_A"; break;case PHP_OP_SWITCH:zOp = "SWITCH"; break;case PHP_OP_LOAD_EXCEPTION:zOp = "LOAD_EXCEP"; break;case PHP_OP_POP_EXCEPTION:zOp = "POP_EXCEP"; break;case PHP_OP_THROW:zOp = "THROW"; break;case PHP_OP_FOREACH_INIT:zOp = "4EACH_INIT"; break;case PHP_OP_FOREACH_STEP:zOp = "4EACH_STEP"; break;default:break;}
	return zOp;
}

PHP_PRIVATE sxi32 PHP_VmDump(
	php_vm* pVm,
	ProcConsumer xConsumer,
	void* pUserData
)
{
	sxi32 rc;
	rc = VmByteCodeDump(pVm->pByteContainer,xConsumer,pUserData);
	return rc;
}

PHP_PRIVATE void PHP_VmExpandConstantValue(php_value* pVal,void* pUserData)
{
	SySet* pByteCode = (SySet*)pUserData;

	VmLocalExec((php_vm*)SySetGetUserData(pByteCode),pByteCode,(php_value*)pVal);
}


static int vm_builtin_func_num_args(php_context* pCtx,int nArg,php_value** apArg)
{
	VmFrame* pFrame;
	php_vm* pVm;

	pVm = pCtx->pVm;

	pFrame = pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	if (pFrame->pParent == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_int(pCtx,-1);
		return SXRET_OK;
	}

	nArg = (int)SySetUsed(&pFrame->sArg);
	php_result_int(pCtx,nArg);
	return SXRET_OK;
}

static int vm_builtin_func_get_arg(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pObj = 0;
	VmSlot* pSlot = 0;
	VmFrame* pFrame;
	php_vm* pVm;

	pVm = pCtx->pVm;

	pFrame = pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	if (nArg < 1 || pFrame->pParent == 0) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Called in the global scope");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	nArg = php_value_to_int(apArg[0]);
	if (nArg < 0 || nArg >= (int)SySetUsed(&pFrame->sArg)) {

		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	if ((pSlot = (VmSlot*)SySetAt(&pFrame->sArg,(sxu32)nArg)) != 0) {
		if ((pObj = (php_value*)SySetAt(&pVm->aMemObj,pSlot->nIdx)) != 0) {

			php_result_value(pCtx,(php_value*)pObj);
		}
		else {

			php_result_bool(pCtx,0);
		}
	}
	else {

		php_result_bool(pCtx,0);
	}
	return SXRET_OK;
}

static int vm_builtin_func_get_args_byref(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray;
	VmFrame* pFrame;
	VmSlot* aSlot;
	sxu32 n;

	pFrame = pCtx->pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	if (pFrame->pParent == 0) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Called in the global scope");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	aSlot = (VmSlot*)SySetBasePtr(&pFrame->sArg);
	for (n = 0; n < SySetUsed(&pFrame->sArg); n++) {
		PHP_HashmapInsertByRef((php_hashmap*)pArray->x.pOther,0,aSlot[n].nIdx);
	}

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}

static int vm_builtin_func_get_args(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pObj = 0;
	php_value* pArray;
	VmFrame* pFrame;
	VmSlot* aSlot;
	sxu32 n;

	pFrame = pCtx->pVm->pFrame;
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	if (pFrame->pParent == 0) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Called in the global scope");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {SXUNUSED(nArg); SXUNUSED(apArg);php_result_bool(pCtx,0);return SXRET_OK;}

	aSlot = (VmSlot*)SySetBasePtr(&pFrame->sArg);
	for (n = 0; n < SySetUsed(&pFrame->sArg); n++) {
		pObj = (php_value*)SySetAt(&pCtx->pVm->aMemObj,aSlot[n].nIdx);
		if (pObj) {
			php_array_add_elem(pArray,0,pObj);
		}
	}

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}

static int vm_builtin_func_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zName;
	php_vm* pVm; int nLen; int res;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	pVm = pCtx->pVm;

	zName = php_value_to_string(apArg[0],&nLen);

	res = 0;

	if (SyHashGet(&pVm->hFunction,(const void*)zName,(sxu32)nLen) != 0 ||
		SyHashGet(&pVm->hHostFunction,(const void*)zName,(sxu32)nLen) != 0) {

		res = 1;
	}
	php_result_bool(pCtx,res);
	return SXRET_OK;
}

static php_class* VmExtractClassFromValue(php_vm* pVm,php_value* pArg);

PHP_PRIVATE int PHP_VmIsCallable(php_vm* pVm,php_value* pValue,int CallInvoke)
{
	int res = 0;
	if (pValue->iFlags & MEMOBJ_OBJ) {

		php_class_instance* pThis = (php_class_instance*)pValue->x.pOther;
		php_class_method* pMethod;
		pMethod = PHP_ClassExtractMethod(pThis->pClass,"__invoke",sizeof("__invoke") - 1);
		if (pMethod && CallInvoke) {
			php_value sResult;
			sxi32 rc;

			PHP_MemObjInit(pVm,&sResult);
			rc = PHP_VmCallClassMethod(pVm,pThis,pMethod,&sResult,0,0);
			if (rc == SXRET_OK && (sResult.iFlags & (MEMOBJ_BOOL | MEMOBJ_INT))) {
				res = sResult.x.iVal != 0;
			}
			PHP_MemObjRelease(&sResult);
		}
	}
	else if (pValue->iFlags & MEMOBJ_HASHMAP) {
		php_hashmap* pMap = (php_hashmap*)pValue->x.pOther;
		if (pMap->nEntry > 1) {
			php_class* pClass;
			php_value* pV;

			pV = (php_value*)SySetAt(&pVm->aMemObj,pMap->pFirst->nValIdx);
			if (pV) {
				pClass = VmExtractClassFromValue(pVm,pV);
				if (pClass) {
					php_class_method* pMethod;

					pV = (php_value*)SySetAt(&pVm->aMemObj,pMap->pFirst->pPrev->nValIdx);
					if (pV && (pV->iFlags & MEMOBJ_STRING) && SyBlobLength(&pV->sBlob) > 0) {

						pMethod = PHP_ClassExtractMethod(pClass,(const char*)SyBlobData(&pV->sBlob),SyBlobLength(&pV->sBlob));
						if (pMethod) {

							res = 1;
						}
					}
				}
			}
		}
	}
	else if (pValue->iFlags & MEMOBJ_STRING) {
		const char* zName; int nLen;

		zName = php_value_to_string(pValue,&nLen);

		if (SyHashGet(&pVm->hFunction,(const void*)zName,(sxu32)nLen) != 0 ||
			SyHashGet(&pVm->hHostFunction,(const void*)zName,(sxu32)nLen) != 0) {

			res = 1;
		}
	}
	return res;
}

static int vm_builtin_is_callable(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm; int res;
	if (nArg < 1) {
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}
	pVm = pCtx->pVm;res = PHP_VmIsCallable(pVm,apArg[0],TRUE);php_result_bool(pCtx,res);return SXRET_OK;
}

static int VmHashFuncStep(SyHashEntry* pEntry,void* pUserData)
{
	php_value* pArray = (php_value*)pUserData;
	php_value sName;
	sxi32 rc;

	PHP_MemObjInitFromString(pArray->pVm,&sName,0);
	PHP_MemObjStringAppend(&sName,(const char*)pEntry->pKey,pEntry->nKeyLen);

	rc = php_array_add_elem(pArray,0,&sName);
	PHP_MemObjRelease(&sName);
	return rc;
}

static int vm_builtin_get_defined_func(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pEntry;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return SXRET_OK;
	}
	pEntry = php_context_new_array(pCtx);
	if (pEntry == 0) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	SyHashForEach(&pCtx->pVm->hHostFunction,VmHashFuncStep,pEntry);

	php_array_add_strkey_elem(pArray,"internal",pEntry);

	pEntry = php_context_new_array(pCtx);
	if (pEntry == 0) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	SyHashForEach(&pCtx->pVm->hFunction,VmHashFuncStep,pEntry);

	php_array_add_strkey_elem(pArray,"user",pEntry);

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}

static int vm_builtin_register_shutdown_function(php_context* pCtx,int nArg,php_value** apArg)
{
	VmShutdownCB sEntry; int i,j;
	if (nArg < 1 || (apArg[0]->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP)) == 0) {

		return PHP_OK;
	}

	SyZero(&sEntry,sizeof(VmShutdownCB));

	PHP_MemObjInit(pCtx->pVm,&sEntry.sCallback);

	PHP_MemObjStore(apArg[0],&sEntry.sCallback);
	for (i = 0; i < (int)SX_ARRAYSIZE(sEntry.aArg); ++i) {
		PHP_MemObjInit(pCtx->pVm,&sEntry.aArg[i]);
	}

	for (j = 0,i = 1; i < nArg; j++,i++) {
		if (j >= (int)SX_ARRAYSIZE(sEntry.aArg)) {

			break;
		}
		PHP_MemObjStore(apArg[i],&sEntry.aArg[j]);
	}
	sEntry.nArg = j;

	SySetPut(&pCtx->pVm->aShutdown,(const void*)&sEntry);
	return PHP_OK;
}


PHP_PRIVATE php_class* PHP_VmPeekTopClass(php_vm* pVm)
{
	SySet* pSet = &pVm->aSelf;
	php_class** apClass;
	if (SySetUsed(pSet) <= 0) {

		return 0;
	}

	apClass = (php_class**)SySetBasePtr(pSet);
	return apClass[pSet->nUsed - 1];
}

static int vm_builtin_get_class(php_context* pCtx,int nArg,php_value** apArg)
{
	php_class* pClass;
	SyString* pName;
	if (nArg < 1) {

		pClass = PHP_VmPeekTopClass(pCtx->pVm);
		if (pClass) {

			pName = &pClass->sName;
			php_result_string(pCtx,pName->zString,(int)pName->nByte);
		}
		else {

			php_result_bool(pCtx,0);
		}
	}
	else {

		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
		if (pClass) {
			pName = &pClass->sName;

			php_result_string(pCtx,pName->zString,(int)pName->nByte);
		}
		else {

			php_result_bool(pCtx,0);
		}
	}
	return PHP_OK;
}

static int vm_builtin_get_parent_class(php_context* pCtx,int nArg,php_value** apArg)
{
	php_class* pClass;
	SyString* pName;
	if (nArg < 1) {

		pClass = PHP_VmPeekTopClass(pCtx->pVm);
		if (pClass && pClass->pBase) {

			pName = &pClass->pBase->sName;
			php_result_string(pCtx,pName->zString,(int)pName->nByte);
		}
		else {

			php_result_bool(pCtx,0);
		}
	}
	else {

		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
		if (pClass) {
			if (pClass->pBase) {
				pName = &pClass->pBase->sName;

				php_result_string(pCtx,pName->zString,(int)pName->nByte);
			}
			else {

				php_result_bool(pCtx,0);
			}
		}
		else {

			php_result_bool(pCtx,0);
		}
	}
	return PHP_OK;
}

static int vm_builtin_get_called_class(php_context* pCtx,int nArg,php_value** apArg)
{
	php_class* pClass;

	pClass = PHP_VmPeekTopClass(pCtx->pVm);
	if (pClass) {
		SyString* pName;

		pName = &pClass->sName;
		php_result_string(pCtx,pName->zString,(int)pName->nByte);
	}
	else {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static php_class* VmExtractClassFromValue(php_vm* pVm,php_value* pArg)
{
	php_class* pClass = 0;
	if (php_value_is_object(pArg)) {

		pClass = ((php_class_instance*)pArg->x.pOther)->pClass;
	}
	else if (php_value_is_string(pArg)) {
		const char* zClass; int nLen;

		zClass = php_value_to_string(pArg,&nLen);
		if (nLen > 0) {
			SyHashEntry* pEntry;

			pEntry = SyHashGet(&pVm->hClass,(const void*)zClass,(sxu32)nLen);
			if (pEntry) {

				pClass = (php_class*)pEntry->pUserData;
			}
		}
	}
	return pClass;
}

static int vm_builtin_property_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 1) {
		php_class* pClass;
		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
		if (pClass) {
			const char* zName; int nLen;

			zName = php_value_to_string(apArg[1],&nLen);
			if (nLen > 0) {

				if (SyHashGet(&pClass->hAttr,(const void*)zName,(sxu32)nLen) != 0
					|| SyHashGet(&pClass->hMethod,(const void*)zName,(sxu32)nLen) != 0) {

					res = 1;
				}
			}
		}
	}
	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int vm_builtin_method_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 1) {
		php_class* pClass;
		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
		if (pClass) {
			const char* zName; int nLen;

			zName = php_value_to_string(apArg[1],&nLen);
			if (nLen > 0) {

				if (SyHashGet(&pClass->hMethod,(const void*)zName,(sxu32)nLen) != 0) {

					res = 1;
				}
			}
		}
	}
	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int vm_builtin_class_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		const char* zName; int nLen;

		zName = php_value_to_string(apArg[0],&nLen);

		if (nLen > 0 && SyHashGet(&pCtx->pVm->hClass,(const void*)zName,(sxu32)nLen) != 0) {

			res = 1;
		}
	}
	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int vm_builtin_interface_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		SyHashEntry* pEntry = 0;
		const char* zName; int nLen;

		zName = php_value_to_string(apArg[0],&nLen);

		if (nLen > 0) {
			pEntry = SyHashGet(&pCtx->pVm->hClass,(const void*)zName,(sxu32)nLen);
		}
		if (pEntry) {
			php_class* pClass = (php_class*)pEntry->pUserData;
			while (pClass) {
				if (pClass->iFlags & PHP_CLASS_INTERFACE) {

					res = 1;
					break;
				}

				pClass = pClass->pNextName;
			}
		}
	}
	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int vm_builtin_class_alias(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zOld,* zNew; int nOldLen,nNewLen;
	SyHashEntry* pEntry;
	php_class* pClass;
	char* zDup;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zOld = php_value_to_string(apArg[0],&nOldLen);

	zNew = php_value_to_string(apArg[1],&nNewLen);
	if (nNewLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = SyHashGet(&pCtx->pVm->hClass,(const void*)zOld,(sxu32)nOldLen);
	if (pEntry == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pClass = (php_class*)pEntry->pUserData;

	zDup = SyMemBackendStrDup(&pCtx->pVm->sAllocator,zNew,(sxu32)nNewLen);
	if (zDup == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = SyHashInsert(&pCtx->pVm->hClass,(const void*)zDup,(sxu32)nNewLen,pClass);
	if (rc != SXRET_OK) {
		SyMemBackendFree(&pCtx->pVm->sAllocator,zDup);
	}
	php_result_bool(pCtx,rc == SXRET_OK);
	return PHP_OK;
}

static int vm_builtin_get_declared_classes(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pName,* pArray;
	SyHashEntry* pEntry;

	pArray = php_context_new_array(pCtx);
	pName = php_context_new_scalar(pCtx);
	if (pArray == 0 || pName == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return PHP_OK;
	}

	SyHashResetLoopCursor(&pCtx->pVm->hClass);
	while ((pEntry = SyHashGetNextEntry(&pCtx->pVm->hClass)) != 0) {
		php_class* pClass = (php_class*)pEntry->pUserData;

		if ((pClass->iFlags & PHP_CLASS_INTERFACE) == 0) {
			php_value_string(pName,SyStringData(&pClass->sName),(int)SyStringLength(&pClass->sName));

			php_array_add_elem(pArray,0,pName);

			php_value_reset_string_cursor(pName);
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int vm_builtin_get_declared_interfaces(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pName,* pArray;
	SyHashEntry* pEntry;

	pArray = php_context_new_array(pCtx);
	pName = php_context_new_scalar(pCtx);
	if (pArray == 0 || pName == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return PHP_OK;
	}

	SyHashResetLoopCursor(&pCtx->pVm->hClass);
	while ((pEntry = SyHashGetNextEntry(&pCtx->pVm->hClass)) != 0) {
		php_class* pClass = (php_class*)pEntry->pUserData;

		if (pClass->iFlags & PHP_CLASS_INTERFACE) {
			php_value_string(pName,SyStringData(&pClass->sName),(int)SyStringLength(&pClass->sName));

			php_array_add_elem(pArray,0,pName);

			php_value_reset_string_cursor(pName);
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int vm_builtin_get_class_methods(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pName,* pArray;
	SyHashEntry* pEntry;
	php_class* pClass;

	pClass = 0;
	if (nArg > 0) {
		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
	}
	if (pClass == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pName = php_context_new_scalar(pCtx);
	if (pArray == 0 || pName == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	SyHashResetLoopCursor(&pClass->hMethod);
	while ((pEntry = SyHashGetNextEntry(&pClass->hMethod)) != 0) {
		php_class_method* pMethod = (php_class_method*)pEntry->pUserData;

		php_value_string(pName,SyStringData(&pMethod->sFunc.sName),(int)SyStringLength(&pMethod->sFunc.sName));
		php_array_add_elem(pArray,0,pName);

		php_value_reset_string_cursor(pName);
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int VmClassMemberAccess(
	php_vm* pVm,
	php_class* pClass,
	const SyString* pAttrName,
	sxi32 iProtection,
	int bLog
)
{
	if (iProtection != PHP_CLASS_PROT_PUBLIC) {
		VmFrame* pFrame = pVm->pFrame;
		php_vm_func* pVmFunc;
		while (pFrame->pParent && (pFrame->iFlags & (VM_FRAME_EXCEPTION | VM_FRAME_CATCH))) {

			pFrame = pFrame->pParent;
		}
		pVmFunc = (php_vm_func*)pFrame->pUserData;
		if (pVmFunc == 0 || (pVmFunc->iFlags & VM_FUNC_CLASS_METHOD) == 0) {
			goto dis;
		}
		if (iProtection == PHP_CLASS_PROT_PRIVATE) {

			if ((php_class*)pVmFunc->pUserData != pClass) {
				goto dis;
			}
		}
		else {

			php_class* pBase = (php_class*)pVmFunc->pUserData;

			if (!VmInstanceOf(pClass,pBase)) {
				goto dis;
			}
		}
	}
	return 1;
dis:
	if (bLog) {
		VmErrorFormat(&(*pVm),PHP_CTX_ERR,
			"Access to the class attribute '%z->%z' is forbidden",
			&pClass->sName,pAttrName);
	}
	return 0;
}

static int vm_builtin_get_class_vars(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pName,* pArray,sValue;
	SyHashEntry* pEntry;
	php_class* pClass;

	pClass = 0;
	if (nArg > 0) {
		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
	}
	if (pClass == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pName = php_context_new_scalar(pCtx);
	PHP_MemObjInit(pCtx->pVm,&sValue);
	if (pArray == 0 || pName == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	SyHashResetLoopCursor(&pClass->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pClass->hAttr)) != 0) {
		php_class_attr* pAttr = (php_class_attr*)pEntry->pUserData;

		if (VmClassMemberAccess(pCtx->pVm,pClass,&pAttr->sName,pAttr->iProtection,FALSE)) {
			SyString* pAttrName = &pAttr->sName;
			php_value* pValue = 0;
			if (pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) {

				pValue = (php_value*)SySetAt(&pCtx->pVm->aMemObj,pAttr->nIdx);
			}
			else {
				if (SySetUsed(&pAttr->aByteCode) > 0) {
					PHP_MemObjRelease(&sValue);

					VmLocalExec(pCtx->pVm,&pAttr->aByteCode,&sValue);
					pValue = &sValue;
				}
			}

			php_value_string(pName,pAttrName->zString,pAttrName->nByte);
			php_array_add_elem(pArray,pName,pValue);

			php_value_reset_string_cursor(pName);
		}
	}
	PHP_MemObjRelease(&sValue);

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int vm_builtin_get_object_vars(php_context* pCtx,int nArg,php_value** apArg)
{
	php_class_instance* pThis = 0;
	php_value* pName,* pArray;
	SyHashEntry* pEntry;
	if (nArg > 0 && (apArg[0]->iFlags & MEMOBJ_OBJ)) {

		pThis = (php_class_instance*)apArg[0]->x.pOther;
	}
	if (pThis == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pName = php_context_new_scalar(pCtx);
	if (pArray == 0 || pName == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	SyHashResetLoopCursor(&pThis->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {
		VmClassAttr* pVmAttr = (VmClassAttr*)pEntry->pUserData;
		SyString* pAttrName;
		if (pVmAttr->pAttr->iFlags & (PHP_CLASS_ATTR_STATIC | PHP_CLASS_ATTR_CONSTANT)) {

			continue;
		}
		pAttrName = &pVmAttr->pAttr->sName;

		if (VmClassMemberAccess(pCtx->pVm,pThis->pClass,pAttrName,pVmAttr->pAttr->iProtection,FALSE)) {
			php_value* pValue = 0;

			pValue = PHP_ClassInstanceExtractAttrValue(pThis,pVmAttr);
			if (pValue) {

				php_value_string(pName,pAttrName->zString,pAttrName->nByte);
				php_array_add_elem(pArray,pName,pValue);
			}

			php_value_reset_string_cursor(pName);
		}
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int VmQueryInterfaceSet(php_class* pClass,SySet* pSet)
{
	php_class** apInterface;
	sxu32 n;
	if (SySetUsed(pSet) < 1) {

		return FALSE;
	}

	apInterface = (php_class**)SySetBasePtr(pSet);

	for (n = 0; n < SySetUsed(pSet); n++) {
		if (apInterface[n] == pClass) {
			return TRUE;
		}
	}
	return FALSE;
}

static int VmInstanceOf(php_class* pThis,php_class* pClass)
{
	php_class* pParent;
	sxi32 rc;
	if (pThis == pClass) {

		return TRUE;
	}

	rc = VmQueryInterfaceSet(pClass,&pThis->aInterface);
	if (rc) {
		return TRUE;
	}

	pParent = pThis->pBase;
	while (pParent) {
		if (pParent == pClass) {

			return TRUE;
		}

		rc = VmQueryInterfaceSet(pClass,&pParent->aInterface);
		if (rc) {
			return TRUE;
		}

		pParent = pParent->pBase;
	}

	return FALSE;
}

static int VmSubclassOf(php_class* pClass,php_class* pBase)
{
	SySet* pInterface = &pClass->aInterface;
	SyHashEntry* pEntry;
	SyString* pName;
	sxi32 rc;
	while (pClass) {
		pName = &pClass->sName;

		pEntry = SyHashGet(&pBase->hDerived,(const void*)pName->zString,pName->nByte);
		if (pEntry) {
			return TRUE;
		}
		pClass = pClass->pBase;
	}
	rc = VmQueryInterfaceSet(pBase,pInterface);
	if (rc) {
		return TRUE;
	}

	return FALSE;
}

static int vm_builtin_is_a(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 1 && php_value_is_object(apArg[0])) {
		php_class_instance* pThis = (php_class_instance*)apArg[0]->x.pOther;
		php_class* pClass;

		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[1]);
		if (pClass) {

			res = VmInstanceOf(pThis->pClass,pClass);
		}
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int vm_builtin_is_subclass_of(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 1) {
		php_class* pClass,* pMain;

		pClass = VmExtractClassFromValue(pCtx->pVm,apArg[0]);
		pMain = VmExtractClassFromValue(pCtx->pVm,apArg[1]);
		if (pClass && pMain) {

			res = VmSubclassOf(pClass,pMain);
		}
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

PHP_PRIVATE sxi32 PHP_VmCallClassMethod(
	php_vm* pVm,
	php_class_instance* pThis,
	php_class_method* pMethod,
	php_value* pResult,
	int nArg,
	php_value** apArg
)
{
	php_value* aStack;
	VmInstr aInstr[2]; int iCursor; int i;

	aStack = VmNewOperandStack(&(*pVm),2 + nArg);
	if (aStack == 0) {
		PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
			"PHP is running out of memory while invoking class method");
		return SXERR_MEM;
	}

	for (i = 0; i < nArg; i++) {
		PHP_MemObjLoad(apArg[i],&aStack[i]);

		aStack[i].nIdx = apArg[i]->nIdx;
	}
	iCursor = nArg + 1;
	if (pThis) {

		pThis->iRef++;
		aStack[i].x.pOther = pThis;
		aStack[i].iFlags = MEMOBJ_OBJ;
	}
	aStack[i].nIdx = SXU32_HIGH;
	i++;

	SyBlobReset(&aStack[i].sBlob);
	SyBlobAppend(&aStack[i].sBlob,(const void*)SyStringData(&pMethod->sVmName),SyStringLength(&pMethod->sVmName));
	aStack[i].iFlags = MEMOBJ_STRING;
	aStack[i].nIdx = SXU32_HIGH;

	aInstr[0].iOp = PHP_OP_CALL;
	aInstr[0].iP1 = nArg;
	aInstr[0].iP2 = 0;
	aInstr[0].p3 = 0;

	aInstr[1].iOp = PHP_OP_DONE;
	aInstr[1].iP1 = 1;
	aInstr[1].iP2 = 0;
	aInstr[1].p3 = 0;

	VmByteCodeExec(&(*pVm),aInstr,aStack,iCursor,pResult,0,TRUE);

	SyMemBackendFree(&pVm->sAllocator,aStack);
	return PHP_OK;
}

PHP_PRIVATE sxi32 PHP_VmCallUserFunction(
	php_vm* pVm,
	php_value* pFunc,
	int nArg,
	php_value** apArg,
	php_value* pResult
)
{
	php_value* aStack;
	VmInstr aInstr[2]; int i;
	if ((pFunc->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP)) == 0) {

		if (pResult) {

			PHP_MemObjRelease(pResult);
		}
		return SXERR_INVALID;
	}
	if (pFunc->iFlags & MEMOBJ_HASHMAP) {

		php_hashmap* pMap = (php_hashmap*)pFunc->x.pOther;
		php_class_method* pMethod = 0;
		php_class_instance* pThis = 0;
		php_class* pClass = 0;
		php_value* pValue;
		sxi32 rc;
		if (pMap->nEntry < 2 ) {

			if (pResult) {

				PHP_MemObjRelease(pResult);
			}
			return SXRET_OK;
		}

		pValue = (php_value*)SySetAt(&pVm->aMemObj,pMap->pFirst->nValIdx);
		if (pValue) {
			pClass = VmExtractClassFromValue(&(*pVm),pValue);
		}
		if (pClass == 0) {

			if (pResult) {
				PHP_MemObjRelease(pResult);
			}
			return SXRET_OK;
		}
		if (pValue->iFlags & MEMOBJ_OBJ) {

			pThis = (php_class_instance*)pValue->x.pOther;
		}

		pValue = (php_value*)SySetAt(&pVm->aMemObj,pMap->pFirst->pPrev->nValIdx);
		if (pValue) {
			if ((pValue->iFlags & MEMOBJ_STRING) && SyBlobLength(&pValue->sBlob) > 0) {
				pMethod = PHP_ClassExtractMethod(pClass,(const char*)SyBlobData(&pValue->sBlob),
					SyBlobLength(&pValue->sBlob));
			}
		}
		if (pMethod == 0) {

			if (pResult) {
				PHP_MemObjRelease(pResult);
			}
			return SXRET_OK;
		}

		rc = PHP_VmCallClassMethod(&(*pVm),pThis,pMethod,pResult,nArg,apArg);
		return rc;
	}

	aStack = VmNewOperandStack(&(*pVm),1 + nArg);
	if (aStack == 0) {
		PHP_VmThrowError(&(*pVm),0,PHP_CTX_ERR,
			"PHP is running out of memory while invoking user callback");
		if (pResult) {

			PHP_MemObjRelease(pResult);
		}
		return SXERR_MEM;
	}

	for (i = 0; i < nArg; i++) {
		PHP_MemObjLoad(apArg[i],&aStack[i]);

		aStack[i].nIdx = apArg[i]->nIdx;
	}

	PHP_MemObjLoad(pFunc,&aStack[i]);
	aStack[i].nIdx = SXU32_HIGH;

	aInstr[0].iOp = PHP_OP_CALL;
	aInstr[0].iP1 = nArg;
	aInstr[0].iP2 = 0;
	aInstr[0].p3 = 0;

	aInstr[1].iOp = PHP_OP_DONE;
	aInstr[1].iP1 = 1;
	aInstr[1].iP2 = 0;
	aInstr[1].p3 = 0;

	VmByteCodeExec(&(*pVm),aInstr,aStack,nArg,pResult,0,TRUE);

	SyMemBackendFree(&pVm->sAllocator,aStack);
	return PHP_OK;
}

PHP_PRIVATE sxi32 PHP_VmCallUserFunctionAp(
	php_vm* pVm,
	php_value* pFunc,
	php_value* pResult,
	...
)
{
	php_value* pArg;
	SySet aArg;
	va_list ap;
	sxi32 rc;
	SySetInit(&aArg,&pVm->sAllocator,sizeof(php_value*));

	va_start(ap,pResult);
	for (;;) {
		pArg = va_arg(ap,php_value*);
		if (pArg == 0) {
			break;
		}
		SySetPut(&aArg,(const void*)&pArg);
	}

	rc = PHP_VmCallUserFunction(&(*pVm),pFunc,(int)SySetUsed(&aArg),(php_value**)SySetBasePtr(&aArg),pResult);

	SySetRelease(&aArg);
	return rc;
}

static int vm_builtin_call_user_func(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value sResult;
	sxi32 rc;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	PHP_MemObjInit(pCtx->pVm,&sResult);
	sResult.nIdx = SXU32_HIGH;

	rc = PHP_VmCallUserFunction(pCtx->pVm,apArg[0],nArg - 1,&apArg[1],&sResult);
	if (rc != SXRET_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_value(pCtx,&sResult);
	}
	PHP_MemObjRelease(&sResult);
	return PHP_OK;
}

static int vm_builtin_call_user_func_array(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_value* pValue,sResult;
	php_hashmap* pMap;
	SySet aArg;
	sxi32 rc;
	sxu32 n;
	if (nArg < 2 || !php_value_is_array(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	PHP_MemObjInit(pCtx->pVm,&sResult);
	sResult.nIdx = SXU32_HIGH;

	SySetInit(&aArg,&pCtx->pVm->sAllocator,sizeof(php_value*));

	pMap = (php_hashmap*)apArg[1]->x.pOther;
	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {

		if ((pValue = (php_value*)SySetAt(&pCtx->pVm->aMemObj,pEntry->nValIdx)) != 0) {
			SySetPut(&aArg,(const void*)&pValue);
		}

		pEntry = pEntry->pPrev;
	}

	rc = PHP_VmCallUserFunction(pCtx->pVm,apArg[0],(int)SySetUsed(&aArg),(php_value**)SySetBasePtr(&aArg),&sResult);
	if (rc != SXRET_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_value(pCtx,&sResult);
	}

	PHP_MemObjRelease(&sResult);
	SySetRelease(&aArg);
	return PHP_OK;
}

static int vm_builtin_defined(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zName; int nLen = 0; int res = 0;
	if (nArg < 1) {

		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Missing constant name");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	zName = php_value_to_string(apArg[0],&nLen);

	if (nLen > 0 && SyHashGet(&pCtx->pVm->hConstant,(const void*)zName,(sxu32)nLen) != 0) {

		res = 1;
	}
	php_result_bool(pCtx,res);
	return SXRET_OK;
}

static void VmExpandUserConstant(php_value* pVal,void* pUserData)
{
	php_value* pConstantValue = (php_value*)pUserData;

	PHP_MemObjStore(pConstantValue,pVal);
}

static int vm_builtin_define(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zName;
	php_value* pValue; int nLen = 0;
	sxi32 rc;
	if (nArg < 2) {

		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Missing constant name/value pair");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}
	if (!php_value_is_string(apArg[0])) {
		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Invalid constant name");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	zName = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {
		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Empty constant name");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	pValue = (php_value*)SyMemBackendPoolAlloc(&pCtx->pVm->sAllocator,sizeof(php_value));
	if (pValue == 0) {
		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Cannot register constant due to a memory failure");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	PHP_MemObjInit(pCtx->pVm,pValue);

	rc = php_create_constant(pCtx->pVm,zName,VmExpandUserConstant,pValue);
	if (rc != SXRET_OK) {
		SyMemBackendPoolFree(&pCtx->pVm->sAllocator,pValue);
		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Cannot register constant due to a memory failure");
		php_result_bool(pCtx,0);
		return SXRET_OK;
	}

	PHP_MemObjStore(apArg[1],pValue);
	if (nArg == 3 && php_value_is_bool(apArg[2]) && php_value_to_bool(apArg[2])) {

		char* zCur = (char*)zName;
		while (zCur < &zName[nLen]) {
			if ((unsigned char)zCur[0] >= 0xc0) {

				zCur++;
				while (zCur < &zName[nLen] && (((unsigned char)zCur[0] & 0xc0) == 0x80)) {
					zCur++;
				}
				continue;
			}
			if (SyisUpper(zCur[0])) {
				int c = SyToLower(zCur[0]);
				zCur[0] = (char)c;
			}
			zCur++;
		}

		php_create_constant(pCtx->pVm,zName,VmExpandUserConstant,pValue);
	}

	php_result_bool(pCtx,1);
	return SXRET_OK;
}

static int vm_builtin_constant(php_context* pCtx,int nArg,php_value** apArg)
{
	SyHashEntry* pEntry;
	php_constant* pCons;
	const char* zName;
	php_value sVal; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Missing/Invalid constant name");
		php_result_null(pCtx);
		return SXRET_OK;
	}

	zName = php_value_to_string(apArg[0],&nLen);

	pEntry = SyHashGet(&pCtx->pVm->hConstant,(const void*)zName,(sxu32)nLen);
	if (pEntry == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_NOTICE,"'%.*s': Undefined constant",nLen,zName);
		php_result_null(pCtx);
		return SXRET_OK;
	}
	PHP_MemObjInit(pCtx->pVm,&sVal);

	pCons = (php_constant*)SyHashEntryGetUserData(pEntry);

	pCons->xExpand(&sVal,pCons->pUserData);

	php_result_value(pCtx,&sVal);

	PHP_MemObjRelease(&sVal);
	return SXRET_OK;
}

static int VmHashConstStep(SyHashEntry* pEntry,void* pUserData)
{
	php_value* pArray = (php_value*)pUserData;
	php_value sName;
	sxi32 rc;

	PHP_MemObjInitFromString(pArray->pVm,&sName,0);
	PHP_MemObjStringAppend(&sName,(const char*)pEntry->pKey,pEntry->nKeyLen);

	rc = php_array_add_elem(pArray,0,&sName);
	PHP_MemObjRelease(&sName);
	return rc;
}

static int vm_builtin_get_defined_constants(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return SXRET_OK;
	}

	SyHashForEach(&pCtx->pVm->hConstant,VmHashConstStep,pArray);

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}


static void VmObRestore(php_vm* pVm,VmObEntry* pEntry);

static int vm_builtin_ob_clean(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	pOb = (VmObEntry*)SySetPeek(&pVm->aOB);
	if (pOb) {
		SyBlobRelease(&pOb->sOB);
	}
	return PHP_OK;
}

static int vm_builtin_ob_end_clean(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;

	pOb = (VmObEntry*)SySetPop(&pVm->aOB);
	if (pOb == 0) {

		php_result_bool(pCtx,0);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
	}
	else {

		VmObRestore(pVm,pOb);

		php_result_bool(pCtx,1);
	}
	return PHP_OK;
}

static int vm_builtin_ob_get_contents(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;

	pOb = (VmObEntry*)SySetPeek(&pVm->aOB);
	if (pOb == 0) {

		php_result_bool(pCtx,0);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
	}
	else {

		php_result_string(pCtx,(const char*)SyBlobData(&pOb->sOB),(int)SyBlobLength(&pOb->sOB));
	}
	return PHP_OK;
}

static int vm_builtin_ob_get_clean(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;

	pOb = (VmObEntry*)SySetPop(&pVm->aOB);
	if (pOb == 0) {

		php_result_bool(pCtx,0);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
	}
	else {

		php_result_string(pCtx,(const char*)SyBlobData(&pOb->sOB),(int)SyBlobLength(&pOb->sOB));

		VmObRestore(pVm,pOb);
	}
	return PHP_OK;
}

static int vm_builtin_ob_get_length(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;

	pOb = (VmObEntry*)SySetPeek(&pVm->aOB);
	if (pOb == 0) {

		php_result_bool(pCtx,0);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
	}
	else {

		php_result_int64(pCtx,(php_int64)SyBlobLength(&pOb->sOB));
	}
	return PHP_OK;
}

static int vm_builtin_ob_get_level(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm; int iNest;
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	iNest = (int)SySetUsed(&pVm->aOB);

	php_result_int(pCtx,iNest);
	return PHP_OK;
}

static int VmObConsumer(const void* pData,unsigned int nDataLen,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	VmObEntry* pEntry;
	php_value sResult;

	pEntry = (VmObEntry*)SySetPeek(&pVm->aOB);
	if (pEntry == 0) {

		return PHP_OK;
	}
	PHP_MemObjInit(pVm,&sResult);
	if (php_value_is_callable(&pEntry->sCallback) && pVm->nObDepth < 15) {
		php_value sArg,* apArg[2];

		PHP_MemObjInitFromString(pVm,&sArg,0);
		PHP_MemObjStringAppend(&sArg,(const char*)pData,nDataLen);
		apArg[0] = &sArg;

		pVm->nObDepth++;
		PHP_VmCallUserFunction(pVm,&pEntry->sCallback,1,apArg,&sResult);
		pVm->nObDepth--;
		if (sResult.iFlags & MEMOBJ_STRING) {

			pData = SyBlobData(&sResult.sBlob);
			nDataLen = SyBlobLength(&sResult.sBlob);
		}
		PHP_MemObjRelease(&sArg);
	}
	if (nDataLen > 0) {

		SyBlobAppend(&pEntry->sOB,pData,nDataLen);
	}

	PHP_MemObjRelease(&sResult);
	return PHP_OK;
}

static void VmObRestore(php_vm* pVm,VmObEntry* pEntry)
{
	php_output_consumer* pCons = &pVm->sVmConsumer;
	if (SySetUsed(&pVm->aOB) < 1) {

		pCons->xConsumer = pCons->xDef;
		pCons->pUserData = pCons->pDefData;
	}

	PHP_MemObjRelease(&pEntry->sCallback);
	SyBlobRelease(&pEntry->sOB);
}

static int vm_builtin_ob_start(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry sOb;
	sxi32 rc;

	PHP_MemObjInit(pCtx->pVm,&sOb.sCallback);
	SyBlobInit(&sOb.sOB,&pVm->sAllocator);
	if (nArg > 0 && (apArg[0]->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP))) {

		PHP_MemObjStore(apArg[0],&sOb.sCallback);
	}

	rc = SySetPut(&pVm->aOB,(const void*)&sOb);
	if (rc != SXRET_OK) {
		PHP_MemObjRelease(&sOb.sCallback);
	}
	else {
		php_output_consumer* pCons = &pVm->sVmConsumer;

		if (pCons->xConsumer != VmObConsumer) {
			pCons->xDef = pCons->xConsumer;
			pCons->pDefData = pCons->pUserData;

			pCons->xConsumer = VmObConsumer;
			pCons->pUserData = pVm;
		}
	}
	php_result_bool(pCtx,rc == SXRET_OK);
	return PHP_OK;
}

static sxi32 VmObFlush(php_vm* pVm,VmObEntry* pEntry,int bRelease)
{
	SyBlob* pBlob = &pEntry->sOB;
	sxi32 rc;

	rc = PHP_OK;
	if (SyBlobLength(pBlob) > 0) {

		rc = pVm->sVmConsumer.xDef(SyBlobData(pBlob),SyBlobLength(pBlob),pVm->sVmConsumer.pDefData);

		pVm->nOutputLen += SyBlobLength(pBlob);
		if (rc != PHP_ABORT) {
			rc = PHP_OK;
		}
	}
	if (bRelease) {
		VmObRestore(&(*pVm),pEntry);
	}
	else {

		SyBlobReset(pBlob);
	}
	return rc;
}

static int vm_builtin_ob_flush(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;
	sxi32 rc;

	pOb = (VmObEntry*)SySetPeek(&pVm->aOB);
	if (pOb == 0) {

		SXUNUSED(nArg);
		SXUNUSED(apArg);
		return PHP_OK;
	}

	rc = VmObFlush(pVm,pOb,FALSE);
	return rc;
}

static int vm_builtin_ob_end_flush(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	VmObEntry* pOb;
	sxi32 rc;

	pOb = (VmObEntry*)SySetPop(&pVm->aOB);
	if (pOb == 0) {

		php_result_bool(pCtx,0);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
		return PHP_OK;
	}

	rc = VmObFlush(pVm,pOb,TRUE);

	php_result_bool(pCtx,1);
	return rc;
}

static int vm_builtin_ob_implicit_flush(php_context* pCtx,int nArg,php_value** apArg)
{

	SXUNUSED(pCtx);
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	return PHP_OK;
}

static int vm_builtin_ob_list_handlers(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pArray;
	VmObEntry* aEntry;
	php_value sVal;
	sxu32 n;
	if (SySetUsed(&pVm->aOB) < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {

		SXUNUSED(nArg);
		SXUNUSED(apArg);
		php_result_null(pCtx);
		return PHP_OK;
	}
	PHP_MemObjInit(pVm,&sVal);

	aEntry = (VmObEntry*)SySetBasePtr(&pVm->aOB);

	for (n = 0; n < SySetUsed(&pVm->aOB); n++) {
		VmObEntry* pEntry = &aEntry[n];

		SyBlobReset(&sVal.sBlob);
		if (pEntry->sCallback.iFlags & MEMOBJ_STRING) {

			SyBlobDup(&pEntry->sCallback.sBlob,&sVal.sBlob);
		}
		else if (pEntry->sCallback.iFlags & MEMOBJ_HASHMAP) {
			SyBlobAppend(&sVal.sBlob,"Class Method",sizeof("Class Method") - 1);
		}
		else {
			SyBlobAppend(&sVal.sBlob,"default output handler",sizeof("default output handler") - 1);
		}
		sVal.iFlags = MEMOBJ_STRING;

		php_array_add_elem(pArray,0,&sVal );
	}
	PHP_MemObjRelease(&sVal);

	php_result_value(pCtx,pArray);
	return PHP_OK;
}


PHP_PRIVATE sxu32 PHP_VmRandomNum(php_vm* pVm)
{
	sxu32 iNum;
	SyRandomness(&pVm->sPrng,(void*)&iNum,sizeof(sxu32));
	return iNum;
}

PHP_PRIVATE void PHP_VmRandomString(php_vm* pVm,char* zBuf,int nLen)
{
	static const char zBase[] = { "abcdefghijklmnopqrstuvwxyz" }; int i;

	SyRandomness(&pVm->sPrng,zBuf,(sxu32)nLen);

	for (i = 0; i < nLen; ++i) {
		zBuf[i] = zBase[zBuf[i] % (sizeof(zBase) - 1)];
	}
}

static int vm_builtin_rand(php_context* pCtx,int nArg,php_value** apArg)
{
	sxu32 iNum;

	iNum = PHP_VmRandomNum(pCtx->pVm);
	if (nArg > 1) {
		sxu32 iMin,iMax;
		iMin = (sxu32)php_value_to_int(apArg[0]);
		iMax = (sxu32)php_value_to_int(apArg[1]);
		if (iMin < iMax) {
			sxu32 iDiv = iMax + 1 - iMin;
			if (iDiv > 0) {
				iNum = (iNum % iDiv) + iMin;
			}
		}
		else if (iMax > 0) {
			iNum %= iMax;
		}
	}

	php_result_int64(pCtx,(php_int64)iNum);
	return SXRET_OK;
}

static int vm_builtin_getrandmax(php_context* pCtx,int nArg,php_value** apArg)
{
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	php_result_int64(pCtx,SXU32_HIGH);
	return SXRET_OK;
}

static int vm_builtin_rand_str(php_context* pCtx,int nArg,php_value** apArg)
{
	char zString[1024]; int iLen = 0x10;
	if (nArg > 0) {

		iLen = php_value_to_int(apArg[0]);
		if (iLen < 1 || iLen > 1024) {

			iLen = 0x10;
		}
	}

	PHP_VmRandomString(pCtx->pVm,zString,iLen);

	php_result_string(pCtx,zString,iLen);
	return SXRET_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
#if !defined(PHP_DISABLE_HASH_FUNC)

struct unique_id_data
{
	php_context* pCtx; int entropy;
};

static int HexConsumer(const void* pData,unsigned int nLen,void* pUserData)
{
	struct unique_id_data* pUniq = (struct unique_id_data*)pUserData;
	sxu32 nBuflen;

	nBuflen = php_context_result_buf_length(pUniq->pCtx);
	if (nBuflen > 12 && !pUniq->entropy) {

		return SXERR_ABORT;
	}
	if (nBuflen > 22) {
		return SXERR_ABORT;
	}

	php_result_string(pUniq->pCtx,(const char*)pData,(int)nLen);
	return SXRET_OK;
}

static int vm_builtin_uniqid(php_context* pCtx,int nArg,php_value** apArg)
{
	struct unique_id_data sUniq;
	unsigned char zDigest[20];
	php_vm* pVm = pCtx->pVm;
	const char* zPrefix;
	SHA1Context sCtx;
	char zRandom[7]; int nPrefix; int entropy;

	PHP_VmRandomString(pVm,zRandom,(int)sizeof(zRandom));

	zPrefix = 0;
	nPrefix = 0;
	entropy = 0;
	if (nArg > 0) {

		zPrefix = php_value_to_string(apArg[0],&nPrefix);
		if (nArg > 1) {
			entropy = php_value_to_bool(apArg[1]);
		}
	}
	SHA1Init(&sCtx);

	if (nPrefix > 0) {
		SHA1Update(&sCtx,(const unsigned char*)zPrefix,(unsigned int)nPrefix);
	}

	SHA1Update(&sCtx,(const unsigned char*)&pVm->unique_id,sizeof(int));

	SHA1Update(&sCtx,(const unsigned char*)zRandom,sizeof(zRandom));

	pVm->unique_id++;
	SHA1Final(&sCtx,zDigest);

	sUniq.pCtx = pCtx;
	sUniq.entropy = entropy;
	SyBinToHexConsumer((const void*)zDigest,sizeof(zDigest),HexConsumer,&sUniq);

	return PHP_OK;
}
#endif
#endif


static int vm_builtin_echo(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zData; int nDataLen = 0;
	php_vm* pVm; int i,rc;

	pVm = pCtx->pVm;

	for (i = 0; i < nArg; ++i) {
		zData = php_value_to_string(apArg[i],&nDataLen);
		if (nDataLen > 0) {
			rc = pVm->sVmConsumer.xConsumer((const void*)zData,(unsigned int)nDataLen,pVm->sVmConsumer.pUserData);
			if (pVm->sVmConsumer.xConsumer != VmObConsumer) {

				pVm->nOutputLen += nDataLen;
			}
			if (rc == SXERR_ABORT) {

				return PHP_ABORT;
			}
		}
	}
	return SXRET_OK;
}

static int vm_builtin_print(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zData; int nDataLen = 0;
	php_vm* pVm; int i,rc;

	pVm = pCtx->pVm;

	for (i = 0; i < nArg; ++i) {
		zData = php_value_to_string(apArg[i],&nDataLen);
		if (nDataLen > 0) {
			rc = pVm->sVmConsumer.xConsumer((const void*)zData,(unsigned int)nDataLen,pVm->sVmConsumer.pUserData);
			if (pVm->sVmConsumer.xConsumer != VmObConsumer) {

				pVm->nOutputLen += nDataLen;
			}
			if (rc == SXERR_ABORT) {

				return PHP_ABORT;
			}
		}
	}

	php_result_int(pCtx,1);
	return SXRET_OK;
}

static int vm_builtin_exit(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg > 0) {
		if (php_value_is_string(apArg[0])) {
			const char* zData; int iLen = 0;

			zData = php_value_to_string(apArg[0],&iLen);
			php_context_output(pCtx,zData,iLen);
		}
		else if (php_value_is_int(apArg[0])) {
			sxi32 iExitStatus;

			iExitStatus = php_value_to_int(apArg[0]);
			pCtx->pVm->iExitStatus = iExitStatus;
		}
	}

	return PHP_ABORT;
}

static int vm_builtin_isset(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pObj; int res = 0; int i;
	if (nArg < 1) {

		php_result_bool(pCtx,res);
		return SXRET_OK;
	}

	for (i = 0; i < nArg; ++i) {
		pObj = apArg[i];
		if (pObj->nIdx == SXU32_HIGH) {
			if ((pObj->iFlags & MEMOBJ_NULL) == 0) {

				php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a variable not a constant");
			}
		}
		res = (pObj->iFlags & MEMOBJ_NULL) ? 0 : 1;
		if (!res) {

			php_result_bool(pCtx,0);
			return SXRET_OK;
		}
	}

	php_result_bool(pCtx,1);
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmUnsetMemObj(php_vm* pVm,sxu32 nObjIdx,int bForce)
{
	php_value* pObj;
	VmRefObj* pRef;
	pObj = (php_value*)SySetAt(&pVm->aMemObj,nObjIdx);
	if (pObj) {

		PHP_MemObjRelease(pObj);
	}

	pRef = VmRefObjExtract(&(*pVm),nObjIdx);
	if (pRef) {
		sxi32 iFlags = pRef->iFlags;

		VmRefObjUnlink(&(*pVm),pRef);
		if ((bForce == TRUE) || (iFlags & VM_REF_IDX_KEEP) == 0) {
			VmSlot sFree;

			sFree.nIdx = nObjIdx;
			sFree.pUserData = 0;
			SySetPut(&pVm->aFreeObj,(const void*)&sFree);
		}
	}
	return SXRET_OK;
}

static int vm_builtin_unset(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pObj;
	php_vm* pVm; int i;

	pVm = pCtx->pVm;

	for (i = 0; i < nArg; ++i) {
		pObj = apArg[i];
		if (pObj->nIdx == SXU32_HIGH) {
			if ((pObj->iFlags & MEMOBJ_NULL) == 0) {

				php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a variable not a constant");
			}
		}
		else {
			sxu32 nIdx = pObj->nIdx;

			if (nIdx != pVm->nGlobalIdx) {
				PHP_VmUnsetMemObj(&(*pVm),nIdx,FALSE);
			}
		}
	}
	return SXRET_OK;
}

static sxi32 VmHashVarWalker(SyHashEntry* pEntry,void* pUserData)
{
	php_value* pArray = (php_value*)pUserData;
	php_vm* pVm = pArray->pVm;
	php_value* pObj;
	sxu32 nIdx;

	nIdx = SX_PTR_TO_INT(pEntry->pUserData);
	pObj = (php_value*)SySetAt(&pVm->aMemObj,nIdx);
	if (pObj) {
		if ((pObj->iFlags & MEMOBJ_HASHMAP) == 0 || (php_hashmap*)pObj->x.pOther != pVm->pGlobal) {
			if (pEntry->nKeyLen > 0) {
				SyString sName;
				php_value sKey;

				SyStringInitFromBuf(&sName,pEntry->pKey,pEntry->nKeyLen);
				PHP_MemObjInitFromString(pVm,&sKey,&sName);
				php_array_add_elem(pArray,&sKey,pObj);
				PHP_MemObjRelease(&sKey);
			}
		}
	}
	return SXRET_OK;
}

static int vm_builtin_get_defined_vars(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pArray;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return SXRET_OK;
	}

	SyHashForEach(&pVm->hSuper,VmHashVarWalker,pArray);

	SyHashForEach(&pVm->pFrame->hVar,VmHashVarWalker,pArray);

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}

static int vm_builtin_gettype(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zType = "Empty";
	if (nArg > 0) {
		zType = PHP_MemObjTypeDump(apArg[0]);
	}

	php_result_string(pCtx,zType,-1);
	return SXRET_OK;
}

static int vm_builtin_get_resource_type(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	php_result_string_format(pCtx,"resID_%#x",apArg[0]->x.pOther);
	return SXRET_OK;
}

static int vm_builtin_var_dump(php_context* pCtx,int nArg,php_value** apArg)
{
	SyBlob sDump; int i;
	SyBlobInit(&sDump,&pCtx->pVm->sAllocator);

	for (i = 0; i < nArg; i++) {
		php_value* pObj = apArg[i];

		SyBlobReset(&sDump);

		PHP_MemObjDump(&sDump,pObj,TRUE,0,0,0);

		if (SyBlobLength(&sDump) > 0) {
			php_context_output(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));
		}
	}

	SyBlobRelease(&sDump);
	return SXRET_OK;
}

static int vm_builtin_print_r(php_context* pCtx,int nArg,php_value** apArg)
{
	int ret_string = 0;
	SyBlob sDump;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return SXRET_OK;
	}
	SyBlobInit(&sDump,&pCtx->pVm->sAllocator);
	if (nArg > 1) {

		ret_string = php_value_to_bool(apArg[1]);
	}

	PHP_MemObjDump(&sDump,apArg[0],FALSE,0,0,0);
	if (!ret_string) {

		php_context_output(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));

		php_result_bool(pCtx,1);
	}
	else {

		php_result_string(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));
	}

	SyBlobRelease(&sDump);
	return SXRET_OK;
}

static int vm_builtin_var_export(php_context* pCtx,int nArg,php_value** apArg)
{
	int ret_string = 0;
	SyBlob sDump;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return SXRET_OK;
	}
	SyBlobInit(&sDump,&pCtx->pVm->sAllocator);
	if (nArg > 1) {

		ret_string = php_value_to_bool(apArg[1]);
	}

	PHP_MemObjDump(&sDump,apArg[0],FALSE,0,0,0);
	if (!ret_string) {

		php_context_output(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));

		php_result_null(pCtx);
	}
	else {

		php_result_string(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));
	}

	SyBlobRelease(&sDump);
	return SXRET_OK;
}

static int vm_builtin_assert_options(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm; int iOld,iNew,iValue;
	if (nArg < 1 || !php_value_is_int(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	iOld = pVm->iAssertFlags;

	iNew = php_value_to_int(apArg[0]);
	if (iNew == PHP_ASSERT_DISABLE) {
		pVm->iAssertFlags &= ~PHP_ASSERT_DISABLE;
		if (nArg > 1) {
			iValue = !php_value_to_bool(apArg[1]);
			if (iValue) {

				pVm->iAssertFlags |= PHP_ASSERT_DISABLE;
			}
		}
	}
	else if (iNew == PHP_ASSERT_WARNING) {
		pVm->iAssertFlags &= ~PHP_ASSERT_WARNING;
		if (nArg > 1) {
			iValue = php_value_to_bool(apArg[1]);
			if (iValue) {

				pVm->iAssertFlags |= PHP_ASSERT_WARNING;
			}
		}
	}
	else if (iNew == PHP_ASSERT_BAIL) {
		pVm->iAssertFlags &= ~PHP_ASSERT_BAIL;
		if (nArg > 1) {
			iValue = php_value_to_bool(apArg[1]);
			if (iValue) {

				pVm->iAssertFlags |= PHP_ASSERT_BAIL;
			}
		}
	}
	else if (iNew == PHP_ASSERT_CALLBACK) {
		pVm->iAssertFlags &= ~PHP_ASSERT_CALLBACK;
		if (nArg > 1 && php_value_is_callable(apArg[1])) {

			PHP_MemObjStore(apArg[1],&pVm->sAssertCallback);
			pVm->iAssertFlags |= PHP_ASSERT_CALLBACK;
		}
	}

	php_result_int(pCtx,iOld);
	return PHP_OK;
}

static int vm_builtin_assert(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pAssert; int iFlags,iResult;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	iFlags = pVm->iAssertFlags;
	if (iFlags & PHP_ASSERT_DISABLE) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pAssert = apArg[0];
	iResult = 1;
	if (pAssert->iFlags & MEMOBJ_STRING) {
		SyString sChunk;
		SyStringInitFromBuf(&sChunk,SyBlobData(&pAssert->sBlob),SyBlobLength(&pAssert->sBlob));
		if (sChunk.nByte > 0) {
			VmEvalChunk(pVm,pCtx,&sChunk,PHP_PHP_ONLY | PHP_PHP_EXPR,FALSE);

			iResult = php_value_to_bool(pCtx->pRet);
		}
		else {
			iResult = 0;
		}
	}
	else {

		iResult = php_value_to_bool(apArg[0]);
	}
	if (!iResult) {

		if (iFlags & PHP_ASSERT_CALLBACK) {
			static const SyString sFileName = { ":Memory",sizeof(":Memory") - 1 };
			php_value sFile,sLine;
			php_value* apCbArg[3];
			SyString* pFile;

			pFile = (SyString*)SySetPeek(&pVm->aFiles);
			if (pFile == 0) {
				pFile = (SyString*)&sFileName;
			}

			PHP_MemObjInitFromString(pVm,&sFile,pFile);
			PHP_MemObjInitFromInt(pVm,&sLine,0);
			apCbArg[0] = &sFile;
			apCbArg[1] = &sLine;
			apCbArg[2] = pAssert;
			PHP_VmCallUserFunction(pVm,&pVm->sAssertCallback,3,apCbArg,0);

			PHP_MemObjRelease(&sFile);
			PHP_MemObjRelease(&sLine);
		}
		if (iFlags & PHP_ASSERT_WARNING) {

			php_context_throw_error(pCtx,PHP_CTX_WARNING,"Assertion failed");
		}
		if (iFlags & PHP_ASSERT_BAIL) {

			return PHP_ABORT;
		}
	}

	php_result_bool(pCtx,iResult);
	return PHP_OK;
}


static int vm_builtin_trigger_error(php_context* pCtx,int nArg,php_value** apArg)
{
	int nErr = PHP_CTX_NOTICE; int rc = PHP_OK;
	if (nArg > 0) {
		const char* zErr; int nLen;

		zErr = php_value_to_string(apArg[0],&nLen);
		if (nArg > 1) {

			nErr = php_value_to_int(apArg[1]);
			switch (nErr) {
			case 1:
			case 16:
			case 64:
			case 256:
				nErr = PHP_CTX_ERR;
				rc = PHP_ABORT;
				break;
			case 2:
			case 32:
			case 123:
			case 512:
				nErr = PHP_CTX_WARNING;
				break;
			default:
				nErr = PHP_CTX_NOTICE;
				break;
			}
		}

		php_context_throw_error_format(pCtx,nErr,"%.*s",nLen,zErr);

		php_result_bool(pCtx,1);
	}
	else {

		php_result_bool(pCtx,0);
	}
	return rc;
}

static int vm_builtin_error_reporting(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm; int nOld;

	nOld = pVm->bErrReport ? 32767  : 0;
	if (nArg > 0) {
		int nNew;

		nNew = php_value_to_int(apArg[0]);
		if (!nNew) {

			pVm->bErrReport = 0;
		}
		else {

			pVm->bErrReport = 1;
		}
	}

	php_result_int(pCtx,nOld);
	return PHP_OK;
}

static int vm_builtin_error_log(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zMessage,* zDest,* zHeader;
	php_vm* pVm = pCtx->pVm; int iType = 0;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (pVm->xErrLog) {

		zMessage = php_value_to_string(apArg[0],0);
		zDest = zHeader = "";
		if (nArg > 1) {
			iType = php_value_to_int(apArg[1]);
			if (nArg > 2) {
				zDest = php_value_to_string(apArg[2],0);
				if (nArg > 3) {
					zHeader = php_value_to_string(apArg[3],0);
				}
			}
		}
		pVm->xErrLog(zMessage,iType,zDest,zHeader);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_restore_exception_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pOld,* pNew;

	pOld = &pVm->aExceptionCB[0];
	pNew = &pVm->aExceptionCB[1];
	if (pOld->iFlags & MEMOBJ_NULL) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	PHP_MemObjStore(pOld,pNew);
	PHP_MemObjRelease(pOld);

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_set_exception_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pOld,* pNew;

	pOld = &pVm->aExceptionCB[0];
	pNew = &pVm->aExceptionCB[1];

	php_result_value(pCtx,pOld);
	if (nArg > 0) {
		if (!php_value_is_callable(apArg[0])) {

			PHP_MemObjRelease(pNew);
			php_result_bool(pCtx,1);
		}
		else {
			PHP_MemObjStore(pNew,pOld);

			PHP_MemObjStore(apArg[0],pNew);
		}
	}
	return PHP_OK;
}

static int vm_builtin_restore_error_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pOld,* pNew;

	pOld = &pVm->aErrCB[0];
	pNew = &pVm->aErrCB[1];
	if (pOld->iFlags & MEMOBJ_NULL) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	PHP_MemObjStore(pOld,pNew);
	PHP_MemObjRelease(pOld);

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_set_error_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pOld,* pNew;

	pOld = &pVm->aErrCB[0];
	pNew = &pVm->aErrCB[1];

	php_result_value(pCtx,pOld);
	if (nArg > 0) {
		if (!php_value_is_callable(apArg[0])) {

			PHP_MemObjRelease(pNew);
			php_result_bool(pCtx,1);
		}
		else {
			PHP_MemObjStore(pNew,pOld);

			PHP_MemObjStore(apArg[0],pNew);
		}
	}
	php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
		"This function is disabled in the current release of the PHP(%s) engine",
		php_lib_version()
	);
	return PHP_OK;
}

static int vm_builtin_debug_backtrace(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	php_value* pArray;
	php_class* pClass;
	php_value* pValue;
	SyString* pFile;

	pArray = php_context_new_array(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pValue == 0) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_null(pCtx);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
		return PHP_OK;
	}

	if (pVm->pFrame->pParent) {
		VmFrame* pFrame = pVm->pFrame;
		php_vm_func* pFunc;
		php_value* pArg;
		while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

			pFrame = pFrame->pParent;
		}
		pFunc = (php_vm_func*)pFrame->pUserData;
		if (pFrame->pParent && pFunc) {
			php_value_string(pValue,pFunc->sName.zString,(int)pFunc->sName.nByte);
			php_array_add_strkey_elem(pArray,"function",pValue);
			php_value_reset_string_cursor(pValue);
		}

		pArg = php_context_new_array(pCtx);
		if (pArg) {
			php_value* pObj;
			VmSlot* aSlot;
			sxu32 n;

			aSlot = (VmSlot*)SySetBasePtr(&pFrame->sArg);
			for (n = 0; n < SySetUsed(&pFrame->sArg); n++) {
				pObj = (php_value*)SySetAt(&pCtx->pVm->aMemObj,aSlot[n].nIdx);
				if (pObj) {
					php_array_add_elem(pArg,0,pObj);
				}
			}

			php_array_add_strkey_elem(pArray,"args",pArg);
		}
	}
	php_value_int(pValue,1);

	php_array_add_strkey_elem(pArray,"line",pValue);

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile) {
		php_value_string(pValue,pFile->zString,(int)pFile->nByte);
		php_array_add_strkey_elem(pArray,"file",pValue);
		php_value_reset_string_cursor(pValue);
	}

	pClass = PHP_VmPeekTopClass(pVm);
	if (pClass) {
		php_value_reset_string_cursor(pValue);
		php_value_string(pValue,pClass->sName.zString,(int)pClass->sName.nByte);
		php_array_add_strkey_elem(pArray,"class",pValue);
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int VmMiniBacktrace(
	php_vm* pVm,
	SyBlob* pOut
)
{
	VmFrame* pFrame = pVm->pFrame;
	php_vm_func* pFunc;
	php_class* pClass;
	SyString* pFile;

	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	pFunc = (php_vm_func*)pFrame->pUserData;
	SyBlobAppend(pOut,"[",sizeof(char));
	if (pFrame->pParent && pFunc) {
		SyBlobAppend(pOut,"Called function: ",sizeof("Called function: ") - 1);
		SyBlobAppend(pOut,pFunc->sName.zString,pFunc->sName.nByte);
	}
	else {
		SyBlobAppend(pOut,"Global scope",sizeof("Global scope") - 1);
	}
	SyBlobAppend(pOut,"]",sizeof(char));

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile) {
		SyBlobAppend(pOut,"[",sizeof(char));
		SyBlobAppend(pOut,"Processed file: ",sizeof("Processed file: ") - 1);
		SyBlobAppend(pOut,pFile->zString,pFile->nByte);
		SyBlobAppend(pOut,"]",sizeof(char));
	}

	pClass = PHP_VmPeekTopClass(pVm);
	if (pClass) {
		SyBlobAppend(pOut,"[",sizeof(char));
		SyBlobAppend(pOut,"Class: ",sizeof("Class: ") - 1);
		SyBlobAppend(pOut,pClass->sName.zString,pClass->sName.nByte);
		SyBlobAppend(pOut,"]",sizeof(char));
	}
	SyBlobAppend(pOut,"\n",sizeof(char));

	return SXRET_OK;
}

static int vm_builtin_debug_print_backtrace(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	SyBlob sDump;
	SyBlobInit(&sDump,&pVm->sAllocator);

	VmMiniBacktrace(pVm,&sDump);

	php_context_output(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));

	SyBlobRelease(&sDump);
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	return PHP_OK;
}

static int vm_builtin_debug_string_backtrace(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	SyBlob sDump;
	SyBlobInit(&sDump,&pVm->sAllocator);

	VmMiniBacktrace(pVm,&sDump);

	php_result_string(pCtx,(const char*)SyBlobData(&sDump),(int)SyBlobLength(&sDump));

	SyBlobRelease(&sDump);
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	return PHP_OK;
}

static sxi32 VmUncaughtException(
	php_vm* pVm,
	php_class_instance* pThis
)
{
	php_value* apArg[2],sArg; int nArg = 1;
	sxi32 rc;
	if (pVm->nExceptDepth > 15) {

		return SXRET_OK;
	}

	PHP_MemObjInit(pVm,&sArg);
	if (pThis) {

		sArg.x.pOther = pThis;
		pThis->iRef++;
		MemObjSetType(&sArg,MEMOBJ_OBJ);
	}
	else {
		nArg = 0;
	}
	apArg[0] = &sArg;

	pVm->nExceptDepth++;
	rc = PHP_VmCallUserFunction(&(*pVm),&pVm->aExceptionCB[1],1,apArg,0);
	pVm->nExceptDepth--;
	if (rc != SXRET_OK) {
		SyString sName = { "Exception" ,sizeof("Exception") - 1 };
		SyString sFuncName = { "Global",sizeof("Global") - 1 };
		VmFrame* pFrame = pVm->pFrame;

		if (pThis) {
			SyStringDupPtr(&sName,&pThis->pClass->sName);
		}
		while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

			pFrame = pFrame->pParent;
		}
		if (pFrame->pParent) {
			if (pFrame->iFlags & VM_FRAME_CATCH) {
				SyStringInitFromBuf(&sFuncName,"Catch_block",sizeof("Catch_block") - 1);
			}
			else {
				php_vm_func* pFunc = (php_vm_func*)pFrame->pUserData;
				if (pFunc) {
					SyStringDupPtr(&sFuncName,&pFunc->sName);
				}
			}
		}

		VmErrorFormat(&(*pVm),PHP_CTX_ERR,
			"Uncaught exception '%z' in the '%z' frame context",
			&sName,&sFuncName);

		rc = SXERR_ABORT;
	}
	PHP_MemObjRelease(&sArg);
	return rc;
}

static sxi32 VmThrowException(
	php_vm* pVm,
	php_class_instance* pThis
)
{
	php_exception_block* pCatch;
	php_exception** apException;
	php_exception* pException;

	apException = (php_exception**)SySetBasePtr(&pVm->aException);
	pException = 0;
	pCatch = 0;
	if (SySetUsed(&pVm->aException) > 0) {
		php_exception_block* aCatch;
		php_class* pClass;
		sxu32 j;

		pException = apException[SySetUsed(&pVm->aException) - 1];
		(void)SySetPop(&pVm->aException);
		aCatch = (php_exception_block*)SySetBasePtr(&pException->sEntry);
		for (j = 0; j < SySetUsed(&pException->sEntry); ++j) {
			SyString* pName = &aCatch[j].sClass;

			pClass = PHP_VmExtractClass(&(*pVm),pName->zString,pName->nByte,TRUE,0);
			if (pClass == 0) {

				continue;
			}
			if (VmInstanceOf(pThis->pClass,pClass)) {

				pCatch = &aCatch[j];
				break;
			}
		}
	}

	if (pCatch == 0) {
		sxi32 rc;
		rc = VmUncaughtException(&(*pVm),pThis);
		if (rc == SXRET_OK && pException) {
			VmFrame* pFrame = pVm->pFrame;
			while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

				pFrame = pFrame->pParent;
			}
			if (pException->pFrame == pFrame) {

				pFrame->iFlags &= ~VM_FRAME_THROW;
			}
		}
		return rc;
	}
	else {
		VmFrame* pFrame = pVm->pFrame;
		sxi32 rc;
		while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

			pFrame = pFrame->pParent;
		}
		if (pException->pFrame == pFrame) {

			pFrame->iFlags &= ~VM_FRAME_THROW;
		}

		rc = VmEnterFrame(&(*pVm),0,0,&pFrame);
		if (rc == SXRET_OK) {

			php_value* pObj = VmExtractMemObj(&(*pVm),&pCatch->sThis,FALSE,TRUE);
			pFrame->iFlags |= VM_FRAME_CATCH;
			if (pObj) {

				pThis->iRef++;
				pObj->x.pOther = pThis;
				MemObjSetType(pObj,MEMOBJ_OBJ);
			}

			VmLocalExec(&(*pVm),&pCatch->sByteCode,0);

			VmLeaveFrame(&(*pVm));
		}
	}

	return SXRET_OK;
}


static int vm_builtin_php_version(php_context* pCtx,int nArg,php_value** apArg)
{
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	php_result_string(pCtx,PHP_VERSION,sizeof(PHP_VERSION) - 1);
	return PHP_OK;
}

#define PHP_HTML_PAGE_HEADER "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">"\
			"<html><head>"\
			"<!-- Copyright (C) 2011-2012 Symisc Systems,http://www.symisc.net contact@symisc.net -->"\
			"<meta content=\"text/html; charset=UTF-8\" http-equiv=\"content-type\"><title>PHP engine credits</title>"\
			"<style type=\"text/css\">"\
			"div {"\
				"border: 1px solid #cccccc;"\
				"-moz-border-radius-topleft: 10px;"\
				"-moz-border-radius-bottomright: 10px;"\
				"-moz-border-radius-bottomleft: 10px;"\
				"-moz-border-radius-topright: 10px;"\
				"-webkit-border-radius: 10px;"\
				"-o-border-radius: 10px;"\
				"border-radius: 10px;"\
				"padding-left: 2em;"\
				"background-color: white;"\
				"margin-left: auto;"\
				"font-family: verdana;"\
				"padding-right: 2em;"\
				"margin-right: auto;"\
				"}"\
				"body {"\
				"padding: 0.2em;"\
				"font-style: normal;"\
				"font-size: medium;"\
				"background-color: #f2f2f2;"\
				"}"\
				"hr {"\
				"border-style: solid none none;"\
				"border-width: 1px medium medium;"\
				"border-top: 1px solid #cccccc;"\
				"height: 1px;"\
				"}"\
				"a {"\
				"color: #3366cc;"\
				"text-decoration: none;"\
				"}"\
				"a:hover {"\
				"color: #999999;"\
				"}"\
				"a:active {"\
				"color: #663399;"\
				"}"\
				"h1 {"\
				"margin: 0;"\
				"padding: 0;"\
				"font-family: Verdana;"\
				"font-weight: bold;"\
				"font-style: normal;"\
				"font-size: medium;"\
				"text-transform: capitalize;"\
				"color: #0a328c;"\
				"}"\
				"p {"\
				"margin: 0 auto;"\
				"font-size: medium;"\
				"font-style: normal;"\
				"font-family: verdana;"\
				"}"\
		"</style></head><body>"\
		"<div style=\"background-color: white; width: 699px;\">"\
		"<h1 style=\"font-family: Verdana; text-align: right;\"><small><small>PHP Engine Credits</small></small></h1>"\
		"<hr style=\"margin-left: auto; margin-right: auto;\">"\
		"<p><small><a href=\"http://php.symisc.net/\"><small><span style=\"font-weight: bold;\">"\
		"Symisc PHP</span></small></a><small>&nbsp;</small></small></p>"\
		"<p style=\"text-align: left;\"><small><small>"\
		"A highly efficient embeddable bytecode compiler and a Virtual Machine for the PHP(5) Programming Language.</small></small></p>"\
		"<p style=\"text-align: left;\"><small><small>Copyright (C) Symisc Systems.<br></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Engine Version:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\">"

#define PHP_HTML_PAGE_FORMAT "<small><small><span style=\"font-weight: normal;\">%s</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Engine ID:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\">%s %s</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Underlying VFS:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\">%s</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Total Built-in Functions:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\">%d</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Total Built-in Classes:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\">%d</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Host Operating System:</small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\">%s</span></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small style=\"font-weight: bold;\"><small><small></small></small></small></p>"\
		"<p style=\"text-align: left; font-weight: bold;\"><small><small>Licensed To: &lt;Public Release Under The <a href=\"http://www.symisc.net/spl.txt\">"\
			"Symisc Public License (SPL)</a>&gt;</small></small></p>"

#define PHP_HTML_PAGE_FOOTER "<p style=\"text-align: left; font-weight: bold; margin-left: 40px;\"><small><small><span style=\"font-weight: normal;\"><br>"\
		"</span></small></small></p>"\
		"<p style=\"text-align: right;\"><small><small>Copyright (C) <a href=\"http://www.symisc.net/\">Symisc Systems</a></small></small><big>"\
		"</big></p></div></body></html>"

static int vm_builtin_php_credits(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;

	php_context_output(pCtx,PHP_HTML_PAGE_HEADER,(int)sizeof(PHP_HTML_PAGE_HEADER) - 1);
	php_context_output_format(
		pCtx,
		PHP_HTML_PAGE_FORMAT,
		php_lib_version(),
		php_lib_signature(),
		php_lib_ident(),
		pVm->pEngine->pVfs ? pVm->pEngine->pVfs->zName : "null_vfs",
		SyHashTotalEntry(&pVm->hFunction) + SyHashTotalEntry(&pVm->hHostFunction),
		SyHashTotalEntry(&pVm->hClass),
#ifdef __WINNT__
		"Windows NT"
#elif defined(__UNIXES__)
		"UNIX-Like"
#else
		"Other OS"
#endif
	);
	php_context_output(pCtx,PHP_HTML_PAGE_FOOTER,(int)sizeof(PHP_HTML_PAGE_FOOTER) - 1);
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	//php_result_bool(pCtx,1);
	return PHP_OK;
}


static sxi32 VmHttpSplitURI(SyhttpUri* pOut,const char* zUri,sxu32 nLen);

static int vm_builtin_parse_url(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zStr;
	SyString* pComp;
	SyhttpUri sURI; int nLen;
	sxi32 rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zStr = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = VmHttpSplitURI(&sURI,zStr,(sxu32)nLen);
	if (rc != SXRET_OK) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {
		int nComponent = php_value_to_int(apArg[1]);

		switch (nComponent) {
		case 1:
			pComp = &sURI.sScheme;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 2:
			pComp = &sURI.sHost;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 3:
			pComp = &sURI.sPort;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				int iPort = 0;

				SyStrToInt32(pComp->zString,pComp->nByte,(void*)&iPort,0);
				php_result_int(pCtx,iPort);
			}
			break;
		case 4:
			pComp = &sURI.sUser;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 5:
			pComp = &sURI.sPass;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 7:
			pComp = &sURI.sQuery;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 8:
			pComp = &sURI.sFragment;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		case 6:
			pComp = &sURI.sPath;
			if (pComp->nByte < 1) {

				php_result_null(pCtx);
			}
			else {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			break;
		default:

			php_result_null(pCtx);
			break;
		}
	}
	else {
		php_value* pArray,* pValue;

		pArray = php_context_new_array(pCtx);
		pValue = php_context_new_scalar(pCtx);
		if (pArray == 0 || pValue == 0) {

			php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP engine is running out of memory");

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		pComp = &sURI.sScheme;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"scheme",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sHost;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"host",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sPort;
		if (pComp->nByte > 0) {
			int iPort = 0;

			SyStrToInt32(pComp->zString,pComp->nByte,(void*)&iPort,0);
			php_value_int(pValue,iPort);
			php_array_add_strkey_elem(pArray,"port",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sUser;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"user",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sPass;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"pass",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sPath;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"path",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sQuery;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"query",pValue);
		}

		php_value_reset_string_cursor(pValue);
		pComp = &sURI.sFragment;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);
			php_array_add_strkey_elem(pArray,"fragment",pValue);
		}

		php_result_value(pCtx,pArray);

	}

	return PHP_OK;
}


struct compact_data
{
	php_value* pArray; int nRecCount;
};

static int VmCompactCallback(php_value* pKey,php_value* pValue,void* pUserData)
{
	struct compact_data* pData = (struct compact_data*)pUserData;
	php_value* pArray = (php_value*)pData->pArray;
	php_vm* pVm = pArray->pVm;

	if (php_value_is_string(pValue)) {
		SyString sVar;
		SyStringInitFromBuf(&sVar,SyBlobData(&pValue->sBlob),SyBlobLength(&pValue->sBlob));
		if (sVar.nByte > 0) {

			pKey = VmExtractMemObj(pVm,&sVar,FALSE,FALSE);

			if (pKey) {

				php_array_add_elem(pArray,pValue,pKey);
			}
		}
	}
	else if (php_value_is_array(pValue) && pData->nRecCount < 32) {
		int rc;

		pData->nRecCount++;
		rc = PHP_HashmapWalk((php_hashmap*)pValue->x.pOther,VmCompactCallback,pUserData);
		pData->nRecCount--;
		return rc;
	}
	return SXRET_OK;
}

static int vm_builtin_compact(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pObj;
	php_vm* pVm = pCtx->pVm;
	const char* zName;
	SyString sVar; int i,nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP engine is running out of memory");

		php_result_null(pCtx);
		return PHP_OK;
	}

	for (i = 0; i < nArg; i++) {
		if (!php_value_is_string(apArg[i])) {
			if (php_value_is_array(apArg[i])) {
				struct compact_data sData;
				php_hashmap* pMap = (php_hashmap*)apArg[i]->x.pOther;

				sData.nRecCount = 0;
				sData.pArray = pArray;
				PHP_HashmapWalk(pMap,VmCompactCallback,&sData);
			}
		}
		else {

			zName = php_value_to_string(apArg[i],&nLen);
			if (nLen > 0) {
				SyStringInitFromBuf(&sVar,zName,nLen);

				pObj = VmExtractMemObj(pVm,&sVar,FALSE,FALSE);
				if (pObj) {
					php_array_add_elem(pArray,apArg[i],pObj);
				}
			}
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

typedef struct extract_aux_data extract_aux_data;
struct extract_aux_data
{
	php_vm* pVm; int iCount;
	const char* zPrefix; int Prefixlen; int iFlags;
	char zWorker[1024];
};

static int VmExtractCallback(php_value* pKey,php_value* pValue,void* pUserData);

static int vm_builtin_extract(php_context* pCtx,int nArg,php_value** apArg)
{
	extract_aux_data sAux;
	php_hashmap* pMap;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	SyZero(&sAux,sizeof(extract_aux_data) - sizeof(sAux.zWorker));
	if (nArg > 1) {
		sAux.iFlags = php_value_to_int(apArg[1]);
		if (nArg > 2) {
			sAux.zPrefix = php_value_to_string(apArg[2],&sAux.Prefixlen);
		}
	}
	sAux.pVm = pCtx->pVm;

	PHP_HashmapWalk(pMap,VmExtractCallback,&sAux);

	php_result_int(pCtx,sAux.iCount);
	return PHP_OK;
}

static int VmExtractCallback(php_value* pKey,php_value* pValue,void* pUserData)
{
	extract_aux_data* pAux = (extract_aux_data*)pUserData; int iFlags = pAux->iFlags;
	php_vm* pVm = pAux->pVm;
	php_value* pObj;
	SyString sVar;
	if ((iFlags & 0x10) && (pKey->iFlags & (MEMOBJ_INT | MEMOBJ_BOOL | MEMOBJ_REAL))) {
		iFlags |= 0x08;
	}

	PHP_MemObjToString(pKey);
	if (SyBlobLength(&pKey->sBlob) < 1) {

		return SXRET_OK;
	}
	sVar.nByte = 0;
	if ((iFlags & 0x08) && pAux->Prefixlen > 0) {
		sVar.nByte = (sxu32)SyBufferFormat(pAux->zWorker,sizeof(pAux->zWorker),"%.*s_%.*s",
			pAux->Prefixlen,pAux->zPrefix,
			SyBlobLength(&pKey->sBlob),SyBlobData(&pKey->sBlob)
		);
	}
	else {
		sVar.nByte = (sxu32)SyMemcpy(SyBlobData(&pKey->sBlob),pAux->zWorker,
			SXMIN(SyBlobLength(&pKey->sBlob),sizeof(pAux->zWorker)));
	}
	sVar.zString = pAux->zWorker;

	pObj = VmExtractMemObj(pVm,&sVar,TRUE,FALSE);
	if (pObj) {

		if (iFlags & 0x02 ) {
			return SXRET_OK;
		}
		if (iFlags & 0x04 ) {
			if ((iFlags & 0x08) || pAux->Prefixlen < 1) {

				return SXRET_OK;
			}
			sVar.nByte = (sxu32)SyBufferFormat(pAux->zWorker,sizeof(pAux->zWorker),"%.*s_%.*s",
				pAux->Prefixlen,pAux->zPrefix,
				SyBlobLength(&pKey->sBlob),SyBlobData(&pKey->sBlob)
			);
			pObj = VmExtractMemObj(pVm,&sVar,TRUE,TRUE);
		}
	}
	else {

		pObj = VmExtractMemObj(pVm,&sVar,TRUE,TRUE);
	}
	if (pObj) {

		PHP_MemObjStore(pValue,pObj);

		pAux->iCount++;
	}
	return SXRET_OK;
}

static int VmImportRequestCallback(php_value* pKey,php_value* pValue,void* pUserData)
{
	extract_aux_data* pAux = (extract_aux_data*)pUserData;
	php_vm* pVm = pAux->pVm;
	php_value* pObj;
	SyString sVar;

	PHP_MemObjToString(pKey);
	if (SyBlobLength(&pKey->sBlob) < 1) {

		return SXRET_OK;
	}
	sVar.nByte = 0;
	if (pAux->Prefixlen > 0) {
		sVar.nByte = (sxu32)SyBufferFormat(pAux->zWorker,sizeof(pAux->zWorker),"%.*s%.*s",
			pAux->Prefixlen,pAux->zPrefix,
			SyBlobLength(&pKey->sBlob),SyBlobData(&pKey->sBlob)
		);
	}
	else {
		sVar.nByte = (sxu32)SyMemcpy(SyBlobData(&pKey->sBlob),pAux->zWorker,
			SXMIN(SyBlobLength(&pKey->sBlob),sizeof(pAux->zWorker)));
	}
	sVar.zString = pAux->zWorker;

	pObj = VmExtractMemObj(pVm,&sVar,TRUE,TRUE);
	if (pObj) {
		PHP_MemObjStore(pValue,pObj);
	}
	return SXRET_OK;
}

static int vm_builtin_import_request_variables(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPrefix,* zEnd,* zImport;
	extract_aux_data sAux; int nLen,nPrefixLen;
	php_value* pSuper;
	php_vm* pVm;

	zImport = "G";
	nLen = (int)sizeof(char);
	zPrefix = 0;
	nPrefixLen = 0;
	if (nArg > 0) {
		if (php_value_is_string(apArg[0])) {
			zImport = php_value_to_string(apArg[0],&nLen);
		}
		if (nArg > 1 && php_value_is_string(apArg[1])) {
			zPrefix = php_value_to_string(apArg[1],&nPrefixLen);
		}
	}

	pVm = pCtx->pVm;

	SyZero(&sAux,sizeof(sAux) - sizeof(sAux.zWorker));
	sAux.zPrefix = zPrefix;
	sAux.Prefixlen = nPrefixLen;
	sAux.pVm = pVm;

	zEnd = &zImport[nLen];
	while (zImport < zEnd) {
		int c = zImport[0];
		pSuper = 0;
		if (c == 'G' || c == 'g') {

			pSuper = VmExtractSuper(pVm,"_GET",sizeof("_GET") - 1);
		}
		else if (c == 'P' || c == 'p') {

			pSuper = VmExtractSuper(pVm,"_POST",sizeof("_POST") - 1);
		}
		else if (c == 'c' || c == 'C') {

			pSuper = VmExtractSuper(pVm,"_COOKIE",sizeof("_COOKIE") - 1);
		}
		if (pSuper) {

			php_array_walk(pSuper,VmImportRequestCallback,&sAux);
		}

		zImport++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static sxi32 VmEvalChunk(
	php_vm* pVm,
	php_context* pCtx,
	SyString* pChunk,
	int iFlags,
	int bTrueReturn
)
{
	SySet* pByteCode,aByteCode;
	ProcConsumer xErr = 0;
	void* pErrData = 0;

	SySetInit(&aByteCode,&pVm->sAllocator,sizeof(VmInstr));
	SySetAlloc(&aByteCode,0x20);

	if (bTrueReturn) {

		xErr = pVm->pEngine->xConf.xErr;
		pErrData = pVm->pEngine->xConf.pErrData;
	}
	PHP_ResetCodeGenerator(pVm,xErr,pErrData);

	pByteCode = pVm->pByteContainer;
	pVm->pByteContainer = &aByteCode;

	PHP_CompileScript(pVm,pChunk,iFlags);
	if (pVm->sCodeGen.nErr > 0) {

		if (pCtx) {
			php_result_bool(pCtx,0);
		}
	}
	else {
		php_value sResult;
		if (SXRET_OK != PHP_VmEmitInstr(pVm,PHP_OP_DONE,0,0,0,0)) {

			if (pCtx) {
				php_result_bool(pCtx,0);
			}
			goto Cleanup;
		}
		if (bTrueReturn) {

			PHP_MemObjInitFromBool(pVm,&sResult,1);
		}
		else {

			PHP_MemObjInit(pVm,&sResult);
		}

		VmLocalExec(pVm,&aByteCode,&sResult);
		if (pCtx) {

			php_result_value(pCtx,&sResult);
		}
		PHP_MemObjRelease(&sResult);
	}
Cleanup:

	pVm->pByteContainer = pByteCode;
	SySetRelease(&aByteCode);
	return SXRET_OK;
}

static int vm_builtin_eval(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sChunk;
	if (nArg < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	sChunk.zString = php_value_to_string(apArg[0],(int*)&sChunk.nByte);
	if (sChunk.nByte < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	VmEvalChunk(pCtx->pVm,&(*pCtx),&sChunk,PHP_PHP_ONLY,FALSE);
	return SXRET_OK;
}

static int VmIsIncludedFile(php_vm* pVm,SyString* pFile)
{
	SyString* aEntries;
	sxu32 n;
	aEntries = (SyString*)SySetBasePtr(&pVm->aIncluded);

	for (n = 0; n < SySetUsed(&pVm->aIncluded); ++n) {
		if (SyStringCmp(pFile,&aEntries[n],SyMemcmp) == 0) {

			return TRUE;
		}
	}
	return FALSE;
}

PHP_PRIVATE sxi32 PHP_VmPushFilePath(php_vm* pVm,const char* zPath,int nLen,sxu8 bMain,sxi32* pNew)
{
	SyString sPath;
	char* zDup;
#ifdef __WINNT__
	char* zCur;
#endif
	sxi32 rc;
	if (nLen < 0) {
		nLen = SyStrlen(zPath);
	}

	zDup = SyMemBackendStrDup(&pVm->sAllocator,zPath,nLen);
	if (zDup == 0) {
		return SXERR_MEM;
	}
#ifdef __WINNT__

	zCur = zDup;
	while (zCur[0] != 0) {
		if (zCur[0] == '/') {
			zCur[0] = '\\';
		}
		else if ((unsigned char)zCur[0] < 0xc0 && SyisUpper(zCur[0])) {
			int c = SyToLower(zCur[0]);
			zCur[0] = (char)c;
		}
		zCur++;
	}
#endif

	SyStringInitFromBuf(&sPath,zDup,nLen);
	if (!bMain) {
		if (VmIsIncludedFile(&(*pVm),&sPath)) {

			*pNew = 0;
		}
		else {

			rc = SySetPut(&pVm->aIncluded,(const void*)&sPath);
			if (rc != SXRET_OK) {
				SyMemBackendFree(&pVm->sAllocator,zDup);
				return rc;
			}
			*pNew = 1;
		}
	}
	SySetPut(&pVm->aFiles,(const void*)&sPath);
	return SXRET_OK;
}

static sxi32 VmExecIncludedFile(
	php_context* pCtx,
	SyString* pPath,
	int IncludeOnce
)
{
	sxi32 rc;
#ifndef PHP_DISABLE_BUILTIN_FUNC
	const php_io_stream* pStream;
	SyBlob sContents;
	void* pHandle;
	php_vm* pVm; int isNew;

	pVm = pCtx->pVm;
	SyBlobInit(&sContents,&pVm->sAllocator);
	isNew = 0;

	pStream = PHP_VmGetStreamDevice(pVm,&pPath->zString,pPath->nByte);

	pHandle = PHP_StreamOpenHandle(pVm,pStream,pPath->zString,PHP_IO_OPEN_RDONLY,TRUE,0,TRUE,&isNew);
	if (pHandle == 0) {
		return SXERR_IO;
	}
	rc = SXRET_OK;
	if (IncludeOnce && !isNew) {

		rc = SXERR_EXISTS;
	}
	else {

		rc = PHP_StreamReadWholeFile(pHandle,pStream,&sContents);
		if (rc == SXRET_OK) {
			SyString sScript;

			SyStringInitFromBuf(&sScript,SyBlobData(&sContents),SyBlobLength(&sContents));
			VmEvalChunk(pCtx->pVm,&(*pCtx),&sScript,0,TRUE);
		}
	}

	(void)SySetPop(&pVm->aFiles);

	PHP_StreamCloseHandle(pStream,pHandle);

	SyBlobRelease(&sContents);
#else
	pCtx = 0;
	pPath = 0;
	IncludeOnce = 0;
	rc = SXERR_IO;
#endif
	return rc;
}

static int vm_builtin_get_include_path(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	SyString* aEntry; int dir_sep;
	sxu32 n;
#ifdef __WINNT__
	dir_sep = ';';
#else

	dir_sep = ':';
#endif
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	aEntry = (SyString*)SySetBasePtr(&pVm->aPaths);
	for (n = 0; n < SySetUsed(&pVm->aPaths); n++) {
		SyString* pEntry = &aEntry[n];
		if (n > 0) {

			php_result_string(pCtx,(const char*)&dir_sep,sizeof(char));
		}

		php_result_string(pCtx,pEntry->zString,(int)pEntry->nByte);
	}
	return PHP_OK;
}

static int vm_builtin_get_included_files(php_context* pCtx,int nArg,php_value** apArg)
{
	SySet* pFiles = &pCtx->pVm->aFiles;
	php_value* pArray,* pWorker;
	SyString* pEntry; int c,d;

	pArray = php_context_new_array(pCtx);
	pWorker = php_context_new_scalar(pCtx);
	if (pArray == 0 || pWorker == 0) {

		php_result_null(pCtx);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
		return PHP_OK;
	}
	c = d = '/';
#ifdef __WINNT__
	d = '\\';
#endif

	SySetResetCursor(pFiles);
	while (SXRET_OK == SySetGetNextEntry(pFiles,(void**)&pEntry)) {
		const char* zBase,* zEnd; int iLen;

		php_value_reset_string_cursor(pWorker);

		zEnd = &pEntry->zString[pEntry->nByte - 1];

		while (zEnd > pEntry->zString && ((int)zEnd[0] == c || (int)zEnd[0] == d)) {
			zEnd--;
		}
		iLen = (int)(&zEnd[1] - pEntry->zString);
		while (zEnd > pEntry->zString && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {
			zEnd--;
		}
		zBase = (zEnd > pEntry->zString) ? &zEnd[1] : pEntry->zString;
		zEnd = &pEntry->zString[iLen];

		php_value_string(pWorker,zBase,(int)(zEnd - zBase));

		php_array_add_elem(pArray,0,pWorker);
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int vm_builtin_include(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sFile;
	sxi32 rc;
	if (nArg < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	sFile.zString = php_value_to_string(apArg[0],(int*)&sFile.nByte);
	if (sFile.nByte < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	rc = VmExecIncludedFile(&(*pCtx),&sFile,FALSE);
	if (rc != SXRET_OK) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,"IO error while importing: '%z'",&sFile);
		php_result_bool(pCtx,0);
	}
	return SXRET_OK;
}

static int vm_builtin_include_once(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sFile;
	sxi32 rc;
	if (nArg < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	sFile.zString = php_value_to_string(apArg[0],(int*)&sFile.nByte);
	if (sFile.nByte < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	rc = VmExecIncludedFile(&(*pCtx),&sFile,TRUE);
	if (rc == SXERR_EXISTS) {

		php_result_bool(pCtx,1);
		return SXRET_OK;
	}
	if (rc != SXRET_OK) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,"IO error while importing: '%z'",&sFile);
		php_result_bool(pCtx,0);
	}
	return SXRET_OK;
}

static int vm_builtin_require(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sFile;
	sxi32 rc;
	if (nArg < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	sFile.zString = php_value_to_string(apArg[0],(int*)&sFile.nByte);
	if (sFile.nByte < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	rc = VmExecIncludedFile(&(*pCtx),&sFile,FALSE);
	if (rc != SXRET_OK) {

		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"Fatal IO error while importing: '%z'",&sFile);
		php_result_bool(pCtx,0);
		return PHP_ABORT;
	}
	return SXRET_OK;
}

static int vm_builtin_require_once(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sFile;
	sxi32 rc;
	if (nArg < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	sFile.zString = php_value_to_string(apArg[0],(int*)&sFile.nByte);
	if (sFile.nByte < 1) {

		php_result_null(pCtx);
		return SXRET_OK;
	}

	rc = VmExecIncludedFile(&(*pCtx),&sFile,TRUE);
	if (rc == SXERR_EXISTS) {

		php_result_bool(pCtx,1);
		return SXRET_OK;
	}
	if (rc != SXRET_OK) {

		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"Fatal IO error while importing: '%z'",&sFile);
		php_result_bool(pCtx,0);
		return PHP_ABORT;
	}
	return SXRET_OK;
}


static const char* VmFindShortOpt(int c,const char* zIn,const char* zEnd)
{
	while (zIn < zEnd) {
		if (zIn[0] == '-' && &zIn[1] < zEnd && (int)zIn[1] == c) {

			return &zIn[1];
		}

		zIn++;
	}

	return 0;
}

static const char* VmFindLongOpt(const char* zLong,int nByte,const char* zIn,const char* zEnd)
{
	const char* zOpt;
	while (zIn < zEnd) {
		if (zIn[0] == '-' && &zIn[1] < zEnd && (int)zIn[1] == '-') {
			zIn += 2;
			zOpt = zIn;
			while (zIn < zEnd && !SyisSpace(zIn[0])) {
				if (zIn[0] == '=' ) {
					break;
				}
				zIn++;
			}

			if ((int)(zIn - zOpt) == nByte && SyMemcmp(zOpt,zLong,nByte) == 0) {

				return zIn;
			}

		}
		else {
			zIn++;
		}
	}

	return 0;
}

struct getopt_long_opt
{
	const char* zArgIn,* zArgEnd;
	php_value* pWorker;
	php_value* pArray;
	php_context* pCtx;
};

static int VmProcessLongOpt(php_value* pKey,php_value* pValue,void* pUserData);

static void VmExtractOptArgValue(
	php_value* pArray,
	php_value* pWorker,
	const char* zArg,
	const char* zArgEnd,
	int need_val,
	php_context* pCtx,
	const char* zName   )
{
	php_value_bool(pWorker,0);
	if (!need_val) {

		php_array_add_strkey_elem(pArray,(const char*)zName,pWorker);
	}
	else {
		const char* zCur;

		zArg++;
		if (zArg < zArgEnd && zArg[0] == '=') {
			zArg++;
		}
		while (zArg < zArgEnd && (unsigned char)zArg[0] < 0xc0 && SyisSpace(zArg[0])) {
			zArg++;
		}
		if (zArg >= zArgEnd || zArg[0] == '-') {

			php_array_add_strkey_elem(pArray,(const char*)zName,pWorker);
			return;
		}

		zCur = zArg;
		if (zArg[0] == '\'' || zArg[0] == '"') {
			int d = zArg[0];

			zArg++;
			zCur = zArg;
			while (zArg < zArgEnd) {
				if (zArg[0] == d && zArg[-1] != '\\') {

					break;
				}
				zArg++;
			}

			php_value_string(pWorker,zCur,(int)(zArg - zCur));
			if (zArg < zArgEnd) { zArg++; }
		}
		else {
			while (zArg < zArgEnd && !SyisSpace(zArg[0])) {
				zArg++;
			}

			php_value_string(pWorker,zCur,(int)(zArg - zCur));
		}

		while (zArg < zArgEnd && (unsigned char)zArg[0] < 0xc0 && SyisSpace(zArg[0])) {
			zArg++;
		}
		if (zArg < zArgEnd && zArg[0] != '-') {
			php_value* pOptArg;
			pOptArg = php_context_new_array(pCtx);
			if (pOptArg == 0) {
				php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
			}
			else {

				php_array_add_elem(pOptArg,0,pWorker);
				for (;;) {
					if (zArg >= zArgEnd || zArg[0] == '-') {

						break;
					}

					zCur = zArg;
					if (zArg < zArgEnd && zArg[0] == '\\') {
						zArg++;
						zCur = zArg;
					}
					while (zArg < zArgEnd && !SyisSpace(zArg[0])) {
						zArg++;
					}

					php_value_reset_string_cursor(pWorker);

					php_value_string(pWorker,zCur,(int)(zArg - zCur));

					php_array_add_elem(pOptArg,0,pWorker);

					while (zArg < zArgEnd && (unsigned char)zArg[0] < 0xc0 && SyisSpace(zArg[0])) {
						zArg++;
					}
				}

				php_array_add_strkey_elem(pArray,(const char*)zName,pOptArg);

				php_context_release_value(pCtx,pOptArg);
			}
		}
		else {

			php_array_add_strkey_elem(pArray,(const char*)zName,pWorker);
		}
	}
}

static int vm_builtin_getopt(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zEnd,* zArg,* zArgIn,* zArgEnd;
	struct getopt_long_opt sLong;
	php_value* pArray,* pWorker;
	SyBlob* pArg; int nByte;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Missing/Invalid option arguments");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nByte);
	zEnd = &zIn[nByte];

	pArg = &pCtx->pVm->sArgv;

	pArray = php_context_new_array(pCtx);
	pWorker = php_context_new_scalar(pCtx);
	if (pArray == 0 || pWorker == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (SyBlobLength(pArg) < 1) {

		php_result_value(pCtx,pArray);

		return PHP_OK;
	}
	zArgIn = (const char*)SyBlobData(pArg);
	zArgEnd = &zArgIn[SyBlobLength(pArg)];

	sLong.pArray = pArray;
	sLong.pWorker = pWorker;
	sLong.zArgIn = zArgIn;
	sLong.zArgEnd = zArgEnd;
	sLong.pCtx = pCtx;

	while (zIn < zEnd) {
		int c = zIn[0]; int need_val = 0;

		zIn++;

		if (!SyisAlphaNum(c)) {
			continue;
		}
		if (zIn < zEnd && zIn[0] == ':') {
			zIn++;
			need_val = 1;
			if (zIn < zEnd && zIn[0] == ':') {
				zIn++;
			}
		}

		zArg = VmFindShortOpt(c,zArgIn,zArgEnd);
		if (zArg == 0) {

			continue;
		}

		VmExtractOptArgValue(pArray,pWorker,zArg,zArgEnd,need_val,pCtx,(const char*)&c);
	}
	if (nArg > 1 && php_value_is_array(apArg[1]) && php_array_count(apArg[1]) > 0) {

		php_array_walk(apArg[1],VmProcessLongOpt,&sLong);
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int VmProcessLongOpt(php_value* pKey,php_value* pValue,void* pUserData)
{
	struct getopt_long_opt* pOpt = (struct getopt_long_opt*)pUserData;
	const char* zArg,* zOpt,* zEnd; int need_value = 0; int nByte;

	if (!php_value_is_string(pValue)) {

		return PHP_OK;
	}
	zOpt = php_value_to_string(pValue,&nByte);
	if (nByte < 1) {

		return PHP_OK;
	}
	zEnd = &zOpt[nByte - 1];
	if (zEnd[0] == ':') {
		char* zTerm;

		need_value = 1;
		while (zEnd >= zOpt && zEnd[0] == ':') {
			zEnd--;
		}
		if (zOpt >= zEnd) {

			SXUNUSED(pKey);
			return PHP_OK;
		}
		zEnd++;
		zTerm = (char*)zEnd;
		zTerm[0] = 0;
	}
	else {
		zEnd = &zOpt[nByte];
	}

	zArg = VmFindLongOpt(zOpt,(int)(zEnd - zOpt),pOpt->zArgIn,pOpt->zArgEnd);
	if (zArg == 0) {

		return PHP_OK;
	}

	VmExtractOptArgValue(pOpt->pArray,pOpt->pWorker,zArg,pOpt->zArgEnd,need_value,pOpt->pCtx,zOpt);
	return PHP_OK;
}


static int VmJsonArrayEncode(php_value* pKey,php_value* pValue,void* pUserData);
static int VmJsonObjectEncode(const char* zAttr,php_value* pValue,void* pUserData);

typedef struct json_private_data json_private_data;
struct json_private_data
{
	php_context* pCtx; int isFirst; int iFlags; int nRecCount;
};

static sxi32 VmJsonEncode(
	php_value* pIn,
	json_private_data* pData
) {
	php_context* pCtx = pData->pCtx; int iFlags = pData->iFlags; int nByte;
	if (php_value_is_null(pIn) || php_value_is_resource(pIn)) {

		php_result_string(pCtx,"null",(int)sizeof("null") - 1);
	}
	else if (php_value_is_bool(pIn)) {
		int iBool = php_value_to_bool(pIn); int iLen;

		iLen = iBool ? (int)sizeof("true") : (int)sizeof("false");
		php_result_string(pCtx,iBool ? "true" : "false",iLen - 1);
	}
	else if (php_value_is_numeric(pIn) && !php_value_is_string(pIn)) {
		const char* zNum;

		zNum = php_value_to_string(pIn,&nByte);
		php_result_string(pCtx,zNum,nByte);
	}
	else if (php_value_is_string(pIn)) {
		if ((iFlags & JSON_NUMERIC_CHECK) && php_value_is_numeric(pIn)) {
			const char* zNum;

			PHP_MemObjToReal(pIn);

			zNum = php_value_to_string(pIn,&nByte);
			php_result_string(pCtx,zNum,nByte);
		}
		else {
			const char* zIn,* zEnd; int c;

			zIn = php_value_to_string(pIn,&nByte);
			zEnd = &zIn[nByte];

			php_result_string(pCtx,"\"",(int)sizeof(char));
			for (;;) {
				if (zIn >= zEnd) {

					break;
				}
				c = zIn[0];

				zIn++;
				if ((c == '<' || c == '>') && (iFlags & JSON_HEX_TAG)) {

					if (c == '<') {
						php_result_string(pCtx,"\\u003C",(int)sizeof("\\u003C") - 1);
					}
					else {
						php_result_string(pCtx,"\\u003E",(int)sizeof("\\u003E") - 1);
					}
					continue;
				}
				else if (c == '&' && (iFlags & JSON_HEX_AMP)) {

					php_result_string(pCtx,"\\u0026",(int)sizeof("\\u0026") - 1);
					continue;
				}
				else if (c == '\'' && (iFlags & JSON_HEX_APOS)) {

					php_result_string(pCtx,"\\u0027",(int)sizeof("\\u0027") - 1);
					continue;
				}
				else if (c == '"' && (iFlags & JSON_HEX_QUOT)) {

					php_result_string(pCtx,"\\u0022",(int)sizeof("\\u0022") - 1);
					continue;
				}
				if (c == '"' || (c == '\\' && ((iFlags & JSON_UNESCAPED_SLASHES) == 0))) {

					php_result_string(pCtx,"\\",(int)sizeof(char));
				}

				php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
			}

			php_result_string(pCtx,"\"",(int)sizeof(char));
		}
	}
	else if (php_value_is_array(pIn)) {
		int c = '[',d = ']';

		pData->isFirst = 1;
		if (iFlags & JSON_FORCE_OBJECT) {

			c = '{';
			d = '}';
		}

		php_result_string(pCtx,(const char*)&c,(int)sizeof(char));

		php_array_walk(pIn,VmJsonArrayEncode,pData);

		php_result_string(pCtx,(const char*)&d,(int)sizeof(char));
	}
	else if (php_value_is_object(pIn)) {

		pData->isFirst = 1;

		php_result_string(pCtx,"{",(int)sizeof(char));

		php_object_walk(pIn,VmJsonObjectEncode,pData);

		php_result_string(pCtx,"}",(int)sizeof(char));
	}
	else {

		php_result_string(pCtx,"null",(int)sizeof("null") - 1);
	}

	return PHP_OK;
}

static int VmJsonArrayEncode(php_value* pKey,php_value* pValue,void* pUserData)
{
	json_private_data* pJson = (json_private_data*)pUserData;
	if (pJson->nRecCount > 31) {

		return PHP_OK;
	}
	if (!pJson->isFirst) {

		php_result_string(pJson->pCtx,",",(int)sizeof(char));
	}
	if (pJson->iFlags & JSON_FORCE_OBJECT) {

		const char* zKey; int nByte;

		zKey = php_value_to_string(pKey,&nByte);

		php_result_string_format(pJson->pCtx,"\"%.*s\":",nByte,zKey);
	}

	pJson->nRecCount++;
	VmJsonEncode(pValue,pJson);
	pJson->nRecCount--;
	pJson->isFirst = 0;
	return PHP_OK;
}

static int VmJsonObjectEncode(const char* zAttr,php_value* pValue,void* pUserData)
{
	json_private_data* pJson = (json_private_data*)pUserData;
	if (pJson->nRecCount > 31) {

		return PHP_OK;
	}
	if (!pJson->isFirst) {

		php_result_string(pJson->pCtx,",",(int)sizeof(char));
	}

	php_result_string_format(pJson->pCtx,"\"%s\":",zAttr);

	pJson->nRecCount++;
	VmJsonEncode(pValue,pJson);
	pJson->nRecCount--;
	pJson->isFirst = 0;
	return PHP_OK;
}

static int vm_builtin_json_encode(php_context* pCtx,int nArg,php_value** apArg)
{
	json_private_data sJson;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	sJson.nRecCount = 0;
	sJson.pCtx = pCtx;
	sJson.isFirst = 1;
	sJson.iFlags = 0;
	if (nArg > 1 && php_value_is_int(apArg[1])) {

		sJson.iFlags = php_value_to_int(apArg[1]);
	}

	VmJsonEncode(apArg[0],&sJson);

	return PHP_OK;
}

static int vm_builtin_json_last_error(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;

	php_result_int(pCtx,pVm->json_rc);
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	return PHP_OK;
}

#define JSON_TK_TRUE    0x001
#define JSON_TK_FALSE   0x002
#define JSON_TK_STR     0x004
#define JSON_TK_NULL    0x008
#define JSON_TK_NUM     0x010
#define JSON_TK_OCB     0x020
#define JSON_TK_CCB     0x040
#define JSON_TK_OSB     0x080
#define JSON_TK_CSB     0x100
#define JSON_TK_COLON   0x200
#define JSON_TK_COMMA   0x400
#define JSON_TK_INVALID 0x800

static sxi32 VmJsonTokenize(SyStream* pStream,SyToken* pToken,void* pUserData,void* pCtxData)
{
	int* pJsonErr = (int*)pUserData;
	SyString* pStr; int c;

	while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisSpace(pStream->zText[0])) {

		if (pStream->zText[0] == '\n') {

			pStream->nLine++;
		}
		pStream->zText++;
	}
	if (pStream->zText >= pStream->zEnd) {

		SXUNUSED(pCtxData);
		return SXERR_EOF;
	}

	pToken->nLine = pStream->nLine;
	pToken->pUserData = 0;
	pStr = &pToken->sData;
	SyStringInitFromBuf(pStr,pStream->zText,0);
	if (pStream->zText[0] == '{' || pStream->zText[0] == '[' || pStream->zText[0] == '}' || pStream->zText[0] == ']'
		|| pStream->zText[0] == ':' || pStream->zText[0] == ',') {

		c = pStream->zText[0];

		switch (c) {
		case '[': pToken->nType = JSON_TK_OSB;   break;
		case '{': pToken->nType = JSON_TK_OCB;   break;
		case '}': pToken->nType = JSON_TK_CCB;   break;
		case ']': pToken->nType = JSON_TK_CSB;   break;
		case ':': pToken->nType = JSON_TK_COLON; break;
		case ',': pToken->nType = JSON_TK_COMMA; break;
		default:
			break;
		}

		pStream->zText++;
	}
	else if (pStream->zText[0] == '"') {

		pStream->zText++;
		pStr->zString++;

		while (pStream->zText < pStream->zEnd) {
			if (pStream->zText[0] == '"' && pStream->zText[-1] != '\\') {
				break;
			}
			if (pStream->zText[0] == '\n') {

				pStream->nLine++;
			}
			pStream->zText++;
		}
		if (pStream->zText >= pStream->zEnd) {

			pToken->nType = JSON_TK_INVALID;
			*pJsonErr = JSON_ERROR_SYNTAX;
		}
		else {
			pToken->nType = JSON_TK_STR;
			pStream->zText++;
		}
	}
	else if (pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {

		pStream->zText++;
		pToken->nType = JSON_TK_NUM;
		while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
			pStream->zText++;
		}
		if (pStream->zText < pStream->zEnd) {
			c = pStream->zText[0];
			if (c == '.') {

				pStream->zText++;
				while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
					pStream->zText++;
				}
				if (pStream->zText < pStream->zEnd) {
					c = pStream->zText[0];
					if (c == 'e' || c == 'E') {
						pStream->zText++;
						if (pStream->zText < pStream->zEnd) {
							c = pStream->zText[0];
							if (c == '+' || c == '-') {
								pStream->zText++;
							}
							while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
								pStream->zText++;
							}
						}
					}
				}
			}
			else if (c == 'e' || c == 'E') {

				pStream->zText++;
				if (pStream->zText < pStream->zEnd) {
					c = pStream->zText[0];
					if (c == '+' || c == '-') {
						pStream->zText++;
					}
					while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
						pStream->zText++;
					}
				}
			}
		}
	}
	else if (XLEX_IN_LEN(pStream) >= sizeof("true") - 1 &&
		SyStrnicmp((const char*)pStream->zText,"true",sizeof("true") - 1) == 0) {

		pToken->nType = JSON_TK_TRUE;

		pStream->zText += sizeof("true") - 1;
	}
	else if (XLEX_IN_LEN(pStream) >= sizeof("false") - 1 &&
		SyStrnicmp((const char*)pStream->zText,"false",sizeof("false") - 1) == 0) {

		pToken->nType = JSON_TK_FALSE;

		pStream->zText += sizeof("false") - 1;
	}
	else if (XLEX_IN_LEN(pStream) >= sizeof("null") - 1 &&
		SyStrnicmp((const char*)pStream->zText,"null",sizeof("null") - 1) == 0) {

		pToken->nType = JSON_TK_NULL;

		pStream->zText += sizeof("null") - 1;
	}
	else {

		pToken->nType = JSON_TK_INVALID;

		pStream->zText++;
		*pJsonErr = JSON_ERROR_SYNTAX;

		return SXERR_ABORT;
	}

	pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
	if (pToken->nType == JSON_TK_STR) {
		pStr->nByte--;
	}

	return SXRET_OK;
}

typedef int (*ProcJsonConsumer)(php_context*,php_value*,php_value*,void*);

typedef struct json_decoder json_decoder;
struct json_decoder
{
	php_context* pCtx;
	ProcJsonConsumer xConsumer;
	void* pUserData; int iFlags;
	SyToken* pIn;
	SyToken* pEnd; int rec_depth; int rec_count; int* pErr;
};
#define JSON_DECODE_ASSOC 0x01

static int VmJsonArrayDecoder(php_context* pCtx,php_value* pKey,php_value* pWorker,void* pUserData);

static void VmJsonDequoteString(const SyString* pStr,php_value* pWorker)
{
	const char* zIn = pStr->zString;
	const char* zEnd = &pStr->zString[pStr->nByte];
	const char* zCur; int c;

	php_value_string(pWorker,"",0);
	for (;;) {
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '\\') {
			zIn++;
		}
		if (zIn > zCur) {

			php_value_string(pWorker,zCur,(int)(zIn - zCur));
		}
		zIn++;
		if (zIn >= zEnd) {

			break;
		}
		c = zIn[0];

		switch (c) {
		case '"':  php_value_string(pWorker,(const char*)&c,(int)sizeof(char)); break;
		case '\\': php_value_string(pWorker,(const char*)&c,(int)sizeof(char)); break;
		case 'n':  php_value_string(pWorker,"\n",(int)sizeof(char)); break;
		case 'r':  php_value_string(pWorker,"\r",(int)sizeof(char)); break;
		case 't':  php_value_string(pWorker,"\t",(int)sizeof(char)); break;
		case 'f':  php_value_string(pWorker,"\f",(int)sizeof(char)); break;
		default:
			php_value_string(pWorker,(const char*)&c,(int)sizeof(char));
			break;
		}

		zIn++;
	}
}

static sxi32 VmJsonDecode(
	json_decoder* pDecoder,
	php_value* pArrayKey
) {
	php_value* pWorker;
	sxi32 rc;

	if (pDecoder->rec_count >= pDecoder->rec_depth) {

		*pDecoder->pErr = JSON_ERROR_DEPTH;
		return SXERR_ABORT;
	}
	if (pDecoder->pIn->nType & (JSON_TK_STR | JSON_TK_TRUE | JSON_TK_FALSE | JSON_TK_NULL | JSON_TK_NUM)) {

		pWorker = php_context_new_scalar(pDecoder->pCtx);
		if (pWorker == 0) {
			php_context_throw_error(pDecoder->pCtx,PHP_CTX_ERR,"PHP is running out of memory");

			return SXERR_ABORT;
		}

		if (pDecoder->pIn->nType & JSON_TK_NULL) {

			php_value_null(pWorker);
		}
		else if (pDecoder->pIn->nType & (JSON_TK_TRUE | JSON_TK_FALSE)) {

			php_value_bool(pWorker,(pDecoder->pIn->nType & JSON_TK_TRUE) ? 1 : 0);
		}
		else if (pDecoder->pIn->nType & JSON_TK_NUM) {
			SyString* pStr = &pDecoder->pIn->sData;

			php_value_string(pWorker,pStr->zString,(int)pStr->nByte);

			PHP_MemObjToNumeric(pWorker);
		}
		else {

			VmJsonDequoteString(&pDecoder->pIn->sData,pWorker);
		}

		rc = pDecoder->xConsumer(pDecoder->pCtx,pArrayKey,pWorker,pDecoder->pUserData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}

		pDecoder->pIn++;
	}
	else if (pDecoder->pIn->nType & JSON_TK_OSB ) {
		ProcJsonConsumer xOld;
		void* pOld;

		pDecoder->pIn++;

		pWorker = php_context_new_array(pDecoder->pCtx);
		if (pWorker == 0) {
			php_context_throw_error(pDecoder->pCtx,PHP_CTX_ERR,"PHP is running out of memory");

			return SXERR_ABORT;
		}

		xOld = pDecoder->xConsumer;
		pOld = pDecoder->pUserData;

		pDecoder->xConsumer = VmJsonArrayDecoder;
		pDecoder->pUserData = pWorker;

		for (;;) {

			while ((pDecoder->pIn < pDecoder->pEnd) && (pDecoder->pIn->nType & JSON_TK_COMMA)) {
				pDecoder->pIn++;
			}
			if (pDecoder->pIn >= pDecoder->pEnd || (pDecoder->pIn->nType & JSON_TK_CSB) ) {
				if (pDecoder->pIn < pDecoder->pEnd) {
					pDecoder->pIn++;
				}
				break;
			}

			pDecoder->rec_count++;
			rc = VmJsonDecode(pDecoder,0);
			pDecoder->rec_count--;
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}

			if ((pDecoder->pIn < pDecoder->pEnd) &&
				((pDecoder->pIn->nType & (JSON_TK_CSB | JSON_TK_COMMA)) == 0)) {

				*pDecoder->pErr = JSON_ERROR_SYNTAX;
				return SXERR_ABORT;
			}
		}

		pDecoder->xConsumer = xOld;
		pDecoder->pUserData = pOld;

		xOld(pDecoder->pCtx,pArrayKey,pWorker,pOld);
	}
	else if (pDecoder->pIn->nType & JSON_TK_OCB ) {
		ProcJsonConsumer xOld;
		php_value* pKey;
		void* pOld;

		pDecoder->pIn++;

		if ((pDecoder->iFlags & JSON_DECODE_ASSOC) == 0) {
			php_context_throw_error(pDecoder->pCtx,PHP_CTX_WARNING,
				"JSON Objects are always returned as an associative array"
			);
		}

		pWorker = php_context_new_array(pDecoder->pCtx);
		pKey = php_context_new_scalar(pDecoder->pCtx);
		if (pWorker == 0 || pKey == 0) {
			php_context_throw_error(pDecoder->pCtx,PHP_CTX_ERR,"PHP is running out of memory");

			return SXERR_ABORT;
		}

		xOld = pDecoder->xConsumer;
		pOld = pDecoder->pUserData;

		pDecoder->xConsumer = VmJsonArrayDecoder;
		pDecoder->pUserData = pWorker;

		for (;;) {

			while ((pDecoder->pIn < pDecoder->pEnd) && (pDecoder->pIn->nType & JSON_TK_COMMA)) {
				pDecoder->pIn++;
			}
			if (pDecoder->pIn >= pDecoder->pEnd || (pDecoder->pIn->nType & JSON_TK_CCB) ) {
				if (pDecoder->pIn < pDecoder->pEnd) {
					pDecoder->pIn++;
				}
				break;
			}
			if ((pDecoder->pIn->nType & JSON_TK_STR) == 0 || &pDecoder->pIn[1] >= pDecoder->pEnd
				|| (pDecoder->pIn[1].nType & JSON_TK_COLON) == 0) {

				*pDecoder->pErr = JSON_ERROR_SYNTAX;
				return SXERR_ABORT;
			}

			VmJsonDequoteString(&pDecoder->pIn->sData,pKey);

			pDecoder->pIn += 2;

			pDecoder->rec_count++;
			rc = VmJsonDecode(pDecoder,pKey);
			pDecoder->rec_count--;
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}

			php_value_reset_string_cursor(pKey);

		}

		pDecoder->xConsumer = xOld;
		pDecoder->pUserData = pOld;

		xOld(pDecoder->pCtx,pArrayKey,pWorker,pOld);

		php_context_release_value(pDecoder->pCtx,pKey);
	}
	else {

		return SXERR_ABORT;
	}

	php_context_release_value(pDecoder->pCtx,pWorker);
	return SXRET_OK;
}

static int VmJsonArrayDecoder(php_context* pCtx,php_value* pKey,php_value* pWorker,void* pUserData)
{
	php_value* pArray = (php_value*)pUserData;

	php_array_add_elem(pArray,pKey,pWorker);
	SXUNUSED(pCtx);

	return SXRET_OK;
}

static int VmJsonDefaultDecoder(php_context* pCtx,php_value* pKey,php_value* pWorker,void* pUserData)
{

	php_result_value(pCtx,pWorker);
	SXUNUSED(pKey);
	SXUNUSED(pUserData);

	return SXRET_OK;
}

static int vm_builtin_json_decode(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vm* pVm = pCtx->pVm;
	json_decoder sDecoder;
	const char* zIn;
	SySet sToken;
	SyLex sLex; int nByte;
	sxi32 rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nByte);
	if (nByte < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pVm->json_rc = JSON_ERROR_NONE;

	SySetInit(&sToken,&pVm->sAllocator,sizeof(SyToken));
	SyLexInit(&sLex,&sToken,VmJsonTokenize,&pVm->json_rc);
	SyLexTokenizeInput(&sLex,zIn,(sxu32)nByte,0,0,0);
	if (pVm->json_rc != JSON_ERROR_NONE) {

		SyLexRelease(&sLex);
		SySetRelease(&sToken);

		php_result_null(pCtx);
		return PHP_OK;
	}

	sDecoder.pCtx = pCtx;
	sDecoder.pErr = &pVm->json_rc;
	sDecoder.pIn = (SyToken*)SySetBasePtr(&sToken);
	sDecoder.pEnd = &sDecoder.pIn[SySetUsed(&sToken)];
	sDecoder.iFlags = 0;
	if (nArg > 1 && php_value_to_bool(apArg[1]) != 0) {

		sDecoder.iFlags |= JSON_DECODE_ASSOC;
	}
	sDecoder.rec_depth = 32;
	if (nArg > 2 && php_value_is_int(apArg[2])) {
		int nDepth = php_value_to_int(apArg[2]);
		if (nDepth > 1 && nDepth < 32) {
			sDecoder.rec_depth = nDepth;
		}
	}
	sDecoder.rec_count = 0;

	sDecoder.xConsumer = VmJsonDefaultDecoder;
	sDecoder.pUserData = 0;

	rc = VmJsonDecode(&sDecoder,0);
	if (rc == SXERR_ABORT || pVm->json_rc != JSON_ERROR_NONE) {

		php_result_null(pCtx);
	}

	SyLexRelease(&sLex);
	SySetRelease(&sToken);

	return PHP_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC

enum php_xml_handler_id {
	PHP_XML_START_TAG = 0,
	PHP_XML_END_TAG,
	PHP_XML_CDATA,
	PHP_XML_PI,
	PHP_XML_DEF,
	PHP_XML_UNPED,
	PHP_XML_ND,
	PHP_XML_EER,
	PHP_XML_NS_START,
	PHP_XML_NS_END
};
#define XML_TOTAL_HANDLER (PHP_XML_NS_END + 1)

typedef struct php_xml_engine php_xml_engine;
struct php_xml_engine
{
	php_vm* pVm;
	php_context* pCtx;
	SyXMLParser sParser;
	php_value aCB[XML_TOTAL_HANDLER];
	php_value sParserValue; int ns_sep;
	SyBlob sErr;
	sxi32 iErrCode;
	sxi32 iNest;
	sxu32 nLine;
	sxu32 nMagic;
};
#define XML_ENGINE_MAGIC 0x851EFC52
#define IS_INVALID_XML_ENGINE(XML) (XML == 0 || (XML)->nMagic != XML_ENGINE_MAGIC)

static php_xml_engine* VmCreateXMLEngine(php_context* pCtx,int process_ns,int ns_sep)
{
	php_xml_engine* pEngine;
	php_vm* pVm = pCtx->pVm;
	php_value* pValue;
	sxu32 n;

	pEngine = (php_xml_engine*)SyMemBackendAlloc(&pVm->sAllocator,sizeof(php_xml_engine));
	if (pEngine == 0) {

		return 0;
	}

	SyZero(pEngine,sizeof(php_xml_engine));

	pEngine->pVm = pVm;
	pEngine->pCtx = 0;
	pEngine->ns_sep = ns_sep;
	SyXMLParserInit(&pEngine->sParser,&pVm->sAllocator,process_ns ? SXML_ENABLE_NAMESPACE : 0);
	SyBlobInit(&pEngine->sErr,&pVm->sAllocator);
	PHP_MemObjInit(pVm,&pEngine->sParserValue);
	for (n = 0; n < SX_ARRAYSIZE(pEngine->aCB); ++n) {
		pValue = &pEngine->aCB[n];

		PHP_MemObjInit(&(*pVm),pValue);
	}
	php_value_resource(&pEngine->sParserValue,pEngine);
	pEngine->iErrCode = SXML_ERROR_NONE;

	pEngine->nMagic = XML_ENGINE_MAGIC;
	return pEngine;
}

static void VmReleaseXMLEngine(php_xml_engine* pEngine)
{
	php_vm* pVm = pEngine->pVm;
	php_value* pValue;
	sxu32 n;

	SyBlobRelease(&pEngine->sErr);
	SyXMLParserRelease(&pEngine->sParser);
	PHP_MemObjRelease(&pEngine->sParserValue);
	for (n = 0; n < SX_ARRAYSIZE(pEngine->aCB); ++n) {
		pValue = &pEngine->aCB[n];
		PHP_MemObjRelease(pValue);
	}
	pEngine->nMagic = 0x2621;

	SyMemBackendFree(&pVm->sAllocator,pEngine);
}

static int vm_builtin_xml_parser_create(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;

	pEngine = VmCreateXMLEngine(&(*pCtx),0,':');
	if (pEngine == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");

		php_result_null(pCtx);
		SXUNUSED(nArg);
		SXUNUSED(apArg);
		return PHP_OK;
	}

	php_result_resource(pCtx,pEngine);
	return PHP_OK;
}

static int vm_builtin_xml_parser_create_ns(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine; int ns_sep = ':';
	if (nArg > 1 && php_value_is_string(apArg[1])) {
		const char* zSep = php_value_to_string(apArg[1],0);
		if (zSep[0] != 0) {
			ns_sep = zSep[0];
		}
	}

	pEngine = VmCreateXMLEngine(&(*pCtx),TRUE,ns_sep);
	if (pEngine == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");

		php_result_null(pCtx);
		return PHP_OK;
	}

	php_result_resource(pCtx,pEngine);
	return PHP_OK;
}

static int vm_builtin_xml_parser_free(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	VmReleaseXMLEngine(pEngine);

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_element_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_START_TAG]);
		if (nArg > 2) {

			PHP_MemObjStore(apArg[2],&pEngine->aCB[PHP_XML_END_TAG]);
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_character_data_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_CDATA]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_default_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_DEF]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_end_namespace_decl_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_NS_END]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_start_namespace_decl_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_NS_START]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_processing_instruction_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_PI]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_unparsed_entity_decl_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_UNPED]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_notation_decl_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_ND]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_set_external_entity_ref_handler(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {

		PHP_MemObjStore(apArg[1],&pEngine->aCB[PHP_XML_EER]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int vm_builtin_xml_get_current_line_number(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_int(pCtx,(int)pEngine->nLine);
	return PHP_OK;
}

static int vm_builtin_xml_get_current_byte_index(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	SyStream* pStream;
	SyToken* pToken;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pToken = (SyToken*)SySetPeekCurrentEntry(&pEngine->sParser.sToken);
	if (pToken == 0) {

		php_result_int(pCtx,0);
		return 0;
	}

	pStream = &pEngine->sParser.sLex.sStream;

	php_result_int64(pCtx,(php_int64)(pToken->sData.zString - (const char*)pStream->zInput));
	return PHP_OK;
}

static int vm_builtin_xml_set_object(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 2 || !php_value_is_resource(apArg[0]) || !php_value_is_object(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_context_throw_error(pCtx,PHP_CTX_NOTICE,"This function is depreceated and is a no-op."
		"In order to mimic this behaviour,you can supply instead of a function name an array "
		"containing an object reference and a method name."
	);

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int vm_builtin_xml_get_current_column_number(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	SyStream* pStream;
	SyToken* pToken;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pToken = (SyToken*)SySetPeekCurrentEntry(&pEngine->sParser.sToken);
	if (pToken == 0) {

		php_result_int(pCtx,0);
		return 0;
	}

	pStream = &pEngine->sParser.sLex.sStream;

	php_result_int64(pCtx,(php_int64)(pToken->sData.zString - (const char*)pStream->zInput) / 80);
	return PHP_OK;
}

static int vm_builtin_xml_get_error_code(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_int(pCtx,pEngine->iErrCode);
	return PHP_OK;
}


static php_value* VmXMLValue(php_xml_engine* pEngine,SyXMLRawStr* pXML,SyXMLRawStr* pNsUri)
{
	php_value* pValue;

	pValue = php_context_new_scalar(pEngine->pCtx);
	if (pValue == 0) {
		php_context_throw_error(pEngine->pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		return 0;
	}
	if (pNsUri && pNsUri->nByte > 0) {

		php_value_string_format(pValue,"%.*s%c",pNsUri->nByte,pNsUri->zString,pEngine->ns_sep);
	}

	php_value_string(pValue,pXML->zString,(int)pXML->nByte);
	return pValue;
}

static php_value* VmXMLAttrValue(php_xml_engine* pEngine,SyXMLRawStr* aAttr,sxu32 nAttr)
{
	php_value* pArray;

	pArray = php_context_new_array(pEngine->pCtx);
	if (pArray == 0) {
		php_context_throw_error(pEngine->pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		return 0;
	}
	if (nAttr > 0) {
		php_value* pKey,* pValue;
		sxu32 n;

		pKey = php_context_new_scalar(pEngine->pCtx);
		pValue = php_context_new_scalar(pEngine->pCtx);
		if (pKey == 0 || pValue == 0) {
			php_context_throw_error(pEngine->pCtx,PHP_CTX_ERR,"PHP is running out of memory");
			return 0;
		}

		for (n = 0; n < nAttr; n += 2) {

			php_value_reset_string_cursor(pKey);
			php_value_reset_string_cursor(pValue);

			php_value_string(pKey,aAttr[n].zString,(int)aAttr[n].nByte);
			php_value_string(pValue,aAttr[n + 1].zString,(int)aAttr[n + 1].nByte);

			php_array_add_elem(pArray,pKey,pValue);
		}

		php_context_release_value(pEngine->pCtx,pKey);
		php_context_release_value(pEngine->pCtx,pValue);
	}

	return pArray;
}

static sxi32 VmXMLStartElementHandler(SyXMLRawStr* pStart,SyXMLRawStr* pNS,sxu32 nAttr,SyXMLRawStr* aAttr,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pTag,* pAttr;

	pCallback = &pEngine->aCB[PHP_XML_START_TAG];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pTag = VmXMLValue(pEngine,pStart,pNS);

	pAttr = VmXMLAttrValue(pEngine,aAttr,nAttr);
	if (pTag == 0 || pAttr == 0) {
		SXUNUSED(pNS);

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pTag,pAttr,0);

	php_context_release_value(pEngine->pCtx,pTag);
	php_context_release_value(pEngine->pCtx,pAttr);
	return SXRET_OK;
}

static sxi32 VmXMLEndElementHandler(SyXMLRawStr* pEnd,SyXMLRawStr* pNS,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pTag;

	pCallback = &pEngine->aCB[PHP_XML_END_TAG];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pTag = VmXMLValue(pEngine,pEnd,pNS);
	if (pTag == 0) {
		SXUNUSED(pNS);

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pTag,0);

	php_context_release_value(pEngine->pCtx,pTag);
	return SXRET_OK;
}

static sxi32 VmXMLTextHandler(SyXMLRawStr* pText,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pData;

	pCallback = &pEngine->aCB[PHP_XML_CDATA];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pData = VmXMLValue(pEngine,&(*pText),0);
	if (pData == 0) {

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pData,0);

	php_context_release_value(pEngine->pCtx,pData);
	return SXRET_OK;
}

static sxi32 VmXMLPIHandler(SyXMLRawStr* pTargetStr,SyXMLRawStr* pDataStr,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pTarget,* pData;

	pCallback = &pEngine->aCB[PHP_XML_PI];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pTarget = VmXMLValue(pEngine,&(*pTargetStr),0);
	pData = VmXMLValue(pEngine,&(*pDataStr),0);
	if (pTarget == 0 || pData == 0) {

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pTarget,pData,0);

	php_context_release_value(pEngine->pCtx,pTarget);
	php_context_release_value(pEngine->pCtx,pData);
	return SXRET_OK;
}

static sxi32 VmXMLNSStartHandler(SyXMLRawStr* pUriStr,SyXMLRawStr* pPrefixStr,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pUri,* pPrefix;

	pCallback = &pEngine->aCB[PHP_XML_NS_START];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pUri = VmXMLValue(pEngine,pUriStr,0);
	pPrefix = VmXMLValue(pEngine,pPrefixStr,0);
	if (pUri == 0 || pPrefix == 0) {

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pUri,pPrefix,0);

	php_context_release_value(pEngine->pCtx,pUri);
	php_context_release_value(pEngine->pCtx,pPrefix);
	return SXRET_OK;
}

static sxi32 VmXMLNSEndHandler(SyXMLRawStr* pPrefixStr,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;
	php_value* pCallback,* pPrefix;

	pCallback = &pEngine->aCB[PHP_XML_NS_END];

	if (!PHP_VmIsCallable(pEngine->pVm,pCallback,0)) {

		return SXRET_OK;
	}

	pPrefix = VmXMLValue(pEngine,pPrefixStr,0);
	if (pPrefix == 0) {

		return SXRET_OK;
	}

	PHP_VmCallUserFunctionAp(pEngine->pVm,pCallback,0,&pEngine->sParserValue,pPrefix,0);

	php_context_release_value(pEngine->pCtx,pPrefix);
	return SXRET_OK;
}

static sxi32 VmXMLErrorHandler(const char* zMessage,sxi32 iErrCode,SyToken* pToken,void* pUserData)
{
	php_xml_engine* pEngine = (php_xml_engine*)pUserData;

	pEngine->iErrCode = iErrCode;
	SXUNUSED(zMessage);
	if (pToken) {
		pEngine->nLine = pToken->nLine;
	}

	return SXERR_ABORT;
}

static int vm_builtin_xml_parse(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	SyXMLParser* pParser;
	const char* zData; int nByte;
	if (nArg < 2 || !php_value_is_resource(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (pEngine->iNest > 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_ERR,
			"Recursive call to %s,PHP is returning false",
			php_function_name(pCtx)
		);

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pEngine->pCtx = pCtx;

	pParser = &pEngine->sParser;

	SyXMLParserSetEventHandler(pParser,pEngine,
		VmXMLStartElementHandler,
		VmXMLTextHandler,
		VmXMLErrorHandler,
		0,
		VmXMLEndElementHandler,
		VmXMLPIHandler,
		0,
		0,
		VmXMLNSStartHandler,
		VmXMLNSEndHandler
	);
	pEngine->iErrCode = SXML_ERROR_NONE;

	zData = php_value_to_string(apArg[1],&nByte);

	pEngine->iNest++;
	SyXMLProcess(pParser,zData,(sxu32)nByte);
	pEngine->iNest--;

	php_result_int(pCtx,pEngine->iErrCode == SXML_ERROR_NONE ? 1 : 0);
	return PHP_OK;
}

static int vm_builtin_xml_parser_set_option(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int vm_builtin_xml_parser_get_option(php_context* pCtx,int nArg,php_value** apArg)
{
	php_xml_engine* pEngine; int nOp;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEngine = (php_xml_engine*)php_value_to_resource(apArg[0]);
	if (IS_INVALID_XML_ENGINE(pEngine)) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nOp = php_value_to_int(apArg[1]);
	switch (nOp) {
	case SXML_OPTION_SKIP_TAGSTART:
	case SXML_OPTION_SKIP_WHITE:
	case SXML_OPTION_CASE_FOLDING:
		php_result_int(pCtx,0); break;
	case SXML_OPTION_TARGET_ENCODING:
		php_result_string(pCtx,"UTF-8",(int)sizeof("UTF-8") - 1);
		break;
	default:

		php_result_bool(pCtx,0);
		break;
	}
	return PHP_OK;
}

static int vm_builtin_xml_error_string(php_context* pCtx,int nArg,php_value** apArg)
{
	int nErr = -1;
	if (nArg > 0) {
		nErr = php_value_to_int(apArg[0]);
	}
	switch (nErr) {
	case SXML_ERROR_DUPLICATE_ATTRIBUTE:
		php_result_string(pCtx,"Duplicate attribute",-1);
		break;
	case SXML_ERROR_INCORRECT_ENCODING:
		php_result_string(pCtx,"Incorrect encoding",-1);
		break;
	case SXML_ERROR_INVALID_TOKEN:
		php_result_string(pCtx,"Unexpected token",-1);
		break;
	case SXML_ERROR_MISPLACED_XML_PI:
		php_result_string(pCtx,"Misplaced processing instruction",-1);
		break;
	case SXML_ERROR_NO_MEMORY:
		php_result_string(pCtx,"Out of memory",-1);
		break;
	case SXML_ERROR_NONE:
		php_result_string(pCtx,"Not an error",-1);
		break;
	case SXML_ERROR_TAG_MISMATCH:
		php_result_string(pCtx,"Tag mismatch",-1);
		break;
	case -1:
		php_result_string(pCtx,"Unknown error code",-1);
		break;
	default:
		php_result_string(pCtx,"Syntax error",-1);
		break;
	}
	return PHP_OK;
}
#endif

static int vm_builtin_utf8_encode(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nByte,c,e;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nByte);
	if (nByte < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	zEnd = &zIn[nByte];

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		c = zIn[0];

		zIn++;

		if (c < 0x00080) {
			e = (c & 0xFF);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
		}
		else if (c < 0x00800) {
			e = 0xC0 + ((c >> 6) & 0x1F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + (c & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
		}
		else if (c < 0x10000) {
			e = 0xE0 + ((c >> 12) & 0x0F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + ((c >> 6) & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + (c & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
		}
		else {
			e = 0xF0 + ((c >> 18) & 0x07);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + ((c >> 12) & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + ((c >> 6) & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
			e = 0x80 + (c & 0x3F);
			php_result_string(pCtx,(const char*)&e,(int)sizeof(char));
		}
	}

	return PHP_OK;
}


static const unsigned char UtfTrans1[] = {
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
	0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	0x00,0x01,0x02,0x03,0x00,0x01,0x00,0x00,
};

#define READ_UTF8(zIn,zTerm,c)                           \
			c = *(zIn++);                                            \
			if( c>=0xc0 ){                                           \
			c = UtfTrans1[c-0xc0];                                 \
			while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \
				c = (c<<6) + (0x3f & *(zIn++));                      \
			}                                                      \
			if( c<0x80                                             \
				|| (c&0xFFFFF800)==0xD800                          \
				|| (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \
			}
PHP_PRIVATE int PHP_Utf8Read(
	const unsigned char* z,
	const unsigned char* zTerm,
	const unsigned char** pzNext
) {
	int c;
	READ_UTF8(z,zTerm,c);
	*pzNext = z;
	return c;
}

static int vm_builtin_utf8_decode(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nByte,c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nByte);
	if (nByte < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	zEnd = &zIn[nByte];

	while (zIn < zEnd) {
		c = PHP_Utf8Read(zIn,zEnd,&zIn);
		if (c == 0x0) {
			break;
		}
		php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
	}
	return PHP_OK;
}

static const php_builtin_func aVmFunc[] = {
	{ "func_num_args"  ,vm_builtin_func_num_args},
	{ "func_get_arg"   ,vm_builtin_func_get_arg},
	{ "func_get_args"  ,vm_builtin_func_get_args},
	{ "func_get_args_byref" ,vm_builtin_func_get_args_byref},
	{ "function_exists",vm_builtin_func_exists},
	{ "is_callable"    ,vm_builtin_is_callable},
	{ "get_defined_functions",vm_builtin_get_defined_func},
	{ "register_shutdown_function",vm_builtin_register_shutdown_function},
	{ "call_user_func",vm_builtin_call_user_func},
	{ "call_user_func_array",vm_builtin_call_user_func_array},
	{ "forward_static_call",vm_builtin_call_user_func},
	{ "forward_static_call_array",vm_builtin_call_user_func_array},
    { "defined",vm_builtin_defined},
    { "define",vm_builtin_define},
    { "constant",vm_builtin_constant},
    { "get_defined_constants",vm_builtin_get_defined_constants},
    { "class_alias",vm_builtin_class_alias},
    { "class_exists",vm_builtin_class_exists},
    { "property_exists",vm_builtin_property_exists},
    { "method_exists",vm_builtin_method_exists},
    { "interface_exists",vm_builtin_interface_exists},
    { "get_class",vm_builtin_get_class},
    { "get_parent_class",vm_builtin_get_parent_class},
    { "get_called_class",vm_builtin_get_called_class},
    { "get_declared_classes",vm_builtin_get_declared_classes},
    { "get_defined_classes",vm_builtin_get_declared_classes},
    { "get_declared_interfaces",vm_builtin_get_declared_interfaces},
    { "get_class_methods",vm_builtin_get_class_methods},
    { "get_class_vars",vm_builtin_get_class_vars},
    { "get_object_vars",vm_builtin_get_object_vars},
    { "is_subclass_of",vm_builtin_is_subclass_of},
    { "is_a",vm_builtin_is_a},
    { "rand",vm_builtin_rand},
    { "mt_rand",vm_builtin_rand},
    { "rand_str",vm_builtin_rand_str},
    { "getrandmax",vm_builtin_getrandmax},
    { "mt_getrandmax",vm_builtin_getrandmax},
#ifndef PHP_DISABLE_BUILTIN_FUNC
#if !defined(PHP_DISABLE_HASH_FUNC)
	{ "uniqid",vm_builtin_uniqid},
#endif
#endif
	{ "echo",vm_builtin_echo},
	{ "print",vm_builtin_print},
	{ "exit",vm_builtin_exit},
	{ "die",vm_builtin_exit},
	{ "eval",vm_builtin_eval},
    { "get_defined_vars",vm_builtin_get_defined_vars},
    { "gettype",vm_builtin_gettype},
    { "get_resource_type",vm_builtin_get_resource_type},
    { "isset",vm_builtin_isset},
    { "unset",vm_builtin_unset},
    { "var_dump",vm_builtin_var_dump},
    { "print_r",vm_builtin_print_r},
    { "var_export",vm_builtin_var_export},
    { "flush",vm_builtin_ob_flush},
    { "ob_clean",vm_builtin_ob_clean},
    { "ob_end_clean",vm_builtin_ob_end_clean},
    { "ob_end_flush",vm_builtin_ob_end_flush},
    { "ob_flush",vm_builtin_ob_flush},
    { "ob_get_clean",vm_builtin_ob_get_clean},
    { "ob_get_contents",vm_builtin_ob_get_contents},
    { "ob_get_flush",vm_builtin_ob_get_clean},
    { "ob_get_length",vm_builtin_ob_get_length},
    { "ob_get_level",vm_builtin_ob_get_level},
    { "ob_implicit_flush",vm_builtin_ob_implicit_flush},
    { "ob_get_level",vm_builtin_ob_get_level},
    { "ob_list_handlers",vm_builtin_ob_list_handlers},
    { "ob_start",vm_builtin_ob_start},
    { "assert_options",vm_builtin_assert_options},
    { "assert",vm_builtin_assert},
    { "trigger_error",vm_builtin_trigger_error},
    { "user_error",vm_builtin_trigger_error},
    { "error_reporting",vm_builtin_error_reporting},
    { "error_log",vm_builtin_error_log},
    { "restore_exception_handler",vm_builtin_restore_exception_handler},
    { "set_exception_handler",vm_builtin_set_exception_handler},
    { "restore_error_handler",vm_builtin_restore_error_handler},
    { "set_error_handler",vm_builtin_set_error_handler},
    { "debug_backtrace",vm_builtin_debug_backtrace},
    { "error_get_last" ,vm_builtin_debug_backtrace},
    { "debug_print_backtrace",vm_builtin_debug_print_backtrace},
    { "debug_string_backtrace",vm_builtin_debug_string_backtrace},
    {"phpversion",vm_builtin_php_version},
    {"phpcredits",vm_builtin_php_credits},
    {"phpinfo",vm_builtin_php_credits},
    {"php_info",vm_builtin_php_credits},
    {"phpinfo",vm_builtin_php_credits},
    {"phpcopyright",vm_builtin_php_credits},
    {"compact",vm_builtin_compact},
    {"extract",vm_builtin_extract},
    {"import_request_variables",vm_builtin_import_request_variables},
    {"parse_url",vm_builtin_parse_url},
#ifndef PHP_DISABLE_BUILTIN_FUNC
	{"xml_parser_create",vm_builtin_xml_parser_create},
	{"xml_parser_create_ns",vm_builtin_xml_parser_create_ns},
	{"xml_parser_free",vm_builtin_xml_parser_free},
	{"xml_set_element_handler",vm_builtin_xml_set_element_handler},
	{"xml_set_character_data_handler",vm_builtin_xml_set_character_data_handler},
	{"xml_set_default_handler",vm_builtin_xml_set_default_handler},
	{"xml_set_end_namespace_decl_handler",vm_builtin_xml_set_end_namespace_decl_handler},
	{"xml_set_start_namespace_decl_handler",vm_builtin_xml_set_start_namespace_decl_handler},
	{"xml_set_processing_instruction_handler",vm_builtin_xml_set_processing_instruction_handler},
	{"xml_set_unparsed_entity_decl_handler",vm_builtin_xml_set_unparsed_entity_decl_handler},
	{"xml_set_notation_decl_handler",vm_builtin_xml_set_notation_decl_handler},
    {"xml_set_external_entity_ref_handler",vm_builtin_xml_set_external_entity_ref_handler},
    {"xml_get_current_line_number",vm_builtin_xml_get_current_line_number},
    {"xml_get_current_byte_index",vm_builtin_xml_get_current_byte_index},
    {"xml_set_object",vm_builtin_xml_set_object},
    {"xml_get_current_column_number",vm_builtin_xml_get_current_column_number},
    {"xml_get_error_code",vm_builtin_xml_get_error_code},
    {"xml_parse",vm_builtin_xml_parse},
    {"xml_parser_set_option",vm_builtin_xml_parser_set_option},
    {"xml_parser_get_option",vm_builtin_xml_parser_get_option},
    {"xml_error_string",vm_builtin_xml_error_string},
#endif

	{"utf8_encode",vm_builtin_utf8_encode},
    {"utf8_decode",vm_builtin_utf8_decode},
{"getopt",vm_builtin_getopt},
    {"json_encode",vm_builtin_json_encode},
{"json_last_error",vm_builtin_json_last_error},
{"json_decode",vm_builtin_json_decode},
{"serialize",vm_builtin_json_encode},
{"unserialize",vm_builtin_json_decode},
    { "get_include_path",vm_builtin_get_include_path},
{ "get_included_files",vm_builtin_get_included_files},
{ "include",vm_builtin_include},
{ "include_once",vm_builtin_include_once},
{ "require",vm_builtin_require},
{ "require_once",vm_builtin_require_once},
};

static sxi32 VmRegisterSpecialFunction(php_vm* pVm)
{
	sxi32 rc;
	sxu32 n;
	for (n = 0; n < SX_ARRAYSIZE(aVmFunc); ++n) {

		rc = php_create_function(&(*pVm),aVmFunc[n].zName,aVmFunc[n].xFunc,&(*pVm));
		if (rc != SXRET_OK) {
			return rc;
		}
	}
	return SXRET_OK;
}

PHP_PRIVATE php_class* PHP_VmExtractClass(
	php_vm* pVm,
	const char* zName,
	sxu32 nByte,
	sxi32 iLoadable,
	sxi32 iNest
)
{
	SyHashEntry* pEntry;
	php_class* pClass;

	pEntry = SyHashGet(&pVm->hClass,(const void*)zName,nByte);

	if (pEntry == 0) {

		iNest = 0;
		return 0;
	}
	pClass = (php_class*)pEntry->pUserData;
	if (!iLoadable) {

		return pClass;
	}
	else {

		while (pClass) {
			if ((pClass->iFlags & (PHP_CLASS_INTERFACE | PHP_CLASS_ABSTRACT)) == 0) {

				return pClass;
			}

			pClass = pClass->pNextName;
		}
	}

	return 0;
}


static VmRefObj* VmNewRefObj(php_vm* pVm,sxu32 nIdx)
{
	VmRefObj* pRef;

	pRef = (VmRefObj*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(VmRefObj));
	if (pRef == 0) {
		return 0;
	}

	SyZero(pRef,sizeof(VmRefObj));

	SySetInit(&pRef->aReference,&pVm->sAllocator,sizeof(SyHashEntry*));
	SySetInit(&pRef->aArrEntries,&pVm->sAllocator,sizeof(php_hashmap_node*));
	pRef->nIdx = nIdx;
	return pRef;
}

static sxu32 VmRefHash(sxu32 nIdx)
{

	return nIdx ^ (nIdx << 8) ^ (nIdx >> 8);
}

static VmRefObj* VmRefObjExtract(php_vm* pVm,sxu32 nObjIdx)
{
	VmRefObj* pRef;
	sxu32 nBucket;

	nBucket = VmRefHash(nObjIdx) & (pVm->nRefSize - 1);

	pRef = pVm->apRefObj[nBucket];
	for (;;) {
		if (pRef == 0) {
			break;
		}
		if (pRef->nIdx == nObjIdx) {

			return pRef;
		}

		pRef = pRef->pNextCollide;
	}

	return 0;
}

static sxi32 VmRefObjInsert(php_vm* pVm,VmRefObj* pRef)
{
	sxu32 nBucket;
	if (pVm->nRefUsed * 3 >= pVm->nRefSize) {
		VmRefObj** apNew;
		sxu32 nNew;

		nNew = pVm->nRefSize << 1;
		apNew = (VmRefObj**)SyMemBackendAlloc(&pVm->sAllocator,sizeof(VmRefObj*) * nNew);
		if (apNew) {
			VmRefObj* pEntry = pVm->pRefList;
			sxu32 n;

			SyZero((void*)apNew,nNew * sizeof(VmRefObj*));

			for (n = 0; n < pVm->nRefUsed; ++n) {

				pEntry->pNextCollide = pEntry->pPrevCollide = 0;

				nBucket = VmRefHash(pEntry->nIdx) & (nNew - 1);

				pEntry->pNextCollide = apNew[nBucket];
				if (apNew[nBucket]) {
					apNew[nBucket]->pPrevCollide = pEntry;
				}
				apNew[nBucket] = pEntry;

				pEntry = pEntry->pNext;
			}

			SyMemBackendFree(&pVm->sAllocator,pVm->apRefObj);

			pVm->apRefObj = apNew;
			pVm->nRefSize = nNew;
		}
	}

	nBucket = VmRefHash(pRef->nIdx) & (pVm->nRefSize - 1);

	pRef->pNextCollide = pVm->apRefObj[nBucket];
	if (pVm->apRefObj[nBucket]) {
		pVm->apRefObj[nBucket]->pPrevCollide = pRef;
	}
	pVm->apRefObj[nBucket] = pRef;
	MACRO_LD_PUSH(pVm->pRefList,pRef);
	pVm->nRefUsed++;
	return SXRET_OK;
}

static sxi32 VmRefObjUnlink(php_vm* pVm,VmRefObj* pRef)
{
	php_hashmap_node** apNode;
	SyHashEntry** apEntry;
	sxu32 n;

	apNode = (php_hashmap_node**)SySetBasePtr(&pRef->aArrEntries);
	apEntry = (SyHashEntry**)SySetBasePtr(&pRef->aReference);

	for (n = 0; n < SySetUsed(&pRef->aReference); n++) {
		if (apEntry[n]) {
			SyHashDeleteEntry2(apEntry[n]);
		}
	}
	for (n = 0; n < SySetUsed(&pRef->aArrEntries); ++n) {
		if (apNode[n]) {
			PHP_HashmapUnlinkNode(apNode[n],FALSE);
		}
	}
	if (pRef->pPrevCollide) {
		pRef->pPrevCollide->pNextCollide = pRef->pNextCollide;
	}
	else {
		pVm->apRefObj[VmRefHash(pRef->nIdx) & (pVm->nRefSize - 1)] = pRef->pNextCollide;
	}
	if (pRef->pNextCollide) {
		pRef->pNextCollide->pPrevCollide = pRef->pPrevCollide;
	}
	MACRO_LD_REMOVE(pVm->pRefList,pRef);

	SySetRelease(&pRef->aReference);
	SySetRelease(&pRef->aArrEntries);
	SyMemBackendPoolFree(&pVm->sAllocator,pRef);
	pVm->nRefUsed--;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmRefObjInstall(
	php_vm* pVm,
	sxu32 nIdx,
	SyHashEntry* pEntry,
	php_hashmap_node* pMapEntry,
	sxi32 iFlags
)
{
	VmFrame* pFrame = pVm->pFrame;
	VmRefObj* pRef;

	pRef = VmRefObjExtract(&(*pVm),nIdx);
	if (pRef == 0) {

		pRef = VmNewRefObj(&(*pVm),nIdx);
		if (pRef == 0) {
			return SXERR_MEM;
		}
		pRef->iFlags = iFlags;

		VmRefObjInsert(&(*pVm),pRef);
	}
	while (pFrame->pParent && (pFrame->iFlags & VM_FRAME_EXCEPTION)) {

		pFrame = pFrame->pParent;
	}
	if (pFrame->pParent != 0 && pEntry) {
		VmSlot sRef;

		sRef.nIdx = nIdx;
		sRef.pUserData = pEntry;
		if (SXRET_OK != SySetPut(&pFrame->sRef,(const void*)&sRef)) {
			pEntry = 0;
		}
	}
	if (pEntry) {

		SySetPut(&pRef->aReference,(const void*)&pEntry);
	}
	if (pMapEntry) {

		SySetPut(&pRef->aArrEntries,(const void*)&pMapEntry);
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_VmRefObjRemove(
	php_vm* pVm,
	sxu32 nIdx,
	SyHashEntry* pEntry,
	php_hashmap_node* pMapEntry
)
{
	VmRefObj* pRef;
	sxu32 n;

	pRef = VmRefObjExtract(&(*pVm),nIdx);
	if (pRef == 0) {

		return SXERR_NOTFOUND;
	}

	if (pEntry) {
		SyHashEntry** apEntry;
		apEntry = (SyHashEntry**)SySetBasePtr(&pRef->aReference);
		for (n = 0; n < SySetUsed(&pRef->aReference); n++) {
			if (apEntry[n] == pEntry) {

				apEntry[n] = 0;

			}
		}
	}
	if (pMapEntry) {
		php_hashmap_node** apNode;
		apNode = (php_hashmap_node**)SySetBasePtr(&pRef->aArrEntries);
		for (n = 0; n < SySetUsed(&pRef->aArrEntries); n++) {
			if (apNode[n] == pMapEntry) {

				apNode[n] = 0;
			}
		}
	}
	return SXRET_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC

PHP_PRIVATE const php_io_stream* PHP_VmGetStreamDevice(
	php_vm* pVm,
	const char** pzDevice,
	int nByte
)
{
	const char* zIn,* zEnd,* zCur,* zNext;
	php_io_stream** apStream,* pStream;
	SyString sDev,sCur;
	sxu32 n,nEntry; int rc;

	zNext = zCur = zIn = *pzDevice;
	zEnd = &zIn[nByte];
	while (zIn < zEnd) {
		if (zIn < &zEnd[-3] && zIn[0] == ':' && zIn[1] == '/' && zIn[2] == '/') {

			zNext = &zIn[sizeof("://") - 1];
			break;
		}

		zIn++;
	}
	if (zIn >= zEnd) {

		return pVm->pDefStream;
	}
	SyStringInitFromBuf(&sDev,zCur,zIn - zCur);

	SyStringFullTrim(&sDev);

	apStream = (php_io_stream**)SySetBasePtr(&pVm->aIOstream);
	nEntry = SySetUsed(&pVm->aIOstream);
	for (n = 0; n < nEntry; n++) {
		pStream = apStream[n];
		SyStringInitFromBuf(&sCur,pStream->zName,SyStrlen(pStream->zName));

		rc = SyStringCmp(&sDev,&sCur,SyStrnicmp);
		if (rc == 0) {

			*pzDevice = zNext;
			return pStream;
		}
	}

	return 0;
}
#endif


static sxi32 VmHttpSplitURI(SyhttpUri* pOut,const char* zUri,sxu32 nLen)
{
	const char* zEnd = &zUri[nLen];
	sxu8 bHostOnly = FALSE;
	sxu8 bIPv6 = FALSE;
	const char* zCur;
	SyString* pComp;
	sxu32 nPos = 0;
	sxi32 rc;

	SyZero(pOut,sizeof(SyhttpUri));

	SyStringInitFromBuf(&pOut->sRaw,zUri,nLen);
	SyStringFullTrim(&pOut->sRaw);

	rc = SyByteFind(zUri,(sxu32)(zEnd - zUri),'/',&nPos);
	if (rc != SXRET_OK) {

		zCur = zEnd;
		bHostOnly = TRUE;
		goto ProcessHost;
	}
	zCur = &zUri[nPos];
	if (zUri != zCur && zCur[-1] == ':') {

		pComp = &pOut->sScheme;
		SyStringInitFromBuf(pComp,zUri,(sxu32)(zCur - zUri - 1));
		SyStringLeftTrim(pComp);
	}
	if (zCur[1] != '/') {
		if (zCur == zUri || zCur[-1] == ':') {

			goto PathSplit;
		}

		goto ProcessHost;
	}
	zUri = &zCur[2];
	zCur = zEnd;
	rc = SyByteFind(zUri,(sxu32)(zEnd - zUri),'/',&nPos);
	if (rc == SXRET_OK) {
		zCur = &zUri[nPos];
	}
ProcessHost:

	rc = SyByteFind(zUri,(sxu32)(zCur - zUri),'@',&nPos);
	if (rc == SXRET_OK) {
		if (nPos > 0) {
			sxu32 nPassOfft;
			pComp = &pOut->sUser;
			SyStringInitFromBuf(pComp,zUri,nPos);

			rc = SyByteFind(zUri,(sxu32)(zCur - zUri),':',&nPassOfft);
			if (rc == SXRET_OK && nPassOfft < nPos) {
				pComp->nByte = nPassOfft;
				pComp = &pOut->sPass;
				pComp->zString = &zUri[nPassOfft + sizeof(char)];
				pComp->nByte = nPos - nPassOfft - 1;
			}

			zUri = &zUri[nPos + 1];
		}
		else {
			zUri++;
		}
	}
	pComp = &pOut->sHost;
	while (zUri < zCur && SyisSpace(zUri[0])) {
		zUri++;
	}
	SyStringInitFromBuf(pComp,zUri,(sxu32)(zCur - zUri));
	if (pComp->zString[0] == '[') {

		zUri++; pComp->zString++; pComp->nByte = 0;
		while (((unsigned char)zUri[0] < 0xc0 && SyisHex(zUri[0])) || zUri[0] == ':') {
			zUri++; pComp->nByte++;
		}
		if (zUri[0] != ']') {
			return SXERR_CORRUPT;
		}
		zUri++;
		bIPv6 = TRUE;
	}

	rc = SyByteFind(zUri,(sxu32)(zCur - zUri),':',&nPos);
	if (rc == SXRET_OK) {
		if (bIPv6 == FALSE) {
			pComp->nByte = (sxu32)(&zUri[nPos] - zUri);
		}
		pComp = &pOut->sPort;
		SyStringInitFromBuf(pComp,&zUri[nPos + 1],(sxu32)(zCur - &zUri[nPos + 1]));
	}
	if (bHostOnly == TRUE) {
		return SXRET_OK;
	}
PathSplit:
	zUri = zCur;
	pComp = &pOut->sPath;
	SyStringInitFromBuf(pComp,zUri,(sxu32)(zEnd - zUri));
	if (pComp->nByte == 0) {
		return SXRET_OK;
	}
	if (SXRET_OK == SyByteFind(zUri,(sxu32)(zEnd - zUri),'?',&nPos)) {
		pComp->nByte = nPos;
		pComp = &pOut->sQuery;
		SyStringInitFromBuf(pComp,&zUri[nPos + 1],(sxu32)(zEnd - &zUri[nPos + 1]));
	}
	if (SXRET_OK == SyByteFind(zUri,(sxu32)(zEnd - zUri),'#',&nPos)) {

		if (pComp == &pOut->sPath) {
			pComp->nByte = nPos;
		}
		else {
			if (&zUri[nPos] < (char*)SyStringData(pComp)) {

				return SXERR_SYNTAX;
			}
			pComp->nByte -= (sxu32)(zEnd - &zUri[nPos]);
		}
		pComp = &pOut->sFragment;
		SyStringInitFromBuf(pComp,&zUri[nPos + 1],(sxu32)(zEnd - &zUri[nPos + 1]))
	}
	return SXRET_OK;
}

static sxi32 VmGetNextLine(SyString* pCursor,SyString* pCurrent)
{
	const char* zIn;
	sxu32 nPos;

	SyStringLeftTrim(pCursor);
	if (pCursor->nByte < 1) {
		SyStringInitFromBuf(pCurrent,0,0);
		return SXERR_EOF;
	}
	zIn = SyStringData(pCursor);
	if (SXRET_OK != SyByteListFind(pCursor->zString,pCursor->nByte,"\r\n",&nPos)) {

		SyStringDupPtr(pCurrent,pCursor);
		return SXERR_MORE;
	}
	pCurrent->zString = zIn;
	pCurrent->nByte = nPos;

	pCursor->zString = &zIn[nPos];
	pCursor->nByte -= nPos;
	return SXRET_OK;
}

static sxi32 VmHttpProcessOneHeader(SyhttpHeader* pHdr,SyhttpHeader* pLast,const char* zLine,sxu32 nLen)
{
	SyString* pName;
	sxu32 nPos;
	sxi32 rc;
	if (nLen < 1) {
		return SXERR_NEXT;
	}

	if (pLast && (zLine[-1] == ' ' || zLine[-1] == '\t')) {
		SyString* pTmp = &pLast->sValue;
		SyStringFullTrim(pTmp);
		if (pTmp->nByte == 0) {
			SyStringInitFromBuf(pTmp,zLine,nLen);
		}
		else {

			pTmp->nByte = (sxu32)(&zLine[nLen] - pTmp->zString);
		}

		return SXERR_CONTINUE;
	}

	pName = &pHdr->sName;
	rc = SyByteFind(zLine,nLen,':',&nPos);
	if (rc != SXRET_OK) {
		return SXERR_NEXT;
	}
	SyStringInitFromBuf(pName,zLine,nPos);
	SyStringFullTrim(pName);

	SyStringInitFromBuf(&pHdr->sValue,&zLine[nPos + 1],nLen - nPos - 1);

	SyStringFullTrim(&pHdr->sValue);
	return SXRET_OK;
}

static sxi32 VmHttpExtractHeaders(SyString* pRequest,SySet* pOut)
{
	SyhttpHeader* pLast = 0;
	SyString sCurrent;
	SyhttpHeader sHdr;
	sxu8 bEol;
	sxi32 rc;
	if (SySetUsed(pOut) > 0) {
		pLast = (SyhttpHeader*)SySetAt(pOut,SySetUsed(pOut) - 1);
	}
	bEol = FALSE;
	for (;;) {
		SyZero(&sHdr,sizeof(SyhttpHeader));

		rc = VmGetNextLine(pRequest,&sCurrent);
		if (rc != SXRET_OK) {
			if (sCurrent.nByte < 1) {
				break;
			}
			bEol = TRUE;
		}

		if (SXRET_OK == VmHttpProcessOneHeader(&sHdr,pLast,sCurrent.zString,sCurrent.nByte)) {
			if (SXRET_OK != SySetPut(pOut,(const void*)&sHdr)) {
				break;
			}

			pLast = (SyhttpHeader*)SySetPeek(pOut);
		}
		if (bEol) {
			break;
		}
	}
	return SXRET_OK;
}

static sxi32 VmHttpProcessFirstLine(
	SyString* pRequest,
	sxi32* pMethod,
	SyhttpUri* pUri,
	sxi32* pProto
)
{
	static const char* azMethods[] = { "get","post","head","put" };
	static const sxi32 aMethods[] = { HTTP_METHOD_GET,HTTP_METHOD_POST,HTTP_METHOD_HEAD,HTTP_METHOD_PUT };
	const char* zIn,* zEnd,* zPtr;
	SyString sLine;
	sxu32 nLen;
	sxi32 rc;

	rc = VmGetNextLine(pRequest,&sLine);
	if (rc != SXRET_OK) {
		return rc;
	}
	if (sLine.nByte < 1) {

		return SXERR_EMPTY;
	}

	zIn = sLine.zString;
	zEnd = &zIn[sLine.nByte];
	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}

	zPtr = zIn;
	while (zIn < zEnd && !SyisSpace(zIn[0])) {
		zIn++;
	}
	*pMethod = HTTP_METHOD_OTHR;
	if (zIn > zPtr) {
		sxu32 i;
		nLen = (sxu32)(zIn - zPtr);
		for (i = 0; i < SX_ARRAYSIZE(azMethods); ++i) {
			if (SyStrnicmp(azMethods[i],zPtr,nLen) == 0) {
				*pMethod = aMethods[i];
				break;
			}
		}
	}

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}

	zPtr = zIn;
	while (zIn < zEnd && !SyisSpace(zIn[0])) {
		zIn++;
	}
	if (zIn > zPtr) {
		nLen = (sxu32)(zIn - zPtr);

		VmHttpSplitURI(pUri,zPtr,nLen);
	}

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}

	zPtr = zIn;
	while (zIn < zEnd && !SyisSpace(zIn[0])) {
		zIn++;
	}
	*pProto = HTTP_PROTO_11;
	rc = 1;
	if (zIn > zPtr) {
		rc = SyStrnicmp(zPtr,"http/1.0",(sxu32)(zIn - zPtr));
	}
	if (!rc) {
		*pProto = HTTP_PROTO_10;
	}
	return SXRET_OK;
}

static sxi32 VmHttpSplitEncodedQuery(
	php_vm* pVm,
	SyString* pQuery,
	SyBlob* pWorker,
	int is_post
)
{
	const char* zEnd = &pQuery->zString[pQuery->nByte];
	const char* zIn = pQuery->zString;
	php_value* pGet,* pRequest;
	SyString sName,sValue;
	const char* zPtr;
	sxu32 nBlobOfft;

	if (is_post) {

		pGet = VmExtractSuper(&(*pVm),"_POST",sizeof("_POST") - 1);
	}
	else {

		pGet = VmExtractSuper(&(*pVm),"_GET",sizeof("_GET") - 1);
	}
	pRequest = VmExtractSuper(&(*pVm),"_REQUEST",sizeof("_REQUEST") - 1);

	for (;;) {

		while (zIn < zEnd && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd) {
			break;
		}
		zPtr = zIn;
		while (zPtr < zEnd && zPtr[0] != '=' && zPtr[0] != '&' && zPtr[0] != ';') {
			zPtr++;
		}

		SyBlobReset(pWorker);

		SyUriDecode(zIn,(sxu32)(zPtr - zIn),PHP_VmBlobConsumer,pWorker,TRUE);

		sName.nByte = SyBlobLength(pWorker);
		sValue.zString = 0;
		sValue.nByte = 0;
		if (zPtr < zEnd && zPtr[0] == '=') {
			zPtr++;
			zIn = zPtr;

			while (zPtr < zEnd && zPtr[0] != '&' && zPtr[0] != ';') {
				zPtr++;
			}
			if (zPtr > zIn) {

				nBlobOfft = SyBlobLength(pWorker);
				SyUriDecode(zIn,(sxu32)(zPtr - zIn),PHP_VmBlobConsumer,pWorker,TRUE);
				sValue.zString = (const char*)SyBlobDataAt(pWorker,nBlobOfft);
				sValue.nByte = SyBlobLength(pWorker) - nBlobOfft;

			}

			zIn = zPtr;
		}
		sName.zString = (const char*)SyBlobData(pWorker);

		if (pGet && (pGet->iFlags & MEMOBJ_HASHMAP)) {
			VmHashmapInsert((php_hashmap*)pGet->x.pOther,
				sName.zString,(int)sName.nByte,
				sValue.zString,(int)sValue.nByte
			);
		}
		if (pRequest && (pRequest->iFlags & MEMOBJ_HASHMAP)) {
			VmHashmapInsert((php_hashmap*)pRequest->x.pOther,
				sName.zString,(int)sName.nByte,
				sValue.zString,(int)sValue.nByte
			);
		}

		zIn = &zPtr[1];
	}

	return SXRET_OK;
}

static SyString* VmHttpExtractHeaderValue(SySet* pSet,const char* zMime,sxu32 nByte)
{
	SyhttpHeader* aMime,* pMime;
	SyString sMime;
	sxu32 n;
	SyStringInitFromBuf(&sMime,zMime,nByte);

	aMime = (SyhttpHeader*)SySetBasePtr(pSet);

	for (n = 0; n < SySetUsed(pSet); ++n) {
		pMime = &aMime[n];
		if (SyStringCmp(&sMime,&pMime->sName,SyStrnicmp) == 0) {

			return &pMime->sValue;
		}
	}

	return 0;
}

static sxi32 VmHttpPorcessCookie(php_vm* pVm,SyBlob* pWorker,const char* zIn,sxu32 nByte)
{
	const char* zPtr,* zDelimiter,* zEnd = &zIn[nByte];
	SyString sName,sValue;
	php_value* pCookie;
	sxu32 nOfft;

	pCookie = VmExtractSuper(&(*pVm),"_COOKIE",sizeof("_COOKIE") - 1);
	if (pCookie == 0 || (pCookie->iFlags & MEMOBJ_HASHMAP) == 0) {

		return SXERR_NOTFOUND;
	}
	for (;;) {

		while (zIn < zEnd && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd) {
			break;
		}

		SyBlobReset(pWorker);
		zDelimiter = zIn;

		while (zDelimiter < zEnd && zDelimiter[0] != ';') {
			zDelimiter++;
		}
		zPtr = zIn;
		while (zPtr < zDelimiter && zPtr[0] != '=') {
			zPtr++;
		}

		SyUriDecode(zIn,(sxu32)(zPtr - zIn),PHP_VmBlobConsumer,pWorker,TRUE);
		sName.nByte = SyBlobLength(pWorker);
		zPtr++;
		sValue.zString = 0;
		sValue.nByte = 0;
		if (zPtr < zDelimiter) {

			nOfft = SyBlobLength(pWorker);
			SyUriDecode(zPtr,(sxu32)(zDelimiter - zPtr),PHP_VmBlobConsumer,pWorker,TRUE);
			SyStringInitFromBuf(&sValue,SyBlobDataAt(pWorker,nOfft),SyBlobLength(pWorker) - nOfft);
		}

		zIn = &zDelimiter[1];

		sName.zString = (const char*)SyBlobData(pWorker);
		VmHashmapInsert((php_hashmap*)pCookie->x.pOther,
			sName.zString,(int)sName.nByte,
			sValue.zString,(int)sValue.nByte
		);
	}
	return SXRET_OK;
}

static sxi32 VmHttpProcessRequest(php_vm* pVm,const char* zRequest,int nByte)
{
	SyString* pName,* pValue,sRequest;
	php_value* pHeaderArray;
	SyhttpHeader* pHeader;
	SyhttpUri sUri;
	SyBlob sWorker;
	SySet sHeader;
	sxi32 iMethod;
	sxi32 iVer;
	sxi32 rc;
	SyStringInitFromBuf(&sRequest,zRequest,nByte);
	SySetInit(&sHeader,&pVm->sAllocator,sizeof(SyhttpHeader));
	SyBlobInit(&sWorker,&pVm->sAllocator);

	SyStringFullTrim(&sRequest);

	rc = VmHttpProcessFirstLine(&sRequest,&iMethod,&sUri,&iVer);
	if (rc != SXRET_OK) {
		return rc;
	}

	VmHttpExtractHeaders(&sRequest,&sHeader);


	php_vm_config(pVm,
		PHP_VM_CONFIG_SERVER_ATTR,
		"SERVER_PROTOCOL",
		iVer == HTTP_PROTO_10 ? "HTTP/1.0" : "HTTP/1.1",
		sizeof("HTTP/1.1") - 1
	);

	php_vm_config(pVm,
		PHP_VM_CONFIG_SERVER_ATTR,
		"REQUEST_METHOD",
		iMethod == HTTP_METHOD_GET ? "GET" :
		(iMethod == HTTP_METHOD_POST ? "POST" :
			(iMethod == HTTP_METHOD_PUT ? "PUT" :
				(iMethod == HTTP_METHOD_HEAD ? "HEAD" : "OTHER"))),
		-1
	);
	if (SyStringLength(&sUri.sQuery) > 0 && iMethod == HTTP_METHOD_GET) {
		pValue = &sUri.sQuery;

		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"QUERY_STRING",
			pValue->zString,
			pValue->nByte
		);

		VmHttpSplitEncodedQuery(&(*pVm),pValue,&sWorker,FALSE);
	}

	pValue = &sUri.sRaw;
	php_vm_config(pVm,
		PHP_VM_CONFIG_SERVER_ATTR,
		"REQUEST_URI",
		pValue->zString,
		pValue->nByte
	);

	pValue = &sUri.sPath;
	php_vm_config(pVm,
		PHP_VM_CONFIG_SERVER_ATTR,
		"PATH_INFO",
		pValue->zString,
		pValue->nByte
	);
	php_vm_config(pVm,
		PHP_VM_CONFIG_SERVER_ATTR,
		"ORIG_PATH_INFO",
		pValue->zString,
		pValue->nByte
	);

	pValue = VmHttpExtractHeaderValue(&sHeader,"Accept",sizeof("Accept") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_ACCEPT",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Accept-Charset",sizeof("Accept-Charset") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_ACCEPT_CHARSET",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Accept-Encoding",sizeof("Accept-Encoding") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_ACCEPT_ENCODING",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Accept-Language",sizeof("Accept-Language") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_ACCEPT_LANGUAGE",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Connection",sizeof("Connection") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_CONNECTION",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Host",sizeof("Host") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_HOST",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Referer",sizeof("Referer") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_REFERER",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"User-Agent",sizeof("User-Agent") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"HTTP_USER_AGENT",
			pValue->zString,
			pValue->nByte
		);
	}

	pValue = VmHttpExtractHeaderValue(&sHeader,"Authorization",sizeof("Authorization") - 1);
	if (pValue) {
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"PHP_AUTH_DIGEST",
			pValue->zString,
			pValue->nByte
		);
		php_vm_config(pVm,
			PHP_VM_CONFIG_SERVER_ATTR,
			"PHP_AUTH",
			pValue->zString,
			pValue->nByte
		);
	}

	pHeaderArray = VmExtractSuper(&(*pVm),"_HEADER",sizeof("_HEADER") - 1);

	SySetResetCursor(&sHeader);
	pHeader = 0;
	while (SXRET_OK == SySetGetNextEntry(&sHeader,(void**)&pHeader)) {
		pName = &pHeader->sName;
		pValue = &pHeader->sValue;
		if (pHeaderArray && (pHeaderArray->iFlags & MEMOBJ_HASHMAP)) {

			VmHashmapInsert((php_hashmap*)pHeaderArray->x.pOther,
				pName->zString,(int)pName->nByte,
				pValue->zString,(int)pValue->nByte
			);
		}
		if (pName->nByte == sizeof("Cookie") - 1 && SyStrnicmp(pName->zString,"Cookie",sizeof("Cookie") - 1) == 0
			&& pValue->nByte > 0) {

			VmHttpPorcessCookie(&(*pVm),&sWorker,pValue->zString,pValue->nByte);
		}
	}
	if (iMethod == HTTP_METHOD_POST) {

		pValue = VmHttpExtractHeaderValue(&sHeader,"Content-Type",sizeof("Content-Type") - 1);
		if (pValue && pValue->nByte >= sizeof("application/x-www-form-urlencoded") - 1 &&
			SyMemcmp("application/x-www-form-urlencoded",pValue->zString,pValue->nByte) == 0) {

			pValue = VmHttpExtractHeaderValue(&sHeader,"Content-Length",sizeof("Content-Length") - 1);
			if (pValue) {
				sxi32 iLen = 0;
				SyStrToInt32(pValue->zString,pValue->nByte,(void*)&iLen,0);
				if (iLen > 0) {

					SyStringFullTrim(&sRequest);
					if ((int)sRequest.nByte > iLen) {
						sRequest.nByte = (sxu32)iLen;
					}

					VmHttpSplitEncodedQuery(&(*pVm),&sRequest,&sWorker,TRUE);
				}
			}
		}
	}

	SySetRelease(&sHeader);
	SyBlobRelease(&sWorker);
	return SXRET_OK;
}




#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


PHP_PRIVATE const char* PHP_ExtractDirName(const char* zPath,int nByte,int* pLen)
{
	const char* zEnd = &zPath[nByte - 1]; int c,d;
	c = d = '/';
#ifdef __WINNT__
	d = '\\';
#endif
	while (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {
		zEnd--;
	}
	*pLen = (int)(zEnd - zPath);
#ifdef __WINNT__
	if ((*pLen) == (int)sizeof(char) && zPath[0] == '/') {

		return "\\";
	}
#endif
	if (zEnd == zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {

		*pLen = sizeof(char);
		return ".";
	}
	if ((*pLen) == 0) {
		*pLen = sizeof(char);
#ifdef __WINNT__
		return "\\";
#else
		return "/";
#endif
	}
	return zPath;
}

#ifndef PHP_DISABLE_BUILTIN_FUNC

static int PHP_vfs_chdir(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xChdir == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xChdir(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_chroot(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xChroot == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xChroot(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_getcwd(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs; int rc;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xGetcwd == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	php_result_string(pCtx,"",0);

	rc = pVfs->xGetcwd(pCtx);
	if (rc != PHP_OK) {

		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_vfs_rmdir(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xRmdir == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xRmdir(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_is_dir(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xIsdir == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xIsdir(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_mkdir(php_context* pCtx,int nArg,php_value** apArg)
{
	int iRecursive = 0;
	const char* zPath;
	php_vfs* pVfs; int iMode,rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xMkdir == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);
#ifdef __WINNT__
	iMode = 0;
#else

	iMode = 0777;
#endif
	if (nArg > 1) {
		iMode = php_value_to_int(apArg[1]);
		if (nArg > 2) {
			iRecursive = php_value_to_bool(apArg[2]);
		}
	}

	rc = pVfs->xMkdir(zPath,iMode,iRecursive);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_rename(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zOld,* zNew;
	php_vfs* pVfs; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xRename == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zOld = php_value_to_string(apArg[0],0);
	zNew = php_value_to_string(apArg[1],0);
	rc = pVfs->xRename(zOld,zNew);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_realpath(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xRealpath == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_string(pCtx,"",0);

	zPath = php_value_to_string(apArg[0],0);
	rc = pVfs->xRealpath(zPath,pCtx);
	if (rc != PHP_OK) {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_vfs_sleep(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs; int rc,nSleep;
	if (nArg < 1 || !php_value_is_int(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xSleep == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nSleep = php_value_to_int(apArg[0]);
	if (nSleep < 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = pVfs->xSleep((unsigned int)(nSleep * SX_USEC_PER_SEC));
	if (rc != PHP_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_int(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_vfs_usleep(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs; int nSleep;
	if (nArg < 1 || !php_value_is_int(apArg[0])) {

		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xSleep == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		return PHP_OK;
	}

	nSleep = php_value_to_int(apArg[0]);
	if (nSleep < 0) {

		return PHP_OK;
	}

	pVfs->xSleep((unsigned int)nSleep);
	return PHP_OK;
}

static int PHP_vfs_unlink(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xUnlink == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xUnlink(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_chmod(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int iMode; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xChmod == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iMode = php_value_to_int(apArg[1]);

	rc = pVfs->xChmod(zPath,iMode);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_chown(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath,* zUser;
	php_vfs* pVfs; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xChown == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	zUser = php_value_to_string(apArg[1],0);

	rc = pVfs->xChown(zPath,zUser);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_chgrp(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath,* zGroup;
	php_vfs* pVfs; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xChgrp == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	zGroup = php_value_to_string(apArg[1],0);

	rc = pVfs->xChgrp(zPath,zGroup);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_disk_free_space(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iSize;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFreeSpace == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iSize = pVfs->xFreeSpace(zPath);

	php_result_int64(pCtx,iSize);
	return PHP_OK;
}

static int PHP_vfs_disk_total_space(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iSize;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xTotalSpace == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iSize = pVfs->xTotalSpace(zPath);

	php_result_int64(pCtx,iSize);
	return PHP_OK;
}

static int PHP_vfs_file_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFileExists == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xFileExists(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_file_size(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iSize;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFileSize == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iSize = pVfs->xFileSize(zPath);

	php_result_int64(pCtx,iSize);
	return PHP_OK;
}

static int PHP_vfs_file_atime(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iTime;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFileAtime == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iTime = pVfs->xFileAtime(zPath);

	php_result_int64(pCtx,iTime);
	return PHP_OK;
}

static int PHP_vfs_file_mtime(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iTime;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFileMtime == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iTime = pVfs->xFileMtime(zPath);

	php_result_int64(pCtx,iTime);
	return PHP_OK;
}

static int PHP_vfs_file_ctime(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_int64 iTime;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFileCtime == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	iTime = pVfs->xFileCtime(zPath);

	php_result_int64(pCtx,iTime);
	return PHP_OK;
}

static int PHP_vfs_is_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xIsfile == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xIsfile(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_is_link(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xIslink == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xIslink(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_is_readable(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xReadable == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xReadable(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_is_writable(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xWritable == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xWritable(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_is_executable(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xExecutable == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xExecutable(zPath);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_filetype(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	php_vfs* pVfs;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xFiletype == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	php_result_string(pCtx,"",0);

	pVfs->xFiletype(zPath,pCtx);
	return PHP_OK;
}

static int PHP_vfs_stat(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pValue;
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xStat == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pValue == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xStat(zPath,pArray,pValue);
	if (rc != PHP_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_value(pCtx,pArray);
	}

	return PHP_OK;
}

static int PHP_vfs_lstat(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pValue;
	const char* zPath;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xlStat == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pValue == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],0);

	rc = pVfs->xlStat(zPath,pArray,pValue);
	if (rc != PHP_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_value(pCtx,pArray);
	}

	return PHP_OK;
}

static int PHP_vfs_getenv(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zEnv;
	php_vfs* pVfs; int iLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xGetenv == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zEnv = php_value_to_string(apArg[0],&iLen);

	php_result_bool(pCtx,0);
	if (iLen < 1) {

		return PHP_OK;
	}

	pVfs->xGetenv(zEnv,pCtx);
	return PHP_OK;
}

static int PHP_vfs_putenv(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zName,* zValue;
	char* zSettings,* zEnd;
	php_vfs* pVfs; int iLen,rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zSettings = (char*)php_value_to_string(apArg[0],&iLen);
	if (iLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zEnd = &zSettings[iLen];
	zValue = 0;
	zName = zSettings;
	while (zSettings < zEnd) {
		if (zSettings[0] == '=') {

			zSettings[0] = 0;
			zValue = &zSettings[1];
			break;
		}
		zSettings++;
	}

	if (zValue == 0 || zName[0] == 0 || zValue >= zEnd || zName >= zValue) {

		php_result_bool(pCtx,0);
		if (zSettings < zEnd) {
			zSettings[0] = '=';
		}
		return PHP_OK;
	}
	php_vm_config(pCtx->pVm,PHP_VM_CONFIG_ENV_ATTR,zName,zValue,(int)(zEnd - zValue));

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xSetenv == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		zSettings[0] = '=';
		return PHP_OK;
	}

	rc = pVfs->xSetenv(zName,zValue);
	php_result_bool(pCtx,rc == PHP_OK);
	zSettings[0] = '=';
	return PHP_OK;
}

static int PHP_vfs_touch(php_context* pCtx,int nArg,php_value** apArg)
{
	php_int64 nTime,nAccess;
	const char* zFile;
	php_vfs* pVfs; int rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xTouch == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nTime = nAccess = -1;
	zFile = php_value_to_string(apArg[0],0);
	if (nArg > 1) {
		nTime = php_value_to_int64(apArg[1]);
		if (nArg > 2) {
			nAccess = php_value_to_int64(apArg[1]);
		}
		else {
			nAccess = nTime;
		}
	}
	rc = pVfs->xTouch(zFile,nTime,nAccess);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}


static int PHP_builtin_dirname(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath,* zDir; int iLen,iDirlen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],&iLen);
	if (iLen < 1) {

		php_result_string(pCtx,".",sizeof(char));
		return PHP_OK;
	}

	zDir = PHP_ExtractDirName(zPath,iLen,&iDirlen);

	php_result_string(pCtx,zDir,iDirlen);
	return PHP_OK;
}

static int PHP_builtin_basename(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath,* zBase,* zEnd; int c,d,iLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	c = d = '/';
#ifdef __WINNT__
	d = '\\';
#endif

	zPath = php_value_to_string(apArg[0],&iLen);
	if (iLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zEnd = &zPath[iLen - 1];

	while (zEnd > zPath && ((int)zEnd[0] == c || (int)zEnd[0] == d)) {
		zEnd--;
	}
	iLen = (int)(&zEnd[1] - zPath);
	while (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {
		zEnd--;
	}
	zBase = (zEnd > zPath) ? &zEnd[1] : zPath;
	zEnd = &zPath[iLen];
	if (nArg > 1 && php_value_is_string(apArg[1])) {
		const char* zSuffix; int nSuffix;

		zSuffix = php_value_to_string(apArg[1],&nSuffix);
		if (nSuffix > 0 && nSuffix < iLen && SyMemcmp(&zEnd[-nSuffix],zSuffix,nSuffix) == 0) {
			zEnd -= nSuffix;
		}
	}

	php_result_string(pCtx,zBase,(int)(zEnd - zBase));
	return PHP_OK;
}

typedef struct path_info path_info;
struct path_info
{
	SyString sDir;
	SyString sBasename;
	SyString sExtension;
	SyString sFilename;
};

static sxi32 ExtractPathInfo(const char* zPath,int nByte,path_info* pOut)
{
	const char* zPtr,* zEnd = &zPath[nByte - 1];
	SyString* pCur; int c,d;
	c = d = '/';
#ifdef __WINNT__
	d = '\\';
#endif

	SyZero(pOut,sizeof(path_info));

	if (nByte == sizeof(char) && ((int)zPath[0] == c || (int)zPath[0] == d)) {
#ifdef __WINNT__
		SyStringInitFromBuf(&pOut->sDir,"\\",sizeof(char));
#else
		SyStringInitFromBuf(&pOut->sDir,"/",sizeof(char));
#endif
		return SXRET_OK;
	}

	while (zEnd > zPath && ((int)zEnd[0] != c && (int)zEnd[0] != d)) {
		zEnd--;
	}
	zPtr = (zEnd > zPath) ? &zEnd[1] : zPath;
	zEnd = &zPath[nByte];

	pCur = &pOut->sDir;
	SyStringInitFromBuf(pCur,zPath,zPtr - zPath);
	if (pCur->nByte > 1) {
		SyStringTrimTrailingChar(pCur,'/');
#ifdef __WINNT__
		SyStringTrimTrailingChar(pCur,'\\');
#endif
	}
	else if ((int)zPath[0] == c || (int)zPath[0] == d) {
#ifdef __WINNT__
		SyStringInitFromBuf(&pOut->sDir,"\\",sizeof(char));
#else
		SyStringInitFromBuf(&pOut->sDir,"/",sizeof(char));
#endif
	}

	pCur = &pOut->sBasename;
	SyStringInitFromBuf(pCur,zPtr,zEnd - zPtr);
	SyStringTrimLeadingChar(pCur,'/');
#ifdef __WINNT__
	SyStringTrimLeadingChar(pCur,'\\');
#endif
	SyStringDupPtr(&pOut->sFilename,pCur);
	if (pCur->nByte > 0) {

		zEnd--;
		while (zEnd > pCur->zString  && zEnd[0] != '.') {
			zEnd--;
		}
		if (zEnd > pCur->zString) {
			zEnd++;
			SyStringInitFromBuf(&pOut->sExtension,zEnd,&zPath[nByte] - zEnd);

			pCur = &pOut->sFilename;
			if (pCur->nByte > SyStringLength(&pOut->sExtension)) {
				pCur->nByte -= 1 + SyStringLength(&pOut->sExtension);
			}
		}
	}
	return SXRET_OK;
}

static int PHP_builtin_pathinfo(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zPath;
	path_info sInfo;
	SyString* pComp; int iLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],&iLen);
	if (iLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	ExtractPathInfo(zPath,iLen,&sInfo);
	if (nArg > 1 && php_value_is_int(apArg[1])) {

		int nComp = php_value_to_int(apArg[1]);
		switch (nComp) {
		case 1:
			pComp = &sInfo.sDir;
			if (pComp->nByte > 0) {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			else {

				php_result_string(pCtx,"",0);
			}
			break;
		case 2:
			pComp = &sInfo.sBasename;
			if (pComp->nByte > 0) {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			else {

				php_result_string(pCtx,"",0);
			}
			break;
		case 3:
			pComp = &sInfo.sExtension;
			if (pComp->nByte > 0) {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			else {

				php_result_string(pCtx,"",0);
			}
			break;
		case 4:
			pComp = &sInfo.sFilename;
			if (pComp->nByte > 0) {
				php_result_string(pCtx,pComp->zString,(int)pComp->nByte);
			}
			else {

				php_result_string(pCtx,"",0);
			}
			break;
		default:

			php_result_string(pCtx,"",0);
			break;
		}
	}
	else {

		php_value* pArray,* pValue;
		pArray = php_context_new_array(pCtx);
		pValue = php_context_new_scalar(pCtx);
		if (pArray == 0 || pValue == 0) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		pComp = &sInfo.sDir;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);

			php_array_add_strkey_elem(pArray,"dirname",pValue);
		}

		php_value_reset_string_cursor(pValue);

		pComp = &sInfo.sBasename;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);

			php_array_add_strkey_elem(pArray,"basename",pValue);
		}

		php_value_reset_string_cursor(pValue);

		pComp = &sInfo.sExtension;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);

			php_array_add_strkey_elem(pArray,"extension",pValue);
		}

		php_value_reset_string_cursor(pValue);

		pComp = &sInfo.sFilename;
		if (pComp->nByte > 0) {
			php_value_string(pValue,pComp->zString,(int)pComp->nByte);

			php_array_add_strkey_elem(pArray,"filename",pValue);
		}

		php_result_value(pCtx,pArray);

	}
	return PHP_OK;
}

typedef unsigned char u8;

static const unsigned char sqlite3UpperToLower[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255};
#define GlogUpperToLower(A)     if( A<0x80 ){ A = sqlite3UpperToLower[A]; }

#define SQLITE_SKIP_UTF8(zIn) {                        \
			if( (*(zIn++))>=0xc0 ){                              \
			while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \
			}                                                    \
		}

static int patternCompare(
	const u8* zPattern,
	const u8* zString,
	const int esc,
	int noCase
) {
	int c,c2; int invert; int seen;
	u8 matchOne = '?';
	u8 matchAll = '*';
	u8 matchSet = '['; int prevEscape = 0;

	if (!zPattern || !zString) return 0;
	while ((c = PHP_Utf8Read(zPattern,0,&zPattern)) != 0) {
		if (!prevEscape && c == matchAll) {
			while ((c = PHP_Utf8Read(zPattern,0,&zPattern)) == matchAll
				|| c == matchOne) {
				if (c == matchOne && PHP_Utf8Read(zString,0,&zString) == 0) {
					return 0;
				}
			}
			if (c == 0) {
				return 1;
			}
			else if (c == esc) {
				c = PHP_Utf8Read(zPattern,0,&zPattern);
				if (c == 0) {
					return 0;
				}
			}
			else if (c == matchSet) {
				if ((esc == 0) || (matchSet < 0x80)) return 0;
				while (*zString && patternCompare(&zPattern[-1],zString,esc,noCase) == 0) {
					SQLITE_SKIP_UTF8(zString);
				}
				return *zString != 0;
			}
			while ((c2 = PHP_Utf8Read(zString,0,&zString)) != 0) {
				if (noCase) {
					GlogUpperToLower(c2);
					GlogUpperToLower(c);
					while (c2 != 0 && c2 != c) {
						c2 = PHP_Utf8Read(zString,0,&zString);
						GlogUpperToLower(c2);
					}
				}
				else {
					while (c2 != 0 && c2 != c) {
						c2 = PHP_Utf8Read(zString,0,&zString);
					}
				}
				if (c2 == 0) return 0;
				if (patternCompare(zPattern,zString,esc,noCase)) return 1;
			}
			return 0;
		}
		else if (!prevEscape && c == matchOne) {
			if (PHP_Utf8Read(zString,0,&zString) == 0) {
				return 0;
			}
		}
		else if (c == matchSet) {
			int prior_c = 0;
			if (esc == 0) return 0;
			seen = 0;
			invert = 0;
			c = PHP_Utf8Read(zString,0,&zString);
			if (c == 0) return 0;
			c2 = PHP_Utf8Read(zPattern,0,&zPattern);
			if (c2 == '^') {
				invert = 1;
				c2 = PHP_Utf8Read(zPattern,0,&zPattern);
			}
			if (c2 == ']') {
				if (c == ']') seen = 1;
				c2 = PHP_Utf8Read(zPattern,0,&zPattern);
			}
			while (c2 && c2 != ']') {
				if (c2 == '-' && zPattern[0] != ']' && zPattern[0] != 0 && prior_c > 0) {
					c2 = PHP_Utf8Read(zPattern,0,&zPattern);
					if (c >= prior_c && c <= c2) seen = 1;
					prior_c = 0;
				}
				else {
					if (c == c2) {
						seen = 1;
					}
					prior_c = c2;
				}
				c2 = PHP_Utf8Read(zPattern,0,&zPattern);
			}
			if (c2 == 0 || (seen ^ invert) == 0) {
				return 0;
			}
		}
		else if (esc == c && !prevEscape) {
			prevEscape = 1;
		}
		else {
			c2 = PHP_Utf8Read(zString,0,&zString);
			if (noCase) {
				GlogUpperToLower(c);
				GlogUpperToLower(c2);
			}
			if (c != c2) {
				return 0;
			}
			prevEscape = 0;
		}
	}
	return *zString == 0;
}

static int Glob(const unsigned char* zPattern,const unsigned char* zString,int iEsc,int CaseCompare)
{
	int rc;
	if (iEsc < 0) {
		iEsc = '\\';
	}
	rc = patternCompare(zPattern,zString,iEsc,CaseCompare);
	return rc;
}

static int PHP_builtin_fnmatch(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zPattern; int iEsc = '\\'; int noCase = 0; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPattern = php_value_to_string(apArg[0],0);
	zString = php_value_to_string(apArg[1],0);

	if (nArg > 2 && php_value_is_int(apArg[2])) {
		rc = php_value_to_int(apArg[2]);
		if (rc & 0x01 ) {
			iEsc = 0;
		}
		if (rc & 0x08 ) {
			noCase = 1;
		}
	}

	rc = Glob((const unsigned char*)zPattern,(const unsigned char*)zString,iEsc,noCase);

	php_result_bool(pCtx,rc);
	return PHP_OK;
}

static int PHP_builtin_strglob(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zPattern; int iEsc = '\\'; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPattern = php_value_to_string(apArg[0],0);
	zString = php_value_to_string(apArg[1],0);

	rc = Glob((const unsigned char*)zPattern,(const unsigned char*)zString,iEsc,0);

	php_result_bool(pCtx,rc);
	return PHP_OK;
}

static int PHP_vfs_link(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zTarget,* zLink;
	php_vfs* pVfs; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xLink == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zTarget = php_value_to_string(apArg[0],0);
	zLink = php_value_to_string(apArg[1],0);

	rc = pVfs->xLink(zTarget,zLink,0);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_symlink(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zTarget,* zLink;
	php_vfs* pVfs; int rc;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xLink == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS,PHP is returning FALSE",
			php_function_name(pCtx)
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zTarget = php_value_to_string(apArg[0],0);
	zLink = php_value_to_string(apArg[1],0);

	rc = pVfs->xLink(zTarget,zLink,1);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_vfs_umask(php_context* pCtx,int nArg,php_value** apArg)
{
	int iOld,iNew;
	php_vfs* pVfs;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xUmask == 0) {

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		php_result_int(pCtx,0);
		return PHP_OK;
	}
	iNew = 0;
	if (nArg > 0) {
		iNew = php_value_to_int(apArg[0]);
	}

	iOld = pVfs->xUmask(iNew);

	php_result_int(pCtx,iOld);
	return PHP_OK;
}

static int PHP_vfs_sys_get_temp_dir(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs;

	php_result_string(pCtx,"",0);

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xTempDir == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		return PHP_OK;
	}

	pVfs->xTempDir(pCtx);
	return PHP_OK;
}

static int PHP_vfs_get_current_user(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xUsername == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);

		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
		return PHP_OK;
	}

	pVfs->xUsername(pCtx);
	return PHP_OK;
}

static int PHP_vfs_getmypid(php_context* pCtx,int nArg,php_value** apArg)
{
	php_int64 nProcessId;
	php_vfs* pVfs;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xProcessId == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	nProcessId = (php_int64)pVfs->xProcessId();

	php_result_int64(pCtx,nProcessId);
	return PHP_OK;
}

static int PHP_vfs_getmyuid(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs; int nUid;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xUid == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	nUid = pVfs->xUid();

	php_result_int(pCtx,nUid);
	return PHP_OK;
}

static int PHP_vfs_getmygid(php_context* pCtx,int nArg,php_value** apArg)
{
	php_vfs* pVfs; int nGid;

	pVfs = (php_vfs*)php_context_user_data(pCtx);
	if (pVfs == 0 || pVfs->xGid == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying VFS",
			php_function_name(pCtx)
		);
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	nGid = pVfs->xGid();

	php_result_int(pCtx,nGid);
	return PHP_OK;
}
#ifdef __WINNT__
#include <Windows.h>
#elif defined(__UNIXES__)
#include <sys/utsname.h>
#endif

static int PHP_vfs_php_uname(php_context* pCtx,int nArg,php_value** apArg)
{
#if defined(__WINNT__)
	const char* zName = "Microsoft Windows";
	OSVERSIONINFOW sVer;
#elif defined(__UNIXES__)
	struct utsname sName;
#endif
	const char* zMode = "a";
	if (nArg > 0 && php_value_is_string(apArg[0])) {

		zMode = php_value_to_string(apArg[0],0);
	}
#if defined(__WINNT__)
	sVer.dwOSVersionInfoSize = sizeof(sVer);
	if (TRUE != GetVersionExW(&sVer)) {
		php_result_string(pCtx,zName,-1);
		return PHP_OK;
	}
	if (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT) {
		if (sVer.dwMajorVersion <= 4) {
			zName = "Microsoft Windows NT";
		}
		else if (sVer.dwMajorVersion == 5) {
			switch (sVer.dwMinorVersion) {
			case 0:	zName = "Microsoft Windows 2000"; break;
			case 1: zName = "Microsoft Windows XP";   break;
			case 2: zName = "Microsoft Windows Server 2003"; break;
			}
		}
		else if (sVer.dwMajorVersion == 6) {
			switch (sVer.dwMinorVersion) {
			case 0: zName = "Microsoft Windows Vista"; break;
			case 1: zName = "Microsoft Windows 7"; break;
			case 2: zName = "Microsoft Windows Server 2008"; break;
			case 3: zName = "Microsoft Windows 8"; break;
			default: break;
			}
		}
	}
	switch (zMode[0]) {
	case 's':

		php_result_string(pCtx,zName,-1);
		break;
	case 'n':

		php_result_string(pCtx,"localhost",(int)sizeof("localhost") - 1);
		break;
	case 'r':
	case 'v':

		php_result_string_format(pCtx,"%u.%u build %u",
			sVer.dwMajorVersion,sVer.dwMinorVersion,sVer.dwBuildNumber
		);
		break;
	case 'm':

		php_result_string(pCtx,"x86",(int)sizeof("x86") - 1);
		break;
	default:
		php_result_string_format(pCtx,"%s localhost %u.%u build %u x86",
			zName,
			sVer.dwMajorVersion,sVer.dwMinorVersion,sVer.dwBuildNumber
		);
		break;
	}
#elif defined(__UNIXES__)
	if (uname(&sName) != 0) {
		php_result_string(pCtx,"Unix",(int)sizeof("Unix") - 1);
		return PHP_OK;
	}
	switch (zMode[0]) {
	case 's':

		php_result_string(pCtx,sName.sysname,-1);
		break;
	case 'n':

		php_result_string(pCtx,sName.nodename,-1);
		break;
	case 'r':

		php_result_string(pCtx,sName.release,-1);
		break;
	case 'v':

		php_result_string(pCtx,sName.version,-1);
		break;
	case 'm':

		php_result_string(pCtx,sName.machine,-1);
		break;
	default:
		php_result_string_format(pCtx,
			"%s %s %s %s %s",
			sName.sysname,
			sName.release,
			sName.version,
			sName.nodename,
			sName.machine
		);
		break;
	}
#else
	php_result_string(pCtx,"Unknown Operating System",(int)sizeof("Unknown Operating System") - 1);
#endif
	return PHP_OK;
}

typedef struct io_private io_private;
struct io_private
{
	const php_io_stream* pStream;
	void* pHandle;

	SyBlob sBuffer;
	sxu32 nOfft;
	sxu32 iMagic;
};
#define IO_PRIVATE_MAGIC 0xFEAC14

#define IO_PRIVATE_INVALID(IO) ( IO == 0 || IO->iMagic != IO_PRIVATE_MAGIC )

static void ResetIOPrivate(io_private* pDev);

static int PHP_builtin_ftruncate(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int rc;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xTrunc == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = pStream->xTrunc(pDev->pHandle,php_value_to_int64(apArg[1]));
	if (rc == PHP_OK) {

		ResetIOPrivate(pDev);
	}

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_builtin_fseek(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	php_int64 iOfft; int whence; int rc;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xSeek == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	iOfft = php_value_to_int64(apArg[1]);
	whence = 0;
	if (nArg > 2 && php_value_is_int(apArg[2])) {
		whence = php_value_to_int(apArg[2]);
	}

	rc = pStream->xSeek(pDev->pHandle,iOfft,whence);
	if (rc == PHP_OK) {

		ResetIOPrivate(pDev);
	}

	php_result_int(pCtx,rc == PHP_OK ? 0 : -1);
	return PHP_OK;
}

static int PHP_builtin_ftell(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	php_int64 iOfft;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xTell == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	iOfft = pStream->xTell(pDev->pHandle);

	php_result_int64(pCtx,iOfft);
	return PHP_OK;
}

static int PHP_builtin_rewind(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xSeek == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = pStream->xSeek(pDev->pHandle,0,0);
	if (rc == PHP_OK) {

		ResetIOPrivate(pDev);
	}

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_builtin_fflush(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xSync == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = pStream->xSync(pDev->pHandle);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_builtin_feof(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,1);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,1);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,1);
		return PHP_OK;
	}
	rc = SXERR_EOF;

	if (SyBlobLength(&pDev->sBuffer) - pDev->nOfft > 0) {

		rc = PHP_OK;
	}
	else {
		char zBuf[4096];
		php_int64 n;

		n = pStream->xRead(pDev->pHandle,zBuf,sizeof(zBuf));
		if (n > 0) {

			SyBlobAppend(&pDev->sBuffer,zBuf,(sxu32)n);
			rc = PHP_OK;
		}
	}

	php_result_bool(pCtx,rc == SXERR_EOF);
	return PHP_OK;
}

static php_int64 StreamRead(io_private* pDev,void* pBuf,php_int64 nLen)
{
	const php_io_stream* pStream = pDev->pStream;
	char* zBuf = (char*)pBuf;
	php_int64 n,nRead;
	n = SyBlobLength(&pDev->sBuffer) - pDev->nOfft;
	if (n > 0) {
		if (n > nLen) {
			n = nLen;
		}

		SyMemcpy(SyBlobDataAt(&pDev->sBuffer,pDev->nOfft),pBuf,(sxu32)n);

		pDev->nOfft += (sxu32)n;
		if (pDev->nOfft >= SyBlobLength(&pDev->sBuffer)) {

			SyBlobReset(&pDev->sBuffer);
			pDev->nOfft = 0;
		}
		nLen -= n;
		if (nLen < 1) {

			return n;
		}

		zBuf += n;
	}

	nRead = pStream->xRead(pDev->pHandle,zBuf,nLen);
	if (nRead > 0) {
		n += nRead;
	}
	else if (n < 1) {

		return nRead;
	}
	return n;
}

static sxi32 GetLine(io_private* pDev,php_int64* pLen,const char** pzLine)
{
	const char* zIn,* zEnd,* zPtr;
	zIn = (const char*)SyBlobDataAt(&pDev->sBuffer,pDev->nOfft);
	zEnd = &zIn[SyBlobLength(&pDev->sBuffer) - pDev->nOfft];
	zPtr = zIn;
	while (zIn < zEnd) {
		if (zIn[0] == '\n') {

			zIn++;
			*pLen = (php_int64)(zIn - zPtr);
			*pzLine = zPtr;
			return SXRET_OK;
		}
		zIn++;
	}

	return SXERR_NOTFOUND;
}

static php_int64 StreamReadLine(io_private* pDev,const char** pzData,php_int64 nMaxLen)
{
	const php_io_stream* pStream = pDev->pStream;
	char zBuf[8192];
	php_int64 n;
	sxi32 rc;
	n = 0;
	if (pDev->nOfft >= SyBlobLength(&pDev->sBuffer)) {

		SyBlobReset(&pDev->sBuffer);
		pDev->nOfft = 0;
	}
	if (SyBlobLength(&pDev->sBuffer) - pDev->nOfft > 0) {

		rc = GetLine(pDev,&n,pzData);
		if (rc == SXRET_OK) {

			pDev->nOfft += (sxu32)n;
			return n;
		}
	}

	for (;;) {
		n = pStream->xRead(pDev->pHandle,zBuf,(nMaxLen > 0 && nMaxLen < sizeof(zBuf)) ? nMaxLen : sizeof(zBuf));
		if (n < 1) {

			break;
		}

		SyBlobAppend(&pDev->sBuffer,zBuf,(sxu32)n);

		rc = GetLine(pDev,&n,pzData);
		if (rc == SXRET_OK) {

			pDev->nOfft += (sxu32)n;
			return n;
		}
		if (nMaxLen > 0 && (SyBlobLength(&pDev->sBuffer) - pDev->nOfft >= nMaxLen)) {

			*pzData = (const char*)SyBlobDataAt(&pDev->sBuffer,pDev->nOfft);
			n = SyBlobLength(&pDev->sBuffer) - pDev->nOfft;

			SyBlobReset(&pDev->sBuffer);
			pDev->nOfft = 0;
			return n;
		}
	}
	if (SyBlobLength(&pDev->sBuffer) - pDev->nOfft > 0) {

		*pzData = (const char*)SyBlobDataAt(&pDev->sBuffer,pDev->nOfft);
		n = SyBlobLength(&pDev->sBuffer) - pDev->nOfft;

		SyBlobReset(&pDev->sBuffer);
		pDev->nOfft = 0;
	}
	return n;
}

PHP_PRIVATE void* PHP_StreamOpenHandle(php_vm* pVm,const php_io_stream* pStream,const char* zFile,
	int iFlags,int use_include,php_value* pResource,int bPushInclude,int* pNew)
{
	void* pHandle = 0;
	SyString sFile; int rc;
	if (pStream == 0) {

		return 0;
	}
	SyStringInitFromBuf(&sFile,zFile,SyStrlen(zFile));
	if (use_include) {
		if (sFile.zString[0] == '/' ||
#ifdef __WINNT__
		(sFile.nByte > 2 && sFile.zString[1] == ':' && (sFile.zString[2] == '\\' || sFile.zString[2] == '/')) ||
#endif
			(sFile.nByte > 1 && sFile.zString[0] == '.' && sFile.zString[1] == '/') ||
			(sFile.nByte > 2 && sFile.zString[0] == '.' && sFile.zString[1] == '.' && sFile.zString[2] == '/')) {

			rc = pStream->xOpen(zFile,iFlags,pResource,&pHandle);
		}
		else {
			SyString* pPath;
			SyBlob sWorker;
#ifdef __WINNT__
			static const int c = '\\';
#else
			static const int c = '/';
#endif

			SyBlobInit(&sWorker,&pVm->sAllocator);

			SySetResetCursor(&pVm->aPaths);
			rc = SXERR_IO;
			while (SXRET_OK == SySetGetNextEntry(&pVm->aPaths,(void**)&pPath)) {

				SyBlobFormat(&sWorker,"%z%c%z",pPath,c,&sFile);

				if (SXRET_OK != SyBlobNullAppend(&sWorker)) {
					continue;
				}

				rc = pStream->xOpen((const char*)SyBlobData(&sWorker),iFlags,pResource,&pHandle);
				if (rc == PHP_OK) {
					if (bPushInclude) {

						PHP_VmPushFilePath(pVm,(const char*)SyBlobData(&sWorker),SyBlobLength(&sWorker),FALSE,pNew);
					}
					break;
				}

				SyBlobReset(&sWorker);

			}
			SyBlobRelease(&sWorker);
		}
		if (rc == PHP_OK) {
			if (bPushInclude) {

				PHP_VmPushFilePath(pVm,sFile.zString,sFile.nByte,FALSE,pNew);
			}
		}
	}
	else {

		rc = pStream->xOpen(zFile,iFlags,pResource,&pHandle);
	}
	if (rc != PHP_OK) {

		return 0;
	}

	return pHandle;
}

PHP_PRIVATE sxi32 PHP_StreamReadWholeFile(void* pHandle,const php_io_stream* pStream,SyBlob* pOut)
{
	php_int64 nRead;
	char zBuf[8192]; int rc;

	for (;;) {
		nRead = pStream->xRead(pHandle,zBuf,sizeof(zBuf));
		if (nRead < 1) {

			break;
		}

		rc = SyBlobAppend(pOut,zBuf,(sxu32)nRead);
		if (rc != SXRET_OK) {
			break;
		}
	}
	return SyBlobLength(pOut) > 0 ? SXRET_OK : -1;
}

PHP_PRIVATE void PHP_StreamCloseHandle(const php_io_stream* pStream,void* pHandle)
{
	if (pStream->xClose) {
		pStream->xClose(pHandle);
	}
}

static int PHP_builtin_fgetc(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int c,n;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	n = (int)StreamRead(pDev,(void*)&c,sizeof(char));

	if (n < 1) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_string(pCtx,(const char*)&c,sizeof(char));
	}
	return PHP_OK;
}

static int PHP_builtin_fgets(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zLine;
	io_private* pDev;
	php_int64 n,nLen;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = -1;
	if (nArg > 1) {

		nLen = php_value_to_int64(apArg[1]);
	}

	n = StreamReadLine(pDev,&zLine,nLen);
	if (n < 1) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_string(pCtx,zLine,(int)n);
	}
	return PHP_OK;
}

static int PHP_builtin_fread(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	php_int64 nRead;
	void* pBuf; int nLen;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = 4096;
	if (nArg > 1) {
		nLen = php_value_to_int(apArg[1]);
		if (nLen < 1) {

			nLen = 4096;
		}
	}

	pBuf = php_context_alloc_chunk(pCtx,(unsigned int)nLen,FALSE,FALSE);
	if (pBuf == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nRead = StreamRead(pDev,pBuf,(php_int64)nLen);
	if (nRead < 1) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_string(pCtx,(const char*)pBuf,(int)nRead);
	}

	php_context_free_chunk(pCtx,pBuf);
	return PHP_OK;
}

static int PHP_builtin_fgetcsv(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zLine;
	io_private* pDev;
	php_int64 n,nLen;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = -1;
	if (nArg > 1) {

		nLen = php_value_to_int64(apArg[1]);
	}

	n = StreamReadLine(pDev,&zLine,nLen);
	if (n < 1) {

		php_result_bool(pCtx,0);
	}
	else {
		php_value* pArray; int delim = ','; int encl = '"'; int escape = '\\';
		if (nArg > 2) {
			const char* zPtr; int i;
			if (php_value_is_string(apArg[2])) {

				zPtr = php_value_to_string(apArg[2],&i);
				if (i > 0) {
					delim = zPtr[0];
				}
			}
			if (nArg > 3) {
				if (php_value_is_string(apArg[3])) {

					zPtr = php_value_to_string(apArg[3],&i);
					if (i > 0) {
						encl = zPtr[0];
					}
				}
				if (nArg > 4) {
					if (php_value_is_string(apArg[4])) {

						zPtr = php_value_to_string(apArg[4],&i);
						if (i > 0) {
							escape = zPtr[0];
						}
					}
				}
			}
		}

		pArray = php_context_new_array(pCtx);
		if (pArray == 0) {
			php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
			php_result_null(pCtx);
			return PHP_OK;
		}

		PHP_ProcessCsv(zLine,(int)n,delim,encl,escape,PHP_CsvConsumer,pArray);

		php_result_value(pCtx,pArray);
	}
	return PHP_OK;
}

static int PHP_builtin_fgetss(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zLine;
	io_private* pDev;
	php_int64 n,nLen;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = -1;
	if (nArg > 1) {

		nLen = php_value_to_int64(apArg[1]);
	}

	n = StreamReadLine(pDev,&zLine,nLen);
	if (n < 1) {

		php_result_bool(pCtx,0);
	}
	else {
		const char* zTaglist = 0; int nTaglen = 0;
		if (nArg > 2 && php_value_is_string(apArg[2])) {

			zTaglist = php_value_to_string(apArg[2],&nTaglen);
		}

		PHP_StripTagsFromString(pCtx,zLine,(int)n,zTaglist,nTaglen);
	}
	return PHP_OK;
}

static int PHP_builtin_readdir(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xReadDir == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	php_result_bool(pCtx,0);

	rc = pStream->xReadDir(pDev->pHandle,pCtx);
	if (rc != PHP_OK) {

		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_rewinddir(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xRewindDir == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream->xRewindDir(pDev->pHandle);
	return PHP_OK;
}

static void InitIOPrivate(php_vm* pVm,const php_io_stream* pStream,io_private* pOut);
static void ReleaseIOPrivate(php_context* pCtx,io_private* pDev);

static int PHP_builtin_closedir(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xCloseDir == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream->xCloseDir(pDev->pHandle);

	ReleaseIOPrivate(pCtx,pDev);
	PHP_MemObjRelease(apArg[0]);
	return PHP_OK;
}

static int PHP_builtin_opendir(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zPath;
	io_private* pDev; int iLen,rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a directory path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zPath = php_value_to_string(apArg[0],&iLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zPath,iLen);
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"No stream device is associated with the given path(%s)",zPath);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (pStream->xOpenDir == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device",
			php_function_name(pCtx),pStream->zName
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_context_alloc_chunk(pCtx,sizeof(io_private),TRUE,FALSE);
	if (pDev == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	InitIOPrivate(pCtx->pVm,pStream,pDev);

	rc = pStream->xOpenDir(zPath,nArg > 1 ? apArg[1] : 0,&pDev->pHandle);
	if (rc != PHP_OK) {

		ReleaseIOPrivate(pCtx,pDev);
		php_result_bool(pCtx,0);
	}
	else {

		php_result_resource(pCtx,pDev);
	}
	return PHP_OK;
}

static int PHP_builtin_readfile(php_context* pCtx,int nArg,php_value** apArg)
{
	int use_include = FALSE;
	const php_io_stream* pStream;
	php_int64 n,nRead;
	const char* zFile;
	char zBuf[8192];
	void* pHandle; int rc,nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {
		use_include = php_value_to_bool(apArg[1]);
	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,
		use_include,nArg > 2 ? apArg[2] : 0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nRead = 0;
	for (;;) {
		n = pStream->xRead(pHandle,zBuf,sizeof(zBuf));
		if (n < 1) {

			break;
		}

		rc = php_context_output(pCtx,zBuf,(int)n);
		if (rc == PHP_ABORT) {
			break;
		}

		nRead += n;
	}

	PHP_StreamCloseHandle(pStream,pHandle);

	php_result_int64(pCtx,nRead);
	return PHP_OK;
}

static int PHP_builtin_file_get_contents(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	php_int64 n,nRead,nMaxlen; int use_include = FALSE;
	const char* zFile;
	char zBuf[8192];
	void* pHandle; int nLen;

	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nMaxlen = -1;
	if (nArg > 1) {
		use_include = php_value_to_bool(apArg[1]);
	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,use_include,nArg > 2 ? apArg[2] : 0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 3) {

		n = php_value_to_int64(apArg[3]);
		if (n > 0) {
			if (pStream->xSeek) {

				pStream->xSeek(pHandle,n,0);
			}
		}
		if (nArg > 4) {

			nMaxlen = php_value_to_int64(apArg[4]);
		}
	}

	nRead = 0;
	for (;;) {
		n = pStream->xRead(pHandle,zBuf,
			(nMaxlen > 0 && (nMaxlen < sizeof(zBuf))) ? nMaxlen : sizeof(zBuf));
		if (n < 1) {

			break;
		}

		php_result_string(pCtx,zBuf,(int)n);

		nRead += n;
		if (nMaxlen > 0 && nRead >= nMaxlen) {

			break;
		}
	}

	PHP_StreamCloseHandle(pStream,pHandle);

	if (php_context_result_buf_length(pCtx) < 1) {

		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_file_put_contents(php_context* pCtx,int nArg,php_value** apArg)
{
	int use_include = FALSE;
	const php_io_stream* pStream;
	const char* zFile;
	const char* zData; int iOpenFlags;
	void* pHandle; int iFlags; int nLen;

	if (nArg < 2 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zData = php_value_to_string(apArg[1],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	iOpenFlags = PHP_IO_OPEN_CREATE | PHP_IO_OPEN_RDWR | PHP_IO_OPEN_TRUNC;

	iFlags = 0;
	if (nArg > 2) {
		iFlags = php_value_to_int(apArg[2]);
		if (iFlags & 0x01 ) {
			use_include = TRUE;
		}
		if (iFlags & 0x08 ) {

			iOpenFlags &= ~PHP_IO_OPEN_TRUNC;

			iOpenFlags |= PHP_IO_OPEN_APPEND;
		}
	}
	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,iOpenFlags,use_include,
		nArg > 3 ? apArg[3] : 0,FALSE,FALSE);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (pStream->xWrite) {
		php_int64 n;
		if ((iFlags & 0x01) && pStream->xLock) {

			pStream->xLock(pHandle,1);
		}

		n = pStream->xWrite(pHandle,(const void*)zData,nLen);
		if (n < 1) {

			php_result_bool(pCtx,0);
		}
		else {

			php_result_int64(pCtx,n);
		}
	}
	else {

		php_context_throw_error_format(pCtx,PHP_CTX_ERR,
			"Read-only stream(%s): Cannot perform write operation",
			pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
	}

	PHP_StreamCloseHandle(pStream,pHandle);
	return PHP_OK;
}

static int PHP_builtin_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFile,* zPtr,* zEnd,* zBuf;
	php_value* pArray,* pLine;
	const php_io_stream* pStream; int use_include = 0;
	io_private* pDev;
	php_int64 n; int iFlags; int nLen;

	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_context_alloc_chunk(pCtx,sizeof(io_private),TRUE,FALSE);
	if (pDev == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	InitIOPrivate(pCtx->pVm,pStream,pDev);
	iFlags = 0;
	if (nArg > 1) {
		iFlags = php_value_to_int(apArg[1]);
	}
	if (iFlags & 0x01 ) {
		use_include = TRUE;
	}

	pArray = php_context_new_array(pCtx);
	pLine = php_context_new_scalar(pCtx);
	if (pArray == 0 || pLine == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev->pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,use_include,nArg > 2 ? apArg[2] : 0,FALSE,0);
	if (pDev->pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);

		return PHP_OK;
	}

	for (;;) {

		n = StreamReadLine(pDev,&zBuf,-1);
		if (n < 1) {

			break;
		}

		php_value_reset_string_cursor(pLine);

		zPtr = zBuf;
		zEnd = &zBuf[n];
		if (iFlags & 0x02 ) {

			while (zPtr < zEnd && (zEnd[-1] == '\n'
#ifdef __WINNT__
				|| zEnd[-1] == '\r'
#endif
				)) {
				n--;
				zEnd--;
			}
		}
		if (iFlags & 0x04 ) {

			while (zPtr < zEnd && (unsigned char)zPtr[0] < 0xc0 && SyisSpace(zPtr[0])) {
				zPtr++;
			}
			if (zPtr >= zEnd) {

				continue;
			}
		}
		php_value_string(pLine,zBuf,(int)(zEnd - zBuf));

		php_array_add_elem(pArray,0,pLine);
	}

	PHP_StreamCloseHandle(pStream,pDev->pHandle);

	ReleaseIOPrivate(pCtx,pDev);

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int PHP_builtin_copy(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pSin,* pSout;
	const char* zFile;
	char zBuf[8192];
	void* pIn,* pOut;
	php_int64 n; int nLen;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a source and a destination path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pSin = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pSin == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pIn = PHP_StreamOpenHandle(pCtx->pVm,pSin,zFile,PHP_IO_OPEN_RDONLY,FALSE,nArg > 2 ? apArg[2] : 0,FALSE,0);
	if (pIn == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening source: '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[1],&nLen);

	pSout = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pSout == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		PHP_StreamCloseHandle(pSin,pIn);
		return PHP_OK;
	}
	if (pSout->xWrite == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pSin->zName
		);
		php_result_bool(pCtx,0);
		PHP_StreamCloseHandle(pSin,pIn);
		return PHP_OK;
	}

	pOut = PHP_StreamOpenHandle(pCtx->pVm,pSout,zFile,
		PHP_IO_OPEN_CREATE | PHP_IO_OPEN_TRUNC | PHP_IO_OPEN_RDWR,FALSE,nArg > 2 ? apArg[2] : 0,FALSE,0);
	if (pOut == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening destination: '%s'",zFile);
		php_result_bool(pCtx,0);
		PHP_StreamCloseHandle(pSin,pIn);
		return PHP_OK;
	}

	for (;;) {

		n = pSin->xRead(pIn,zBuf,sizeof(zBuf));
		if (n < 1) {

			break;
		}

		n = pSout->xWrite(pOut,zBuf,n);
		if (n < 1) {

			break;
		}
	}

	PHP_StreamCloseHandle(pSin,pIn);
	PHP_StreamCloseHandle(pSout,pOut);

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int PHP_builtin_fstat(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pValue;
	const php_io_stream* pStream;
	io_private* pDev;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xStat == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pValue == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream->xStat(pDev->pHandle,pArray,pValue);

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int PHP_builtin_fwrite(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zString;
	io_private* pDev; int nLen,n;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xWrite == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[1],&nLen);
	if (nArg > 2) {

		n = php_value_to_int(apArg[2]);
		if (n >= 0 && n < nLen) {
			nLen = n;
		}
	}
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	n = (int)pStream->xWrite(pDev->pHandle,(const void*)zString,nLen);
	if (n < 0) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_int(pCtx,n);
	}
	return PHP_OK;
}

static int PHP_builtin_flock(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev; int nLock; int rc;
	if (nArg < 2 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xLock == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nLock = php_value_to_int(apArg[1]);

	rc = pStream->xLock(pDev->pHandle,nLock);

	php_result_bool(pCtx,rc == PHP_OK);
	return PHP_OK;
}

static int PHP_builtin_fpassthru(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	php_int64 n,nRead;
	char zBuf[8192]; int rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nRead = 0;
	for (;;) {
		n = StreamRead(pDev,zBuf,sizeof(zBuf));
		if (n < 1) {

			break;
		}

		nRead += n;

		rc = php_context_output(pCtx,zBuf,(int)nRead );
		if (rc == PHP_ABORT) {

			break;
		}
	}

	php_result_int64(pCtx,nRead);
	return PHP_OK;
}

struct csv_data
{
	int delimiter; int enclosure;
	io_private* pDev; int iCount;
};

static int csv_write_callback(php_value* pKey,php_value* pValue,void* pUserData)
{
	struct csv_data* pData = (struct csv_data*)pUserData;
	const char* zData; int nLen,c2;
	sxu32 n;

	zData = php_value_to_string(pValue,&nLen);
	if (nLen < 1) {

		return PHP_OK;
	}
	if (pData->iCount > 0) {

		pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)&pData->delimiter,sizeof(char));
	}
	n = 1;
	c2 = 0;
	if (SyByteFind(zData,(sxu32)nLen,pData->delimiter,0) == SXRET_OK ||
		SyByteFind(zData,(sxu32)nLen,pData->enclosure,&n) == SXRET_OK) {
		c2 = 1;
		if (n == 0) {
			c2 = 2;
		}

		pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)&pData->enclosure,sizeof(char));
		if (c2 > 1) {
			pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)&pData->enclosure,sizeof(char));
		}
	}

	if (pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)zData,(php_int64)nLen) < 1) {
		SXUNUSED(pKey);
		return PHP_ABORT;
	}
	if (c2 > 0) {

		pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)&pData->enclosure,sizeof(char));
		if (c2 > 1) {
			pData->pDev->pStream->xWrite(pData->pDev->pHandle,(const void*)&pData->enclosure,sizeof(char));
		}
	}
	pData->iCount++;
	return PHP_OK;
}

static int PHP_builtin_fputcsv(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	struct csv_data sCsv;
	io_private* pDev;
	char* zEol; int eolen;
	if (nArg < 2 || !php_value_is_resource(apArg[0]) || !php_value_is_array(apArg[1])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Missing/Invalid arguments");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0 || pStream->xWrite == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	sCsv.delimiter = ',';
	sCsv.enclosure = '"';
	sCsv.pDev = pDev;
	sCsv.iCount = 0;
	if (nArg > 2) {

		const char* z; int n;
		z = php_value_to_string(apArg[2],&n);
		if (n > 0) {
			sCsv.delimiter = z[0];
		}
		if (nArg > 3) {
			z = php_value_to_string(apArg[3],&n);
			if (n > 0) {
				sCsv.enclosure = z[0];
			}
		}
	}

	php_array_walk(apArg[1],csv_write_callback,&sCsv);

#ifdef __WINNT__
	zEol = "\r\n";
	eolen = (int)sizeof("\r\n") - 1;
#else

	zEol = "\n";
	eolen = (int)sizeof(char);
#endif
	pDev->pStream->xWrite(pDev->pHandle,(const void*)zEol,eolen);
	return PHP_OK;
}

typedef struct fprintf_data fprintf_data;
struct fprintf_data
{
	io_private* pIO;
	php_int64 nCount;
};

static int fprintfConsumer(php_context* pCtx,const char* zInput,int nLen,void* pUserData)
{
	fprintf_data* pFdata = (fprintf_data*)pUserData;
	php_int64 n;

	n = pFdata->pIO->pStream->xWrite(pFdata->pIO->pHandle,(const void*)zInput,nLen);
	if (n < 1) {
		SXUNUSED(pCtx);

		return SXERR_ABORT;
	}

	pFdata->nCount += n;
	return PHP_OK;
}

static int PHP_builtin_fprintf(php_context* pCtx,int nArg,php_value** apArg)
{
	fprintf_data sFdata;
	const char* zFormat;
	io_private* pDev; int nLen;
	if (nArg < 2 || !php_value_is_resource(apArg[0]) || !php_value_is_string(apArg[1])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Invalid arguments");
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (pDev->pStream == 0 || pDev->pStream->xWrite == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device",
			php_function_name(pCtx),pDev->pStream ? pDev->pStream->zName : "null_stream"
		);
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[1],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	sFdata.nCount = 0;
	sFdata.pIO = pDev;

	PHP_InputFormat(fprintfConsumer,pCtx,zFormat,nLen,nArg - 1,&apArg[1],(void*)&sFdata,FALSE);

	php_result_int64(pCtx,sFdata.nCount);
	return PHP_OK;
}

static int PHP_builtin_vfprintf(php_context* pCtx,int nArg,php_value** apArg)
{
	fprintf_data sFdata;
	const char* zFormat;
	php_hashmap* pMap;
	io_private* pDev;
	SySet sArg; int n,nLen;
	if (nArg < 3 || !php_value_is_resource(apArg[0]) || !php_value_is_string(apArg[1]) || !php_value_is_array(apArg[2])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Invalid arguments");
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (pDev->pStream == 0 || pDev->pStream->xWrite == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device",
			php_function_name(pCtx),pDev->pStream ? pDev->pStream->zName : "null_stream"
		);
		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[1],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[2]->x.pOther;

	n = PHP_HashmapValuesToSet(pMap,&sArg);

	sFdata.nCount = 0;
	sFdata.pIO = pDev;

	PHP_InputFormat(fprintfConsumer,pCtx,zFormat,nLen,n,(php_value**)SySetBasePtr(&sArg),(void*)&sFdata,TRUE);

	php_result_int64(pCtx,sFdata.nCount);
	SySetRelease(&sArg);
	return PHP_OK;
}

static int StrModeToFlags(php_context* pCtx,const char* zMode,int nLen)
{
	const char* zEnd = &zMode[nLen]; int iFlag = 0; int c;
	if (nLen < 1) {

		return PHP_IO_OPEN_RDONLY;
	}
	c = zMode[0];
	if (c == 'r' || c == 'R') {

		iFlag = PHP_IO_OPEN_RDONLY;
		zMode++;
		if (zMode < zEnd) {
			c = zMode[0];
			if (c == '+' || c == 'w' || c == 'W') {

				iFlag = PHP_IO_OPEN_RDWR;
			}
		}
	}
	else if (c == 'w' || c == 'W') {

		iFlag = PHP_IO_OPEN_WRONLY | PHP_IO_OPEN_TRUNC | PHP_IO_OPEN_CREATE;
		zMode++;
		if (zMode < zEnd) {
			c = zMode[0];
			if (c == '+' || c == 'r' || c == 'R') {

				iFlag &= ~PHP_IO_OPEN_WRONLY;
				iFlag |= PHP_IO_OPEN_RDWR;
			}
		}
	}
	else if (c == 'a' || c == 'A') {

		iFlag = PHP_IO_OPEN_WRONLY | PHP_IO_OPEN_APPEND | PHP_IO_OPEN_CREATE;
		zMode++;
		if (zMode < zEnd) {
			c = zMode[0];
			if (c == '+') {

				iFlag &= ~PHP_IO_OPEN_WRONLY;
				iFlag |= PHP_IO_OPEN_RDWR;
			}
		}
	}
	else if (c == 'x' || c == 'X') {

		iFlag = PHP_IO_OPEN_WRONLY | PHP_IO_OPEN_EXCL;
		zMode++;
		if (zMode < zEnd) {
			c = zMode[0];
			if (c == '+' || c == 'r' || c == 'R') {

				iFlag &= ~PHP_IO_OPEN_WRONLY;
				iFlag |= PHP_IO_OPEN_RDWR;
			}
		}
	}
	else if (c == 'c' || c == 'C') {

		iFlag = PHP_IO_OPEN_WRONLY | PHP_IO_OPEN_CREATE;
		zMode++;
		if (zMode < zEnd) {
			c = zMode[0];
			if (c == '+') {

				iFlag &= ~PHP_IO_OPEN_WRONLY;
				iFlag |= PHP_IO_OPEN_RDWR;
			}
		}
	}
	else {

		php_context_throw_error(pCtx,PHP_CTX_NOTICE,"Invalid open mode,PHP is assuming a Read-Only open");
		iFlag = PHP_IO_OPEN_RDONLY;
	}
	while (zMode < zEnd) {
		c = zMode[0];
		if (c == 'b' || c == 'B') {
			iFlag &= ~PHP_IO_OPEN_TEXT;
			iFlag |= PHP_IO_OPEN_BINARY;
		}
		else if (c == 't' || c == 'T') {
			iFlag &= ~PHP_IO_OPEN_BINARY;
			iFlag |= PHP_IO_OPEN_TEXT;
		}
		zMode++;
	}
	return iFlag;
}

static void InitIOPrivate(php_vm* pVm,const php_io_stream* pStream,io_private* pOut)
{
	pOut->pStream = pStream;
	SyBlobInit(&pOut->sBuffer,&pVm->sAllocator);
	pOut->nOfft = 0;

	pOut->iMagic = IO_PRIVATE_MAGIC;
}

static void ReleaseIOPrivate(php_context* pCtx,io_private* pDev)
{
	SyBlobRelease(&pDev->sBuffer);
	pDev->iMagic = 0x2126;

	php_context_free_chunk(pCtx,pDev);
}

static void ResetIOPrivate(io_private* pDev)
{
	SyBlobReset(&pDev->sBuffer);
	pDev->nOfft = 0;
}

static int is_php_stream(const php_io_stream* pStream);

static int PHP_builtin_fopen_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zUri,* zMode;
	php_value* pResource;
	io_private* pDev; int iLen,imLen; int iOpenFlags;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path or URL");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zUri = php_value_to_string(apArg[0],&iLen);
	if (nArg > 1) {
		zMode = php_value_to_string(apArg[1],&imLen);
	}
	else {

		zMode = "r";
		imLen = (int)sizeof(char);
	}

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zUri,iLen);
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"No stream device is associated with the given URI(%s)",zUri);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_context_alloc_chunk(pCtx,sizeof(io_private),TRUE,FALSE);
	if (pDev == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pResource = 0;
	if (nArg > 3) {
		pResource = apArg[3];
	}
	else if (is_php_stream(pStream)) {

		pResource = apArg[0];
	}

	InitIOPrivate(pCtx->pVm,pStream,pDev);

	iOpenFlags = StrModeToFlags(pCtx,zMode,imLen);

	pDev->pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zUri,iOpenFlags,
		nArg > 2 ? php_value_to_bool(apArg[2]) : FALSE,pResource,FALSE,0);
	if (pDev->pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zUri);
		php_result_bool(pCtx,0);
		php_context_free_chunk(pCtx,pDev);
		return PHP_OK;
	}

	php_result_resource(pCtx,pDev);
	return PHP_OK;
}

static int PHP_builtin_fclose(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	io_private* pDev;
	php_vm* pVm;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pDev = (io_private*)php_value_to_resource(apArg[0]);

	if (IO_PRIVATE_INVALID(pDev)) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting an IO handle");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pStream = pDev->pStream;
	if (pStream == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_WARNING,
			"IO routine(%s) not implemented in the underlying stream(%s) device,PHP is returning FALSE",
			php_function_name(pCtx),pStream ? pStream->zName : "null_stream"
		);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pVm = pCtx->pVm;

	if (pDev != pVm->pStdin && pDev != pVm->pStdout && pDev != pVm->pStderr) {

		PHP_StreamCloseHandle(pStream,pDev->pHandle);

		ReleaseIOPrivate(pCtx,pDev);

		php_value_release(apArg[0]);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}
#if !defined(PHP_DISABLE_HASH_FUNC)

static int vfsHashConsumer(const void* pData,unsigned int nLen,void* pUserData)
{

	php_result_string((php_context*)pUserData,(const char*)pData,(int)nLen);
	return SXRET_OK;
}

static int PHP_builtin_md5_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	unsigned char zDigest[16]; int raw_output = FALSE;
	const char* zFile;
	MD5Context sCtx;
	char zBuf[8192];
	void* pHandle;
	php_int64 n; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {
		raw_output = php_value_to_bool(apArg[1]);
	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,FALSE,0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	MD5Init(&sCtx);

	for (;;) {
		n = pStream->xRead(pHandle,zBuf,sizeof(zBuf));
		if (n < 1) {

			break;
		}
		MD5Update(&sCtx,(const unsigned char*)zBuf,(unsigned int)n);
	}

	PHP_StreamCloseHandle(pStream,pHandle);

	MD5Final(zDigest,&sCtx);
	if (raw_output) {

		php_result_string(pCtx,(const char*)zDigest,sizeof(zDigest));
	}
	else {

		SyBinToHexConsumer((const void*)zDigest,sizeof(zDigest),vfsHashConsumer,pCtx);
	}
	return PHP_OK;
}

static int PHP_builtin_sha1_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	unsigned char zDigest[20]; int raw_output = FALSE;
	const char* zFile;
	SHA1Context sCtx;
	char zBuf[8192];
	void* pHandle;
	php_int64 n; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 1) {
		raw_output = php_value_to_bool(apArg[1]);
	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,FALSE,0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	SHA1Init(&sCtx);

	for (;;) {
		n = pStream->xRead(pHandle,zBuf,sizeof(zBuf));
		if (n < 1) {

			break;
		}
		SHA1Update(&sCtx,(const unsigned char*)zBuf,(unsigned int)n);
	}

	PHP_StreamCloseHandle(pStream,pHandle);

	SHA1Final(&sCtx,zDigest);
	if (raw_output) {

		php_result_string(pCtx,(const char*)zDigest,sizeof(zDigest));
	}
	else {

		SyBinToHexConsumer((const void*)zDigest,sizeof(zDigest),vfsHashConsumer,pCtx);
	}
	return PHP_OK;
}
#endif

static int PHP_builtin_parse_ini_file(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	const char* zFile;
	SyBlob sContents;
	void* pHandle; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,FALSE,0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	SyBlobInit(&sContents,&pCtx->pVm->sAllocator);

	PHP_StreamReadWholeFile(pHandle,pStream,&sContents);
	if (SyBlobLength(&sContents) < 1) {

		php_result_bool(pCtx,0);
	}
	else {

		PHP_ParseIniString(pCtx,(const char*)SyBlobData(&sContents),SyBlobLength(&sContents),
			nArg > 1 ? php_value_to_bool(apArg[1]) : 0);
	}

	PHP_StreamCloseHandle(pStream,pHandle);

	SyBlobRelease(&sContents);
	return PHP_OK;
}

typedef struct zip_raw_data zip_raw_data;
struct zip_raw_data
{
	int iType;
	union raw_data {
		struct mmap_data {
			void* pMap;
			php_int64 nSize;
			const php_vfs* pVfs;
		}mmap;
		SyBlob sBlob;
	}raw;
};
#define ZIP_RAW_DATA_MMAPED 1
#define ZIP_RAW_DATA_MEMBUF 2

static int PHP_builtin_zip_open(php_context* pCtx,int nArg,php_value** apArg)
{
	const php_io_stream* pStream;
	SyArchive* pArchive;
	zip_raw_data* pRaw;
	const char* zFile;
	SyBlob* pContents;
	void* pHandle; int nLen;
	sxi32 rc;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Expecting a file path");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zFile = php_value_to_string(apArg[0],&nLen);

	pStream = PHP_VmGetStreamDevice(pCtx->pVm,&zFile,nLen);
	if (pStream == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"No such stream device,PHP is returning FALSE");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArchive = (SyArchive*)php_context_alloc_chunk(pCtx,sizeof(SyArchive) + sizeof(zip_raw_data),TRUE,FALSE);
	if (pArchive == 0) {
		php_context_throw_error(pCtx,PHP_CTX_WARNING,"PHP is running out of memory");
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pRaw = (zip_raw_data*)&pArchive[1];

	SyArchiveInit(pArchive,&pCtx->pVm->sAllocator,0,0);

	if (pStream == pCtx->pVm->pDefStream ) {
		const php_vfs* pVfs;

		pVfs = PHP_ExportBuiltinVfs();
		if (pVfs && pVfs->xMmap) {
			rc = pVfs->xMmap(zFile,&pRaw->raw.mmap.pMap,&pRaw->raw.mmap.nSize);
			if (rc == PHP_OK) {

				rc = SyZipExtractFromBuf(pArchive,(const char*)pRaw->raw.mmap.pMap,(sxu32)pRaw->raw.mmap.nSize);
				if (rc != SXRET_OK) {
					if (pVfs->xUnmap) {
						pVfs->xUnmap(pRaw->raw.mmap.pMap,pRaw->raw.mmap.nSize);
					}

					php_context_free_chunk(pCtx,pArchive);

					php_result_bool(pCtx,0);
					return PHP_OK;
				}

				pRaw->iType = ZIP_RAW_DATA_MMAPED;
				pRaw->raw.mmap.pVfs = pVfs;
				goto success;
			}
		}

	}

	pHandle = PHP_StreamOpenHandle(pCtx->pVm,pStream,zFile,PHP_IO_OPEN_RDONLY,FALSE,0,FALSE,0);
	if (pHandle == 0) {
		php_context_throw_error_format(pCtx,PHP_CTX_ERR,"IO error while opening '%s'",zFile);
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pContents = &pRaw->raw.sBlob;
	SyBlobInit(pContents,&pCtx->pVm->sAllocator);

	PHP_StreamReadWholeFile(pHandle,pStream,pContents);

	rc = SXERR_INVALID;
	if (SyBlobLength(pContents) > 0) {

		rc = SyZipExtractFromBuf(pArchive,(const char*)SyBlobData(pContents),SyBlobLength(pContents));
	}
	pRaw->iType = ZIP_RAW_DATA_MEMBUF;

	PHP_StreamCloseHandle(pStream,pHandle);
	if (rc != SXRET_OK) {

		SyBlobRelease(pContents);

		php_context_free_chunk(pCtx,pArchive);

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
success:

	SyArchiveResetLoopCursor(pArchive);

	php_result_resource(pCtx,pArchive);
	return PHP_OK;
}

static int PHP_builtin_zip_close(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchive* pArchive;
	zip_raw_data* pRaw;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");
		return PHP_OK;
	}

	pArchive = (SyArchive*)php_value_to_resource(apArg[0]);

	if (SXARCH_INVALID(pArchive)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");
		return PHP_OK;
	}

	SyArchiveRelease(pArchive);
	pRaw = (zip_raw_data*)&pArchive[1];
	if (pRaw->iType == ZIP_RAW_DATA_MEMBUF) {
		SyBlobRelease(&pRaw->raw.sBlob);
	}
	else {
		const php_vfs* pVfs = pRaw->raw.mmap.pVfs;
		if (pVfs->xUnmap) {

			pVfs->xUnmap(pRaw->raw.mmap.pMap,pRaw->raw.mmap.nSize);
		}
	}

	php_context_free_chunk(pCtx,pArchive);
	return PHP_OK;
}

static int PHP_builtin_zip_read(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pNext = 0;
	SyArchive* pArchive;
	sxi32 rc;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArchive = (SyArchive*)php_value_to_resource(apArg[0]);

	if (SXARCH_INVALID(pArchive)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = SyArchiveGetNextEntry(pArchive,&pNext);
	if (rc != SXRET_OK) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_resource(pCtx,pNext);

		pNext->pUserData = (void*)&pArchive[1];
	}
	return PHP_OK;
}

static int PHP_builtin_zip_entry_open(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	SyArchive* pArchive;
	if (nArg < 2 || !php_value_is_resource(apArg[0]) || !php_value_is_resource(apArg[1])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArchive = (SyArchive*)php_value_to_resource(apArg[0]);

	if (SXARCH_INVALID(pArchive)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[1]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_close(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry->nReadCount = 0;

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_name(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	SyString* pName;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pName = &pEntry->sFileName;
	php_result_string(pCtx,pName->zString,(int)pName->nByte);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_filesize(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_int64(pCtx,(php_int64)pEntry->nByte);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_compressedsize(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	php_result_int64(pCtx,(php_int64)pEntry->nByteCompr);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_read(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	zip_raw_data* pRaw;
	const char* zData; int iLength;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	zData = 0;
	if (pEntry->nReadCount >= pEntry->nByteCompr) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	iLength = 1024;
	if (nArg > 1) {
		iLength = php_value_to_int(apArg[1]);
		if (iLength < 1) {
			iLength = 1024;
		}
	}
	if ((sxu32)iLength > pEntry->nByteCompr - pEntry->nReadCount) {
		iLength = (int)(pEntry->nByteCompr - pEntry->nReadCount);
	}

	pRaw = (zip_raw_data*)pEntry->pUserData;
	if (pRaw->iType == ZIP_RAW_DATA_MEMBUF) {
		zData = (const char*)SyBlobDataAt(&pRaw->raw.sBlob,(pEntry->nOfft + pEntry->nReadCount));
	}
	else {
		const char* zMap = (const char*)pRaw->raw.mmap.pMap;

		zData = &zMap[pEntry->nOfft + pEntry->nReadCount];
	}

	pEntry->nReadCount += iLength;

	php_result_string(pCtx,zData,iLength);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_reset_read_cursor(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry->nReadCount = 0;

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int PHP_builtin_zip_entry_compressionmethod(php_context* pCtx,int nArg,php_value** apArg)
{
	SyArchiveEntry* pEntry;
	if (nArg < 1 || !php_value_is_resource(apArg[0])) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pEntry = (SyArchiveEntry*)php_value_to_resource(apArg[0]);
	if (SXARCH_ENTRY_INVALID(pEntry)) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"Expecting a ZIP archive entry");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	switch (pEntry->nComprMeth) {
	case 0:

		php_result_string(pCtx,"stored",(int)sizeof("stored") - 1);
		break;
	case 8:

		php_result_string(pCtx,"deflate",(int)sizeof("deflate") - 1);
		break;

	case 1:
		php_result_string(pCtx,"shrunk",(int)sizeof("shrunk") - 1);
		break;
	case 2:
	case 3:
	case 4:
	case 5:

		php_result_string(pCtx,"reduced",(int)sizeof("reduced") - 1);
		break;
	case 6:

		php_result_string(pCtx,"implode",(int)sizeof("implode") - 1);
		break;
	default:
		php_result_string(pCtx,"unknown",(int)sizeof("unknown") - 1);
		break;
	}
	return PHP_OK;
}
#endif

static const php_vfs null_vfs = { "null_vfs", PHP_VFS_VERSION, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_DISK_IO
#ifdef __WINNT__


#include <Windows.h>

static WCHAR* utf8ToUnicode(const char* zFilename) {
	int nChar;
	WCHAR* zWideFilename;

	nChar = MultiByteToWideChar(CP_UTF8,0,zFilename,-1,0,0);
	zWideFilename = (WCHAR*)HeapAlloc(GetProcessHeap(),0,nChar * sizeof(zWideFilename[0]));
	if (zWideFilename == 0) {
		return 0;
	}
	nChar = MultiByteToWideChar(CP_UTF8,0,zFilename,-1,zWideFilename,nChar);
	if (nChar == 0) {
		HeapFree(GetProcessHeap(),0,zWideFilename);
		return 0;
	}
	return zWideFilename;
}

static void* convertUtf8Filename(const char* zFilename) {
	void* zConverted;
	zConverted = utf8ToUnicode(zFilename);
	return zConverted;
}

static char* unicodeToUtf8(const WCHAR* zWideFilename) {
	char* zFilename; int nByte;

	nByte = WideCharToMultiByte(CP_UTF8,0,zWideFilename,-1,0,0,0,0);
	zFilename = (char*)HeapAlloc(GetProcessHeap(),0,nByte);
	if (zFilename == 0) {
		return 0;
	}
	nByte = WideCharToMultiByte(CP_UTF8,0,zWideFilename,-1,zFilename,nByte,0,0);
	if (nByte == 0) {
		HeapFree(GetProcessHeap(),0,zFilename);
		return 0;
	}
	return zFilename;
}

static int WinVfs_chdir(const char* zPath)
{
	void* pConverted;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	rc = SetCurrentDirectoryW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	return rc ? PHP_OK : -1;
}

static int WinVfs_getcwd(php_context* pCtx)
{
	WCHAR zDir[2048];
	char* zConverted;
	DWORD rc;

	rc = GetCurrentDirectoryW(sizeof(zDir),zDir);
	if (rc < 1) {
		return -1;
	}
	zConverted = unicodeToUtf8(zDir);
	if (zConverted == 0) {
		return -1;
	}
	php_result_string(pCtx,zConverted,-1);
	HeapFree(GetProcessHeap(),0,zConverted);
	return PHP_OK;
}

static int WinVfs_mkdir(const char* zPath,int mode,int recursive)
{
	void* pConverted;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	mode = 0;
	recursive = 0;
	rc = CreateDirectoryW((LPCWSTR)pConverted,0);
	HeapFree(GetProcessHeap(),0,pConverted);
	return rc ? PHP_OK : -1;
}

static int WinVfs_rmdir(const char* zPath)
{
	void* pConverted;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	rc = RemoveDirectoryW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	return rc ? PHP_OK : -1;
}

static int WinVfs_isdir(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	return (dwAttr & FILE_ATTRIBUTE_DIRECTORY) ? PHP_OK : -1;
}

static int WinVfs_Rename(const char* zOld,const char* zNew)
{
	void* pOld,* pNew;
	BOOL rc = 0;
	pOld = convertUtf8Filename(zOld);
	if (pOld == 0) {
		return -1;
	}
	pNew = convertUtf8Filename(zNew);
	if (pNew) {
		rc = MoveFileW((LPCWSTR)pOld,(LPCWSTR)pNew);
	}
	HeapFree(GetProcessHeap(),0,pOld);
	if (pNew) {
		HeapFree(GetProcessHeap(),0,pNew);
	}
	return rc ? PHP_OK : -1;
}

static int WinVfs_Realpath(const char* zPath,php_context* pCtx)
{
	WCHAR zTemp[2048];
	void* pPath;
	char* zReal;
	DWORD n;
	pPath = convertUtf8Filename(zPath);
	if (pPath == 0) {
		return -1;
	}
	n = GetFullPathNameW((LPCWSTR)pPath,0,0,0);
	if (n > 0) {
		if (n >= sizeof(zTemp)) {
			n = sizeof(zTemp) - 1;
		}
		GetFullPathNameW((LPCWSTR)pPath,n,zTemp,0);
	}
	HeapFree(GetProcessHeap(),0,pPath);
	if (!n) {
		return -1;
	}
	zReal = unicodeToUtf8(zTemp);
	if (zReal == 0) {
		return -1;
	}
	php_result_string(pCtx,zReal,-1);
	HeapFree(GetProcessHeap(),0,zReal);
	return PHP_OK;
}

static int WinVfs_Sleep(unsigned int uSec)
{
	Sleep(uSec / 1000);
	return PHP_OK;
}

static int WinVfs_unlink(const char* zPath)
{
	void* pConverted;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	rc = DeleteFileW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	return rc ? PHP_OK : -1;
}

static php_int64 WinVfs_DiskFreeSpace(const char* zPath)
{
#ifdef _WIN32_WCE

	SXUNUSED(zPath);
	return 0;
#else
	DWORD dwSectPerClust,dwBytesPerSect,dwFreeClusters,dwTotalClusters;
	void* pConverted;
	WCHAR* p;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return 0;
	}
	p = (WCHAR*)pConverted;
	for (; *p; p++) {
		if (*p == '\\' || *p == '/') {
			*p = '\0';
			break;
		}
	}
	rc = GetDiskFreeSpaceW((LPCWSTR)pConverted,&dwSectPerClust,&dwBytesPerSect,&dwFreeClusters,&dwTotalClusters);
	if (!rc) {
		return 0;
	}
	return (php_int64)dwFreeClusters * dwSectPerClust * dwBytesPerSect;
#endif
}

static php_int64 WinVfs_DiskTotalSpace(const char* zPath)
{
#ifdef _WIN32_WCE

	SXUNUSED(zPath);
	return 0;
#else
	DWORD dwSectPerClust,dwBytesPerSect,dwFreeClusters,dwTotalClusters;
	void* pConverted;
	WCHAR* p;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return 0;
	}
	p = (WCHAR*)pConverted;
	for (; *p; p++) {
		if (*p == '\\' || *p == '/') {
			*p = '\0';
			break;
		}
	}
	rc = GetDiskFreeSpaceW((LPCWSTR)pConverted,&dwSectPerClust,&dwBytesPerSect,&dwFreeClusters,&dwTotalClusters);
	if (!rc) {
		return 0;
	}
	return (php_int64)dwTotalClusters * dwSectPerClust * dwBytesPerSect;
#endif
}

static int WinVfs_FileExists(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	return PHP_OK;
}

static HANDLE OpenReadOnly(LPCWSTR pPath)
{
	DWORD dwType = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	DWORD dwAccess = GENERIC_READ;
	DWORD dwCreate = OPEN_EXISTING;
	HANDLE pHandle;
	pHandle = CreateFileW(pPath,dwAccess,dwShare,0,dwCreate,dwType,0);
	if (pHandle == INVALID_HANDLE_VALUE) {
		return 0;
	}
	return pHandle;
}

static php_int64 WinVfs_FileSize(const char* zPath)
{
	DWORD dwLow,dwHigh;
	void* pConverted;
	php_int64 nSize;
	HANDLE pHandle;

	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (pHandle) {
		dwLow = GetFileSize(pHandle,&dwHigh);
		nSize = dwHigh;
		nSize <<= 32;
		nSize += dwLow;
		CloseHandle(pHandle);
	}
	else {
		nSize = -1;
	}
	return nSize;
}
#define TICKS_PER_SECOND 10000000
#define EPOCH_DIFFERENCE 11644473600LL

static php_int64 convertWindowsTimeToUnixTime(LPFILETIME pTime)
{
	php_int64 input,temp;
	input = pTime->dwHighDateTime;
	input <<= 32;
	input += pTime->dwLowDateTime;
	temp = input / TICKS_PER_SECOND;
	temp = temp - EPOCH_DIFFERENCE;
	return temp;
}

static void convertUnixTimeToWindowsTime(php_int64 nUnixtime,LPFILETIME pOut)
{
	php_int64 result = EPOCH_DIFFERENCE;
	result += nUnixtime;
	result *= 10000000LL;
	pOut->dwHighDateTime = (DWORD)(nUnixtime >> 32);
	pOut->dwLowDateTime = (DWORD)nUnixtime;
}

static int WinVfs_Touch(const char* zPath,php_int64 touch_time,php_int64 access_time)
{
	FILETIME sTouch,sAccess;
	void* pConverted;
	void* pHandle;
	BOOL rc = 0;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	if (pHandle) {
		if (touch_time < 0) {
			GetSystemTimeAsFileTime(&sTouch);
		}
		else {
			convertUnixTimeToWindowsTime(touch_time,&sTouch);
		}
		if (access_time < 0) {

			sAccess = sTouch;
		}
		else {
			convertUnixTimeToWindowsTime(access_time,&sAccess);
		}
		rc = SetFileTime(pHandle,&sTouch,&sAccess,0);

		CloseHandle(pHandle);
	}
	HeapFree(GetProcessHeap(),0,pConverted);
	return rc ? PHP_OK : -1;
}

static php_int64 WinVfs_FileAtime(const char* zPath)
{
	BY_HANDLE_FILE_INFORMATION sInfo;
	void* pConverted;
	php_int64 atime;
	HANDLE pHandle;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	if (pHandle) {
		BOOL rc;
		rc = GetFileInformationByHandle(pHandle,&sInfo);
		if (rc) {
			atime = convertWindowsTimeToUnixTime(&sInfo.ftLastAccessTime);
		}
		else {
			atime = -1;
		}
		CloseHandle(pHandle);
	}
	else {
		atime = -1;
	}
	HeapFree(GetProcessHeap(),0,pConverted);
	return atime;
}

static php_int64 WinVfs_FileMtime(const char* zPath)
{
	BY_HANDLE_FILE_INFORMATION sInfo;
	void* pConverted;
	php_int64 mtime;
	HANDLE pHandle;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	if (pHandle) {
		BOOL rc;
		rc = GetFileInformationByHandle(pHandle,&sInfo);
		if (rc) {
			mtime = convertWindowsTimeToUnixTime(&sInfo.ftLastWriteTime);
		}
		else {
			mtime = -1;
		}
		CloseHandle(pHandle);
	}
	else {
		mtime = -1;
	}
	HeapFree(GetProcessHeap(),0,pConverted);
	return mtime;
}

static php_int64 WinVfs_FileCtime(const char* zPath)
{
	BY_HANDLE_FILE_INFORMATION sInfo;
	void* pConverted;
	php_int64 ctime;
	HANDLE pHandle;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	if (pHandle) {
		BOOL rc;
		rc = GetFileInformationByHandle(pHandle,&sInfo);
		if (rc) {
			ctime = convertWindowsTimeToUnixTime(&sInfo.ftCreationTime);
		}
		else {
			ctime = -1;
		}
		CloseHandle(pHandle);
	}
	else {
		ctime = -1;
	}
	HeapFree(GetProcessHeap(),0,pConverted);
	return ctime;
}


static int WinVfs_Stat(const char* zPath,php_value* pArray,php_value* pWorker)
{
	BY_HANDLE_FILE_INFORMATION sInfo;
	void* pConverted;
	HANDLE pHandle;
	BOOL rc;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (pHandle == 0) {
		return -1;
	}
	rc = GetFileInformationByHandle(pHandle,&sInfo);
	CloseHandle(pHandle);
	if (!rc) {
		return -1;
	}

	php_value_int64(pWorker,(php_int64)sInfo.dwVolumeSerialNumber);
	php_array_add_strkey_elem(pArray,"dev",pWorker);

	php_value_int64(pWorker,(php_int64)(((php_int64)sInfo.nFileIndexHigh << 32) | sInfo.nFileIndexLow));
	php_array_add_strkey_elem(pArray,"ino",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"mode",pWorker);

	php_value_int(pWorker,(int)sInfo.nNumberOfLinks);
	php_array_add_strkey_elem(pArray,"nlink",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"uid",pWorker);
	php_array_add_strkey_elem(pArray,"gid",pWorker);
	php_array_add_strkey_elem(pArray,"rdev",pWorker);

	php_value_int64(pWorker,(php_int64)(((php_int64)sInfo.nFileSizeHigh << 32) | sInfo.nFileSizeLow));
	php_array_add_strkey_elem(pArray,"size",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftLastAccessTime));
	php_array_add_strkey_elem(pArray,"atime",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftLastWriteTime));
	php_array_add_strkey_elem(pArray,"mtime",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftCreationTime));
	php_array_add_strkey_elem(pArray,"ctime",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"blksize",pWorker);
	php_array_add_strkey_elem(pArray,"blocks",pWorker);
	return PHP_OK;
}

static int WinVfs_isfile(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	return (dwAttr & (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE)) ? PHP_OK : -1;
}

static int WinVfs_islink(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	return (dwAttr & FILE_ATTRIBUTE_REPARSE_POINT) ? PHP_OK : -1;
}

static int WinVfs_iswritable(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	if ((dwAttr & (FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_NORMAL)) == 0) {

		return -1;
	}
	if (dwAttr & FILE_ATTRIBUTE_READONLY) {

		return -1;
	}

	return PHP_OK;
}

static int WinVfs_isexecutable(const char* zPath)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {
		return -1;
	}
	if ((dwAttr & FILE_ATTRIBUTE_NORMAL) == 0) {

		return -1;
	}

	return PHP_OK;
}

static int WinVfs_Filetype(const char* zPath,php_context* pCtx)
{
	void* pConverted;
	DWORD dwAttr;
	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {

		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
		return -1;
	}
	dwAttr = GetFileAttributesW((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (dwAttr == INVALID_FILE_ATTRIBUTES) {

		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
		return -1;
	}
	if (dwAttr & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE)) {
		php_result_string(pCtx,"file",sizeof("file") - 1);
	}
	else if (dwAttr & FILE_ATTRIBUTE_DIRECTORY) {
		php_result_string(pCtx,"dir",sizeof("dir") - 1);
	}
	else if (dwAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		php_result_string(pCtx,"link",sizeof("link") - 1);
	}
	else if (dwAttr & (FILE_ATTRIBUTE_DEVICE)) {
		php_result_string(pCtx,"block",sizeof("block") - 1);
	}
	else {
		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
	}
	return PHP_OK;
}

static int WinVfs_Getenv(const char* zVar,php_context* pCtx)
{
	char zValue[1024];
	DWORD n;

	n = sizeof(zValue);
	SyMemcpy("Undefined",zValue,sizeof("Undefined") - 1);

	n = GetEnvironmentVariableA(zVar,zValue,sizeof(zValue));
	if (!n) {

		return -1;
	}
	php_result_string(pCtx,zValue,(int)n);
	return PHP_OK;
}

static int WinVfs_Setenv(const char* zName,const char* zValue)
{
	BOOL rc;
	rc = SetEnvironmentVariableA(zName,zValue);
	return rc ? PHP_OK : -1;
}

static int WinVfs_Mmap(const char* zPath,void** ppMap,php_int64* pSize)
{
	DWORD dwSizeLow,dwSizeHigh;
	HANDLE pHandle,pMapHandle;
	void* pConverted,* pView;

	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}
	pHandle = OpenReadOnly((LPCWSTR)pConverted);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (pHandle == 0) {
		return -1;
	}

	dwSizeLow = GetFileSize(pHandle,&dwSizeHigh);

	pMapHandle = CreateFileMappingW(pHandle,0,PAGE_READONLY,dwSizeHigh,dwSizeLow,0);
	if (pMapHandle == 0) {
		CloseHandle(pHandle);
		return -1;
	}
	*pSize = ((php_int64)dwSizeHigh << 32) | dwSizeLow;

	pView = MapViewOfFile(pMapHandle,FILE_MAP_READ,0,0,(SIZE_T)(*pSize));
	if (pView) {

		*ppMap = pView;
	}

	CloseHandle(pMapHandle);
	CloseHandle(pHandle);
	return pView ? PHP_OK : -1;
}

static void WinVfs_Unmap(void* pView,php_int64 nSize)
{
	nSize = 0;
	UnmapViewOfFile(pView);
}

static void WinVfs_TempDir(php_context* pCtx)
{
	CHAR zTemp[1024];
	DWORD n;
	n = GetTempPathA(sizeof(zTemp),zTemp);
	if (n < 1) {

		php_result_string(pCtx,"C:\\Windows\\Temp",-1);
	}
	else {
		php_result_string(pCtx,zTemp,(int)n);
	}
}

static unsigned int WinVfs_ProcessId(void)
{
	DWORD nID = 0;
#ifndef __MINGW32__
	nID = GetProcessId(GetCurrentProcess());
#endif
	return (unsigned int)nID;
}


static const php_vfs sWinVfs = {
	"Windows_vfs",
	PHP_VFS_VERSION,
	WinVfs_chdir,
	0,
	WinVfs_getcwd,
	WinVfs_mkdir,
	WinVfs_rmdir,
	WinVfs_isdir,
	WinVfs_Rename,
	WinVfs_Realpath,
	WinVfs_Sleep,
	WinVfs_unlink,
	WinVfs_FileExists,
	0,
	0,
	0,
	WinVfs_DiskFreeSpace,
	WinVfs_DiskTotalSpace,
	WinVfs_FileSize,
	WinVfs_FileAtime,
	WinVfs_FileMtime,
	WinVfs_FileCtime,
	WinVfs_Stat,
	WinVfs_Stat,
	WinVfs_isfile,
	WinVfs_islink,
	WinVfs_isfile,
	WinVfs_iswritable,
	WinVfs_isexecutable,
	WinVfs_Filetype,
	WinVfs_Getenv,
	WinVfs_Setenv,
	WinVfs_Touch,
	WinVfs_Mmap,
	WinVfs_Unmap,
	0,
	0,
	WinVfs_TempDir,
	WinVfs_ProcessId,
	0,
	0,
	0
};

#ifndef INVALID_SET_FILE_POINTER
# define INVALID_SET_FILE_POINTER ((DWORD)-1)
#endif

static int WinFile_Open(const char* zPath,int iOpenMode,php_value* pResource,void** ppHandle)
{
	DWORD dwType = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS;
	DWORD dwAccess = GENERIC_READ;
	DWORD dwShare,dwCreate;
	void* pConverted;
	HANDLE pHandle;

	pConverted = convertUtf8Filename(zPath);
	if (pConverted == 0) {
		return -1;
	}

	if (iOpenMode & PHP_IO_OPEN_CREATE) {

		dwCreate = OPEN_ALWAYS;
		if (iOpenMode & PHP_IO_OPEN_TRUNC) {

			dwCreate = CREATE_ALWAYS;
		}
	}
	else if (iOpenMode & PHP_IO_OPEN_EXCL) {

		dwCreate = CREATE_NEW;
	}
	else if (iOpenMode & PHP_IO_OPEN_TRUNC) {

		dwCreate = TRUNCATE_EXISTING;
	}
	else {

		dwCreate = OPEN_EXISTING;
	}
	if (iOpenMode & PHP_IO_OPEN_RDWR) {

		dwAccess |= GENERIC_WRITE;
	}
	else if (iOpenMode & PHP_IO_OPEN_WRONLY) {

		dwAccess = GENERIC_WRITE;
	}
	if (iOpenMode & PHP_IO_OPEN_APPEND) {

		dwAccess = FILE_APPEND_DATA;
	}
	if (iOpenMode & PHP_IO_OPEN_TEMP) {

		dwType = FILE_ATTRIBUTE_TEMPORARY;
	}
	dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	pHandle = CreateFileW((LPCWSTR)pConverted,dwAccess,dwShare,0,dwCreate,dwType,0);
	HeapFree(GetProcessHeap(),0,pConverted);
	if (pHandle == INVALID_HANDLE_VALUE) {
		SXUNUSED(pResource);
		return -1;
	}

	*ppHandle = (void*)pHandle;
	return PHP_OK;
}

typedef struct WinDir_Info WinDir_Info;
struct WinDir_Info
{
	HANDLE pDirHandle;
	void* pPath;
	WIN32_FIND_DATAW sInfo; int rc;
};

static int WinDir_Open(const char* zPath,php_value* pResource,void** ppHandle)
{
	WinDir_Info* pDirInfo;
	void* pConverted;
	char* zPrep;
	sxu32 n;

	n = SyStrlen(zPath);
	zPrep = (char*)HeapAlloc(GetProcessHeap(),0,n + sizeof("\\*") + 4);
	if (zPrep == 0) {
		return -1;
	}
	SyMemcpy((const void*)zPath,zPrep,n);
	zPrep[n] = '\\';
	zPrep[n + 1] = '*';
	zPrep[n + 2] = 0;
	pConverted = convertUtf8Filename(zPrep);
	HeapFree(GetProcessHeap(),0,zPrep);
	if (pConverted == 0) {
		return -1;
	}

	pDirInfo = (WinDir_Info*)HeapAlloc(GetProcessHeap(),0,sizeof(WinDir_Info));
	if (pDirInfo == 0) {
		pResource = 0;
		return -1;
	}
	pDirInfo->rc = SXRET_OK;
	pDirInfo->pDirHandle = FindFirstFileW((LPCWSTR)pConverted,&pDirInfo->sInfo);
	if (pDirInfo->pDirHandle == INVALID_HANDLE_VALUE) {

		HeapFree(GetProcessHeap(),0,pConverted);
		HeapFree(GetProcessHeap(),0,pDirInfo);
		return -1;
	}

	pDirInfo->pPath = pConverted;

	*ppHandle = pDirInfo;
	return PHP_OK;
}

static void WinDir_Close(void* pUserData)
{
	WinDir_Info* pDirInfo = (WinDir_Info*)pUserData;
	if (pDirInfo->pDirHandle != INVALID_HANDLE_VALUE) {
		FindClose(pDirInfo->pDirHandle);
	}
	HeapFree(GetProcessHeap(),0,pDirInfo->pPath);
	HeapFree(GetProcessHeap(),0,pDirInfo);
}

static void WinFile_Close(void* pUserData)
{
	HANDLE pHandle = (HANDLE)pUserData;
	CloseHandle(pHandle);
}

static int WinDir_Read(void* pUserData,php_context* pCtx)
{
	WinDir_Info* pDirInfo = (WinDir_Info*)pUserData;
	LPWIN32_FIND_DATAW pData;
	char* zName;
	BOOL rc;
	sxu32 n;
	if (pDirInfo->rc != SXRET_OK) {

		return -1;
	}
	pData = &pDirInfo->sInfo;
	for (;;) {
		zName = unicodeToUtf8(pData->cFileName);
		if (zName == 0) {

			return -1;
		}
		n = SyStrlen(zName);

		if (n > sizeof("..") - 1 || zName[0] != '.' || (n == sizeof("..") - 1 && zName[1] != '.')) {
			break;
		}
		HeapFree(GetProcessHeap(),0,zName);
		rc = FindNextFileW(pDirInfo->pDirHandle,&pDirInfo->sInfo);
		if (!rc) {
			return -1;
		}
	}

	php_result_string(pCtx,zName,-1);
	HeapFree(GetProcessHeap(),0,zName);

	rc = FindNextFileW(pDirInfo->pDirHandle,&pDirInfo->sInfo);
	if (!rc) {
		pDirInfo->rc = SXERR_EOF;
	}
	return PHP_OK;
}

static void WinDir_RewindDir(void* pUserData)
{
	WinDir_Info* pDirInfo = (WinDir_Info*)pUserData;
	FindClose(pDirInfo->pDirHandle);
	pDirInfo->pDirHandle = FindFirstFileW((LPCWSTR)pDirInfo->pPath,&pDirInfo->sInfo);
	if (pDirInfo->pDirHandle == INVALID_HANDLE_VALUE) {
		pDirInfo->rc = SXERR_EOF;
	}
	else {
		pDirInfo->rc = SXRET_OK;
	}
}

static php_int64 WinFile_Read(void* pOS,void* pBuffer,php_int64 nDatatoRead)
{
	HANDLE pHandle = (HANDLE)pOS;
	DWORD nRd;
	BOOL rc;
	rc = ReadFile(pHandle,pBuffer,(DWORD)nDatatoRead,&nRd,0);
	if (!rc) {

		return -1;
	}
	return (php_int64)nRd;
}

static php_int64 WinFile_Write(void* pOS,const void* pBuffer,php_int64 nWrite)
{
	const char* zData = (const char*)pBuffer;
	HANDLE pHandle = (HANDLE)pOS;
	php_int64 nCount;
	DWORD nWr;
	BOOL rc;
	nWr = 0;
	nCount = 0;
	for (;;) {
		if (nWrite < 1) {
			break;
		}
		rc = WriteFile(pHandle,zData,(DWORD)nWrite,&nWr,0);
		if (!rc) {

			break;
		}
		nWrite -= nWr;
		nCount += nWr;
		zData += nWr;
	}
	if (nWrite > 0) {
		return -1;
	}
	return nCount;
}

static int WinFile_Seek(void* pUserData,php_int64 iOfft,int whence)
{
	HANDLE pHandle = (HANDLE)pUserData;
	DWORD dwMove,dwNew;
	LONG nHighOfft;
	switch (whence) {
	case 1:
		dwMove = FILE_CURRENT;
		break;
	case 2:
		dwMove = FILE_END;
		break;
	case 0:
	default:
		dwMove = FILE_BEGIN;
		break;
	}
	nHighOfft = (LONG)(iOfft >> 32);
	dwNew = SetFilePointer(pHandle,(LONG)iOfft,&nHighOfft,dwMove);
	if (dwNew == INVALID_SET_FILE_POINTER) {
		return -1;
	}
	return PHP_OK;
}

static int WinFile_Lock(void* pUserData,int lock_type)
{
	HANDLE pHandle = (HANDLE)pUserData;
	static DWORD dwLo = 0,dwHi = 0;
	OVERLAPPED sDummy;
	BOOL rc;
	SyZero(&sDummy,sizeof(sDummy));

	if (lock_type < 1) {

		rc = UnlockFileEx(pHandle,0,dwLo,dwHi,&sDummy);
	}
	else {
		DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;

		if (lock_type == 1 ) {
			dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;
		}
		dwLo = GetFileSize(pHandle,&dwHi);
		rc = LockFileEx(pHandle,dwFlags,0,dwLo,dwHi,&sDummy);
	}
	return rc ? PHP_OK : -1 ;
}

static php_int64 WinFile_Tell(void* pUserData)
{
	HANDLE pHandle = (HANDLE)pUserData;
	DWORD dwNew;
	dwNew = SetFilePointer(pHandle,0,0,FILE_CURRENT);
	if (dwNew == INVALID_SET_FILE_POINTER) {
		return -1;
	}
	return (php_int64)dwNew;
}

static int WinFile_Trunc(void* pUserData,php_int64 nOfft)
{
	HANDLE pHandle = (HANDLE)pUserData;
	LONG HighOfft;
	DWORD dwNew;
	BOOL rc;
	HighOfft = (LONG)(nOfft >> 32);
	dwNew = SetFilePointer(pHandle,(LONG)nOfft,&HighOfft,FILE_BEGIN);
	if (dwNew == INVALID_SET_FILE_POINTER) {
		return -1;
	}
	rc = SetEndOfFile(pHandle);
	return rc ? PHP_OK : -1;
}

static int WinFile_Sync(void* pUserData)
{
	HANDLE pHandle = (HANDLE)pUserData;
	BOOL rc;
	rc = FlushFileBuffers(pHandle);
	return rc ? PHP_OK : -1;
}

static int WinFile_Stat(void* pUserData,php_value* pArray,php_value* pWorker)
{
	BY_HANDLE_FILE_INFORMATION sInfo;
	HANDLE pHandle = (HANDLE)pUserData;
	BOOL rc;
	rc = GetFileInformationByHandle(pHandle,&sInfo);
	if (!rc) {
		return -1;
	}

	php_value_int64(pWorker,(php_int64)sInfo.dwVolumeSerialNumber);
	php_array_add_strkey_elem(pArray,"dev",pWorker);

	php_value_int64(pWorker,(php_int64)(((php_int64)sInfo.nFileIndexHigh << 32) | sInfo.nFileIndexLow));
	php_array_add_strkey_elem(pArray,"ino",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"mode",pWorker);

	php_value_int(pWorker,(int)sInfo.nNumberOfLinks);
	php_array_add_strkey_elem(pArray,"nlink",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"uid",pWorker);
	php_array_add_strkey_elem(pArray,"gid",pWorker);
	php_array_add_strkey_elem(pArray,"rdev",pWorker);

	php_value_int64(pWorker,(php_int64)(((php_int64)sInfo.nFileSizeHigh << 32) | sInfo.nFileSizeLow));
	php_array_add_strkey_elem(pArray,"size",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftLastAccessTime));
	php_array_add_strkey_elem(pArray,"atime",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftLastWriteTime));
	php_array_add_strkey_elem(pArray,"mtime",pWorker);

	php_value_int64(pWorker,convertWindowsTimeToUnixTime(&sInfo.ftCreationTime));
	php_array_add_strkey_elem(pArray,"ctime",pWorker);

	php_value_int(pWorker,0);
	php_array_add_strkey_elem(pArray,"blksize",pWorker);
	php_array_add_strkey_elem(pArray,"blocks",pWorker);
	return PHP_OK;
}

static const php_io_stream sWinFileStream = {
	"file",
	PHP_IO_STREAM_VERSION,
	WinFile_Open,
	WinDir_Open,
	WinFile_Close,
	WinDir_Close,
	WinFile_Read,
	WinDir_Read,
	WinFile_Write,
	WinFile_Seek,
	WinFile_Lock,
	WinDir_RewindDir,
	WinFile_Tell,
	WinFile_Trunc,
	WinFile_Sync,
	WinFile_Stat
};
#elif defined(__UNIXES__)

#include <sys/types.h>
#include <limits.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/uio.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/file.h>
#include <pwd.h>
#include <grp.h>
#include <dirent.h>
#include <utime.h>
#include <stdio.h>
#include <stdlib.h>

static int UnixVfs_chdir(const char* zPath)
{
	int rc;
	rc = chdir(zPath);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_getcwd(php_context* pCtx)
{
	char zBuf[4096];
	char* zDir;

	zDir = getcwd(zBuf,sizeof(zBuf));
	if (zDir == 0) {
		return -1;
	}
	php_result_string(pCtx,zDir,-1);
	return PHP_OK;
}

static int UnixVfs_mkdir(const char* zPath,int mode,int recursive)
{
	int rc;
	rc = mkdir(zPath,mode);
	recursive = 0;
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_rmdir(const char* zPath)
{
	int rc;
	rc = rmdir(zPath);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_isdir(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	rc = S_ISDIR(st.st_mode);
	return rc ? PHP_OK : -1;
}

static int UnixVfs_Rename(const char* zOld,const char* zNew)
{
	int rc;
	rc = rename(zOld,zNew);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_Realpath(const char* zPath,php_context* pCtx)
{
#ifndef PHP_UNIX_OLD_LIBC
	char* zReal;
	zReal = realpath(zPath,0);
	if (zReal == 0) {
		return -1;
	}
	php_result_string(pCtx,zReal,-1);

	free(zReal);
	return PHP_OK;
#else
	zPath = 0;
	pCtx = 0;
	return -1;
#endif
}

static int UnixVfs_Sleep(unsigned int uSec)
{
	usleep(uSec);
	return PHP_OK;
}

static int UnixVfs_unlink(const char* zPath)
{
	int rc;
	rc = unlink(zPath);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_FileExists(const char* zPath)
{
	int rc;
	rc = access(zPath,F_OK);
	return rc == 0 ? PHP_OK : -1;
}

static php_int64 UnixVfs_FileSize(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	return (php_int64)st.st_size;
}

static int UnixVfs_Touch(const char* zPath,php_int64 touch_time,php_int64 access_time)
{
	struct utimbuf ut; int rc;
	ut.actime = (time_t)access_time;
	ut.modtime = (time_t)touch_time;
	rc = utime(zPath,&ut);
	if (rc != 0) {
		return -1;
	}
	return PHP_OK;
}

static php_int64 UnixVfs_FileAtime(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	return (php_int64)st.st_atime;
}

static php_int64 UnixVfs_FileMtime(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	return (php_int64)st.st_mtime;
}

static php_int64 UnixVfs_FileCtime(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	return (php_int64)st.st_ctime;
}

static int UnixVfs_Stat(const char* zPath,php_value* pArray,php_value* pWorker)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}

	php_value_int64(pWorker,(php_int64)st.st_dev); php_array_add_strkey_elem(pArray,"dev",pWorker); php_value_int64(pWorker,(php_int64)st.st_ino); php_array_add_strkey_elem(pArray,"ino",pWorker); php_value_int(pWorker,(int)st.st_mode); php_array_add_strkey_elem(pArray,"mode",pWorker); php_value_int(pWorker,(int)st.st_nlink); php_array_add_strkey_elem(pArray,"nlink",pWorker); php_value_int(pWorker,(int)st.st_uid); php_array_add_strkey_elem(pArray,"uid",pWorker); php_value_int(pWorker,(int)st.st_gid); php_array_add_strkey_elem(pArray,"gid",pWorker); php_value_int(pWorker,(int)st.st_rdev); php_array_add_strkey_elem(pArray,"rdev",pWorker); php_value_int64(pWorker,(php_int64)st.st_size); php_array_add_strkey_elem(pArray,"size",pWorker); php_value_int64(pWorker,(php_int64)st.st_atime); php_array_add_strkey_elem(pArray,"atime",pWorker); php_value_int64(pWorker,(php_int64)st.st_mtime); php_array_add_strkey_elem(pArray,"mtime",pWorker); php_value_int64(pWorker,(php_int64)st.st_ctime); php_array_add_strkey_elem(pArray,"ctime",pWorker); php_value_int(pWorker,(int)st.st_blksize); php_array_add_strkey_elem(pArray,"blksize",pWorker); php_value_int(pWorker,(int)st.st_blocks); php_array_add_strkey_elem(pArray,"blocks",pWorker);
	return PHP_OK;
}

static int UnixVfs_lStat(const char* zPath,php_value* pArray,php_value* pWorker)
{
	struct stat st; int rc;
	rc = lstat(zPath,&st);
	if (rc != 0) {
		return -1;
	}

	php_value_int64(pWorker,(php_int64)st.st_dev); php_array_add_strkey_elem(pArray,"dev",pWorker); php_value_int64(pWorker,(php_int64)st.st_ino); php_array_add_strkey_elem(pArray,"ino",pWorker); php_value_int(pWorker,(int)st.st_mode); php_array_add_strkey_elem(pArray,"mode",pWorker); php_value_int(pWorker,(int)st.st_nlink); php_array_add_strkey_elem(pArray,"nlink",pWorker); php_value_int(pWorker,(int)st.st_uid); php_array_add_strkey_elem(pArray,"uid",pWorker); php_value_int(pWorker,(int)st.st_gid); php_array_add_strkey_elem(pArray,"gid",pWorker); php_value_int(pWorker,(int)st.st_rdev); php_array_add_strkey_elem(pArray,"rdev",pWorker); php_value_int64(pWorker,(php_int64)st.st_size); php_array_add_strkey_elem(pArray,"size",pWorker); php_value_int64(pWorker,(php_int64)st.st_atime); php_array_add_strkey_elem(pArray,"atime",pWorker); php_value_int64(pWorker,(php_int64)st.st_mtime); php_array_add_strkey_elem(pArray,"mtime",pWorker); php_value_int64(pWorker,(php_int64)st.st_ctime); php_array_add_strkey_elem(pArray,"ctime",pWorker); php_value_int(pWorker,(int)st.st_blksize); php_array_add_strkey_elem(pArray,"blksize",pWorker); php_value_int(pWorker,(int)st.st_blocks); php_array_add_strkey_elem(pArray,"blocks",pWorker);
	return PHP_OK;
}

static int UnixVfs_Chmod(const char* zPath,int mode)
{
	int rc;
	rc = chmod(zPath,(mode_t)mode);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_Chown(const char* zPath,const char* zUser)
{
#ifndef PHP_UNIX_STATIC_BUILD
	struct passwd* pwd;
	uid_t uid; int rc;
	pwd = getpwnam(zUser);
	if (pwd == 0) {
		return -1;
	}
	uid = pwd->pw_uid;
	rc = chown(zPath,uid,-1);
	return rc == 0 ? PHP_OK : -1;
#else
	SXUNUSED(zPath);
	SXUNUSED(zUser);
	return -1;
#endif
}

static int UnixVfs_Chgrp(const char* zPath,const char* zGroup)
{
#ifndef PHP_UNIX_STATIC_BUILD
	struct group* group;
	gid_t gid; int rc;
	group = getgrnam(zGroup);
	if (group == 0) {
		return -1;
	}
	gid = group->gr_gid;
	rc = chown(zPath,-1,gid);
	return rc == 0 ? PHP_OK : -1;
#else
	SXUNUSED(zPath);
	SXUNUSED(zGroup);
	return -1;
#endif
}

static int UnixVfs_isfile(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	rc = S_ISREG(st.st_mode);
	return rc ? PHP_OK : -1;
}

static int UnixVfs_islink(const char* zPath)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {
		return -1;
	}
	rc = S_ISLNK(st.st_mode);
	return rc ? PHP_OK : -1;
}

static int UnixVfs_isreadable(const char* zPath)
{
	int rc;
	rc = access(zPath,R_OK);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_iswritable(const char* zPath)
{
	int rc;
	rc = access(zPath,W_OK);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_isexecutable(const char* zPath)
{
	int rc;
	rc = access(zPath,X_OK);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_Filetype(const char* zPath,php_context* pCtx)
{
	struct stat st; int rc;
	rc = stat(zPath,&st);
	if (rc != 0) {

		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
		return -1;
	}
	if (S_ISREG(st.st_mode)) {
		php_result_string(pCtx,"file",sizeof("file") - 1);
	}
	else if (S_ISDIR(st.st_mode)) {
		php_result_string(pCtx,"dir",sizeof("dir") - 1);
	}
	else if (S_ISLNK(st.st_mode)) {
		php_result_string(pCtx,"link",sizeof("link") - 1);
	}
	else if (S_ISBLK(st.st_mode)) {
		php_result_string(pCtx,"block",sizeof("block") - 1);
	}
	else if (S_ISSOCK(st.st_mode)) {
		php_result_string(pCtx,"socket",sizeof("socket") - 1);
	}
	else if (S_ISFIFO(st.st_mode)) {
		php_result_string(pCtx,"fifo",sizeof("fifo") - 1);
	}
	else {
		php_result_string(pCtx,"unknown",sizeof("unknown") - 1);
	}
	return PHP_OK;
}

static int UnixVfs_Getenv(const char* zVar,php_context* pCtx)
{
	char* zEnv;
	zEnv = getenv(zVar);
	if (zEnv == 0) {
		return -1;
	}
	php_result_string(pCtx,zEnv,-1);
	return PHP_OK;
}

static int UnixVfs_Setenv(const char* zName,const char* zValue)
{
	int rc;
	rc = setenv(zName,zValue,1);
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_Mmap(const char* zPath,void** ppMap,php_int64* pSize)
{
	struct stat st;
	void* pMap; int fd; int rc;

	fd = open(zPath,O_RDONLY);
	if (fd < 0) {
		return -1;
	}

	fstat(fd,&st);

	pMap = mmap(0,st.st_size,PROT_READ,MAP_PRIVATE | MAP_FILE,fd,0);
	rc = PHP_OK;
	if (pMap == MAP_FAILED) {
		rc = -1;
	}
	else {

		*ppMap = pMap;
		*pSize = (php_int64)st.st_size;
	}
	close(fd);
	return rc;
}

static void UnixVfs_Unmap(void* pView,php_int64 nSize)
{
	munmap(pView,(size_t)nSize);
}

static void UnixVfs_TempDir(php_context* pCtx)
{
	static const char* azDirs[] = {
		"/var/tmp",
		"/usr/tmp",
		"/usr/local/tmp"
	};
	unsigned int i;
	struct stat buf;
	const char* zDir;
	zDir = getenv("TMPDIR");
	if (zDir && zDir[0] != 0 && !access(zDir,07)) {
		php_result_string(pCtx,zDir,-1);
		return;
	}
	for (i = 0; i < sizeof(azDirs) / sizeof(azDirs[0]); i++) {
		zDir = azDirs[i];
		if (zDir == 0) continue;
		if (stat(zDir,&buf)) continue;
		if (!S_ISDIR(buf.st_mode)) continue;
		if (access(zDir,07)) continue;

		php_result_string(pCtx,zDir,-1);
		return;
	}

	php_result_string(pCtx,"/tmp",(int)sizeof("/tmp") - 1);
}

static unsigned int UnixVfs_ProcessId(void)
{
	return (unsigned int)getpid();
}

static int UnixVfs_uid(void)
{
	return (int)getuid();
}

static int UnixVfs_gid(void)
{
	return (int)getgid();
}

static int UnixVfs_Umask(int new_mask)
{
	int old_mask;
	old_mask = umask(new_mask);
	return old_mask;
}

static void UnixVfs_Username(php_context* pCtx)
{
#ifndef PHP_UNIX_STATIC_BUILD
	struct passwd* pwd;
	uid_t uid;
	uid = getuid();
	pwd = getpwuid(uid);
	if (pwd == 0) {
		return;
	}

	php_result_string(pCtx,pwd->pw_name,-1);
#else
	php_result_string(pCtx,"Unknown",-1);
#endif
	return;
}

static int UnixVfs_link(const char* zSrc,const char* zTarget,int is_sym)
{
	int rc;
	if (is_sym) {

		rc = symlink(zSrc,zTarget);
	}
	else {

		rc = link(zSrc,zTarget);
	}
	return rc == 0 ? PHP_OK : -1;
}

static int UnixVfs_chroot(const char* zRootDir)
{
	int rc;
	rc = chroot(zRootDir);
	return rc == 0 ? PHP_OK : -1;
}

static const php_vfs sUnixVfs = { "Unix_vfs", PHP_VFS_VERSION, UnixVfs_chdir, UnixVfs_chroot, UnixVfs_getcwd, UnixVfs_mkdir, UnixVfs_rmdir, UnixVfs_isdir, UnixVfs_Rename, UnixVfs_Realpath, UnixVfs_Sleep, UnixVfs_unlink, UnixVfs_FileExists, UnixVfs_Chmod, UnixVfs_Chown, UnixVfs_Chgrp, 0, 0, UnixVfs_FileSize, UnixVfs_FileAtime, UnixVfs_FileMtime, UnixVfs_FileCtime, UnixVfs_Stat, UnixVfs_lStat, UnixVfs_isfile, UnixVfs_islink, UnixVfs_isreadable, UnixVfs_iswritable, UnixVfs_isexecutable, UnixVfs_Filetype, UnixVfs_Getenv, UnixVfs_Setenv, UnixVfs_Touch, UnixVfs_Mmap, UnixVfs_Unmap, UnixVfs_link, UnixVfs_Umask, UnixVfs_TempDir, UnixVfs_ProcessId, UnixVfs_uid, UnixVfs_gid, UnixVfs_Username, 0 };

#define PHP_UNIX_OPEN_MODE	0640

static int UnixFile_Open(const char* zPath,int iOpenMode,php_value* pResource,void** ppHandle)
{
	int iOpen = O_RDONLY; int fd;

	if (iOpenMode & PHP_IO_OPEN_CREATE) {

		iOpen = O_CREAT;
		if (iOpenMode & PHP_IO_OPEN_TRUNC) {

			iOpen |= O_TRUNC;
			SXUNUSED(pResource);
		}
	}
	else if (iOpenMode & PHP_IO_OPEN_EXCL) {

		iOpen = O_CREAT | O_EXCL;
	}
	else if (iOpenMode & PHP_IO_OPEN_TRUNC) {

		iOpen = O_RDWR | O_TRUNC;
	}
	if (iOpenMode & PHP_IO_OPEN_RDWR) {

		iOpen &= ~O_RDONLY;
		iOpen |= O_RDWR;
	}
	else if (iOpenMode & PHP_IO_OPEN_WRONLY) {

		iOpen &= ~O_RDONLY;
		iOpen |= O_WRONLY;
	}
	if (iOpenMode & PHP_IO_OPEN_APPEND) {

		iOpen |= O_APPEND;
	}
#ifdef O_TEMP
	if (iOpenMode & PHP_IO_OPEN_TEMP) {

		iOpen |= O_TEMP;
	}
#endif

	fd = open(zPath,iOpen,PHP_UNIX_OPEN_MODE);
	if (fd < 0) {

		return -1;
	}

	*ppHandle = SX_INT_TO_PTR(fd);
	return PHP_OK;
}

static int UnixDir_Open(const char* zPath,php_value* pResource,void** ppHandle)
{
	DIR* pDir;

	pDir = opendir(zPath);
	if (pDir == 0) {
		pResource = 0;
		return -1;
	}

	*ppHandle = pDir;
	return PHP_OK;
}

static void UnixDir_Close(void* pUserData)
{
	closedir((DIR*)pUserData);
}

static void UnixFile_Close(void* pUserData)
{
	close(SX_PTR_TO_INT(pUserData));
}

static int UnixDir_Read(void* pUserData,php_context* pCtx)
{
	DIR* pDir = (DIR*)pUserData;
	struct dirent* pEntry;
	char* zName = 0;
	sxu32 n = 0;
	for (;;) {
		pEntry = readdir(pDir);
		if (pEntry == 0) {

			return -1;
		}
		zName = pEntry->d_name;
		n = SyStrlen(zName);

		if (n > sizeof("..") - 1 || zName[0] != '.' || (n == sizeof("..") - 1 && zName[1] != '.')) {
			break;
		}

	}

	php_result_string(pCtx,zName,(int)n);
	return PHP_OK;
}

static void UnixDir_Rewind(void* pUserData)
{
	rewinddir((DIR*)pUserData);
}

static php_int64 UnixFile_Read(void* pUserData,void* pBuffer,php_int64 nDatatoRead)
{
	ssize_t nRd;
	nRd = read(SX_PTR_TO_INT(pUserData),pBuffer,(size_t)nDatatoRead);
	if (nRd < 1) {

		return -1;
	}
	return (php_int64)nRd;
}

static php_int64 UnixFile_Write(void* pUserData,const void* pBuffer,php_int64 nWrite)
{
	const char* zData = (const char*)pBuffer; int fd = SX_PTR_TO_INT(pUserData);
	php_int64 nCount;
	ssize_t nWr;
	nCount = 0;
	for (;;) {
		if (nWrite < 1) {
			break;
		}
		nWr = write(fd,zData,(size_t)nWrite);
		if (nWr < 1) {

			break;
		}
		nWrite -= nWr;
		nCount += nWr;
		zData += nWr;
	}
	if (nWrite > 0) {
		return -1;
	}
	return nCount;
}

static int UnixFile_Seek(void* pUserData,php_int64 iOfft,int whence)
{
	off_t iNew;
	switch (whence) {
	case 1:
		whence = SEEK_CUR;
		break;
	case 2:
		whence = SEEK_END;
		break;
	case 0:
	default:
		whence = SEEK_SET;
		break;
	}
	iNew = lseek(SX_PTR_TO_INT(pUserData),(off_t)iOfft,whence);
	if (iNew < 0) {
		return -1;
	}
	return PHP_OK;
}

static int UnixFile_Lock(void* pUserData,int lock_type)
{
	int fd = SX_PTR_TO_INT(pUserData); int rc = PHP_OK;
	if (lock_type < 0) {

		rc = flock(fd,LOCK_UN);
	}
	else {
		if (lock_type == 1) {

			rc = flock(fd,LOCK_EX);
		}
		else {

			rc = flock(fd,LOCK_SH);
		}
	}
	return !rc ? PHP_OK : -1;
}

static php_int64 UnixFile_Tell(void* pUserData)
{
	off_t iNew;
	iNew = lseek(SX_PTR_TO_INT(pUserData),0,SEEK_CUR);
	return (php_int64)iNew;
}

static int UnixFile_Trunc(void* pUserData,php_int64 nOfft)
{
	int rc;
	rc = ftruncate(SX_PTR_TO_INT(pUserData),(off_t)nOfft);
	if (rc != 0) {
		return -1;
	}
	return PHP_OK;
}

static int UnixFile_Sync(void* pUserData)
{
	int rc;
	rc = fsync(SX_PTR_TO_INT(pUserData));
	return rc == 0 ? PHP_OK : -1;
}

static int UnixFile_Stat(void* pUserData,php_value* pArray,php_value* pWorker) { struct stat st; int rc; rc = fstat(SX_PTR_TO_INT(pUserData),&st); if (rc != 0) { return -1; } php_value_int64(pWorker,(php_int64)st.st_dev); php_array_add_strkey_elem(pArray,"dev",pWorker); php_value_int64(pWorker,(php_int64)st.st_ino); php_array_add_strkey_elem(pArray,"ino",pWorker); php_value_int(pWorker,(int)st.st_mode); php_array_add_strkey_elem(pArray,"mode",pWorker); php_value_int(pWorker,(int)st.st_nlink); php_array_add_strkey_elem(pArray,"nlink",pWorker); php_value_int(pWorker,(int)st.st_uid); php_array_add_strkey_elem(pArray,"uid",pWorker); php_value_int(pWorker,(int)st.st_gid); php_array_add_strkey_elem(pArray,"gid",pWorker); php_value_int(pWorker,(int)st.st_rdev); php_array_add_strkey_elem(pArray,"rdev",pWorker); php_value_int64(pWorker,(php_int64)st.st_size); php_array_add_strkey_elem(pArray,"size",pWorker); php_value_int64(pWorker,(php_int64)st.st_atime); php_array_add_strkey_elem(pArray,"atime",pWorker); php_value_int64(pWorker,(php_int64)st.st_mtime); php_array_add_strkey_elem(pArray,"mtime",pWorker); php_value_int64(pWorker,(php_int64)st.st_ctime); php_array_add_strkey_elem(pArray,"ctime",pWorker); php_value_int(pWorker,(int)st.st_blksize); php_array_add_strkey_elem(pArray,"blksize",pWorker); php_value_int(pWorker,(int)st.st_blocks); php_array_add_strkey_elem(pArray,"blocks",pWorker); return PHP_OK; }

static const php_io_stream sUnixFileStream = { "file", PHP_IO_STREAM_VERSION, UnixFile_Open, UnixDir_Open, UnixFile_Close, UnixDir_Close, UnixFile_Read, UnixDir_Read, UnixFile_Write, UnixFile_Seek, UnixFile_Lock, UnixDir_Rewind, UnixFile_Tell, UnixFile_Trunc, UnixFile_Sync, UnixFile_Stat };
#endif
#endif
#endif

PHP_PRIVATE const php_vfs* PHP_ExportBuiltinVfs(void)
{
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifdef PHP_DISABLE_DISK_IO
	return &null_vfs;
#else
#ifdef __WINNT__
	return &sWinVfs;
#elif defined(__UNIXES__)
	return &sUnixVfs;
#else
	return &null_vfs;
#endif
#endif
#else
	return &null_vfs;
#endif
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_DISK_IO

#ifndef STDIN_FILENO
#define STDIN_FILENO	0
#endif
#ifndef STDOUT_FILENO
#define STDOUT_FILENO	1
#endif
#ifndef STDERR_FILENO
#define STDERR_FILENO	2
#endif

typedef struct php_stream_data php_stream_data;

#define PHP_IO_STREAM_STDIN  1
#define PHP_IO_STREAM_STDOUT 2
#define PHP_IO_STREAM_STDERR 3
#define PHP_IO_STREAM_OUTPUT 4

struct php_stream_data
{
	php_vm* pVm; int iType;
	union {
		void* pHandle;
		php_output_consumer sConsumer;
	}x;
};

static php_stream_data* PHPStreamDataInit(php_vm* pVm,int iType)
{
	php_stream_data* pData;
	if (pVm == 0) {
		return 0;
	}

	pData = (php_stream_data*)SyMemBackendAlloc(&pVm->sAllocator,sizeof(php_stream_data));
	if (pData == 0) {
		return 0;
	}

	SyZero(pData,sizeof(php_stream_data));

	pData->iType = iType;
	if (iType == PHP_IO_STREAM_OUTPUT) {

		pData->x.sConsumer = pVm->sVmConsumer;
	}
	else {
#ifdef __WINNT__
		DWORD nChannel;
		switch (iType) {
		case PHP_IO_STREAM_STDOUT:	nChannel = STD_OUTPUT_HANDLE; break;
		case PHP_IO_STREAM_STDERR:  nChannel = STD_ERROR_HANDLE; break;
		default:
			nChannel = STD_INPUT_HANDLE;
			break;
		}
		pData->x.pHandle = GetStdHandle(nChannel);
#else

		int ifd = STDIN_FILENO;
		switch (iType) {
		case PHP_IO_STREAM_STDOUT:  ifd = STDOUT_FILENO; break;
		case PHP_IO_STREAM_STDERR:  ifd = STDERR_FILENO; break;
		default:
			break;
		}
		pData->x.pHandle = SX_INT_TO_PTR(ifd);
#endif
	}
	pData->pVm = pVm;
	return pData;
}


static int PHPStreamData_Open(const char* zName,int iMode,php_value* pResource,void** ppHandle)
{
	php_stream_data* pData;
	SyString sStream;
	SyStringInitFromBuf(&sStream,zName,SyStrlen(zName));

	SyStringFullTrim(&sStream);

	if (SyStrnicmp(sStream.zString,"stdin",sizeof("stdin") - 1) == 0) {
		iMode = PHP_IO_STREAM_STDIN;
	}
	else if (SyStrnicmp(sStream.zString,"output",sizeof("output") - 1) == 0) {
		iMode = PHP_IO_STREAM_OUTPUT;
	}
	else if (SyStrnicmp(sStream.zString,"stdout",sizeof("stdout") - 1) == 0) {
		iMode = PHP_IO_STREAM_STDOUT;
	}
	else {

		return -1;
	}

	pData = PHPStreamDataInit(pResource ? pResource->pVm : 0,iMode);
	if (pData == 0) {
		return -1;
	}

	*ppHandle = (void*)pData;
	return PHP_OK;
}

static php_int64 PHPStreamData_Read(void* pHandle,void* pBuffer,php_int64 nDatatoRead)
{
	php_stream_data* pData = (php_stream_data*)pHandle;
	if (pData == 0) {
		return -1;
	}
	if (pData->iType != PHP_IO_STREAM_STDIN) {

		return -1;
	}
#ifdef __WINNT__
	{
		DWORD nRd;
		BOOL rc;
		rc = ReadFile(pData->x.pHandle,pBuffer,(DWORD)nDatatoRead,&nRd,0);
		if (!rc) {

			return -1;
		}
		return (php_int64)nRd;
	}
#elif defined(__UNIXES__)
	{
		ssize_t nRd; int fd;
		fd = SX_PTR_TO_INT(pData->x.pHandle);
		nRd = read(fd,pBuffer,(size_t)nDatatoRead);
		if (nRd < 1) {
			return -1;
		}
		return (php_int64)nRd;
	}
#else
	return -1;
#endif
}

static php_int64 PHPStreamData_Write(void* pHandle,const void* pBuf,php_int64 nWrite)
{
	php_stream_data* pData = (php_stream_data*)pHandle;
	if (pData == 0) {
		return -1;
	}
	if (pData->iType == PHP_IO_STREAM_STDIN) {

		return -1;
	}
	else if (pData->iType == PHP_IO_STREAM_OUTPUT) {
		php_output_consumer* pCons = &pData->x.sConsumer; int rc;

		rc = pCons->xConsumer(pBuf,(unsigned int)nWrite,pCons->pUserData);
		if (rc == PHP_ABORT) {
			return -1;
		}
		return nWrite;
	}
#ifdef __WINNT__
	{
		DWORD nWr;
		BOOL rc;
		rc = WriteFile(pData->x.pHandle,pBuf,(DWORD)nWrite,&nWr,0);
		if (!rc) {

			return -1;
		}
		return (php_int64)nWr;
	}
#elif defined(__UNIXES__)
	{
		ssize_t nWr; int fd;
		fd = SX_PTR_TO_INT(pData->x.pHandle);
		nWr = write(fd,pBuf,(size_t)nWrite);
		if (nWr < 1) {
			return -1;
		}
		return (php_int64)nWr;
	}
#else
	return -1;
#endif
}

static void PHPStreamData_Close(void* pHandle)
{
	php_stream_data* pData = (php_stream_data*)pHandle;
	php_vm* pVm;
	if (pData == 0) {
		return;
	}
	pVm = pData->pVm;

	SyMemBackendFree(&pVm->sAllocator,pData);
}

static const php_io_stream sPHP_Stream = {
	"php",
	PHP_IO_STREAM_VERSION,
	PHPStreamData_Open,
	0,
	PHPStreamData_Close,
	0,
	PHPStreamData_Read,
	0,
	PHPStreamData_Write,
	0,
	0,
	0,
	0,
	0,
	0,
	0
};
#endif

static int is_php_stream(const php_io_stream* pStream)
{
#ifndef PHP_DISABLE_DISK_IO
	return pStream == &sPHP_Stream;
#else
	SXUNUSED(pStream);
	return 0;
#endif
}

#endif

PHP_PRIVATE sxi32 PHP_RegisterIORoutine(php_vm* pVm)
{
#ifndef PHP_DISABLE_BUILTIN_FUNC
	static const php_builtin_func aVfsFunc[] = {
        {"chdir",PHP_vfs_chdir},
        {"chroot",PHP_vfs_chroot},
        {"getcwd",PHP_vfs_getcwd},
        {"rmdir",PHP_vfs_rmdir},
        {"is_dir",PHP_vfs_is_dir},
        {"mkdir",PHP_vfs_mkdir},
        {"rename",PHP_vfs_rename},
        {"realpath",PHP_vfs_realpath},
        {"sleep",PHP_vfs_sleep},
        {"usleep",PHP_vfs_usleep},
        {"unlink",PHP_vfs_unlink},
        {"delete",PHP_vfs_unlink},
        {"chmod",PHP_vfs_chmod},
        {"chown",PHP_vfs_chown},
        {"chgrp",PHP_vfs_chgrp},
        {"disk_free_space",PHP_vfs_disk_free_space},
        {"diskfreespace",PHP_vfs_disk_free_space},
        {"disk_total_space",PHP_vfs_disk_total_space},
        {"file_exists",PHP_vfs_file_exists},
        {"filesize",PHP_vfs_file_size},
        {"fileatime",PHP_vfs_file_atime},
        {"filemtime",PHP_vfs_file_mtime},
        {"filectime",PHP_vfs_file_ctime},
        {"is_file",PHP_vfs_is_file},
        {"is_link",PHP_vfs_is_link},
        {"is_readable",PHP_vfs_is_readable},
        {"is_writable",PHP_vfs_is_writable},
        {"is_executable",PHP_vfs_is_executable},
        {"filetype",PHP_vfs_filetype},
        {"stat",PHP_vfs_stat},
        {"lstat",PHP_vfs_lstat},
        {"getenv",PHP_vfs_getenv},
        {"setenv",PHP_vfs_putenv},
        {"putenv",PHP_vfs_putenv},
        {"touch",PHP_vfs_touch},
        {"link",PHP_vfs_link},
        {"symlink",PHP_vfs_symlink},
        {"umask",PHP_vfs_umask},
        {"sys_get_temp_dir",PHP_vfs_sys_get_temp_dir},
        {"get_current_user",PHP_vfs_get_current_user},
        {"getmypid",PHP_vfs_getmypid},
        {"getpid",PHP_vfs_getmypid},
        {"getmyuid",PHP_vfs_getmyuid},
        {"getuid",PHP_vfs_getmyuid},
        {"getmygid",PHP_vfs_getmygid},
        {"getgid",PHP_vfs_getmygid},
        {"php_uname",PHP_vfs_php_uname},
        {"php_uname",PHP_vfs_php_uname},
        {"dirname",PHP_builtin_dirname},
        {"basename",PHP_builtin_basename},
        {"pathinfo",PHP_builtin_pathinfo},
        {"strglob",PHP_builtin_strglob},
        {"fnmatch",PHP_builtin_fnmatch},
        {"zip_open",PHP_builtin_zip_open},
        {"zip_close",PHP_builtin_zip_close},
        {"zip_read",PHP_builtin_zip_read},
        {"zip_entry_open",PHP_builtin_zip_entry_open},
        {"zip_entry_close",PHP_builtin_zip_entry_close},
        {"zip_entry_name",PHP_builtin_zip_entry_name},
        {"zip_entry_filesize",PHP_builtin_zip_entry_filesize},
        {"zip_entry_compressedsize",PHP_builtin_zip_entry_compressedsize},
        {"zip_entry_read",PHP_builtin_zip_entry_read},
        {"zip_entry_reset_read_cursor",PHP_builtin_zip_entry_reset_read_cursor},
        {"zip_entry_compressionmethod",PHP_builtin_zip_entry_compressionmethod}
    };

	static const php_builtin_func aIOFunc[] = {
		{"ftruncate",PHP_builtin_ftruncate},
        {"fseek",PHP_builtin_fseek},
        {"ftell",PHP_builtin_ftell},
        {"rewind",PHP_builtin_rewind},
        {"fflush",PHP_builtin_fflush},
        {"feof",PHP_builtin_feof},
        {"fgetc",PHP_builtin_fgetc},
        {"fgets",PHP_builtin_fgets},
        {"fread",PHP_builtin_fread},
        {"fgetcsv",PHP_builtin_fgetcsv},
        {"fgetss",PHP_builtin_fgetss},
        {"readdir",PHP_builtin_readdir},
        {"rewinddir",PHP_builtin_rewinddir},
        {"closedir",PHP_builtin_closedir},
        {"opendir",PHP_builtin_opendir},
        {"readfile",PHP_builtin_readfile},
        {"file_get_contents",PHP_builtin_file_get_contents},
        {"file_put_contents",PHP_builtin_file_put_contents},
        {"file",PHP_builtin_file},
        {"copy",PHP_builtin_copy},
        {"fstat",PHP_builtin_fstat},
        {"fwrite",PHP_builtin_fwrite},
        {"fputs",PHP_builtin_fwrite},
        {"flock",PHP_builtin_flock},
        {"fclose",PHP_builtin_fclose},
        {"fopen",PHP_builtin_fopen_file},
        {"fpassthru",PHP_builtin_fpassthru},
        {"fputcsv",PHP_builtin_fputcsv},
        {"fprintf",PHP_builtin_fprintf},
#if !defined(PHP_DISABLE_HASH_FUNC)
		{"md5_file",PHP_builtin_md5_file},
		{"sha1_file",PHP_builtin_sha1_file},
#endif
		{"parse_ini_file",PHP_builtin_parse_ini_file},
		{"vfprintf",PHP_builtin_vfprintf}
	};
	const php_io_stream* pFileStream = 0;
	sxu32 n = 0;

	for (n = 0; n < SX_ARRAYSIZE(aVfsFunc); ++n) {
		php_create_function(&(*pVm),aVfsFunc[n].zName,aVfsFunc[n].xFunc,(void*)pVm->pEngine->pVfs);
	}
	for (n = 0; n < SX_ARRAYSIZE(aIOFunc); ++n) {
		php_create_function(&(*pVm),aIOFunc[n].zName,aIOFunc[n].xFunc,pVm);
	}
#ifndef PHP_DISABLE_DISK_IO

#ifdef __WINNT__
	pFileStream = &sWinFileStream;
#elif defined(__UNIXES__)
	pFileStream = &sUnixFileStream;
#endif

	php_vm_config(pVm,PHP_VM_CONFIG_IO_STREAM,&sPHP_Stream);
#endif
	if (pFileStream) {

		php_vm_config(pVm,PHP_VM_CONFIG_IO_STREAM,pFileStream);
	}
#else
	SXUNUSED(pVm);
#endif
	return SXRET_OK;
}

PHP_PRIVATE void* PHP_ExportStdin(php_vm* pVm)
{
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_DISK_IO
	if (pVm->pStdin == 0) {
		io_private* pIn;

		pIn = (io_private*)SyMemBackendAlloc(&pVm->sAllocator,sizeof(io_private));
		if (pIn == 0) {
			return 0;
		}
		InitIOPrivate(pVm,&sPHP_Stream,pIn);

		pIn->pHandle = PHPStreamDataInit(pVm,PHP_IO_STREAM_STDIN);

		pVm->pStdin = pIn;
		return pIn;
	}
	else {

		return pVm->pStdin;
	}
#else
	return 0;
#endif
#else
	SXUNUSED(pVm);
	return 0;
#endif
}

PHP_PRIVATE void* PHP_ExportStdout(php_vm* pVm)
{
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_DISK_IO
	if (pVm->pStdout == 0) {
		io_private* pOut;

		pOut = (io_private*)SyMemBackendAlloc(&pVm->sAllocator,sizeof(io_private));
		if (pOut == 0) {
			return 0;
		}
		InitIOPrivate(pVm,&sPHP_Stream,pOut);

		pOut->pHandle = PHPStreamDataInit(pVm,PHP_IO_STREAM_STDOUT);

		pVm->pStdout = pOut;
		return pOut;
	}
	else {

		return pVm->pStdout;
	}
#else
	return 0;
#endif
#else
	SXUNUSED(pVm);
	return 0;
#endif
}

PHP_PRIVATE void* PHP_ExportStderr(php_vm* pVm)
{
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_DISK_IO
	if (pVm->pStderr == 0) {
		io_private* pErr;

		pErr = (io_private*)SyMemBackendAlloc(&pVm->sAllocator,sizeof(io_private));
		if (pErr == 0) {
			return 0;
		}
		InitIOPrivate(pVm,&sPHP_Stream,pErr);

		pErr->pHandle = PHPStreamDataInit(pVm,PHP_IO_STREAM_STDERR);

		pVm->pStderr = pErr;
		return pErr;
	}
	else {

		return pVm->pStderr;
	}
#else
	return 0;
#endif
#else
	SXUNUSED(pVm);
	return 0;
#endif
}




#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


#define EXPR_OP_ASSOC_LEFT   0x01
#define EXPR_OP_ASSOC_RIGHT  0x02
#define EXPR_OP_NON_ASSOC    0x04

static const php_expr_op aOpTable[] = {
    {{"new",sizeof("new") - 1},EXPR_OP_NEW,1,EXPR_OP_NON_ASSOC,PHP_OP_NEW },
    {{"clone",sizeof("clone") - 1},EXPR_OP_CLONE,1,EXPR_OP_NON_ASSOC,PHP_OP_CLONE },
    {{"->",sizeof(char) * 2},EXPR_OP_ARROW,2,EXPR_OP_ASSOC_LEFT ,PHP_OP_MEMBER },
    {{"::",sizeof(char) * 2},EXPR_OP_DC,2,EXPR_OP_ASSOC_LEFT ,PHP_OP_MEMBER },
    {{"[",sizeof(char)},EXPR_OP_SUBSCRIPT,2,EXPR_OP_ASSOC_LEFT ,PHP_OP_LOAD_IDX },
    {{"++",sizeof(char) * 2},EXPR_OP_INCR,3,EXPR_OP_NON_ASSOC ,PHP_OP_INCR },
    {{"--",sizeof(char) * 2},EXPR_OP_DECR,3,EXPR_OP_NON_ASSOC ,PHP_OP_DECR },
    {{"-",sizeof(char)},EXPR_OP_UMINUS,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_UMINUS },
    {{"+",sizeof(char)},EXPR_OP_UPLUS,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_UPLUS },
    {{"~",sizeof(char)},EXPR_OP_BITNOT,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_BITNOT },
    {{"!",sizeof(char)},EXPR_OP_LOGNOT,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_LNOT },
    {{"@",sizeof(char)},EXPR_OP_ALT,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_ERR_CTRL },
    {{"(int)",sizeof("(int)") - 1   },EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_INT },
    {{"(bool)",sizeof("(bool)") - 1  },EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_BOOL },
    {{"(string)",sizeof("(string)") - 1},EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_STR },
    {{"(float)",sizeof("(float)") - 1 },EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_REAL },
    {{"(array)",sizeof("(array)") - 1 },EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_ARRAY },
    {{"(object)",sizeof("(object)") - 1},EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_OBJ },
    {{"(unset)",sizeof("(unset)") - 1 },EXPR_OP_TYPECAST,4,EXPR_OP_ASSOC_RIGHT,PHP_OP_CVT_NULL },
    {{"instanceof",sizeof("instanceof") - 1},EXPR_OP_INSTOF,7,EXPR_OP_NON_ASSOC,PHP_OP_IS_A },
    {{"*",sizeof(char)},EXPR_OP_MUL,7,EXPR_OP_ASSOC_LEFT ,PHP_OP_MUL },
    {{"/",sizeof(char)},EXPR_OP_DIV,7,EXPR_OP_ASSOC_LEFT ,PHP_OP_DIV },
    {{"%",sizeof(char)},EXPR_OP_MOD,7,EXPR_OP_ASSOC_LEFT ,PHP_OP_MOD },
    {{"+",sizeof(char)},EXPR_OP_ADD,8,EXPR_OP_ASSOC_LEFT,PHP_OP_ADD },
    {{"-",sizeof(char)},EXPR_OP_SUB,8,EXPR_OP_ASSOC_LEFT,PHP_OP_SUB },
    {{".",sizeof(char)},EXPR_OP_DOT,8,EXPR_OP_ASSOC_LEFT,PHP_OP_CAT },
    {{"<<",sizeof(char) * 2},EXPR_OP_SHL,9,EXPR_OP_ASSOC_LEFT,PHP_OP_SHL },
    {{">>",sizeof(char) * 2},EXPR_OP_SHR,9,EXPR_OP_ASSOC_LEFT,PHP_OP_SHR },
    {{"<",sizeof(char)},EXPR_OP_LT,10,EXPR_OP_NON_ASSOC,PHP_OP_LT },
    {{">",sizeof(char)},EXPR_OP_GT,10,EXPR_OP_NON_ASSOC,PHP_OP_GT },
    {{"<=",sizeof(char) * 2},EXPR_OP_LE,10,EXPR_OP_NON_ASSOC,PHP_OP_LE },
    {{">=",sizeof(char) * 2},EXPR_OP_GE,10,EXPR_OP_NON_ASSOC,PHP_OP_GE },
    {{"<>",sizeof(char) * 2},EXPR_OP_NE,10,EXPR_OP_NON_ASSOC,PHP_OP_NEQ },
    {{"==",sizeof(char) * 2},EXPR_OP_EQ,11,EXPR_OP_NON_ASSOC,PHP_OP_EQ },
    {{"!=",sizeof(char) * 2},EXPR_OP_NE,11,EXPR_OP_NON_ASSOC,PHP_OP_NEQ },
    {{"eq",sizeof(char) * 2},EXPR_OP_SEQ,11,EXPR_OP_NON_ASSOC,PHP_OP_SEQ },
    {{"ne",sizeof(char) * 2},EXPR_OP_SNE,11,EXPR_OP_NON_ASSOC,PHP_OP_SNE },
    {{"===",sizeof(char) * 3},EXPR_OP_TEQ,11,EXPR_OP_NON_ASSOC,PHP_OP_TEQ },
    {{"!==",sizeof(char) * 3},EXPR_OP_TNE,11,EXPR_OP_NON_ASSOC,PHP_OP_TNE },
    {{"&",sizeof(char)},EXPR_OP_BAND,12,EXPR_OP_ASSOC_LEFT,PHP_OP_BAND },
    {{"=&",sizeof(char) * 2},EXPR_OP_REF,12,EXPR_OP_ASSOC_LEFT,PHP_OP_STORE_REF },
    {{"^",sizeof(char)},EXPR_OP_XOR,13,EXPR_OP_ASSOC_LEFT,PHP_OP_BXOR },
    {{"|",sizeof(char)},EXPR_OP_BOR,14,EXPR_OP_ASSOC_LEFT,PHP_OP_BOR },
    {{"&&",sizeof(char) * 2},EXPR_OP_LAND,15,EXPR_OP_ASSOC_LEFT,PHP_OP_LAND },
    {{"||",sizeof(char) * 2},EXPR_OP_LOR,16,EXPR_OP_ASSOC_LEFT,PHP_OP_LOR },
    {{"?",sizeof(char)},EXPR_OP_QUESTY,17,EXPR_OP_ASSOC_LEFT,0 },
    {{"=",sizeof(char)},EXPR_OP_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_STORE },
    {{"+=",sizeof(char) * 2},EXPR_OP_ADD_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_ADD_STORE },
    {{"-=",sizeof(char) * 2},EXPR_OP_SUB_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_SUB_STORE },
    {{".=",sizeof(char) * 2},EXPR_OP_DOT_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_CAT_STORE },
    {{"*=",sizeof(char) * 2},EXPR_OP_MUL_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_MUL_STORE },
    {{"/=",sizeof(char) * 2},EXPR_OP_DIV_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_DIV_STORE },
    {{"%=",sizeof(char) * 2},EXPR_OP_MOD_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_MOD_STORE },
    {{"&=",sizeof(char) * 2},EXPR_OP_AND_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_BAND_STORE },
    {{"|=",sizeof(char) * 2},EXPR_OP_OR_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_BOR_STORE },
    {{"^=",sizeof(char) * 2},EXPR_OP_XOR_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_BXOR_STORE },
    {{"<<=",sizeof(char) * 3},EXPR_OP_SHL_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_SHL_STORE },
    {{">>=",sizeof(char) * 3},EXPR_OP_SHR_ASSIGN,18,EXPR_OP_ASSOC_RIGHT,PHP_OP_SHR_STORE },
    {{"and",sizeof("and") - 1},EXPR_OP_LAND,19,EXPR_OP_ASSOC_LEFT,PHP_OP_LAND },
    {{"xor",sizeof("xor") - 1},EXPR_OP_LXOR,20,EXPR_OP_ASSOC_LEFT,PHP_OP_LXOR },
    {{"or",sizeof("or") - 1},EXPR_OP_LOR,21,EXPR_OP_ASSOC_LEFT,PHP_OP_LOR },
    {{",",sizeof(char)},EXPR_OP_COMMA,22,EXPR_OP_ASSOC_LEFT,0}
};
static const php_expr_op sFCallOp = {{"(",sizeof(char)},EXPR_OP_FUNC_CALL,2,EXPR_OP_ASSOC_LEFT ,PHP_OP_CALL };

PHP_PRIVATE const php_expr_op* PHP_ExprExtractOperator(SyString* pStr,SyToken* pLast)
{
	sxu32 n = 0;
	sxi32 rc;

	for (;;) {
		if (n >= SX_ARRAYSIZE(aOpTable)) {
			break;
		}
		if (SyisAlpha(aOpTable[n].sOp.zString[0])) {

			rc = SyStringCmp(pStr,&aOpTable[n].sOp,SyStrnicmp);
		}
		else {
			rc = SyStringCmp(pStr,&aOpTable[n].sOp,SyMemcmp);
		}
		if (rc == 0) {
			if (aOpTable[n].sOp.nByte != sizeof(char) || (aOpTable[n].iOp != EXPR_OP_UMINUS && aOpTable[n].iOp != EXPR_OP_UPLUS) || pLast == 0) {

				return &aOpTable[n];
			}

			if (pLast->nType & (PHP_TK_LPAREN | PHP_TK_OCB | PHP_TK_OSB | PHP_TK_COLON | PHP_TK_COMMA)) {

				return &aOpTable[n];
			}
			if (pLast->nType & PHP_TK_OP) {
				const php_expr_op* pOp = (const php_expr_op*)pLast->pUserData;

				if (pOp->iOp != EXPR_OP_INCR && pOp->iOp != EXPR_OP_DECR) {

					return &aOpTable[n];
				}

			}
		}
		++n;
	}

	return 0;
}

PHP_PRIVATE void PHP_DelimitNestedTokens(SyToken* pIn,SyToken* pEnd,sxu32 nTokStart,sxu32 nTokEnd,SyToken** ppEnd)
{
	SyToken* pCur = pIn;
	sxi32 iNest = 1;
	for (;;) {
		if (pCur >= pEnd) {
			break;
		}
		if (pCur->nType & nTokStart) {

			iNest++;
		}
		else if (pCur->nType & nTokEnd) {

			iNest--;
			if (iNest <= 0) {
				break;
			}
		}

		pCur++;
	}

	*ppEnd = pCur;
}

PHP_PRIVATE int PHP_IsLangConstruct(sxu32 nKeyID,sxu8 bCheckFunc)
{
	if (nKeyID == PHP_TKWRD_ECHO || nKeyID == PHP_TKWRD_PRINT || nKeyID == PHP_TKWRD_INCLUDE
		|| nKeyID == PHP_TKWRD_INCONCE || nKeyID == PHP_TKWRD_REQUIRE || nKeyID == PHP_TKWRD_REQONCE
		) {
		return TRUE;
	}
	if (bCheckFunc) {
		if (nKeyID == PHP_TKWRD_ISSET || nKeyID == PHP_TKWRD_UNSET || nKeyID == PHP_TKWRD_EVAL
			|| nKeyID == PHP_TKWRD_EMPTY || nKeyID == PHP_TKWRD_ARRAY || nKeyID == PHP_TKWRD_LIST
			||  nKeyID == PHP_TKWRD_NEW || nKeyID == PHP_TKWRD_CLONE) {
			return TRUE;
		}
	}

	return FALSE;
}

static sxi32 ExprVerifyNodes(php_gen_state* pGen,php_expr_node** apNode,sxi32 nNode)
{
	sxi32 iParen,iSquare,iQuesty,iBraces;
	sxi32 i,rc;

	if (nNode > 0 && apNode[0]->pOp && (apNode[0]->pOp->iOp == EXPR_OP_ADD || apNode[0]->pOp->iOp == EXPR_OP_SUB)) {

		apNode[0]->pOp = PHP_ExprExtractOperator(&apNode[0]->pStart->sData,0);
		apNode[0]->pStart->pUserData = (void*)apNode[0]->pOp;
	}
	iParen = iSquare = iQuesty = iBraces = 0;
	for (i = 0; i < nNode; ++i) {
		if (apNode[i]->pStart->nType & PHP_TK_LPAREN ) {
			if (i > 0 && (apNode[i - 1]->xCode == PHP_CompileVariable || apNode[i - 1]->xCode == PHP_CompileLiteral ||
				(apNode[i - 1]->pStart->nType & (PHP_TK_ID | PHP_TK_KEYWORD | PHP_TK_SSTR | PHP_TK_DSTR | PHP_TK_RPAREN | PHP_TK_CSB | PHP_TK_CCB)))) {

				if ((apNode[i - 1]->pStart->nType & PHP_TK_OP) == 0) {

					apNode[i]->pStart->nType |= PHP_TK_OP;
					apNode[i]->pStart->pUserData = (void*)&sFCallOp;
					apNode[i]->pOp = &sFCallOp;
				}
			}
			iParen++;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_RPAREN) {
			if (iParen <= 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,apNode[i]->pStart->nLine,"Syntax error: Unexpected token ')'");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			iParen--;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_OSB ) {
			iSquare++;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_CSB ) {
			if (iSquare <= 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,apNode[i]->pStart->nLine,"Syntax error: Unexpected token ']'");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			iSquare--;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_OCB ) {
			iBraces++;
			if (i > 0 && (apNode[i - 1]->xCode == PHP_CompileVariable || (apNode[i - 1]->pStart->nType & PHP_TK_CSB))) {
				const php_expr_op* pOp,* pEnd; int iNest = 1;
				sxi32 j = i + 1;

				apNode[i]->pStart->nType &= ~PHP_TK_OCB ;
				apNode[i]->pStart->nType |= PHP_TK_OSB ;
				pOp = aOpTable;
				pEnd = &pOp[sizeof(aOpTable)];
				while (pOp < pEnd) {
					if (pOp->iOp == EXPR_OP_SUBSCRIPT) {
						break;
					}
					pOp++;
				}
				if (pOp >= pEnd) {
					pOp = 0;
				}
				if (pOp) {
					apNode[i]->pOp = pOp;
					apNode[i]->pStart->nType |= PHP_TK_OP;
				}
				iBraces--;
				iSquare++;
				while (j < nNode) {
					if (apNode[j]->pStart->nType & PHP_TK_OCB ) {

						iNest++;
					}
					else if (apNode[j]->pStart->nType & PHP_TK_CCB) {

						iNest--;
						if (iNest < 1) {
							break;
						}
					}
					j++;
				}
				if (j < nNode) {
					apNode[j]->pStart->nType &= ~PHP_TK_CCB ;
					apNode[j]->pStart->nType |= PHP_TK_CSB ;
				}

			}
		}
		else if (apNode[i]->pStart->nType & PHP_TK_CCB ) {
			if (iBraces <= 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,apNode[i]->pStart->nLine,"Syntax error: Unexpected token '}'");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			iBraces--;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_COLON) {
			if (iQuesty <= 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,apNode[i]->pStart->nLine,"Syntax error: Unexpected token ':'");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			iQuesty--;
		}
		else if (apNode[i]->pStart->nType & PHP_TK_OP) {
			const php_expr_op* pOp = (const php_expr_op*)apNode[i]->pOp;
			if (pOp->iOp == EXPR_OP_QUESTY) {
				iQuesty++;
			}
			else if (i > 0 && (pOp->iOp == EXPR_OP_UMINUS || pOp->iOp == EXPR_OP_UPLUS)) {
				if (apNode[i - 1]->xCode == PHP_CompileVariable || apNode[i - 1]->xCode == PHP_CompileLiteral) {
					sxi32 iExprOp = EXPR_OP_SUB;
					sxu32 n = 0;
					if (pOp->iOp == EXPR_OP_UPLUS) {
						iExprOp = EXPR_OP_ADD;
					}

					while (n < SX_ARRAYSIZE(aOpTable) && aOpTable[n].iOp != iExprOp) {
						++n;
					}
					pOp = &aOpTable[n];

					apNode[i]->pOp = pOp;
					apNode[i]->pStart->pUserData = (void*)pOp;
				}
			}
		}
	}
	if (iParen != 0 || iSquare != 0 || iQuesty != 0 || iBraces != 0) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,apNode[0]->pStart->nLine,"Syntax error,mismatched '(','[','{' or '?'");
		if (rc != SXERR_ABORT) {
			rc = SXERR_SYNTAX;
		}
		return rc;
	}
	return SXRET_OK;
}

static void ExprAssembleLiteral(SyToken** ppCur,SyToken* pEnd)
{
	SyToken* pIn = *ppCur;

	if ((pIn->nType & PHP_TK_NSSEP) == 0) {
		pIn++;
	}
	for (;;) {
		if (pIn < pEnd && (pIn->nType & PHP_TK_NSSEP)) {
			pIn++;
			if (pIn < pEnd && (pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD))) {
				pIn++;
			}
		}
		else {
			break;
		}
	}

	*ppCur = pIn;
}

static sxi32 ExprAssembleAnnon(php_gen_state* pGen,SyToken** ppCur,SyToken* pEnd)
{
	SyToken* pIn = *ppCur;
	sxu32 nLine;
	sxi32 rc;

	nLine = pIn->nLine;
	pIn++;
	if (pIn < pEnd && (pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD))) {
		pIn++;
	}
	if (pIn >= pEnd || (pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Missing opening parenthesis '(' while declaring annonymous function");
		if (rc != SXERR_ABORT) {
			rc = SXERR_SYNTAX;
		}
		goto Synchronize;
	}
	pIn++;
	PHP_DelimitNestedTokens(pIn,pEnd,PHP_TK_LPAREN,PHP_TK_RPAREN,&pIn);
	if (pIn >= pEnd || &pIn[1] >= pEnd) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Syntax error while declaring annonymous function");
		if (rc != SXERR_ABORT) {
			rc = SXERR_SYNTAX;
		}
		goto Synchronize;
	}
	pIn++;
	if (pIn->nType & PHP_TK_KEYWORD) {
		sxu32 nKey = SX_PTR_TO_INT(pIn->pUserData);

		if (nKey == PHP_TKWRD_USE) {
			pIn++;
			if (pIn >= pEnd || (pIn->nType & PHP_TK_LPAREN) == 0) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Syntax error while declaring annonymous function");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				goto Synchronize;
			}
			pIn++;
			PHP_DelimitNestedTokens(pIn,pEnd,PHP_TK_LPAREN,PHP_TK_RPAREN,&pIn);
			if (pIn >= pEnd || &pIn[1] >= pEnd) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Syntax error while declaring annonymous function");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				goto Synchronize;
			}
			pIn++;
		}
		else {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Syntax error while declaring annonymous function");
			if (rc != SXERR_ABORT) {
				rc = SXERR_SYNTAX;
			}
			goto Synchronize;
		}
	}
	if (pIn->nType & PHP_TK_OCB ) {
		pIn++;
		PHP_DelimitNestedTokens(pIn,pEnd,PHP_TK_OCB,PHP_TK_CCB,&pIn);
		if (pIn < pEnd) {
			pIn++;
		}
	}
	else {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Syntax error while declaring annonymous function,missing '{'");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	rc = SXRET_OK;
Synchronize:

	*ppCur = pIn;
	return rc;
}

static sxi32 ExprExtractNode(php_gen_state* pGen,php_expr_node** ppNode)
{
	php_expr_node* pNode;
	SyToken* pCur;
	sxi32 rc;

	pNode = (php_expr_node*)SyMemBackendPoolAlloc(&pGen->pVm->sAllocator,sizeof(php_expr_node));
	if (pNode == 0) {

		return SXERR_MEM;
	}

	SyZero(pNode,sizeof(php_expr_node));
	SySetInit(&pNode->aNodeArgs,&pGen->pVm->sAllocator,sizeof(php_expr_node**));

	pCur = pNode->pStart = pGen->pIn;

	if (pCur->nType & PHP_TK_OP) {

		pNode->pOp = (const php_expr_op*)pCur->pUserData;

		pCur++;
	}
	else if (pCur->nType & PHP_TK_DOLLAR) {

		while (pCur < pGen->pEnd && (pCur->nType & PHP_TK_DOLLAR)) {
			pCur++;
		}
		if (pCur < pGen->pEnd) {
			if (pCur->nType & (PHP_TK_ID | PHP_TK_KEYWORD)) {

				pCur++;
			}
			else if (pCur->nType & PHP_TK_OCB ) {
				pCur++;

				PHP_DelimitNestedTokens(pCur,pGen->pEnd,PHP_TK_OCB,PHP_TK_CCB,&pCur);
				if (pCur < pGen->pEnd) {
					pCur++;
				}
				else {
					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"Syntax error: Missing closing brace '}'");
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
					return rc;
				}
			}
		}
		pNode->xCode = PHP_CompileVariable;
	}
	else if (pCur->nType & PHP_TK_KEYWORD) {
		sxu32 nKeyword = (sxu32)SX_PTR_TO_INT(pCur->pUserData);
		if (nKeyword == PHP_TKWRD_ARRAY || nKeyword == PHP_TKWRD_LIST) {

			if (&pCur[1] >= pGen->pEnd || (pCur[1].nType & PHP_TK_LPAREN) == 0) {

				ExprAssembleLiteral(&pCur,pGen->pEnd);
				pNode->xCode = PHP_CompileLiteral;
			}
			else {
				pCur += 2;

				PHP_DelimitNestedTokens(pCur,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pCur);
				if (pCur < pGen->pEnd) {
					pCur++;
				}
				else {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,
						"%s: Missing closing parenthesis ')'",nKeyword == PHP_TKWRD_LIST ? "list" : "array");
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
					return rc;
				}
				pNode->xCode = (nKeyword == PHP_TKWRD_LIST) ? PHP_CompileList : PHP_CompileArray;
				if (pNode->xCode == PHP_CompileList) {
					php_expr_op* pOp = (pCur < pGen->pEnd) ? (php_expr_op*)pCur->pUserData : 0;
					if (pCur >= pGen->pEnd || (pCur->nType & PHP_TK_OP) == 0 || pOp == 0 || pOp->iVmOp != PHP_OP_STORE ) {

						rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"list(): expecting '=' after construct");
						if (rc != SXERR_ABORT) {
							rc = SXERR_SYNTAX;
						}
						SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
						return rc;
					}
				}
			}
		}
		else if (nKeyword == PHP_TKWRD_FUNCTION) {

			if (&pCur[1] >= pGen->pEnd) {

				ExprAssembleLiteral(&pCur,pGen->pEnd);
				pNode->xCode = PHP_CompileLiteral;
			}
			else {

				rc = ExprAssembleAnnon(&(*pGen),&pCur,pGen->pEnd);
				if (rc != SXRET_OK) {
					SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
					return rc;
				}
				pNode->xCode = PHP_CompileAnnonFunc;
			}
		}
		else if (PHP_IsLangConstruct(nKeyword,FALSE) == TRUE && &pCur[1] < pGen->pEnd) {

			PHP_DelimitNestedTokens(pCur,pGen->pEnd,PHP_TK_LPAREN | PHP_TK_OCB | PHP_TK_OSB,PHP_TK_RPAREN | PHP_TK_CCB | PHP_TK_CSB,&pCur);
			pNode->xCode = PHP_CompileLangConstruct;
		}
		else {

			ExprAssembleLiteral(&pCur,pGen->pEnd);
			pNode->xCode = PHP_CompileLiteral;
		}
	}
	else if (pCur->nType & (PHP_TK_NSSEP | PHP_TK_ID)) {

		ExprAssembleLiteral(&pCur,pGen->pEnd);
		pNode->xCode = PHP_CompileLiteral;
	}
	else {
		if ((pCur->nType & (PHP_TK_LPAREN | PHP_TK_RPAREN | PHP_TK_COMMA | PHP_TK_COLON | PHP_TK_CSB | PHP_TK_OCB | PHP_TK_CCB)) == 0) {

			pNode->xCode = PHP_GetNodeHandler(pCur->nType);
			if (pNode->xCode == 0) {
				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"Syntax error: Unexpected token '%z'",&pNode->pStart->sData);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
				return rc;
			}
		}

		pCur++;
	}

	pNode->pEnd = pCur;

	*ppNode = pNode;

	pGen->pIn = pCur;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_GetNextExpr(SyToken* pStart,SyToken* pEnd,SyToken** ppNext)
{
	SyToken* pCur = pStart;
	sxi32 iNest = 0;
	if (pCur >= pEnd || (pCur->nType & PHP_TK_SEMI)) {

		return SXERR_EOF;
	}
	while (pCur < pEnd) {
		if ((pCur->nType & (PHP_TK_COMMA | PHP_TK_SEMI)) && iNest <= 0) {
			break;
		}
		if (pCur->nType & (PHP_TK_LPAREN | PHP_TK_OSB | PHP_TK_OCB)) {
			iNest++;
		}
		else if (pCur->nType & (PHP_TK_RPAREN | PHP_TK_CSB | PHP_TK_CCB)) {
			iNest--;
		}
		pCur++;
	}
	*ppNext = pCur;
	return SXRET_OK;
}

static void ExprFreeTree(php_gen_state* pGen,php_expr_node* pNode)
{
	if (pNode->pLeft) {

		ExprFreeTree(&(*pGen),pNode->pLeft);
	}
	if (pNode->pRight) {

		ExprFreeTree(&(*pGen),pNode->pRight);
	}
	if (pNode->pCond) {

		ExprFreeTree(&(*pGen),pNode->pCond);
	}
	if (SySetUsed(&pNode->aNodeArgs) > 0) {
		php_expr_node** apArg;
		sxu32 n;

		apArg = (php_expr_node**)SySetBasePtr(&pNode->aNodeArgs);
		for (n = 0; n < SySetUsed(&pNode->aNodeArgs); ++n) {
			ExprFreeTree(&(*pGen),apArg[n]);
		}
		SySetRelease(&pNode->aNodeArgs);
	}

	SyMemBackendPoolFree(&pGen->pVm->sAllocator,pNode);
}

PHP_PRIVATE sxi32 PHP_ExprFreeTree(php_gen_state* pGen,SySet* pNodeSet)
{
	php_expr_node** apNode;
	sxu32 n;
	apNode = (php_expr_node**)SySetBasePtr(pNodeSet);
	for (n = 0; n < SySetUsed(pNodeSet); ++n) {
		if (apNode[n]) {
			ExprFreeTree(&(*pGen),apNode[n]);
		}
	}
	return SXRET_OK;
}

static int ExprIsModifiableValue(php_expr_node* pNode,sxu8 bFunc)
{
	sxi32 iExprOp;
	if (pNode->pOp == 0) {
		return pNode->xCode == PHP_CompileVariable ? TRUE : FALSE;
	}
	iExprOp = pNode->pOp->iOp;
	if (iExprOp == EXPR_OP_ARROW  || iExprOp == EXPR_OP_DC ) {
		return TRUE;
	}
	if (iExprOp == EXPR_OP_SUBSCRIPT) {
		if (pNode->pLeft->pOp) {
			if (pNode->pLeft->pOp->iOp != EXPR_OP_SUBSCRIPT  && pNode->pLeft->pOp->iOp != EXPR_OP_ARROW
				&& pNode->pLeft->pOp->iOp != EXPR_OP_DC ) {
				return FALSE;
			}
		}
		else if (pNode->pLeft->xCode != PHP_CompileVariable) {
			return FALSE;
		}
		return TRUE;
	}
	if (bFunc && iExprOp == EXPR_OP_FUNC_CALL) {
		return TRUE;
	}

	return FALSE;
}

static sxi32 ExprMakeTree(php_gen_state* pGen,php_expr_node** apNode,sxi32 nToken);

#define NODE_ISTERM(NODE) (apNode[NODE] && (!apNode[NODE]->pOp || apNode[NODE]->pLeft ))

static sxi32 ExprProcessFuncArguments(php_gen_state* pGen,php_expr_node* pOp,php_expr_node** apNode,sxi32 nToken)
{
	sxi32 iNest,iCur,iNode;
	sxi32 rc;

	iCur = 0;
	for (;;) {
		if (iCur >= nToken) {

			break;
		}
		iNode = iCur;
		iNest = 0;
		while (iCur < nToken) {
			if (apNode[iCur]) {
				if ((apNode[iCur]->pStart->nType & PHP_TK_COMMA) && apNode[iCur]->pLeft == 0 && iNest <= 0) {
					break;
				}
				else if (apNode[iCur]->pStart->nType & (PHP_TK_LPAREN | PHP_TK_OSB | PHP_TK_OCB)) {
					iNest++;
				}
				else if (apNode[iCur]->pStart->nType & (PHP_TK_RPAREN | PHP_TK_CCB | PHP_TK_CSB)) {
					iNest--;
				}
			}
			iCur++;
		}
		if (iCur > iNode) {
			if (apNode[iNode] && (apNode[iNode]->pStart->nType & PHP_TK_AMPER ) && ((iCur - iNode) == 2)
				&& apNode[iNode + 1]->xCode == PHP_CompileVariable) {
				PHP_GenCompileError(&(*pGen),E_WARNING,apNode[iNode]->pStart->nLine,
					"call-time pass-by-reference is depreceated");
				ExprFreeTree(&(*pGen),apNode[iNode]);
				apNode[iNode] = 0;
			}
			ExprMakeTree(&(*pGen),&apNode[iNode],iCur - iNode);
			if (apNode[iNode]) {

				SySetPut(&pOp->aNodeArgs,(const void*)&apNode[iNode]);
			}
			else {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pOp->pStart->nLine,"Empty function argument");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
		}
		else {
			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pOp->pStart->nLine,"Missing function argument");
			if (rc != SXERR_ABORT) {
				rc = SXERR_SYNTAX;
			}
			return rc;
		}

		if (iCur < nToken && apNode[iCur] && (apNode[iCur]->pStart->nType & PHP_TK_COMMA)) {
			iCur++;
			if (iCur >= nToken) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pOp->pStart->nLine,"Missing function argument");
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
		}
	}
	return SXRET_OK;
}

static sxi32 ExprMakeTree(php_gen_state* pGen,php_expr_node** apNode,sxi32 nToken)
{
	sxi32 i,iLeft,iRight;
	php_expr_node* pNode;
	sxi32 iCur;
	sxi32 rc;
	if (nToken <= 0 || (nToken == 1 && apNode[0]->xCode)) {

		return SXRET_OK;
	}

	for (iCur = 0; iCur < nToken; ++iCur) {
		sxi32 iNest;

		if (apNode[iCur] == 0 || apNode[iCur]->pStart->nType != PHP_TK_LPAREN) {
			continue;
		}
		iNest = 1;
		iLeft = iCur;

		iCur++;
		while (iCur < nToken) {
			if (apNode[iCur]) {
				if (apNode[iCur]->pStart->nType & PHP_TK_RPAREN ) {

					iNest--;
					if (iNest <= 0) {
						break;
					}
				}
				else if (apNode[iCur]->pStart->nType & PHP_TK_LPAREN ) {

					iNest++;
				}
			}
			iCur++;
		}
		if (iCur - iLeft > 1) {

			rc = ExprMakeTree(&(*pGen),&apNode[iLeft + 1],iCur - iLeft - 1);
			if (rc != SXRET_OK) {
				return rc;
			}
		}

		ExprFreeTree(&(*pGen),apNode[iLeft]);
		ExprFreeTree(&(*pGen),apNode[iCur]);
		apNode[iLeft] = 0;
		apNode[iCur] = 0;
	}

	for (iCur = 0; iCur < nToken; ++iCur) {
		sxi32 iNest;

		if (apNode[iCur] == 0 || apNode[iCur]->pStart->nType != PHP_TK_OCB) {
			continue;
		}
		iNest = 1;
		iLeft = iCur;

		iCur++;
		while (iCur < nToken) {
			if (apNode[iCur]) {
				if (apNode[iCur]->pStart->nType & PHP_TK_CCB) {

					iNest--;
					if (iNest <= 0) {
						break;
					}
				}
				else if (apNode[iCur]->pStart->nType & PHP_TK_OCB ) {

					iNest++;
				}
			}
			iCur++;
		}
		if (iCur - iLeft > 1) {

			rc = ExprMakeTree(&(*pGen),&apNode[iLeft + 1],iCur - iLeft - 1);
			if (rc != SXRET_OK) {
				return rc;
			}
		}

		ExprFreeTree(&(*pGen),apNode[iLeft]);
		ExprFreeTree(&(*pGen),apNode[iCur]);
		apNode[iLeft] = 0;
		apNode[iCur] = 0;
	}

	iLeft = -1;
	for (iCur = 0; iCur < nToken; ++iCur) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iPrec == 2 && pNode->pLeft == 0) {
			if (pNode->pOp->iOp == EXPR_OP_FUNC_CALL) {

				sxi32 iPtr = 0;
				sxi32 nFuncTok = 0;
				while (nFuncTok + iCur < nToken) {
					if (apNode[nFuncTok + iCur]) {
						if (apNode[nFuncTok + iCur]->pStart->nType & PHP_TK_LPAREN ) {
							iPtr++;
						}
						else if (apNode[nFuncTok + iCur]->pStart->nType & PHP_TK_RPAREN ) {
							iPtr--;
							if (iPtr <= 0) {
								break;
							}
						}
					}
					nFuncTok++;
				}
				if (nFuncTok + iCur >= nToken) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"Missing right parenthesis ')'");
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
				if (iLeft < 0 || !NODE_ISTERM(iLeft) ) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"Invalid function name");
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
				if (nFuncTok > 1) {

					rc = ExprProcessFuncArguments(&(*pGen),pNode,&apNode[iCur + 1],nFuncTok - 1);
					if (rc != SXRET_OK) {
						return rc;
					}
				}

				pNode->pLeft = apNode[iLeft];
				apNode[iLeft] = 0;
				for (iPtr = 1; iPtr <= nFuncTok; iPtr++) {
					apNode[iCur + iPtr] = 0;
				}
			}
			else if (pNode->pOp->iOp == EXPR_OP_SUBSCRIPT) {

				sxi32 iArrTok = iCur + 1;
				sxi32 iNest = 1;
				if (iLeft < 0 || apNode[iLeft] == 0 || (apNode[iLeft]->pOp == 0 && (apNode[iLeft]->xCode != PHP_CompileVariable &&
					apNode[iLeft]->xCode != PHP_CompileSimpleString && apNode[iLeft]->xCode != PHP_CompileString)) ||
					(apNode[iLeft]->pOp && apNode[iLeft]->pOp->iPrec != 2 )) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"Invalid array name");
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}

				while (iArrTok < nToken) {
					if (apNode[iArrTok]) {
						if (apNode[iArrTok]->pOp && apNode[iArrTok]->pOp->iOp == EXPR_OP_SUBSCRIPT && apNode[iArrTok]->pLeft == 0) {

							iNest++;
						}
						else if (apNode[iArrTok]->pStart->nType & PHP_TK_CSB ) {

							iNest--;
							if (iNest <= 0) {
								break;
							}
						}
					}
					++iArrTok;
				}
				if (iArrTok > iCur + 1) {

					rc = ExprMakeTree(&(*pGen),&apNode[iCur + 1],iArrTok - iCur - 1);
					if (rc != SXRET_OK) {
						return rc;
					}

					SySetPut(&pNode->aNodeArgs,(const void*)&apNode[iCur + 1]);
				}

				pNode->pLeft = apNode[iLeft];
				pNode->pRight = 0;
				apNode[iLeft] = 0;
				for (iNest = iCur + 1; iNest <= iArrTok; ++iNest) {
					apNode[iNest] = 0;
				}
			}
			else {

				iRight = iCur + 1;
				while (iRight < nToken && apNode[iRight] == 0) {
					iRight++;
				}
				if (iRight >= nToken || iLeft < 0 || !NODE_ISTERM(iRight) || !NODE_ISTERM(iLeft)) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing/Invalid member name",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}

				pNode->pLeft = apNode[iLeft];
				if (pNode->pOp->iOp == EXPR_OP_ARROW  && pNode->pLeft->pOp == 0 &&
					pNode->pLeft->xCode != PHP_CompileVariable) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,
						"'%z': Expecting a variable as left operand",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
				pNode->pRight = apNode[iRight];
				apNode[iLeft] = apNode[iRight] = 0;
			}
		}
		iLeft = iCur;
	}

	for (iCur = 0; iCur < nToken; ++iCur) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iPrec == 1 && pNode->pLeft == 0) {
			SyToken* pToken;

			iLeft = iCur + 1;
			while (iLeft < nToken && apNode[iLeft] == 0) {
				iLeft++;
			}
			if (iLeft >= nToken || !NODE_ISTERM(iLeft)) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Expecting class constructor call",
					&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}

			if (pNode->pOp->iOp == EXPR_OP_CLONE) {

				if (apNode[iLeft]->pOp == 0) {
					if (apNode[iLeft]->xCode != PHP_CompileVariable) {
						pToken = apNode[iLeft]->pStart;
						rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Unexpected token '%z'",
							&pNode->pOp->sOp,&pToken->sData);
						if (rc != SXERR_ABORT) {
							rc = SXERR_SYNTAX;
						}
						return rc;
					}
				}
			}
			else {

				if (apNode[iLeft]->pOp == 0) {
					ProcNodeConstruct xCons = apNode[iLeft]->xCode;
					if (xCons != PHP_CompileVariable && xCons != PHP_CompileLiteral && xCons != PHP_CompileSimpleString) {
						pToken = apNode[iLeft]->pStart;

						rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,
							"'%z': Unexpected token '%z',expecting literal,variable or constructor call",
							&pNode->pOp->sOp,&pToken->sData);
						if (rc != SXERR_ABORT) {
							rc = SXERR_SYNTAX;
						}
						return rc;
					}
				}
			}

			pNode->pLeft = apNode[iLeft];
			apNode[iLeft] = 0;
			pNode->pRight = 0;
		}
	}

	iLeft = -1;
	for (iCur = 0; iCur < nToken; ++iCur) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iPrec == 3 && pNode->pLeft == 0) {
			if (iLeft >= 0 && ((apNode[iLeft]->pOp && apNode[iLeft]->pOp->iPrec == 2 )
				|| apNode[iLeft]->xCode == PHP_CompileVariable)) {

				pNode->pLeft = apNode[iLeft];
				apNode[iLeft] = 0;
			}
		}
		iLeft = iCur;
	}
	iLeft = -1;
	for (iCur = nToken - 1; iCur >= 0; iCur--) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iPrec == 3 && pNode->pLeft == 0) {
			if (iLeft < 0 || (apNode[iLeft]->pOp == 0 && apNode[iLeft]->xCode != PHP_CompileVariable)
				|| (apNode[iLeft]->pOp && apNode[iLeft]->pOp->iPrec != 2 )) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z' operator needs l-value",&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}

			pNode->pLeft = apNode[iLeft];
			apNode[iLeft] = 0;

			pNode->iFlags |= EXPR_NODE_PRE_INCR;
		}
		iLeft = iCur;
	}

	iLeft = 0;
	for (iCur = nToken - 1; iCur >= 0; iCur--) {
		if (apNode[iCur]) {
			pNode = apNode[iCur];
			if (pNode->pOp && pNode->pOp->iPrec == 4 && pNode->pLeft == 0) {
				if (iLeft > 0) {

					pNode->pLeft = apNode[iLeft];
					apNode[iLeft] = 0;
					if (pNode->pLeft && pNode->pLeft->pOp && pNode->pLeft->pOp->iPrec > 4) {
						if (pNode->pLeft->pLeft == 0 || pNode->pLeft->pRight == 0) {

							rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pLeft->pStart->nLine,"'%z': Missing operand",&pNode->pLeft->pOp->sOp);
							if (rc != SXERR_ABORT) {
								rc = SXERR_SYNTAX;
							}
							return rc;
						}
					}
				}
				else {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing operand",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
			}

			iLeft = iCur;
		}
	}

	for (i = 7; i < 17; i++) {
		iLeft = -1;
		for (iCur = 0; iCur < nToken; ++iCur) {
			if (apNode[iCur] == 0) {
				continue;
			}
			pNode = apNode[iCur];
			if (pNode->pOp && pNode->pOp->iPrec == i && pNode->pLeft == 0) {

				iRight = iCur + 1;
				while (iRight < nToken && apNode[iRight] == 0) {
					iRight++;
				}
				if (iRight >= nToken || iLeft < 0 || !NODE_ISTERM(iRight) || !NODE_ISTERM(iLeft)) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing/Invalid operand",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
				if (pNode->pOp->iOp == EXPR_OP_REF) {
					sxi32  iTmp;

					if (ExprIsModifiableValue(apNode[iLeft],FALSE) == FALSE || (apNode[iLeft]->pOp && apNode[iLeft]->pOp->iVmOp == PHP_OP_MEMBER )) {

						rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'&': Left operand must be a modifiable l-value");
						if (rc != SXERR_ABORT) {
							rc = SXERR_SYNTAX;
						}
						return rc;
					}
					if (apNode[iLeft]->pOp == 0 || apNode[iLeft]->pOp->iOp != EXPR_OP_SUBSCRIPT ) {
						if (ExprIsModifiableValue(apNode[iRight],TRUE) == FALSE) {
							if (apNode[iRight]->pOp == 0 || (apNode[iRight]->pOp->iOp != EXPR_OP_NEW
								&& apNode[iRight]->pOp->iOp != EXPR_OP_CLONE )) {
								rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,
									"Reference operator '&' require a variable not a constant expression as it's right operand");
								if (rc != SXERR_ABORT) {
									rc = SXERR_SYNTAX;
								}
								return rc;
							}
						}
					}

					iTmp = iRight;
					iRight = iLeft;
					iLeft = iTmp;
				}

				pNode->pLeft = apNode[iLeft];
				pNode->pRight = apNode[iRight];
				apNode[iLeft] = apNode[iRight] = 0;
			}
			iLeft = iCur;
		}
	}

	iLeft = -1;
	for (iCur = 0; iCur < nToken; ++iCur) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iOp == EXPR_OP_QUESTY && pNode->pLeft == 0) {
			sxi32 iNest = 1;
			if (iLeft < 0 || !NODE_ISTERM(iLeft)) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Syntax error",&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}

			iRight = iCur + 1;
			while (iRight < nToken) {
				if (apNode[iRight]) {
					if (apNode[iRight]->pOp && apNode[iRight]->pOp->iOp == EXPR_OP_QUESTY && apNode[iRight]->pCond == 0) {

						++iNest;
					}
					else if (apNode[iRight]->pStart->nType & PHP_TK_COLON ) {

						--iNest;
						if (iNest <= 0) {
							break;
						}
					}
				}
				iRight++;
			}
			if (iRight > iCur + 1) {

				rc = ExprMakeTree(&(*pGen),&apNode[iCur + 1],iRight - iCur - 1);
				if (rc != SXRET_OK) {
					return rc;
				}

				pNode->pLeft = apNode[iCur + 1];
			}
			else {
				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing 'then' expression",&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			apNode[iCur + 1] = 0;
			if (iRight + 1 < nToken) {

				rc = ExprMakeTree(&(*pGen),&apNode[iRight + 1],nToken - iRight - 1);
				if (rc != SXRET_OK) {
					return rc;
				}

				pNode->pRight = apNode[iRight + 1];
				apNode[iRight + 1] = apNode[iRight] = 0;
			}
			else {
				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing 'else' expression",&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}

			pNode->pCond = apNode[iLeft];
			apNode[iLeft] = 0;
			break;
		}
		iLeft = iCur;
	}

	iRight = -1;
	for (iCur = nToken - 1; iCur >= 0; iCur--) {
		if (apNode[iCur] == 0) {
			continue;
		}
		pNode = apNode[iCur];
		if (pNode->pOp && pNode->pOp->iPrec == 18 && pNode->pLeft == 0) {

			iLeft = iCur - 1;
			while (iLeft >= 0 && apNode[iLeft] == 0) {
				iLeft--;
			}
			if (iLeft < 0 || iRight < 0 || !NODE_ISTERM(iRight) || !NODE_ISTERM(iLeft)) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing/Invalid operand",&pNode->pOp->sOp);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			if (ExprIsModifiableValue(apNode[iLeft],FALSE) == FALSE) {
				if (pNode->pOp->iVmOp != PHP_OP_STORE || apNode[iLeft]->xCode != PHP_CompileList) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,
						"'%z': Left operand must be a modifiable l-value",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}
			}

			pNode->pLeft = apNode[iRight];
			pNode->pRight = apNode[iLeft];
			apNode[iLeft] = apNode[iRight] = 0;
		}
		iRight = iCur;
	}

	for (i = 19; i < 23; i++) {
		iLeft = -1;
		for (iCur = 0; iCur < nToken; ++iCur) {
			if (apNode[iCur] == 0) {
				continue;
			}
			pNode = apNode[iCur];
			if (pNode->pOp && pNode->pOp->iPrec == i && pNode->pLeft == 0) {

				iRight = iCur + 1;
				while (iRight < nToken && apNode[iRight] == 0) {
					iRight++;
				}
				if (iRight >= nToken || iLeft < 0 || !NODE_ISTERM(iRight) || !NODE_ISTERM(iLeft)) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pNode->pStart->nLine,"'%z': Missing/Invalid operand",&pNode->pOp->sOp);
					if (rc != SXERR_ABORT) {
						rc = SXERR_SYNTAX;
					}
					return rc;
				}

				pNode->pLeft = apNode[iLeft];
				pNode->pRight = apNode[iRight];
				apNode[iLeft] = apNode[iRight] = 0;
			}
			iLeft = iCur;
		}
	}

	for (iCur = 1; iCur < nToken; ++iCur) {
		if (apNode[iCur]) {
			if ((apNode[iCur]->pOp || apNode[iCur]->xCode) && apNode[0] != 0) {
				rc = PHP_GenCompileError(pGen,E_ERROR,apNode[iCur]->pStart->nLine,"Unexpected token '%z'",&apNode[iCur]->pStart->sData);
				if (rc != SXERR_ABORT) {
					rc = SXERR_SYNTAX;
				}
				return rc;
			}
			apNode[0] = apNode[iCur];
			apNode[iCur] = 0;
		}
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_ExprMakeTree(php_gen_state* pGen,SySet* pExprNode,php_expr_node** ppRoot)
{
	php_expr_node** apNode;
	php_expr_node* pNode;
	sxi32 rc;

	SySetReset(pExprNode);
	pNode = 0;

	while (pGen->pIn < pGen->pEnd) {
		rc = ExprExtractNode(&(*pGen),&pNode);
		if (rc != SXRET_OK) {
			return rc;
		}

		SySetPut(pExprNode,(const void*)&pNode);
	}
	if (SySetUsed(pExprNode) < 1) {

		*ppRoot = 0;
		return SXRET_OK;
	}
	apNode = (php_expr_node**)SySetBasePtr(pExprNode);

	rc = ExprVerifyNodes(&(*pGen),apNode,(sxi32)SySetUsed(pExprNode));
	if (rc != SXRET_OK) {

		*ppRoot = 0;
		return rc;
	}

	rc = ExprMakeTree(&(*pGen),apNode,(sxi32)SySetUsed(pExprNode));
	if (rc != SXRET_OK) {

		*ppRoot = 0;
		return rc;
	}

	*ppRoot = apNode[0];
	return SXRET_OK;
}



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


PHP_PRIVATE php_class* PHP_NewRawClass(php_vm* pVm,const SyString* pName,sxu32 nLine)
{
	php_class* pClass;
	char* zName;

	pClass = (php_class*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_class));
	if (pClass == 0) {
		return 0;
	}

	SyZero(pClass,sizeof(php_class));

	zName = SyMemBackendStrDup(&pVm->sAllocator,pName->zString,pName->nByte);
	if (zName == 0) {
		SyMemBackendPoolFree(&pVm->sAllocator,pClass);
		return 0;
	}

	SyStringInitFromBuf(&pClass->sName,zName,pName->nByte);
	SyHashInit(&pClass->hMethod,&pVm->sAllocator,0,0);
	SyHashInit(&pClass->hAttr,&pVm->sAllocator,0,0);
	SyHashInit(&pClass->hDerived,&pVm->sAllocator,0,0);
	SySetInit(&pClass->aInterface,&pVm->sAllocator,sizeof(php_class*));
	pClass->nLine = nLine;

	return pClass;
}

PHP_PRIVATE php_class_attr* PHP_NewClassAttr(php_vm* pVm,const SyString* pName,sxu32 nLine,sxi32 iProtection,sxi32 iFlags)
{
	php_class_attr* pAttr;
	char* zName;
	pAttr = (php_class_attr*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_class_attr));
	if (pAttr == 0) {
		return 0;
	}

	SyZero(pAttr,sizeof(php_class_attr));

	zName = SyMemBackendStrDup(&pVm->sAllocator,pName->zString,pName->nByte);
	if (zName == 0) {
		SyMemBackendPoolFree(&pVm->sAllocator,pAttr);
		return 0;
	}

	SySetInit(&pAttr->aByteCode,&pVm->sAllocator,sizeof(VmInstr));
	SyStringInitFromBuf(&pAttr->sName,zName,pName->nByte);
	pAttr->iProtection = iProtection;
	pAttr->nIdx = SXU32_HIGH;
	pAttr->iFlags = iFlags;
	pAttr->nLine = nLine;
	return pAttr;
}

PHP_PRIVATE php_class_method* PHP_NewClassMethod(php_vm* pVm,php_class* pClass,const SyString* pName,sxu32 nLine,
	sxi32 iProtection,sxi32 iFlags,sxi32 iFuncFlags)
{
	php_class_method* pMeth;
	SyHashEntry* pEntry;
	SyString* pNamePtr;
	char zSalt[10];
	char* zName;
	sxu32 nByte;

	pMeth = (php_class_method*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_class_method));
	if (pMeth == 0) {
		return 0;
	}

	SyZero(pMeth,sizeof(php_class_method));

	pEntry = SyHashGet(&pClass->hMethod,(const void*)pName->zString,pName->nByte);
	if (pEntry == 0) {

		nByte = sizeof(zSalt) + pName->nByte + SyStringLength(&pClass->sName) + sizeof(char) * 7;
		zName = (char*)SyMemBackendAlloc(&pVm->sAllocator,nByte);
		if (zName == 0) {
			SyMemBackendPoolFree(&pVm->sAllocator,pMeth);
			return 0;
		}
		pNamePtr = &pMeth->sVmName;

		PHP_VmRandomString(&(*pVm),zSalt,sizeof(zSalt));
		pNamePtr->nByte = SyBufferFormat(zName,nByte,"[__%z@%z_%.*s]",&pClass->sName,pName,sizeof(zSalt),zSalt);
		pNamePtr->zString = zName;
	}
	else {

		php_class_method* pCurrent = (php_class_method*)pEntry->pUserData;
		pNamePtr = &pMeth->sVmName;

		SyStringDupPtr(pNamePtr,&pCurrent->sVmName);
		zName = (char*)pNamePtr->zString;
	}
	if (iProtection != PHP_CLASS_PROT_PUBLIC) {
		if ((pName->nByte == sizeof("__construct") - 1 && SyMemcmp(pName->zString,"__construct",sizeof("__construct") - 1) == 0)
			|| (pName->nByte == sizeof("__destruct") - 1 && SyMemcmp(pName->zString,"__destruct",sizeof("__destruct") - 1) == 0)
			|| SyStringCmp(pName,&pClass->sName,SyMemcmp) == 0) {

			iProtection = PHP_CLASS_PROT_PUBLIC;
		}
	}

	pMeth->iProtection = iProtection;
	pMeth->iFlags = iFlags;
	pMeth->nLine = nLine;
	PHP_VmInitFuncState(&(*pVm),&pMeth->sFunc,&zName[sizeof(char) * 4 + SyStringLength(&pClass->sName)],
		pName->nByte,iFuncFlags | VM_FUNC_CLASS_METHOD,pClass);
	return pMeth;
}

PHP_PRIVATE php_class_method* PHP_ClassExtractMethod(php_class* pClass,const char* zName,sxu32 nByte)
{
	SyHashEntry* pEntry;

	pEntry = SyHashGet(&pClass->hMethod,(const void*)zName,nByte);
	if (pEntry == 0) {

		return 0;
	}

	return (php_class_method*)pEntry->pUserData;
}

PHP_PRIVATE php_class_attr* PHP_ClassExtractAttribute(php_class* pClass,const char* zName,sxu32 nByte)
{
	SyHashEntry* pEntry;

	pEntry = SyHashGet(&pClass->hAttr,(const void*)zName,nByte);
	if (pEntry == 0) {

		return 0;
	}

	return (php_class_attr*)pEntry->pUserData;
}

PHP_PRIVATE sxi32 PHP_ClassInstallAttr(php_class* pClass,php_class_attr* pAttr)
{
	SyString* pName = &pAttr->sName;
	sxi32 rc;
	rc = SyHashInsert(&pClass->hAttr,(const void*)pName->zString,pName->nByte,pAttr);
	return rc;
}

PHP_PRIVATE sxi32 PHP_ClassInstallMethod(php_class* pClass,php_class_method* pMeth)
{
	SyString* pName = &pMeth->sFunc.sName;
	sxi32 rc;
	rc = SyHashInsert(&pClass->hMethod,(const void*)pName->zString,pName->nByte,pMeth);
	return rc;
}

PHP_PRIVATE sxi32 PHP_ClassInherit(php_gen_state* pGen,php_class* pSub,php_class* pBase)
{
	php_class_method* pMeth;
	php_class_attr* pAttr;
	SyHashEntry* pEntry;
	SyString* pName;
	sxi32 rc;

	rc = SyHashInsert(&pBase->hDerived,(const void*)SyStringData(&pSub->sName),SyStringLength(&pSub->sName),pSub);
	if (rc != SXRET_OK) {
		return rc;
	}

	SyHashResetLoopCursor(&pBase->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pBase->hAttr)) != 0) {

		pAttr = (php_class_attr*)pEntry->pUserData;
		pName = &pAttr->sName;
		if ((pEntry = SyHashGet(&pSub->hAttr,(const void*)pName->zString,pName->nByte)) != 0) {
			if (pAttr->iProtection == PHP_CLASS_PROT_PRIVATE &&
				((php_class_attr*)pEntry->pUserData)->iProtection != PHP_CLASS_PROT_PUBLIC) {

				PHP_GenCompileError(&(*pGen),E_WARNING,((php_class_attr*)pEntry->pUserData)->nLine,
					"Private attribute '%z::%z' redeclared inside child class '%z'",
					&pBase->sName,pName,&pSub->sName);

			}
			continue;
		}

		if (pAttr->iProtection != PHP_CLASS_PROT_PRIVATE) {
			rc = SyHashInsert(&pSub->hAttr,(const void*)pName->zString,pName->nByte,pAttr);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}
	SyHashResetLoopCursor(&pBase->hMethod);
	while ((pEntry = SyHashGetNextEntry(&pBase->hMethod)) != 0) {

		pMeth = (php_class_method*)pEntry->pUserData;
		pName = &pMeth->sFunc.sName;
		if ((pEntry = SyHashGet(&pSub->hMethod,(const void*)pName->zString,pName->nByte)) != 0) {
			if (pMeth->iFlags & PHP_CLASS_ATTR_FINAL) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,((php_class_method*)pEntry->pUserData)->nLine,
					"Cannot Overwrite final method '%z:%z' inside child class '%z'",
					&pBase->sName,pName,&pSub->sName);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			continue;
		}
		else {
			if (pMeth->iFlags & PHP_CLASS_ATTR_ABSTRACT) {

				PHP_GenCompileError(&(*pGen),E_WARNING,pMeth->nLine,
					"Abstract method '%z:%z' must be defined inside child class '%z'",
					&pBase->sName,pName,&pSub->sName);
				continue;
			}
		}

		if (pMeth->iProtection != PHP_CLASS_PROT_PRIVATE) {
			rc = SyHashInsert(&pSub->hMethod,(const void*)pName->zString,pName->nByte,pMeth);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}

	pSub->pBase = pBase;

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_ClassInterfaceInherit(php_class* pSub,php_class* pBase)
{
	php_class_method* pMeth;
	php_class_attr* pAttr;
	SyHashEntry* pEntry;
	SyString* pName;
	sxi32 rc;

	SyHashInsert(&pBase->hDerived,(const void*)SyStringData(&pSub->sName),SyStringLength(&pSub->sName),pSub);
	SyHashResetLoopCursor(&pBase->hAttr);

	while ((pEntry = SyHashGetNextEntry(&pBase->hAttr)) != 0) {

		pAttr = (php_class_attr*)pEntry->pUserData;
		pName = &pAttr->sName;
		if (SyHashGet(&pSub->hAttr,(const void*)pName->zString,pName->nByte) == 0) {

			rc = SyHashInsert(&pSub->hAttr,(const void*)pName->zString,pName->nByte,pAttr);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}
	SyHashResetLoopCursor(&pBase->hMethod);

	while ((pEntry = SyHashGetNextEntry(&pBase->hMethod)) != 0) {

		pMeth = (php_class_method*)pEntry->pUserData;
		pName = &pMeth->sFunc.sName;
		if (SyHashGet(&pSub->hMethod,(const void*)pName->zString,pName->nByte) == 0) {

			rc = SyHashInsert(&pSub->hMethod,(const void*)pName->zString,pName->nByte,pMeth);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}

	pSub->pBase = pBase;

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_ClassImplement(php_class* pMain,php_class* pInterface)
{
	php_class_attr* pAttr;
	SyHashEntry* pEntry;
	SyString* pName;
	sxi32 rc;

	SyHashResetLoopCursor(&pInterface->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pInterface->hAttr)) != 0) {

		pAttr = (php_class_attr*)pEntry->pUserData;
		pName = &pAttr->sName;

		if (SyHashGet(&pMain->hAttr,pName->zString,pName->nByte) == 0) {

			rc = SyHashInsert(&pMain->hAttr,pName->zString,pName->nByte,pAttr);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
	}

	SySetPut(&pMain->aInterface,(const void*)&pInterface);

	return SXRET_OK;
}

static php_class_instance* NewClassInstance(php_vm* pVm,php_class* pClass)
{
	php_class_instance* pThis;

	pThis = (php_class_instance*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_class_instance));
	if (pThis == 0) {
		return 0;
	}

	SyZero(pThis,sizeof(php_class_instance));

	pThis->iRef = 1;
	pThis->pVm = pVm;
	pThis->pClass = pClass;
	SyHashInit(&pThis->hAttr,&pVm->sAllocator,0,0);
	return pThis;
}

PHP_PRIVATE php_class_instance* PHP_NewClassInstance(php_vm* pVm,php_class* pClass)
{
	php_class_instance* pNew;
	sxi32 rc;
	pNew = NewClassInstance(&(*pVm),&(*pClass));
	if (pNew == 0) {
		return 0;
	}

	rc = PHP_VmCreateClassInstanceFrame(&(*pVm),pNew);
	if (rc != SXRET_OK) {
		SyMemBackendPoolFree(&pVm->sAllocator,pNew);
		return 0;
	}
	return pNew;
}

static php_value* ExtractClassAttrValue(php_vm* pVm,VmClassAttr* pAttr)
{

	php_value* pValue;
	pValue = (php_value*)SySetAt(&pVm->aMemObj,pAttr->nIdx);
	return pValue;
}

PHP_PRIVATE php_class_instance* PHP_CloneClassInstance(php_class_instance* pSrc)
{
	php_class_instance* pClone;
	php_class_method* pMethod;
	SyHashEntry* pEntry2;
	SyHashEntry* pEntry;
	php_vm* pVm;
	sxi32 rc;

	pVm = pSrc->pVm;
	pClone = NewClassInstance(pVm,pSrc->pClass);
	if (pClone == 0) {
		return 0;
	}

	rc = PHP_VmCreateClassInstanceFrame(pVm,pClone);
	if (rc != SXRET_OK) {
		SyMemBackendPoolFree(&pVm->sAllocator,pClone);
		return 0;
	}

	SyHashResetLoopCursor(&pSrc->hAttr);
	SyHashResetLoopCursor(&pClone->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pSrc->hAttr)) != 0 && (pEntry2 = SyHashGetNextEntry(&pClone->hAttr)) != 0) {
		VmClassAttr* pSrcAttr = (VmClassAttr*)pEntry->pUserData;
		VmClassAttr* pDestAttr = (VmClassAttr*)pEntry2->pUserData;

		if ((pSrcAttr->pAttr->iFlags & (PHP_CLASS_ATTR_STATIC | PHP_CLASS_ATTR_CONSTANT)) == 0) {
			php_value* pvSrc,* pvDest;
			pvSrc = ExtractClassAttrValue(pVm,pSrcAttr);
			pvDest = ExtractClassAttrValue(pVm,pDestAttr);
			if (pvSrc && pvDest) {
				PHP_MemObjStore(pvSrc,pvDest);
			}
		}
	}

	pMethod = PHP_ClassExtractMethod(pClone->pClass,"__clone",sizeof("__clone") - 1);
	if (pMethod) {
		if (pMethod->iCloneDepth < 16) {
			pMethod->iCloneDepth++;
			PHP_VmCallClassMethod(pVm,pClone,pMethod,0,0,0);
		}
		else {

			PHP_VmThrowError(pVm,0,PHP_CTX_ERR,"Object clone limit reached,no more call to __clone()");
		}

		pMethod->iCloneDepth = 0;
	}

	return pClone;
}
#define CLASS_INSTANCE_DESTROYED 0x001

static void PHP_ClassInstanceRelease(php_class_instance* pThis)
{
	php_class_method* pDestr;
	SyHashEntry* pEntry;
	php_class* pClass;
	php_vm* pVm;
	if (pThis->iFlags & CLASS_INSTANCE_DESTROYED) {

		return;
	}

	pThis->iFlags |= CLASS_INSTANCE_DESTROYED;

	pVm = pThis->pVm;
	pClass = pThis->pClass;
	pDestr = PHP_ClassExtractMethod(pClass,"__destruct",sizeof("__destruct") - 1);
	if (pDestr) {

		pThis->iRef = 2;
		PHP_VmCallClassMethod(pVm,pThis,pDestr,0,0,0);
	}

	SyHashResetLoopCursor(&pThis->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {
		VmClassAttr* pVmAttr = (VmClassAttr*)pEntry->pUserData;
		if ((pVmAttr->pAttr->iFlags & (PHP_CLASS_ATTR_STATIC | PHP_CLASS_ATTR_CONSTANT)) == 0) {
			PHP_VmUnsetMemObj(pVm,pVmAttr->nIdx,TRUE);
		}
		SyMemBackendPoolFree(&pVm->sAllocator,pVmAttr);
	}

	SyHashRelease(&pThis->hAttr);
	SyMemBackendPoolFree(&pVm->sAllocator,pThis);
}

PHP_PRIVATE void PHP_ClassInstanceUnref(php_class_instance* pThis)
{
	pThis->iRef--;
	if (pThis->iRef < 1) {

		PHP_ClassInstanceRelease(&(*pThis));
	}
}

PHP_PRIVATE sxi32 PHP_ClassInstanceCmp(php_class_instance* pLeft,php_class_instance* pRight,int bStrict,int iNest)
{
	SyHashEntry* pEntry,* pEntry2;
	php_value sV1,sV2;
	sxi32 rc;
	if (iNest > 31) {

		PHP_VmThrowError(pLeft->pVm,0,PHP_CTX_ERR,"Nesting limit reached: Infinite recursion?");
		return 1;
	}

	if (pLeft->pClass != pRight->pClass) {
		return 1;
	}
	if (bStrict) {

		return !(pLeft == pRight);
	}

	if (pLeft == pRight) {

		return 0;
	}
	SyHashResetLoopCursor(&pLeft->hAttr);
	SyHashResetLoopCursor(&pRight->hAttr);
	PHP_MemObjInit(pLeft->pVm,&sV1);
	PHP_MemObjInit(pLeft->pVm,&sV2);
	sV1.nIdx = sV2.nIdx = SXU32_HIGH;
	while ((pEntry = SyHashGetNextEntry(&pLeft->hAttr)) != 0 && (pEntry2 = SyHashGetNextEntry(&pRight->hAttr)) != 0) {
		VmClassAttr* p1 = (VmClassAttr*)pEntry->pUserData;
		VmClassAttr* p2 = (VmClassAttr*)pEntry2->pUserData;

		if ((p1->pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) == 0) {
			php_value* pL,* pR;
			pL = ExtractClassAttrValue(pLeft->pVm,p1);
			pR = ExtractClassAttrValue(pRight->pVm,p2);
			if (pL && pR) {
				PHP_MemObjLoad(pL,&sV1);
				PHP_MemObjLoad(pR,&sV2);

				rc = PHP_MemObjCmp(&sV1,&sV2,bStrict,iNest + 1);
				PHP_MemObjRelease(&sV1);
				PHP_MemObjRelease(&sV2);
				if (rc != 0) {

					return rc;
				}
			}
		}
	}

	return 0;
}

PHP_PRIVATE sxi32 PHP_ClassInstanceDump(SyBlob* pOut,php_class_instance* pThis,int ShowType,int nTab,int nDepth)
{
	SyHashEntry* pEntry;
	php_value* pValue;
	sxi32 rc; int i;
	if (nDepth > 31) {
		static const char zInfinite[] = "Nesting limit reached: Infinite recursion?";

		SyBlobAppend(&(*pOut),zInfinite,sizeof(zInfinite) - 1);
		if (ShowType) {
			SyBlobAppend(&(*pOut),")",sizeof(char));
		}
		return SXERR_LIMIT;
	}
	rc = SXRET_OK;
	if (!ShowType) {
		SyBlobAppend(&(*pOut),"Object(",sizeof("Object(") - 1);
	}

	SyBlobFormat(&(*pOut),"%z) {",&pThis->pClass->sName);
#ifdef __WINNT__
	SyBlobAppend(&(*pOut),"\r\n",sizeof("\r\n") - 1);
#else
	SyBlobAppend(&(*pOut),"\n",sizeof(char));
#endif

	SyHashResetLoopCursor(&pThis->hAttr);
	while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {
		VmClassAttr* pVmAttr = (VmClassAttr*)pEntry->pUserData;
		if ((pVmAttr->pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) == 0) {

			for (i = 0; i < nTab; i++) {
				SyBlobAppend(&(*pOut)," ",sizeof(char));
			}
			pValue = ExtractClassAttrValue(pThis->pVm,pVmAttr);
			if (pValue) {
				SyBlobFormat(&(*pOut),"['%z'] =>",&pVmAttr->pAttr->sName);
#ifdef __WINNT__
				SyBlobAppend(&(*pOut),"\r\n",sizeof("\r\n") - 1);
#else
				SyBlobAppend(&(*pOut),"\n",sizeof(char));
#endif
				rc = PHP_MemObjDump(&(*pOut),pValue,ShowType,nTab + 1,nDepth,0);
				if (rc == SXERR_LIMIT) {
					break;
				}
			}
		}
	}
	for (i = 0; i < nTab; i++) {
		SyBlobAppend(&(*pOut)," ",sizeof(char));
	}
	SyBlobAppend(&(*pOut),"}",sizeof(char));
	return rc;
}

PHP_PRIVATE sxi32 PHP_ClassInstanceCallMagicMethod(
	php_vm* pVm,
	php_class* pClass,
	php_class_instance* pThis,
	const char* zMethod,
	sxu32 nByte,
	const SyString* pAttrName
)
{
	php_value* apArg[2] = { 0 ,0 };
	php_class_method* pMeth;
	php_value sAttr;
	sxi32 rc; int nArg;

	pMeth = PHP_ClassExtractMethod(&(*pClass),zMethod,nByte);
	if (pMeth == 0) {

		return SXERR_NOTFOUND;
	}
	nArg = 0;

	if (pAttrName) {
		PHP_MemObjInitFromString(pVm,&sAttr,pAttrName);
		sAttr.nIdx = SXU32_HIGH;
		apArg[0] = &sAttr;
		nArg = 1;
	}

	rc = PHP_VmCallClassMethod(pVm,&(*pThis),pMeth,0,nArg,apArg);

	if (pAttrName) {
		PHP_MemObjRelease(&sAttr);
	}
	return rc;
}

PHP_PRIVATE php_value* PHP_ClassInstanceExtractAttrValue(php_class_instance* pThis,VmClassAttr* pAttr)
{

	php_value* pValue;
	pValue = ExtractClassAttrValue(pThis->pVm,pAttr);
	return pValue;
}

PHP_PRIVATE sxi32 PHP_ClassInstanceToHashmap(php_class_instance* pThis,php_hashmap* pMap)
{
	SyHashEntry* pEntry;
	SyString* pAttrName;
	VmClassAttr* pAttr;
	php_value* pValue;
	php_value sName;

	SyHashResetLoopCursor(&pThis->hAttr);
	PHP_MemObjInitFromString(pThis->pVm,&sName,0);
	while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {

		pAttr = (VmClassAttr*)pEntry->pUserData;

		pValue = ExtractClassAttrValue(pThis->pVm,pAttr);
		if (pValue) {

			pAttrName = &pAttr->pAttr->sName;
			PHP_MemObjStringAppend(&sName,pAttrName->zString,pAttrName->nByte);

			PHP_HashmapInsert(pMap,&sName,pValue);

			SyBlobReset(&sName.sBlob);
		}
	}
	PHP_MemObjRelease(&sName);
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_ClassInstanceWalk(
	php_class_instance* pThis,
	int (*xWalk)(const char*,php_value*,void*),
	void* pUserData
)
{
	SyHashEntry* pEntry;
	VmClassAttr* pAttr;
	php_value* pValue;
	php_value sValue; int rc;

	SyHashResetLoopCursor(&pThis->hAttr);
	PHP_MemObjInit(pThis->pVm,&sValue);

	while ((pEntry = SyHashGetNextEntry(&pThis->hAttr)) != 0) {

		pAttr = (VmClassAttr*)pEntry->pUserData;

		pValue = ExtractClassAttrValue(pThis->pVm,pAttr);
		if (pValue) {
			PHP_MemObjLoad(pValue,&sValue);

			rc = xWalk(SyStringData(&pAttr->pAttr->sName),&sValue,pUserData);
			PHP_MemObjRelease(&sValue);
			if (rc != PHP_OK) {

				return SXERR_ABORT;
			}
		}
	}

	return SXRET_OK;
}

PHP_PRIVATE php_value* PHP_ClassInstanceFetchAttr(php_class_instance* pThis,const SyString* pName)
{
	SyHashEntry* pEntry;
	VmClassAttr* pAttr;

	pEntry = SyHashGet(&pThis->hAttr,(const void*)pName->zString,pName->nByte);
	if (pEntry == 0) {

		return 0;
	}

	pAttr = (VmClassAttr*)pEntry->pUserData;

	if (pAttr->pAttr->iFlags & (PHP_CLASS_ATTR_CONSTANT | PHP_CLASS_ATTR_STATIC)) {

		return 0;
	}

	return ExtractClassAttrValue(pThis->pVm,pAttr);
}



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif



static sxi64 MemObjRealToInt(php_value* pObj)
{
#ifdef PHP_OMIT_FLOATING_POINT

	return pObj->rVal;
#else

	static const sxi64 maxInt = LARGEST_INT64;
	static const sxi64 minInt = SMALLEST_INT64;
	php_real r = pObj->rVal;
	if (r < (php_real)minInt) {
		return minInt;
	}
	else if (r > (php_real)maxInt) {

		return minInt;
	}
	else {
		return (sxi64)r;
	}
#endif
}

PHP_PRIVATE sxi64 PHP_TokenValueToInt64(SyString* pVal)
{
	sxi64 iVal = 0;
	if (pVal->nByte <= 0) {
		return 0;
	}
	if (pVal->zString[0] == '0') {
		sxi32 c;
		if (pVal->nByte == sizeof(char)) {
			return 0;
		}
		c = pVal->zString[1];
		if (c == 'x' || c == 'X') {

			SyHexStrToInt64(pVal->zString,pVal->nByte,(void*)&iVal,0);
		}
		else if (c == 'b' || c == 'B') {

			SyBinaryStrToInt64(pVal->zString,pVal->nByte,(void*)&iVal,0);
		}
		else {

			SyOctalStrToInt64(pVal->zString,pVal->nByte,(void*)&iVal,0);
		}
	}
	else {

		SyStrToInt64(pVal->zString,pVal->nByte,(void*)&iVal,0);
	}
	return iVal;
}

static sxi64 MemObjStringToInt(php_value* pObj)
{
	SyString sVal;
	SyStringInitFromBuf(&sVal,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));
	return PHP_TokenValueToInt64(&sVal);
}

static sxi32 MemObjCallClassCastMethod(
	php_vm* pVm,
	php_class_instance* pThis,
	const char* zMethod,
	sxu32 nLen,
	php_value* pResult
)
{
	php_class_method* pMethod;

	pMethod = PHP_ClassExtractMethod(pThis->pClass,zMethod,nLen);
	if (pMethod == 0) {

		return SXERR_NOTFOUND;
	}

	PHP_VmCallClassMethod(&(*pVm),&(*pThis),pMethod,&(*pResult),0,0);

	return SXRET_OK;
}

static sxi64 MemObjIntValue(php_value* pObj)
{
	sxi32 iFlags;
	iFlags = pObj->iFlags;
	if (iFlags & MEMOBJ_REAL) {
		return MemObjRealToInt(&(*pObj));
	}
	else if (iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
		return pObj->x.iVal;
	}
	else if (iFlags & MEMOBJ_STRING) {
		return MemObjStringToInt(&(*pObj));
	}
	else if (iFlags & MEMOBJ_NULL) {
		return 0;
	}
	else if (iFlags & MEMOBJ_HASHMAP) {
		php_hashmap* pMap = (php_hashmap*)pObj->x.pOther;
		sxu32 n = pMap->nEntry;
		PHP_HashmapUnref(pMap);

		return n;
	}
	else if (iFlags & MEMOBJ_OBJ) {
		php_value sResult;
		sxi64 iVal = 1;
		sxi32 rc;

		PHP_MemObjInit(pObj->pVm,&sResult);
		rc = MemObjCallClassCastMethod(pObj->pVm,(php_class_instance*)pObj->x.pOther,
			"__toInt",sizeof("__toInt") - 1,&sResult);
		if (rc == SXRET_OK && (sResult.iFlags & MEMOBJ_INT)) {

			iVal = sResult.x.iVal;
		}
		PHP_ClassInstanceUnref((php_class_instance*)pObj->x.pOther);
		PHP_MemObjRelease(&sResult);
		return iVal;
	}
	else if (iFlags & MEMOBJ_RES) {
		return pObj->x.pOther != 0;
	}

	return 0;
}

static php_real MemObjRealValue(php_value* pObj)
{
	sxi32 iFlags;
	iFlags = pObj->iFlags;
	if (iFlags & MEMOBJ_REAL) {
		return pObj->rVal;
	}
	else if (iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
		return (php_real)pObj->x.iVal;
	}
	else if (iFlags & MEMOBJ_STRING) {
		SyString sString;
#ifdef PHP_OMIT_FLOATING_POINT
		php_real rVal = 0;
#else
		php_real rVal = 0.0;
#endif
		SyStringInitFromBuf(&sString,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));
		if (SyBlobLength(&pObj->sBlob) > 0) {

#ifdef PHP_OMIT_FLOATING_POINT
			rVal = MemObjStringToInt(&(*pObj));
#else
			SyStrToReal(sString.zString,sString.nByte,(void*)&rVal,0);
#endif
		}
		return rVal;
	}
	else if (iFlags & MEMOBJ_NULL) {
#ifdef PHP_OMIT_FLOATING_POINT
		return 0;
#else
		return 0.0;
#endif
	}
	else if (iFlags & MEMOBJ_HASHMAP) {

		php_hashmap* pMap = (php_hashmap*)pObj->x.pOther;
		php_real n = (php_real)pMap->nEntry;
		PHP_HashmapUnref(pMap);
		return n;
	}
	else if (iFlags & MEMOBJ_OBJ) {
		php_value sResult;
		php_real rVal = 1;
		sxi32 rc;

		PHP_MemObjInit(pObj->pVm,&sResult);
		rc = MemObjCallClassCastMethod(pObj->pVm,(php_class_instance*)pObj->x.pOther,
			"__toFloat",sizeof("__toFloat") - 1,&sResult);
		if (rc == SXRET_OK && (sResult.iFlags & MEMOBJ_REAL)) {

			rVal = sResult.rVal;
		}
		PHP_ClassInstanceUnref((php_class_instance*)pObj->x.pOther);
		PHP_MemObjRelease(&sResult);
		return rVal;
	}
	else if (iFlags & MEMOBJ_RES) {
		return (php_real)(pObj->x.pOther != 0);
	}

	return 0;
}

static sxi32 MemObjStringValue(SyBlob* pOut,php_value* pObj,sxu8 bStrictBool)
{
	if (pObj->iFlags & MEMOBJ_REAL) {
		SyBlobFormat(&(*pOut),"%.15g",pObj->rVal);
	}
	else if (pObj->iFlags & MEMOBJ_INT) {
		SyBlobFormat(&(*pOut),"%qd",pObj->x.iVal);

	}
	else if (pObj->iFlags & MEMOBJ_BOOL) {
		if (pObj->x.iVal) {
			SyBlobAppend(&(*pOut),"TRUE",sizeof("TRUE") - 1);
		}
		else {
			if (!bStrictBool) {
				SyBlobAppend(&(*pOut),"FALSE",sizeof("FALSE") - 1);
			}
		}
	}
	else if (pObj->iFlags & MEMOBJ_HASHMAP) {
		SyBlobAppend(&(*pOut),"Array",sizeof("Array") - 1);
		PHP_HashmapUnref((php_hashmap*)pObj->x.pOther);
	}
	else if (pObj->iFlags & MEMOBJ_OBJ) {
		php_value sResult;
		sxi32 rc;

		PHP_MemObjInit(pObj->pVm,&sResult);
		rc = MemObjCallClassCastMethod(pObj->pVm,(php_class_instance*)pObj->x.pOther,
			"__toString",sizeof("__toString") - 1,&sResult);
		if (rc == SXRET_OK && (sResult.iFlags & MEMOBJ_STRING) && SyBlobLength(&sResult.sBlob) > 0) {

			SyBlobDup(&sResult.sBlob,pOut);
		}
		else {

			SyBlobAppend(&(*pOut),"Object",sizeof("Object") - 1);
		}
		PHP_ClassInstanceUnref((php_class_instance*)pObj->x.pOther);
		PHP_MemObjRelease(&sResult);
	}
	else if (pObj->iFlags & MEMOBJ_RES) {
		SyBlobFormat(&(*pOut),"ResourceID_%#x",pObj->x.pOther);
	}
	return SXRET_OK;
}

static sxi32 MemObjBooleanValue(php_value* pObj)
{
	sxi32 iFlags;
	iFlags = pObj->iFlags;
	if (iFlags & MEMOBJ_REAL) {
#ifdef PHP_OMIT_FLOATING_POINT
		return pObj->rVal ? 1 : 0;
#else
		return pObj->rVal != 0.0 ? 1 : 0;
#endif
	}
	else if (iFlags & MEMOBJ_INT) {
		return pObj->x.iVal ? 1 : 0;
	}
	else if (iFlags & MEMOBJ_STRING) {
		SyString sString;
		SyStringInitFromBuf(&sString,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));
		if (sString.nByte == 0) {

			return 0;
		}
		else if ((sString.nByte == sizeof("true") - 1 && SyStrnicmp(sString.zString,"true",sizeof("true") - 1) == 0) ||
			(sString.nByte == sizeof("on") - 1 && SyStrnicmp(sString.zString,"on",sizeof("on") - 1) == 0) ||
			(sString.nByte == sizeof("yes") - 1 && SyStrnicmp(sString.zString,"yes",sizeof("yes") - 1) == 0)) {
			return 1;
		}
		else if (sString.nByte == sizeof("false") - 1 && SyStrnicmp(sString.zString,"false",sizeof("false") - 1) == 0) {
			return 0;
		}
		else {
			const char* zIn,* zEnd;
			zIn = sString.zString;
			zEnd = &zIn[sString.nByte];
			while (zIn < zEnd&& zIn[0] == '0') {
				zIn++;
			}
			return zIn >= zEnd ? 0 : 1;
		}
	}
	else if (iFlags & MEMOBJ_NULL) {
		return 0;
	}
	else if (iFlags & MEMOBJ_HASHMAP) {
		php_hashmap* pMap = (php_hashmap*)pObj->x.pOther;
		sxu32 n = pMap->nEntry;
		PHP_HashmapUnref(pMap);
		return n > 0 ? TRUE : FALSE;
	}
	else if (iFlags & MEMOBJ_OBJ) {
		php_value sResult;
		sxi32 iVal = 1;
		sxi32 rc;

		PHP_MemObjInit(pObj->pVm,&sResult);
		rc = MemObjCallClassCastMethod(pObj->pVm,(php_class_instance*)pObj->x.pOther,
			"__toBool",sizeof("__toBool") - 1,&sResult);
		if (rc == SXRET_OK && (sResult.iFlags & (MEMOBJ_INT | MEMOBJ_BOOL))) {

			iVal = (sxi32)(sResult.x.iVal != 0);
		}
		PHP_ClassInstanceUnref((php_class_instance*)pObj->x.pOther);
		PHP_MemObjRelease(&sResult);
		return iVal;
	}
	else if (iFlags & MEMOBJ_RES) {
		return pObj->x.pOther != 0;
	}

	return 0;
}

static sxi32 MemObjTryIntger(php_value* pObj)
{
	pObj->x.iVal = MemObjRealToInt(&(*pObj));

	if (pObj->rVal == (php_real)pObj->x.iVal && pObj->x.iVal > SMALLEST_INT64
		&& pObj->x.iVal < LARGEST_INT64) {
		pObj->iFlags |= MEMOBJ_INT;
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjToInteger(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_INT) == 0) {

		pObj->x.iVal = MemObjIntValue(&(*pObj));

		SyBlobRelease(&pObj->sBlob);
		MemObjSetType(pObj,MEMOBJ_INT);
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjToReal(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_REAL) == 0) {

		pObj->rVal = MemObjRealValue(&(*pObj));

		SyBlobRelease(&pObj->sBlob);
		MemObjSetType(pObj,MEMOBJ_REAL);

		MemObjTryIntger(&(*pObj));
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjToBool(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_BOOL) == 0) {

		pObj->x.iVal = MemObjBooleanValue(&(*pObj));

		SyBlobRelease(&pObj->sBlob);
		MemObjSetType(pObj,MEMOBJ_BOOL);
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjToString(php_value* pObj)
{
	sxi32 rc = SXRET_OK;
	if ((pObj->iFlags & MEMOBJ_STRING) == 0) {

		SyBlobReset(&pObj->sBlob);
		rc = MemObjStringValue(&pObj->sBlob,&(*pObj),TRUE);
		MemObjSetType(pObj,MEMOBJ_STRING);
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_MemObjToNull(php_value* pObj)
{
	return PHP_MemObjRelease(pObj);
}

PHP_PRIVATE sxi32 PHP_MemObjToHashmap(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_HASHMAP) == 0) {
		php_hashmap* pMap;

		pMap = PHP_NewHashmap(pObj->pVm,0,0);
		if (pMap == 0) {
			return SXERR_MEM;
		}
		if ((pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_RES)) == 0) {

			if (pObj->iFlags & MEMOBJ_OBJ) {

				PHP_ClassInstanceToHashmap((php_class_instance*)pObj->x.pOther,pMap);
			}
			else {

				PHP_HashmapInsert(pMap,0,&(*pObj));
			}
			SyBlobRelease(&pObj->sBlob);
		}

		MemObjSetType(pObj,MEMOBJ_HASHMAP);
		pObj->x.pOther = pMap;
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjToObject(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_OBJ) == 0) {
		php_class_instance* pStd;
		php_class_method* pCons;
		php_class* pClass;
		php_vm* pVm;

		pVm = pObj->pVm;

		pClass = PHP_VmExtractClass(pVm,"stdClass",sizeof("stdClass") - 1,0,0);
		if (pClass == 0) {

			PHP_MemObjRelease(pObj);
			return SXRET_OK;
		}

		pStd = PHP_NewClassInstance(pVm,pClass);
		if (pStd == 0) {

			PHP_MemObjRelease(pObj);
			return SXRET_OK;
		}

		pCons = PHP_ClassExtractMethod(pClass,"__construct",sizeof("__construct") - 1);
		if (pCons) {
			php_value* apArg[2];

			apArg[0] = pObj;
			PHP_VmCallClassMethod(pVm,pStd,pCons,0,1,apArg);
			if (pStd->iRef < 1) {
				pStd->iRef = 1;
			}
		}

		PHP_MemObjRelease(pObj);

		pObj->x.pOther = pStd;
		MemObjSetType(pObj,MEMOBJ_OBJ);
	}
	return SXRET_OK;
}

PHP_PRIVATE ProcMemObjCast PHP_MemObjCastMethod(sxi32 iFlags)
{
	if (iFlags & MEMOBJ_STRING) {
		return PHP_MemObjToString;
	}
	else if (iFlags & MEMOBJ_INT) {
		return PHP_MemObjToInteger;
	}
	else if (iFlags & MEMOBJ_REAL) {
		return PHP_MemObjToReal;
	}
	else if (iFlags & MEMOBJ_BOOL) {
		return PHP_MemObjToBool;
	}
	else if (iFlags & MEMOBJ_HASHMAP) {
		return PHP_MemObjToHashmap;
	}
	else if (iFlags & MEMOBJ_OBJ) {
		return PHP_MemObjToObject;
	}

	return PHP_MemObjToNull;
}

PHP_PRIVATE sxi32 PHP_MemObjIsNumeric(php_value* pObj)
{
	if (pObj->iFlags & (MEMOBJ_BOOL | MEMOBJ_INT | MEMOBJ_REAL)) {
		return TRUE;
	}
	else if (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) {
		return FALSE;
	}
	else if (pObj->iFlags & MEMOBJ_STRING) {
		SyString sStr;
		sxi32 rc;
		SyStringInitFromBuf(&sStr,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));
		if (sStr.nByte <= 0) {

			return FALSE;
		}

		rc = SyStrIsNumeric(sStr.zString,sStr.nByte,0,0);
		return rc == SXRET_OK ? TRUE : FALSE;
	}

	return FALSE;
}

PHP_PRIVATE sxi32 PHP_MemObjIsEmpty(php_value* pObj)
{
	if (pObj->iFlags & MEMOBJ_NULL) {
		return TRUE;
	}
	else if (pObj->iFlags & MEMOBJ_INT) {
		return pObj->x.iVal == 0 ? TRUE : FALSE;
	}
	else if (pObj->iFlags & MEMOBJ_REAL) {
		return pObj->rVal == (php_real)0 ? TRUE : FALSE;
	}
	else if (pObj->iFlags & MEMOBJ_BOOL) {
		return !pObj->x.iVal;
	}
	else if (pObj->iFlags & MEMOBJ_STRING) {
		if (SyBlobLength(&pObj->sBlob) <= 0) {
			return TRUE;
		}
		else {
			const char* zIn,* zEnd;
			zIn = (const char*)SyBlobData(&pObj->sBlob);
			zEnd = &zIn[SyBlobLength(&pObj->sBlob)];
			while (zIn < zEnd) {
				if (zIn[0] != '0') {
					break;
				}
				zIn++;
			}
			return zIn >= zEnd ? TRUE : FALSE;
		}
	}
	else if (pObj->iFlags & MEMOBJ_HASHMAP) {
		php_hashmap* pMap = (php_hashmap*)pObj->x.pOther;
		return pMap->nEntry == 0 ? TRUE : FALSE;
	}
	else if (pObj->iFlags & (MEMOBJ_OBJ | MEMOBJ_RES)) {
		return FALSE;
	}

	return TRUE;
}

PHP_PRIVATE sxi32 PHP_MemObjToNumeric(php_value* pObj)
{
	if (pObj->iFlags & (MEMOBJ_INT | MEMOBJ_REAL | MEMOBJ_BOOL | MEMOBJ_NULL)) {
		if (pObj->iFlags & (MEMOBJ_BOOL | MEMOBJ_NULL)) {
			if (pObj->iFlags & MEMOBJ_NULL) {
				pObj->x.iVal = 0;
			}
			MemObjSetType(pObj,MEMOBJ_INT);
		}

		return  SXRET_OK;
	}
	if (pObj->iFlags & MEMOBJ_STRING) {
		sxi32 rc = SXERR_INVALID;
		sxu8 bReal = FALSE;
		SyString sString;
		SyStringInitFromBuf(&sString,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob));

		if (sString.nByte > 0) {
			rc = SyStrIsNumeric(sString.zString,sString.nByte,&bReal,0);
		}
		if (bReal) {
			PHP_MemObjToReal(&(*pObj));
		}
		else {
			if (rc != SXRET_OK) {

				pObj->x.iVal = 0;
			}
			else {

				pObj->x.iVal = MemObjStringToInt(&(*pObj));
			}
			MemObjSetType(pObj,MEMOBJ_INT);
			SyBlobRelease(&pObj->sBlob);
		}
	}
	else if (pObj->iFlags & (MEMOBJ_OBJ | MEMOBJ_HASHMAP | MEMOBJ_RES)) {
		PHP_MemObjToInteger(pObj);
	}
	else {

		PHP_MemObjToReal(&(*pObj));
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjTryInteger(php_value* pObj)
{
	if (pObj->iFlags & MEMOBJ_REAL) {

		MemObjTryIntger(&(*pObj));
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjInit(php_vm* pVm,php_value* pObj)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);

	pObj->iFlags = MEMOBJ_NULL;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjInitFromInt(php_vm* pVm,php_value* pObj,sxi64 iVal)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);

	pObj->x.iVal = iVal;
	pObj->iFlags = MEMOBJ_INT;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjInitFromBool(php_vm* pVm,php_value* pObj,sxi32 iVal)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);

	pObj->x.iVal = iVal ? 1 : 0;
	pObj->iFlags = MEMOBJ_BOOL;
	return SXRET_OK;
}
#if 0

PHP_PRIVATE sxi32 PHP_MemObjInitFromReal(php_vm* pVm,php_value* pObj,php_real rVal)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);

	pObj->rVal = rVal;
	pObj->iFlags = MEMOBJ_REAL;
	return SXRET_OK;
}
#endif

PHP_PRIVATE sxi32 PHP_MemObjInitFromArray(php_vm* pVm,php_value* pObj,php_hashmap* pArray)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);

	pObj->iFlags = MEMOBJ_HASHMAP;
	pObj->x.pOther = pArray;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjInitFromString(php_vm* pVm,php_value* pObj,const SyString* pVal)
{

	SyZero(pObj,sizeof(php_value));

	pObj->pVm = pVm;
	SyBlobInit(&pObj->sBlob,&pVm->sAllocator);
	if (pVal) {

		SyBlobAppend(&pObj->sBlob,(const void*)pVal->zString,pVal->nByte);
	}

	pObj->iFlags = MEMOBJ_STRING;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjStringAppend(php_value* pObj,const char* zData,sxu32 nLen)
{
	sxi32 rc;
	if ((pObj->iFlags & MEMOBJ_STRING) == 0) {

		PHP_MemObjRelease(pObj);
		MemObjSetType(pObj,MEMOBJ_STRING);
	}

	rc = SyBlobAppend(&pObj->sBlob,zData,nLen);
	return rc;
}
#if 0

PHP_PRIVATE sxi32 PHP_MemObjStringFormat(php_value* pObj,const char* zFormat,va_list ap)
{
	sxi32 rc;
	if ((pObj->iFlags & MEMOBJ_STRING) == 0) {

		PHP_MemObjRelease(pObj);
		MemObjSetType(pObj,MEMOBJ_STRING);
	}

	rc = SyBlobFormatAp(&pObj->sBlob,zFormat,ap);
	return rc;
}
#endif

PHP_PRIVATE sxi32 PHP_MemObjStore(php_value* pSrc,php_value* pDest)
{
	php_class_instance* pObj = 0;
	php_hashmap* pMap = 0;
	sxi32 rc;
	if (pSrc->iFlags & MEMOBJ_HASHMAP) {

		((php_hashmap*)pSrc->x.pOther)->iRef++;
	}
	else if (pSrc->iFlags & MEMOBJ_OBJ) {

		((php_class_instance*)pSrc->x.pOther)->iRef++;
	}
	if (pDest->iFlags & MEMOBJ_HASHMAP) {
		pMap = (php_hashmap*)pDest->x.pOther;
	}
	else if (pDest->iFlags & MEMOBJ_OBJ) {
		pObj = (php_class_instance*)pDest->x.pOther;
	}
	SyMemcpy((const void*)&(*pSrc),&(*pDest),sizeof(php_value) - (sizeof(php_vm*) + sizeof(SyBlob) + sizeof(sxu32)));
	pDest->iFlags &= ~MEMOBJ_AUX;
	rc = SXRET_OK;
	if (SyBlobLength(&pSrc->sBlob) > 0) {
		SyBlobReset(&pDest->sBlob);
		rc = SyBlobDup(&pSrc->sBlob,&pDest->sBlob);
	}
	else {
		if (SyBlobLength(&pDest->sBlob) > 0) {
			SyBlobRelease(&pDest->sBlob);
		}
	}
	if (pMap) {
		PHP_HashmapUnref(pMap);
	}
	else if (pObj) {
		PHP_ClassInstanceUnref(pObj);
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_MemObjLoad(php_value* pSrc,php_value* pDest)
{
	SyMemcpy((const void*)&(*pSrc),&(*pDest),
		sizeof(php_value) - (sizeof(php_vm*) + sizeof(SyBlob) + sizeof(sxu32)));
	if (pSrc->iFlags & MEMOBJ_HASHMAP) {

		((php_hashmap*)pSrc->x.pOther)->iRef++;
	}
	else if (pSrc->iFlags & MEMOBJ_OBJ) {

		((php_class_instance*)pSrc->x.pOther)->iRef++;
	}
	if (SyBlobLength(&pDest->sBlob) > 0) {
		SyBlobRelease(&pDest->sBlob);
	}
	if (SyBlobLength(&pSrc->sBlob) > 0) {
		SyBlobReadOnly(&pDest->sBlob,SyBlobData(&pSrc->sBlob),SyBlobLength(&pSrc->sBlob));
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjRelease(php_value* pObj)
{
	if ((pObj->iFlags & MEMOBJ_NULL) == 0) {
		if (pObj->iFlags & MEMOBJ_HASHMAP) {
			PHP_HashmapUnref((php_hashmap*)pObj->x.pOther);
		}
		else if (pObj->iFlags & MEMOBJ_OBJ) {
			PHP_ClassInstanceUnref((php_class_instance*)pObj->x.pOther);
		}

		SyBlobRelease(&pObj->sBlob);

		pObj->iFlags = MEMOBJ_NULL;
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_MemObjCmp(php_value* pObj1,php_value* pObj2,int bStrict,int iNest)
{
	sxi32 iComb;
	sxi32 rc;
	if (bStrict) {
		sxi32 iF1,iF2;

		iF1 = pObj1->iFlags & ~MEMOBJ_AUX;
		iF2 = pObj2->iFlags & ~MEMOBJ_AUX;
		if (iF1 != iF2) {

			return 1;
		}
	}

	iComb = pObj1->iFlags | pObj2->iFlags;
	if (iComb & (MEMOBJ_NULL | MEMOBJ_RES | MEMOBJ_BOOL)) {

		if ((pObj1->iFlags & MEMOBJ_BOOL) == 0) {
			PHP_MemObjToBool(pObj1);
		}
		if ((pObj2->iFlags & MEMOBJ_BOOL) == 0) {
			PHP_MemObjToBool(pObj2);
		}
		return (sxi32)((pObj1->x.iVal != 0) - (pObj2->x.iVal != 0));
	}
	else if (iComb & MEMOBJ_HASHMAP) {

		if ((pObj1->iFlags & MEMOBJ_HASHMAP) == 0) {

			return -1;
		}
		if ((pObj2->iFlags & MEMOBJ_HASHMAP) == 0) {

			return 1;
		}

		rc = PHP_HashmapCmp((php_hashmap*)pObj1->x.pOther,(php_hashmap*)pObj2->x.pOther,bStrict);
		return rc;
	}
	else if (iComb & MEMOBJ_OBJ) {

		if ((pObj1->iFlags & MEMOBJ_OBJ) == 0) {

			return -1;
		}
		if ((pObj2->iFlags & MEMOBJ_OBJ) == 0) {

			return 1;
		}

		rc = PHP_ClassInstanceCmp((php_class_instance*)pObj1->x.pOther,(php_class_instance*)pObj2->x.pOther,bStrict,iNest);
		return rc;
	}
	else if (iComb & MEMOBJ_STRING) {
		SyString s1,s2;
		if (!bStrict) {

			if (PHP_MemObjIsNumeric(pObj1)) {

				goto Numeric;
			}
			if (PHP_MemObjIsNumeric(pObj2)) {

				goto Numeric;
			}
		}

		if ((pObj1->iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(pObj1);
		}
		if ((pObj2->iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(pObj2);
		}
		SyStringInitFromBuf(&s1,SyBlobData(&pObj1->sBlob),SyBlobLength(&pObj1->sBlob));
		SyStringInitFromBuf(&s2,SyBlobData(&pObj2->sBlob),SyBlobLength(&pObj2->sBlob));

		rc = SyMemcmp((const void*)s1.zString,(const void*)s2.zString,SXMIN(s1.nByte,s2.nByte));
		if (rc == 0) {
			if (s1.nByte != s2.nByte) {
				rc = s1.nByte < s2.nByte ? -1 : 1;
			}
		}
		return rc;
	}
	else if (iComb & (MEMOBJ_INT | MEMOBJ_REAL)) {
	Numeric:

		if ((pObj1->iFlags & (MEMOBJ_INT | MEMOBJ_REAL)) == 0) {
			PHP_MemObjToNumeric(pObj1);
		}
		if ((pObj2->iFlags & (MEMOBJ_INT | MEMOBJ_REAL)) == 0) {
			PHP_MemObjToNumeric(pObj2);
		}
		if ((pObj1->iFlags & pObj2->iFlags & MEMOBJ_INT) == 0) {

			php_real r1,r2;

			if ((pObj1->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pObj1);
			}
			r1 = pObj1->rVal;
			if ((pObj2->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pObj2);
			}
			r2 = pObj2->rVal;
			if (r1 > r2) {
				return 1;
			}
			else if (r1 < r2) {
				return -1;
			}
			return 0;
		}
		else {

			if (pObj1->x.iVal > pObj2->x.iVal) {
				return 1;
			}
			else if (pObj1->x.iVal < pObj2->x.iVal) {
				return -1;
			}
			return 0;
		}
	}

	return 0;
}

PHP_PRIVATE sxi32 PHP_MemObjAdd(php_value* pObj1,php_value* pObj2,int bAddStore)
{
	if (((pObj1->iFlags | pObj2->iFlags) & MEMOBJ_HASHMAP) == 0) {

		PHP_MemObjToNumeric(pObj1);
		PHP_MemObjToNumeric(pObj2);
		if ((pObj1->iFlags | pObj2->iFlags) & MEMOBJ_REAL) {

			php_real a,b;
			if ((pObj1->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pObj1);
			}
			if ((pObj2->iFlags & MEMOBJ_REAL) == 0) {
				PHP_MemObjToReal(pObj2);
			}
			a = pObj1->rVal;
			b = pObj2->rVal;
			pObj1->rVal = a + b;
			MemObjSetType(pObj1,MEMOBJ_REAL);

			MemObjTryIntger(&(*pObj1));
		}
		else {

			sxi64 a,b;
			a = pObj1->x.iVal;
			b = pObj2->x.iVal;
			pObj1->x.iVal = a + b;
			MemObjSetType(pObj1,MEMOBJ_INT);
		}
	}
	else {
		if ((pObj1->iFlags | pObj2->iFlags) & MEMOBJ_HASHMAP) {
			php_hashmap* pMap;
			sxi32 rc;
			if (bAddStore) {

				if ((pObj1->iFlags & MEMOBJ_HASHMAP) == 0) {

					rc = PHP_MemObjToHashmap(pObj1);
					if (rc != SXRET_OK) {
						PHP_VmThrowError(pObj1->pVm,0,PHP_CTX_ERR,"PHP is running out of memory while creating array");
						return rc;
					}
				}

				pMap = (php_hashmap*)pObj1->x.pOther;
			}
			else {

				pMap = PHP_NewHashmap(pObj1->pVm,0,0);
				if (pMap == 0) {
					PHP_VmThrowError(pObj1->pVm,0,PHP_CTX_ERR,"PHP is running out of memory while creating array");
					return SXERR_MEM;
				}
			}
			if (!bAddStore) {
				if (pObj1->iFlags & MEMOBJ_HASHMAP) {

					PHP_HashmapDup((php_hashmap*)pObj1->x.pOther,pMap);
				}
				else {
					if ((pObj1->iFlags & MEMOBJ_NULL) == 0) {

						PHP_HashmapInsert(pMap,0,pObj1);
					}
				}
			}

			if (pObj2->iFlags & MEMOBJ_HASHMAP) {
				PHP_HashmapUnion(pMap,(php_hashmap*)pObj2->x.pOther);
			}
			else {
				if ((pObj2->iFlags & MEMOBJ_NULL) == 0) {

					PHP_HashmapInsert(pMap,0,pObj2);
				}
			}

			if (pObj1->iFlags & MEMOBJ_STRING) {
				SyBlobRelease(&pObj1->sBlob);
			}
			pObj1->x.pOther = pMap;
			MemObjSetType(pObj1,MEMOBJ_HASHMAP);
		}
	}
	return SXRET_OK;
}

PHP_PRIVATE const char* PHP_MemObjTypeDump(php_value* pVal)
{
	const char* zType = "";
	if (pVal->iFlags & MEMOBJ_NULL) {
		zType = "null";
	}
	else if (pVal->iFlags & MEMOBJ_INT) {
		zType = "int";
	}
	else if (pVal->iFlags & MEMOBJ_REAL) {
		zType = "float";
	}
	else if (pVal->iFlags & MEMOBJ_STRING) {
		zType = "string";
	}
	else if (pVal->iFlags & MEMOBJ_BOOL) {
		zType = "bool";
	}
	else if (pVal->iFlags & MEMOBJ_HASHMAP) {
		zType = "array";
	}
	else if (pVal->iFlags & MEMOBJ_OBJ) {
		zType = "object";
	}
	else if (pVal->iFlags & MEMOBJ_RES) {
		zType = "resource";
	}
	return zType;
}

PHP_PRIVATE sxi32 PHP_MemObjDump(
	SyBlob* pOut,
	php_value* pObj,
	int ShowType,
	int nTab,
	int nDepth,
	int isRef
)
{
	sxi32 rc = SXRET_OK;
	const char* zType; int i;
	for (i = 0; i < nTab; i++) {
		SyBlobAppend(&(*pOut)," ",sizeof(char));
	}
	if (ShowType) {
		if (isRef) {
			SyBlobAppend(&(*pOut),"&",sizeof(char));
		}

		zType = PHP_MemObjTypeDump(pObj);
		SyBlobAppend(&(*pOut),zType,SyStrlen(zType));
	}
	if ((pObj->iFlags & MEMOBJ_NULL) == 0) {
		if (ShowType) {
			SyBlobAppend(&(*pOut),"(",sizeof(char));
		}
		if (pObj->iFlags & MEMOBJ_HASHMAP) {

			rc = PHP_HashmapDump(&(*pOut),(php_hashmap*)pObj->x.pOther,ShowType,nTab + 1,nDepth + 1);
		}
		else if (pObj->iFlags & MEMOBJ_OBJ) {

			rc = PHP_ClassInstanceDump(&(*pOut),(php_class_instance*)pObj->x.pOther,ShowType,nTab + 1,nDepth + 1);
		}
		else {
			SyBlob* pContents = &pObj->sBlob;

			if ((pObj->iFlags & MEMOBJ_STRING) == 0) {
				MemObjStringValue(&(*pOut),&(*pObj),FALSE);
			}
			else {

				if (ShowType) {
					SyBlobFormat(&(*pOut),"%u '",SyBlobLength(&pObj->sBlob));
				}
				if (SyBlobLength(pContents) > 0) {
					SyBlobAppend(&(*pOut),SyBlobData(pContents),SyBlobLength(pContents));
				}
				if (ShowType) {
					SyBlobAppend(&(*pOut),"'",sizeof(char));
				}
			}
		}
		if (ShowType) {
			if ((pObj->iFlags & (MEMOBJ_HASHMAP | MEMOBJ_OBJ)) == 0) {
				SyBlobAppend(&(*pOut),")",sizeof(char));
			}
		}
	}
#ifdef __WINNT__
	SyBlobAppend(&(*pOut),"\r\n",sizeof("\r\n") - 1);
#else
	SyBlobAppend(&(*pOut),"\n",sizeof(char));
#endif
	return rc;
}




#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif
#if defined(__WINNT__)
#include <Windows.h>
#else
#include <stdlib.h>
#endif
#if defined(PHP_ENABLE_THREADS)

#if defined(__WINNT__)
struct SyMutex
{
	CRITICAL_SECTION sMutex;
	sxu32 nType;
};

static SyMutex aStaticMutexes[] = {
		{{0},SXMUTEX_TYPE_STATIC_1},{{0},SXMUTEX_TYPE_STATIC_2},{{0},SXMUTEX_TYPE_STATIC_3},{{0},SXMUTEX_TYPE_STATIC_4},{{0},SXMUTEX_TYPE_STATIC_5},{{0},SXMUTEX_TYPE_STATIC_6}
};
static BOOL winMutexInit = FALSE;
static LONG winMutexLock = 0;

static sxi32 WinMutexGlobaInit(void)
{
	LONG rc;
	rc = InterlockedCompareExchange(&winMutexLock,1,0);
	if (rc == 0) {
		sxu32 n;
		for (n = 0; n < SX_ARRAYSIZE(aStaticMutexes); ++n) {
			InitializeCriticalSection(&aStaticMutexes[n].sMutex);
		}
		winMutexInit = TRUE;
	}
	else {

		while (winMutexInit == FALSE) {
			Sleep(1);
		}
	}
	return SXRET_OK;
}
static void WinMutexGlobalRelease(void)
{
	LONG rc;
	rc = InterlockedCompareExchange(&winMutexLock,0,1);
	if (rc == 1) {

		if (winMutexInit == TRUE) {
			sxu32 n;
			for (n = 0; n < SX_ARRAYSIZE(aStaticMutexes); ++n) {
				DeleteCriticalSection(&aStaticMutexes[n].sMutex);
			}
			winMutexInit = FALSE;
		}
	}
}
static SyMutex* WinMutexNew(int nType)
{
	SyMutex* pMutex = 0;
	if (nType == SXMUTEX_TYPE_FAST || nType == SXMUTEX_TYPE_RECURSIVE) {

		pMutex = (SyMutex*)HeapAlloc(GetProcessHeap(),0,sizeof(SyMutex));
		if (pMutex == 0) {
			return 0;
		}
		InitializeCriticalSection(&pMutex->sMutex);
	}
	else {

		if (nType > SXMUTEX_TYPE_STATIC_6) {
			nType = SXMUTEX_TYPE_STATIC_6;
		}
		pMutex = &aStaticMutexes[nType - 3];
	}
	pMutex->nType = nType;
	return pMutex;
}
static void WinMutexRelease(SyMutex* pMutex)
{
	if (pMutex->nType == SXMUTEX_TYPE_FAST || pMutex->nType == SXMUTEX_TYPE_RECURSIVE) {
		DeleteCriticalSection(&pMutex->sMutex);
		HeapFree(GetProcessHeap(),0,pMutex);
	}
}
static void WinMutexEnter(SyMutex* pMutex)
{
	EnterCriticalSection(&pMutex->sMutex);
}
static sxi32 WinMutexTryEnter(SyMutex* pMutex)
{
#ifdef _WIN32_WINNT
	BOOL rc;

	rc = TryEnterCriticalSection(&pMutex->sMutex);
	if (rc) {
		return SXRET_OK;
	}
	else {
		return SXERR_BUSY;
	}
#else
	return SXERR_NOTIMPLEMENTED;
#endif
}
static void WinMutexLeave(SyMutex* pMutex)
{
	LeaveCriticalSection(&pMutex->sMutex);
}

static const SyMutexMethods sWinMutexMethods = {
	WinMutexGlobaInit,
	WinMutexGlobalRelease,
	WinMutexNew,
	WinMutexRelease,
	WinMutexEnter,
	WinMutexTryEnter,
	WinMutexLeave
};
PHP_PRIVATE const SyMutexMethods* SyMutexExportMethods(void)
{
	return &sWinMutexMethods;
}
#elif defined(__UNIXES__)
#include <pthread.h>
struct SyMutex
{
	pthread_mutex_t sMutex;
	sxu32 nType;
};
static SyMutex* UnixMutexNew(int nType)
{
	static SyMutex aStaticMutexes[] = {
		{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_1},{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_2},{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_3},{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_4},{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_5},{PTHREAD_MUTEX_INITIALIZER,SXMUTEX_TYPE_STATIC_6}
	};
	SyMutex* pMutex;

	if (nType == SXMUTEX_TYPE_FAST || nType == SXMUTEX_TYPE_RECURSIVE) {
		pthread_mutexattr_t sRecursiveAttr;

		pMutex = (SyMutex*)malloc(sizeof(SyMutex));
		if (pMutex == 0) {
			return 0;
		}
		if (nType == SXMUTEX_TYPE_RECURSIVE) {
			pthread_mutexattr_init(&sRecursiveAttr);
			pthread_mutexattr_settype(&sRecursiveAttr,PTHREAD_MUTEX_RECURSIVE);
		}
		pthread_mutex_init(&pMutex->sMutex,nType == SXMUTEX_TYPE_RECURSIVE ? &sRecursiveAttr : 0);
		if (nType == SXMUTEX_TYPE_RECURSIVE) {
			pthread_mutexattr_destroy(&sRecursiveAttr);
		}
	}
	else {

		if (nType > SXMUTEX_TYPE_STATIC_6) {
			nType = SXMUTEX_TYPE_STATIC_6;
		}
		pMutex = &aStaticMutexes[nType - 3];
	}
	pMutex->nType = nType;

	return pMutex;
}
static void UnixMutexRelease(SyMutex* pMutex)
{
	if (pMutex->nType == SXMUTEX_TYPE_FAST || pMutex->nType == SXMUTEX_TYPE_RECURSIVE) {
		pthread_mutex_destroy(&pMutex->sMutex);
		free(pMutex);
	}
}
static void UnixMutexEnter(SyMutex* pMutex)
{
	pthread_mutex_lock(&pMutex->sMutex);
}
static void UnixMutexLeave(SyMutex* pMutex)
{
	pthread_mutex_unlock(&pMutex->sMutex);
}

static const SyMutexMethods sPthreadMutexMethods = {
	0,
	0,
	UnixMutexNew,
	UnixMutexRelease,
	UnixMutexEnter,
	0,
	UnixMutexLeave
};
PHP_PRIVATE const SyMutexMethods* SyMutexExportMethods(void)
{
	return &sPthreadMutexMethods;
}
#else

struct SyMutex
{
	sxu32 nType;
};
static SyMutex* DummyMutexNew(int nType)
{
	static SyMutex sMutex;
	SXUNUSED(nType);
	return &sMutex;
}
static void DummyMutexRelease(SyMutex* pMutex)
{
	SXUNUSED(pMutex);
}
static void DummyMutexEnter(SyMutex* pMutex)
{
	SXUNUSED(pMutex);
}
static void DummyMutexLeave(SyMutex* pMutex)
{
	SXUNUSED(pMutex);
}

static const SyMutexMethods sDummyMutexMethods = {
	0,
	0,
	DummyMutexNew,
	DummyMutexRelease,
	DummyMutexEnter,
	0,
	DummyMutexLeave
};
PHP_PRIVATE const SyMutexMethods* SyMutexExportMethods(void)
{
	return &sDummyMutexMethods;
}
#endif
#endif
static void* SyOSHeapAlloc(sxu32 nByte)
{
	void* pNew;
#if defined(__WINNT__)
	pNew = HeapAlloc(GetProcessHeap(),0,nByte);
#else
	pNew = malloc((size_t)nByte);
#endif
	return pNew;
}
static void* SyOSHeapRealloc(void* pOld,sxu32 nByte)
{
	void* pNew;
#if defined(__WINNT__)
	pNew = HeapReAlloc(GetProcessHeap(),0,pOld,nByte);
#else
	pNew = realloc(pOld,(size_t)nByte);
#endif
	return pNew;
}
static void SyOSHeapFree(void* pPtr)
{
#if defined(__WINNT__)
	HeapFree(GetProcessHeap(),0,pPtr);
#else
	free(pPtr);
#endif
}

PHP_PRIVATE sxu32 SyStrlen(const char* zSrc)
{
	register const char* zIn = zSrc;
#if defined(UNTRUST)
	if (zIn == 0) {
		return 0;
	}
#endif
	for (;;) {
		if (!zIn[0]) { break; } zIn++;
		if (!zIn[0]) { break; } zIn++;
		if (!zIn[0]) { break; } zIn++;
		if (!zIn[0]) { break; } zIn++;
	}
	return (sxu32)(zIn - zSrc);
}
PHP_PRIVATE sxi32 SyByteFind(const char* zStr,sxu32 nLen,sxi32 c,sxu32* pPos)
{
	const char* zIn = zStr;
	const char* zEnd;

	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; }if (zIn[0] == c) { if (pPos) { *pPos = (sxu32)(zIn - zStr); } return SXRET_OK; } zIn++;
		if (zIn >= zEnd) { break; }if (zIn[0] == c) { if (pPos) { *pPos = (sxu32)(zIn - zStr); } return SXRET_OK; } zIn++;
		if (zIn >= zEnd) { break; }if (zIn[0] == c) { if (pPos) { *pPos = (sxu32)(zIn - zStr); } return SXRET_OK; } zIn++;
		if (zIn >= zEnd) { break; }if (zIn[0] == c) { if (pPos) { *pPos = (sxu32)(zIn - zStr); } return SXRET_OK; } zIn++;
	}
	return SXERR_NOTFOUND;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyByteFind2(const char* zStr,sxu32 nLen,sxi32 c,sxu32* pPos)
{
	const char* zIn = zStr;
	const char* zEnd;

	zEnd = &zIn[nLen - 1];
	for (;; ) {
		if (zEnd < zIn) { break; } if (zEnd[0] == c) { if (pPos) { *pPos = (sxu32)(zEnd - zIn); } return SXRET_OK; } zEnd--;
		if (zEnd < zIn) { break; } if (zEnd[0] == c) { if (pPos) { *pPos = (sxu32)(zEnd - zIn); } return SXRET_OK; } zEnd--;
		if (zEnd < zIn) { break; } if (zEnd[0] == c) { if (pPos) { *pPos = (sxu32)(zEnd - zIn); } return SXRET_OK; } zEnd--;
		if (zEnd < zIn) { break; } if (zEnd[0] == c) { if (pPos) { *pPos = (sxu32)(zEnd - zIn); } return SXRET_OK; } zEnd--;
	}
	return SXERR_NOTFOUND;
}
#endif
PHP_PRIVATE sxi32 SyByteListFind(const char* zSrc,sxu32 nLen,const char* zList,sxu32* pFirstPos)
{
	const char* zIn = zSrc;
	const char* zPtr;
	const char* zEnd;
	sxi32 c;
	zEnd = &zSrc[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; }	for (zPtr = zList; (c = zPtr[0]) != 0; zPtr++) { if (zIn[0] == c) { if (pFirstPos) { *pFirstPos = (sxu32)(zIn - zSrc); } return SXRET_OK; } } zIn++;
		if (zIn >= zEnd) { break; }	for (zPtr = zList; (c = zPtr[0]) != 0; zPtr++) { if (zIn[0] == c) { if (pFirstPos) { *pFirstPos = (sxu32)(zIn - zSrc); } return SXRET_OK; } } zIn++;
		if (zIn >= zEnd) { break; }	for (zPtr = zList; (c = zPtr[0]) != 0; zPtr++) { if (zIn[0] == c) { if (pFirstPos) { *pFirstPos = (sxu32)(zIn - zSrc); } return SXRET_OK; } } zIn++;
		if (zIn >= zEnd) { break; }	for (zPtr = zList; (c = zPtr[0]) != 0; zPtr++) { if (zIn[0] == c) { if (pFirstPos) { *pFirstPos = (sxu32)(zIn - zSrc); } return SXRET_OK; } } zIn++;
	}
	return SXERR_NOTFOUND;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyStrncmp(const char* zLeft,const char* zRight,sxu32 nLen)
{
	const unsigned char* zP = (const unsigned char*)zLeft;
	const unsigned char* zQ = (const unsigned char*)zRight;

	if (SX_EMPTY_STR(zP) || SX_EMPTY_STR(zQ)) {
		return SX_EMPTY_STR(zP) ? (SX_EMPTY_STR(zQ) ? 0 : -1) : 1;
	}
	if (nLen <= 0) {
		return 0;
	}
	for (;;) {
		if (nLen <= 0) { return 0; } if (zP[0] == 0 || zQ[0] == 0 || zP[0] != zQ[0]) { break; } zP++; zQ++; nLen--;
		if (nLen <= 0) { return 0; } if (zP[0] == 0 || zQ[0] == 0 || zP[0] != zQ[0]) { break; } zP++; zQ++; nLen--;
		if (nLen <= 0) { return 0; } if (zP[0] == 0 || zQ[0] == 0 || zP[0] != zQ[0]) { break; } zP++; zQ++; nLen--;
		if (nLen <= 0) { return 0; } if (zP[0] == 0 || zQ[0] == 0 || zP[0] != zQ[0]) { break; } zP++; zQ++; nLen--;
	}
	return (sxi32)(zP[0] - zQ[0]);
}
#endif
PHP_PRIVATE sxi32 SyStrnicmp(const char* zLeft,const char* zRight,sxu32 SLen)
{
	register unsigned char* p = (unsigned char*)zLeft;
	register unsigned char* q = (unsigned char*)zRight;

	if (SX_EMPTY_STR(p) || SX_EMPTY_STR(q)) {
		return SX_EMPTY_STR(p) ? SX_EMPTY_STR(q) ? 0 : -1 : 1;
	}
	for (;;) {
		if (!SLen) { return 0; }if (!*p || !*q || SyCharToLower(*p) != SyCharToLower(*q)) { break; }p++; q++; --SLen;
		if (!SLen) { return 0; }if (!*p || !*q || SyCharToLower(*p) != SyCharToLower(*q)) { break; }p++; q++; --SLen;
		if (!SLen) { return 0; }if (!*p || !*q || SyCharToLower(*p) != SyCharToLower(*q)) { break; }p++; q++; --SLen;
		if (!SLen) { return 0; }if (!*p || !*q || SyCharToLower(*p) != SyCharToLower(*q)) { break; }p++; q++; --SLen;

	}
	return (sxi32)(SyCharToLower(p[0]) - SyCharToLower(q[0]));
}
PHP_PRIVATE sxi32 SyStrnmicmp(const void* pLeft,const void* pRight,sxu32 SLen)
{
	return SyStrnicmp((const char*)pLeft,(const char*)pRight,SLen);
}
static sxu32 Systrcpy(char* zDest,sxu32 nDestLen,const char* zSrc,sxu32 nLen)
{
	unsigned char* zBuf = (unsigned char*)zDest;
	unsigned char* zIn = (unsigned char*)zSrc;
	unsigned char* zEnd;
#if defined(UNTRUST)
	if (zSrc == (const char*)zDest) {
		return 0;
	}
#endif
	if (nLen <= 0) {
		nLen = SyStrlen(zSrc);
	}
	zEnd = &zBuf[nDestLen - 1];
	for (;;) {
		if (zBuf >= zEnd || nLen == 0) { break; } zBuf[0] = zIn[0]; zIn++; zBuf++; nLen--;
		if (zBuf >= zEnd || nLen == 0) { break; } zBuf[0] = zIn[0]; zIn++; zBuf++; nLen--;
		if (zBuf >= zEnd || nLen == 0) { break; } zBuf[0] = zIn[0]; zIn++; zBuf++; nLen--;
		if (zBuf >= zEnd || nLen == 0) { break; } zBuf[0] = zIn[0]; zIn++; zBuf++; nLen--;
	}
	zBuf[0] = 0;
	return (sxu32)(zBuf - (unsigned char*)zDest);
}

PHP_PRIVATE void SyZero(void* pSrc,sxu32 nSize)
{
	register unsigned char* zSrc = (unsigned char*)pSrc;
	unsigned char* zEnd;
#if defined(UNTRUST)
	if (zSrc == 0 || nSize <= 0) {
		return;
	}
#endif
	zEnd = &zSrc[nSize];
	for (;;) {
		if (zSrc >= zEnd) { break; } zSrc[0] = 0; zSrc++;
		if (zSrc >= zEnd) { break; } zSrc[0] = 0; zSrc++;
		if (zSrc >= zEnd) { break; } zSrc[0] = 0; zSrc++;
		if (zSrc >= zEnd) { break; } zSrc[0] = 0; zSrc++;
	}
}
PHP_PRIVATE sxi32 SyMemcmp(const void* pB1,const void* pB2,sxu32 nSize)
{
	sxi32 rc;
	if (nSize <= 0) {
		return 0;
	}
	if (pB1 == 0 || pB2 == 0) {
		return pB1 != 0 ? 1 : (pB2 == 0 ? 0 : -1);
	}
	SX_MACRO_FAST_CMP(pB1,pB2,nSize,rc);
	return rc;
}
PHP_PRIVATE sxu32 SyMemcpy(const void* pSrc,void* pDest,sxu32 nLen)
{
#if defined(UNTRUST)
	if (pSrc == 0 || pDest == 0) {
		return 0;
	}
#endif
	if (pSrc == (const void*)pDest) {
		return nLen;
	}
	SX_MACRO_FAST_MEMCPY(pSrc,pDest,nLen);
	return nLen;
}
static void* MemOSAlloc(sxu32 nBytes)
{
	sxu32* pChunk;
	pChunk = (sxu32*)SyOSHeapAlloc(nBytes + sizeof(sxu32));
	if (pChunk == 0) {
		return 0;
	}
	pChunk[0] = nBytes;
	return (void*)&pChunk[1];
}
static void* MemOSRealloc(void* pOld,sxu32 nBytes)
{
	sxu32* pOldChunk;
	sxu32* pChunk;
	pOldChunk = (sxu32*)(((char*)pOld) - sizeof(sxu32));
	if (pOldChunk[0] >= nBytes) {
		return pOld;
	}
	pChunk = (sxu32*)SyOSHeapRealloc(pOldChunk,nBytes + sizeof(sxu32));
	if (pChunk == 0) {
		return 0;
	}
	pChunk[0] = nBytes;
	return (void*)&pChunk[1];
}
static void MemOSFree(void* pBlock)
{
	void* pChunk;
	pChunk = (void*)(((char*)pBlock) - sizeof(sxu32));
	SyOSHeapFree(pChunk);
}
static sxu32 MemOSChunkSize(void* pBlock)
{
	sxu32* pChunk;
	pChunk = (sxu32*)(((char*)pBlock) - sizeof(sxu32));
	return pChunk[0];
}

static const SyMemMethods sOSAllocMethods = {
	MemOSAlloc,
	MemOSRealloc,
	MemOSFree,
	MemOSChunkSize,
	0,
	0,
	0
};
static void* MemBackendAlloc(SyMemBackend* pBackend,sxu32 nByte)
{
	SyMemBlock* pBlock;
	sxi32 nRetry = 0;


	nByte += sizeof(SyMemBlock);
	for (;;) {
		pBlock = (SyMemBlock*)pBackend->pMethods->xAlloc(nByte);
		if (pBlock != 0 || pBackend->xMemError == 0 || nRetry > SXMEM_BACKEND_RETRY
			|| SXERR_RETRY != pBackend->xMemError(pBackend->pUserData)) {
			break;
		}
		nRetry++;
	}
	if (pBlock == 0) {
		return 0;
	}
	pBlock->pNext = pBlock->pPrev = 0;

	MACRO_LD_PUSH(pBackend->pBlocks,pBlock);
#if defined(UNTRUST)
	pBlock->nGuard = SXMEM_BACKEND_MAGIC;
#endif
	pBackend->nBlock++;
	return (void*)&pBlock[1];
}
PHP_PRIVATE void* SyMemBackendAlloc(SyMemBackend* pBackend,sxu32 nByte)
{
	void* pChunk;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return 0;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	pChunk = MemBackendAlloc(&(*pBackend),nByte);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return pChunk;
}
static void* MemBackendRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte)
{
	SyMemBlock* pBlock,* pNew,* pPrev,* pNext;
	sxu32 nRetry = 0;

	if (pOld == 0) {
		return MemBackendAlloc(&(*pBackend),nByte);
	}
	pBlock = (SyMemBlock*)(((char*)pOld) - sizeof(SyMemBlock));
#if defined(UNTRUST)
	if (pBlock->nGuard != SXMEM_BACKEND_MAGIC) {
		return 0;
	}
#endif
	nByte += sizeof(SyMemBlock);
	pPrev = pBlock->pPrev;
	pNext = pBlock->pNext;
	for (;;) {
		pNew = (SyMemBlock*)pBackend->pMethods->xRealloc(pBlock,nByte);
		if (pNew != 0 || pBackend->xMemError == 0 || nRetry > SXMEM_BACKEND_RETRY ||
			SXERR_RETRY != pBackend->xMemError(pBackend->pUserData)) {
			break;
		}
		nRetry++;
	}
	if (pNew == 0) {
		return 0;
	}
	if (pNew != pBlock) {
		if (pPrev == 0) {
			pBackend->pBlocks = pNew;
		}
		else {
			pPrev->pNext = pNew;
		}
		if (pNext) {
			pNext->pPrev = pNew;
		}
#if defined(UNTRUST)
		pNew->nGuard = SXMEM_BACKEND_MAGIC;
#endif
	}
	return (void*)&pNew[1];
}
PHP_PRIVATE void* SyMemBackendRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte)
{
	void* pChunk;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return 0;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	pChunk = MemBackendRealloc(&(*pBackend),pOld,nByte);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return pChunk;
}
static sxi32 MemBackendFree(SyMemBackend* pBackend,void* pChunk)
{
	SyMemBlock* pBlock;
	pBlock = (SyMemBlock*)(((char*)pChunk) - sizeof(SyMemBlock));
#if defined(UNTRUST)
	if (pBlock->nGuard != SXMEM_BACKEND_MAGIC) {
		return SXERR_CORRUPT;
	}
#endif

	if (pBackend->nBlock > 0) {

#if defined(UNTRUST)

		pBlock->nGuard = 0x635B;
#endif
		MACRO_LD_REMOVE(pBackend->pBlocks,pBlock);
		pBackend->nBlock--;
		pBackend->pMethods->xFree(pBlock);
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendFree(SyMemBackend* pBackend,void* pChunk)
{
	sxi32 rc;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return SXERR_CORRUPT;
	}
#endif
	if (pChunk == 0) {
		return SXRET_OK;
	}
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	rc = MemBackendFree(&(*pBackend),pChunk);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return rc;
}
#if defined(PHP_ENABLE_THREADS)
PHP_PRIVATE sxi32 SyMemBackendMakeThreadSafe(SyMemBackend* pBackend,const SyMutexMethods* pMethods)
{
	SyMutex* pMutex;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend) || pMethods == 0 || pMethods->xNew == 0) {
		return SXERR_CORRUPT;
	}
#endif
	pMutex = pMethods->xNew(SXMUTEX_TYPE_FAST);
	if (pMutex == 0) {
		return SXERR_OS;
	}

	pBackend->pMutex = pMutex;
	pBackend->pMutexMethods = pMethods;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendDisbaleMutexing(SyMemBackend* pBackend)
{
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return SXERR_CORRUPT;
	}
#endif
	if (pBackend->pMutex == 0) {

		return SXRET_OK;
	}
	SyMutexRelease(pBackend->pMutexMethods,pBackend->pMutex);
	pBackend->pMutexMethods = 0;
	pBackend->pMutex = 0;
	return SXRET_OK;
}
#endif

#define SXMEM_POOL_MAGIC		0xDEAD
#define SXMEM_POOL_MAXALLOC		(1<<(SXMEM_POOL_NBUCKETS+SXMEM_POOL_INCR))
#define SXMEM_POOL_MINALLOC		(1<<(SXMEM_POOL_INCR))
static sxi32 MemPoolBucketAlloc(SyMemBackend* pBackend,sxu32 nBucket)
{
	char* zBucket,* zBucketEnd;
	SyMemHeader* pHeader;
	sxu32 nBucketSize;


	zBucket = (char*)MemBackendAlloc(&(*pBackend),SXMEM_POOL_MAXALLOC);
	if (zBucket == 0) {
		return SXERR_MEM;
	}
	zBucketEnd = &zBucket[SXMEM_POOL_MAXALLOC];

	nBucketSize = 1 << (nBucket + SXMEM_POOL_INCR);
	pBackend->apPool[nBucket] = pHeader = (SyMemHeader*)zBucket;
	for (;;) {
		if (&zBucket[nBucketSize] >= zBucketEnd) {
			break;
		}
		pHeader->pNext = (SyMemHeader*)&zBucket[nBucketSize];

		pHeader = pHeader->pNext;
		zBucket += nBucketSize;
	}
	pHeader->pNext = 0;

	return SXRET_OK;
}
static void* MemBackendPoolAlloc(SyMemBackend* pBackend,sxu32 nByte)
{
	SyMemHeader* pBucket,* pNext;
	sxu32 nBucketSize;
	sxu32 nBucket;

	if (nByte + sizeof(SyMemHeader) >= SXMEM_POOL_MAXALLOC) {

		pBucket = (SyMemHeader*)MemBackendAlloc(&(*pBackend),nByte + sizeof(SyMemHeader));
		if (pBucket == 0) {
			return 0;
		}

		pBucket->nBucket = (sxu32)(SXMEM_POOL_MAGIC << 16) | SXU16_HIGH;
		return (void*)(pBucket + 1);
	}

	nBucket = 0;
	nBucketSize = SXMEM_POOL_MINALLOC;
	while (nByte + sizeof(SyMemHeader) > nBucketSize) {
		nBucketSize <<= 1;
		nBucket++;
	}
	pBucket = pBackend->apPool[nBucket];
	if (pBucket == 0) {
		sxi32 rc;
		rc = MemPoolBucketAlloc(&(*pBackend),nBucket);
		if (rc != SXRET_OK) {
			return 0;
		}
		pBucket = pBackend->apPool[nBucket];
	}

	pNext = pBucket->pNext;
	pBackend->apPool[nBucket] = pNext;

	pBucket->nBucket = (SXMEM_POOL_MAGIC << 16) | nBucket;
	return (void*)&pBucket[1];
}
PHP_PRIVATE void* SyMemBackendPoolAlloc(SyMemBackend* pBackend,sxu32 nByte)
{
	void* pChunk;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return 0;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	pChunk = MemBackendPoolAlloc(&(*pBackend),nByte);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return pChunk;
}
static sxi32 MemBackendPoolFree(SyMemBackend* pBackend,void* pChunk)
{
	SyMemHeader* pHeader;
	sxu32 nBucket;

	pHeader = (SyMemHeader*)(((char*)pChunk) - sizeof(SyMemHeader));

	if ((pHeader->nBucket >> 16) != SXMEM_POOL_MAGIC) {
		return SXERR_CORRUPT;
	}
	nBucket = pHeader->nBucket & 0xFFFF;
	if (nBucket == SXU16_HIGH) {

		MemBackendFree(&(*pBackend),pHeader);
	}
	else {

		pHeader->pNext = pBackend->apPool[nBucket & 0x0f];
		pBackend->apPool[nBucket & 0x0f] = pHeader;
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendPoolFree(SyMemBackend* pBackend,void* pChunk)
{
	sxi32 rc;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend) || pChunk == 0) {
		return SXERR_CORRUPT;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	rc = MemBackendPoolFree(&(*pBackend),pChunk);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return rc;
}
#if 0
static void* MemBackendPoolRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte)
{
	sxu32 nBucket,nBucketSize;
	SyMemHeader* pHeader;
	void* pNew;

	if (pOld == 0) {

		pNew = MemBackendPoolAlloc(&(*pBackend),nByte);
		return pNew;
	}

	pHeader = (SyMemHeader*)(((char*)pOld) - sizeof(SyMemHeader));

	if ((pHeader->nBucket >> 16) != SXMEM_POOL_MAGIC) {
		return 0;
	}
	nBucket = pHeader->nBucket & 0xFFFF;
	if (nBucket == SXU16_HIGH) {

		return MemBackendRealloc(&(*pBackend),pHeader,nByte);
	}
	nBucketSize = 1 << (nBucket + SXMEM_POOL_INCR);
	if (nBucketSize >= nByte + sizeof(SyMemHeader)) {

		return pOld;
	}

	pNew = MemBackendPoolAlloc(&(*pBackend),nByte);
	if (pNew == 0) {
		return 0;
	}

	SyMemcpy(pOld,pNew,nBucketSize);

	MemBackendPoolFree(&(*pBackend),pOld);
	return pNew;
}
PHP_PRIVATE void* SyMemBackendPoolRealloc(SyMemBackend* pBackend,void* pOld,sxu32 nByte)
{
	void* pChunk;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return 0;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	pChunk = MemBackendPoolRealloc(&(*pBackend),pOld,nByte);
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return pChunk;
}
#endif
PHP_PRIVATE sxi32 SyMemBackendInit(SyMemBackend* pBackend,ProcMemError xMemErr,void* pUserData)
{
#if defined(UNTRUST)
	if (pBackend == 0) {
		return SXERR_EMPTY;
	}
#endif

	SyZero(&(*pBackend),sizeof(SyMemBackend));
	pBackend->xMemError = xMemErr;
	pBackend->pUserData = pUserData;

	pBackend->pMethods = &sOSAllocMethods;
	if (pBackend->pMethods->xInit) {

		if (SXRET_OK != pBackend->pMethods->xInit(pBackend->pMethods->pUserData)) {
			return SXERR_ABORT;
		}
	}
#if defined(UNTRUST)
	pBackend->nMagic = SXMEM_BACKEND_MAGIC;
#endif
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendInitFromOthers(SyMemBackend* pBackend,const SyMemMethods* pMethods,ProcMemError xMemErr,void* pUserData)
{
#if defined(UNTRUST)
	if (pBackend == 0 || pMethods == 0) {
		return SXERR_EMPTY;
	}
#endif
	if (pMethods->xAlloc == 0 || pMethods->xRealloc == 0 || pMethods->xFree == 0 || pMethods->xChunkSize == 0) {

		return SXERR_INVALID;
	}

	SyZero(&(*pBackend),sizeof(SyMemBackend));
	pBackend->xMemError = xMemErr;
	pBackend->pUserData = pUserData;

	pBackend->pMethods = pMethods;
	if (pBackend->pMethods->xInit) {

		if (SXRET_OK != pBackend->pMethods->xInit(pBackend->pMethods->pUserData)) {
			return SXERR_ABORT;
		}
	}
#if defined(UNTRUST)
	pBackend->nMagic = SXMEM_BACKEND_MAGIC;
#endif
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendInitFromParent(SyMemBackend* pBackend,SyMemBackend* pParent)
{
	sxu8 bInheritMutex;
#if defined(UNTRUST)
	if (pBackend == 0 || SXMEM_BACKEND_CORRUPT(pParent)) {
		return SXERR_CORRUPT;
	}
#endif

	SyZero(&(*pBackend),sizeof(SyMemBackend));
	pBackend->pMethods = pParent->pMethods;
	pBackend->xMemError = pParent->xMemError;
	pBackend->pUserData = pParent->pUserData;
	bInheritMutex = pParent->pMutexMethods ? TRUE : FALSE;
	if (bInheritMutex) {
		pBackend->pMutexMethods = pParent->pMutexMethods;

		pBackend->pMutex = pBackend->pMutexMethods->xNew(SXMUTEX_TYPE_FAST);
		if (pBackend->pMutex == 0) {
			return SXERR_OS;
		}
	}
#if defined(UNTRUST)
	pBackend->nMagic = SXMEM_BACKEND_MAGIC;
#endif
	return SXRET_OK;
}
static sxi32 MemBackendRelease(SyMemBackend* pBackend)
{
	SyMemBlock* pBlock,* pNext;

	pBlock = pBackend->pBlocks;
	for (;;) {
		if (pBackend->nBlock == 0) {
			break;
		}
		pNext = pBlock->pNext;
		pBackend->pMethods->xFree(pBlock);
		pBlock = pNext;
		pBackend->nBlock--;

		if (pBackend->nBlock == 0) {
			break;
		}
		pNext = pBlock->pNext;
		pBackend->pMethods->xFree(pBlock);
		pBlock = pNext;
		pBackend->nBlock--;

		if (pBackend->nBlock == 0) {
			break;
		}
		pNext = pBlock->pNext;
		pBackend->pMethods->xFree(pBlock);
		pBlock = pNext;
		pBackend->nBlock--;

		if (pBackend->nBlock == 0) {
			break;
		}
		pNext = pBlock->pNext;
		pBackend->pMethods->xFree(pBlock);
		pBlock = pNext;
		pBackend->nBlock--;

	}
	if (pBackend->pMethods->xRelease) {
		pBackend->pMethods->xRelease(pBackend->pMethods->pUserData);
	}
	pBackend->pMethods = 0;
	pBackend->pBlocks = 0;
#if defined(UNTRUST)
	pBackend->nMagic = 0x2626;
#endif
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMemBackendRelease(SyMemBackend* pBackend)
{
	sxi32 rc;
#if defined(UNTRUST)
	if (SXMEM_BACKEND_CORRUPT(pBackend)) {
		return SXERR_INVALID;
	}
#endif
	if (pBackend->pMutexMethods) {
		SyMutexEnter(pBackend->pMutexMethods,pBackend->pMutex);
	}
	rc = MemBackendRelease(&(*pBackend));
	if (pBackend->pMutexMethods) {
		SyMutexLeave(pBackend->pMutexMethods,pBackend->pMutex);
		SyMutexRelease(pBackend->pMutexMethods,pBackend->pMutex);
	}
	return SXRET_OK;
}
PHP_PRIVATE void* SyMemBackendDup(SyMemBackend* pBackend,const void* pSrc,sxu32 nSize)
{
	void* pNew;
#if defined(UNTRUST)
	if (pSrc == 0 || nSize <= 0) {
		return 0;
	}
#endif
	pNew = SyMemBackendAlloc(&(*pBackend),nSize);
	if (pNew) {
		SyMemcpy(pSrc,pNew,nSize);
	}
	return pNew;
}
PHP_PRIVATE char* SyMemBackendStrDup(SyMemBackend* pBackend,const char* zSrc,sxu32 nSize)
{
	char* zDest;
	zDest = (char*)SyMemBackendAlloc(&(*pBackend),nSize + 1);
	if (zDest) {
		Systrcpy(zDest,nSize + 1,zSrc,nSize);
	}
	return zDest;
}
PHP_PRIVATE sxi32 SyBlobInitFromBuf(SyBlob* pBlob,void* pBuffer,sxu32 nSize)
{
#if defined(UNTRUST)
	if (pBlob == 0 || pBuffer == 0 || nSize < 1) {
		return SXERR_EMPTY;
	}
#endif
	pBlob->pBlob = pBuffer;
	pBlob->mByte = nSize;
	pBlob->nByte = 0;
	pBlob->pAllocator = 0;
	pBlob->nFlags = SXBLOB_LOCKED | SXBLOB_STATIC;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBlobInit(SyBlob* pBlob,SyMemBackend* pAllocator)
{
#if defined(UNTRUST)
	if (pBlob == 0) {
		return SXERR_EMPTY;
	}
#endif
	pBlob->pBlob = 0;
	pBlob->mByte = pBlob->nByte = 0;
	pBlob->pAllocator = &(*pAllocator);
	pBlob->nFlags = 0;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBlobReadOnly(SyBlob* pBlob,const void* pData,sxu32 nByte)
{
#if defined(UNTRUST)
	if (pBlob == 0) {
		return SXERR_EMPTY;
	}
#endif
	pBlob->pBlob = (void*)pData;
	pBlob->nByte = nByte;
	pBlob->mByte = 0;
	pBlob->nFlags |= SXBLOB_RDONLY;
	return SXRET_OK;
}
#ifndef SXBLOB_MIN_GROWTH
#define SXBLOB_MIN_GROWTH 16
#endif
static sxi32 BlobPrepareGrow(SyBlob* pBlob,sxu32* pByte)
{
	sxu32 nByte;
	void* pNew;
	nByte = *pByte;
	if (pBlob->nFlags & (SXBLOB_LOCKED | SXBLOB_STATIC)) {
		if (SyBlobFreeSpace(pBlob) < nByte) {
			*pByte = SyBlobFreeSpace(pBlob);
			if ((*pByte) == 0) {
				return SXERR_SHORT;
			}
		}
		return SXRET_OK;
	}
	if (pBlob->nFlags & SXBLOB_RDONLY) {

		if (pBlob->nByte > 0) {
			pNew = SyMemBackendDup(pBlob->pAllocator,pBlob->pBlob,pBlob->nByte);
			if (pNew == 0) {
				return SXERR_MEM;
			}
			pBlob->pBlob = pNew;
			pBlob->mByte = pBlob->nByte;
		}
		else {
			pBlob->pBlob = 0;
			pBlob->mByte = 0;
		}

		pBlob->nFlags &= ~SXBLOB_RDONLY;
	}
	if (SyBlobFreeSpace(pBlob) >= nByte) {
		return SXRET_OK;
	}
	if (pBlob->mByte > 0) {
		nByte = nByte + pBlob->mByte * 2 + SXBLOB_MIN_GROWTH;
	}
	else if (nByte < SXBLOB_MIN_GROWTH) {
		nByte = SXBLOB_MIN_GROWTH;
	}
	pNew = SyMemBackendRealloc(pBlob->pAllocator,pBlob->pBlob,nByte);
	if (pNew == 0) {
		return SXERR_MEM;
	}
	pBlob->pBlob = pNew;
	pBlob->mByte = nByte;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBlobAppend(SyBlob* pBlob,const void* pData,sxu32 nSize)
{
	sxu8* zBlob;
	sxi32 rc;
	if (nSize < 1) {
		return SXRET_OK;
	}
	rc = BlobPrepareGrow(&(*pBlob),&nSize);
	if (SXRET_OK != rc) {
		return rc;
	}
	if (pData) {
		zBlob = (sxu8*)pBlob->pBlob;
		zBlob = &zBlob[pBlob->nByte];
		pBlob->nByte += nSize;
		SX_MACRO_FAST_MEMCPY(pData,zBlob,nSize);
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBlobNullAppend(SyBlob* pBlob)
{
	sxi32 rc;
	sxu32 n;
	n = pBlob->nByte;
	rc = SyBlobAppend(&(*pBlob),(const void*)"\0",sizeof(char));
	if (rc == SXRET_OK) {
		pBlob->nByte = n;
	}
	return rc;
}
PHP_PRIVATE sxi32 SyBlobDup(SyBlob* pSrc,SyBlob* pDest)
{
	sxi32 rc = SXRET_OK;
#ifdef UNTRUST
	if (pSrc == 0 || pDest == 0) {
		return SXERR_EMPTY;
	}
#endif
	if (pSrc->nByte > 0) {
		rc = SyBlobAppend(&(*pDest),pSrc->pBlob,pSrc->nByte);
	}
	return rc;
}
PHP_PRIVATE sxi32 SyBlobCmp(SyBlob* pLeft,SyBlob* pRight)
{
	sxi32 rc;
#ifdef UNTRUST
	if (pLeft == 0 || pRight == 0) {
		return pLeft ? 1 : -1;
	}
#endif
	if (pLeft->nByte != pRight->nByte) {

		return pLeft->nByte - pRight->nByte;
	}
	if (pLeft->nByte == 0) {
		return 0;
	}

	rc = SyMemcmp(pLeft->pBlob,pRight->pBlob,pLeft->nByte);
	return rc;
}
PHP_PRIVATE sxi32 SyBlobReset(SyBlob* pBlob)
{
	pBlob->nByte = 0;
	if (pBlob->nFlags & SXBLOB_RDONLY) {
		pBlob->pBlob = 0;
		pBlob->mByte = 0;
		pBlob->nFlags &= ~SXBLOB_RDONLY;
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBlobRelease(SyBlob* pBlob)
{
	if ((pBlob->nFlags & (SXBLOB_STATIC | SXBLOB_RDONLY)) == 0 && pBlob->mByte > 0) {
		SyMemBackendFree(pBlob->pAllocator,pBlob->pBlob);
	}
	pBlob->pBlob = 0;
	pBlob->nByte = pBlob->mByte = 0;
	pBlob->nFlags = 0;
	return SXRET_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBlobSearch(const void* pBlob,sxu32 nLen,const void* pPattern,sxu32 pLen,sxu32* pOfft)
{
	const char* zIn = (const char*)pBlob;
	const char* zEnd;
	sxi32 rc;
	if (pLen > nLen) {
		return SXERR_NOTFOUND;
	}
	zEnd = &zIn[nLen - pLen];
	for (;;) {
		if (zIn > zEnd) { break; } SX_MACRO_FAST_CMP(zIn,pPattern,pLen,rc); if (rc == 0) { if (pOfft) { *pOfft = (sxu32)(zIn - (const char*)pBlob); } return SXRET_OK; } zIn++;
		if (zIn > zEnd) { break; } SX_MACRO_FAST_CMP(zIn,pPattern,pLen,rc); if (rc == 0) { if (pOfft) { *pOfft = (sxu32)(zIn - (const char*)pBlob); } return SXRET_OK; } zIn++;
		if (zIn > zEnd) { break; } SX_MACRO_FAST_CMP(zIn,pPattern,pLen,rc); if (rc == 0) { if (pOfft) { *pOfft = (sxu32)(zIn - (const char*)pBlob); } return SXRET_OK; } zIn++;
		if (zIn > zEnd) { break; } SX_MACRO_FAST_CMP(zIn,pPattern,pLen,rc); if (rc == 0) { if (pOfft) { *pOfft = (sxu32)(zIn - (const char*)pBlob); } return SXRET_OK; } zIn++;
	}
	return SXERR_NOTFOUND;
}
#endif

PHP_PRIVATE sxi32 SySetInit(SySet* pSet,SyMemBackend* pAllocator,sxu32 ElemSize)
{
	pSet->nSize = 0;
	pSet->nUsed = 0;
	pSet->nCursor = 0;
	pSet->eSize = ElemSize;
	pSet->pAllocator = pAllocator;
	pSet->pBase = 0;
	pSet->pUserData = 0;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetPut(SySet* pSet,const void* pItem)
{
	unsigned char* zbase;
	if (pSet->nUsed >= pSet->nSize) {
		void* pNew;
		if (pSet->pAllocator == 0) {
			return  SXERR_LOCKED;
		}
		if (pSet->nSize <= 0) {
			pSet->nSize = 4;
		}
		pNew = SyMemBackendRealloc(pSet->pAllocator,pSet->pBase,pSet->eSize * pSet->nSize * 2);
		if (pNew == 0) {
			return SXERR_MEM;
		}
		pSet->pBase = pNew;
		pSet->nSize <<= 1;
	}
	zbase = (unsigned char*)pSet->pBase;
	SX_MACRO_FAST_MEMCPY(pItem,&zbase[pSet->nUsed * pSet->eSize],pSet->eSize);
	pSet->nUsed++;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetAlloc(SySet* pSet,sxi32 nItem)
{
	if (pSet->nSize > 0) {
		return SXERR_LOCKED;
	}
	if (nItem < 8) {
		nItem = 8;
	}
	pSet->pBase = SyMemBackendAlloc(pSet->pAllocator,pSet->eSize * nItem);
	if (pSet->pBase == 0) {
		return SXERR_MEM;
	}
	pSet->nSize = nItem;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetReset(SySet* pSet)
{
	pSet->nUsed = 0;
	pSet->nCursor = 0;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetResetCursor(SySet* pSet)
{
	pSet->nCursor = 0;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetGetNextEntry(SySet* pSet,void** ppEntry)
{
	register unsigned char* zSrc;
	if (pSet->nCursor >= pSet->nUsed) {

		pSet->nCursor = 0;
		return SXERR_EOF;
	}
	zSrc = (unsigned char*)SySetBasePtr(pSet);
	if (ppEntry) {
		*ppEntry = (void*)&zSrc[pSet->nCursor * pSet->eSize];
	}
	pSet->nCursor++;
	return SXRET_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE void* SySetPeekCurrentEntry(SySet* pSet)
{
	register unsigned char* zSrc;
	if (pSet->nCursor >= pSet->nUsed) {
		return 0;
	}
	zSrc = (unsigned char*)SySetBasePtr(pSet);
	return (void*)&zSrc[pSet->nCursor * pSet->eSize];
}
#endif
PHP_PRIVATE sxi32 SySetTruncate(SySet* pSet,sxu32 nNewSize)
{
	if (nNewSize < pSet->nUsed) {
		pSet->nUsed = nNewSize;
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SySetRelease(SySet* pSet)
{
	sxi32 rc = SXRET_OK;
	if (pSet->pAllocator && pSet->pBase) {
		rc = SyMemBackendFree(pSet->pAllocator,pSet->pBase);
	}
	pSet->pBase = 0;
	pSet->nUsed = 0;
	pSet->nCursor = 0;
	return rc;
}
PHP_PRIVATE void* SySetPeek(SySet* pSet)
{
	const char* zBase;
	if (pSet->nUsed <= 0) {
		return 0;
	}
	zBase = (const char*)pSet->pBase;
	return (void*)&zBase[(pSet->nUsed - 1) * pSet->eSize];
}
PHP_PRIVATE void* SySetPop(SySet* pSet)
{
	const char* zBase;
	void* pData;
	if (pSet->nUsed <= 0) {
		return 0;
	}
	zBase = (const char*)pSet->pBase;
	pSet->nUsed--;
	pData = (void*)&zBase[pSet->nUsed * pSet->eSize];
	return pData;
}
PHP_PRIVATE void* SySetAt(SySet* pSet,sxu32 nIdx)
{
	const char* zBase;
	if (nIdx >= pSet->nUsed) {

		return 0;
	}
	zBase = (const char*)pSet->pBase;
	return (void*)&zBase[nIdx * pSet->eSize];
}

struct SyHashEntry_Pr
{
	const void* pKey;
	sxu32 nKeyLen;
	void* pUserData;

	sxu32 nHash;
	SyHash* pHash;
	SyHashEntry_Pr* pNext,* pPrev;
	SyHashEntry_Pr* pNextCollide,* pPrevCollide;
};
#define INVALID_HASH(H) ((H)->apBucket == 0)

static sxu32 SyBinHash(const void* pSrc,sxu32 nLen);
PHP_PRIVATE sxi32 SyHashInit(SyHash* pHash,SyMemBackend* pAllocator,ProcHash xHash,ProcCmp xCmp)
{
	SyHashEntry_Pr** apNew;
#if defined(UNTRUST)
	if (pHash == 0) {
		return SXERR_EMPTY;
	}
#endif

	apNew = (SyHashEntry_Pr**)SyMemBackendAlloc(&(*pAllocator),sizeof(SyHashEntry_Pr*) * SXHASH_BUCKET_SIZE);
	if (apNew == 0) {
		return SXERR_MEM;
	}
	SyZero((void*)apNew,sizeof(SyHashEntry_Pr*) * SXHASH_BUCKET_SIZE);
	pHash->pAllocator = &(*pAllocator);
	pHash->xHash = xHash ? xHash : SyBinHash;
	pHash->xCmp = xCmp ? xCmp : SyMemcmp;
	pHash->pCurrent = pHash->pList = 0;
	pHash->nEntry = 0;
	pHash->apBucket = apNew;
	pHash->nBucketSize = SXHASH_BUCKET_SIZE;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyHashRelease(SyHash* pHash)
{
	SyHashEntry_Pr* pEntry,* pNext;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return SXERR_EMPTY;
	}
#endif
	pEntry = pHash->pList;
	for (;;) {
		if (pHash->nEntry == 0) {
			break;
		}
		pNext = pEntry->pNext;
		SyMemBackendPoolFree(pHash->pAllocator,pEntry);
		pEntry = pNext;
		pHash->nEntry--;
	}
	if (pHash->apBucket) {
		SyMemBackendFree(pHash->pAllocator,(void*)pHash->apBucket);
	}
	pHash->apBucket = 0;
	pHash->nBucketSize = 0;
	pHash->pAllocator = 0;
	return SXRET_OK;
}
static SyHashEntry_Pr* HashGetEntry(SyHash* pHash,const void* pKey,sxu32 nKeyLen)
{
	SyHashEntry_Pr* pEntry;
	sxu32 nHash;

	nHash = pHash->xHash(pKey,nKeyLen);
	pEntry = pHash->apBucket[nHash & (pHash->nBucketSize - 1)];
	for (;;) {
		if (pEntry == 0) {
			break;
		}
		if (pEntry->nHash == nHash && pEntry->nKeyLen == nKeyLen &&
			pHash->xCmp(pEntry->pKey,pKey,nKeyLen) == 0) {
			return pEntry;
		}
		pEntry = pEntry->pNextCollide;
	}

	return 0;
}
PHP_PRIVATE SyHashEntry* SyHashGet(SyHash* pHash,const void* pKey,sxu32 nKeyLen)
{
	SyHashEntry_Pr* pEntry;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return 0;
	}
#endif
	if (pHash->nEntry < 1 || nKeyLen < 1) {

		return 0;
	}
	pEntry = HashGetEntry(&(*pHash),pKey,nKeyLen);
	if (pEntry == 0) {
		return 0;
	}
	return (SyHashEntry*)pEntry;
}
static sxi32 HashDeleteEntry(SyHash* pHash,SyHashEntry_Pr* pEntry,void** ppUserData)
{
	sxi32 rc;
	if (pEntry->pPrevCollide == 0) {
		pHash->apBucket[pEntry->nHash & (pHash->nBucketSize - 1)] = pEntry->pNextCollide;
	}
	else {
		pEntry->pPrevCollide->pNextCollide = pEntry->pNextCollide;
	}
	if (pEntry->pNextCollide) {
		pEntry->pNextCollide->pPrevCollide = pEntry->pPrevCollide;
	}
	MACRO_LD_REMOVE(pHash->pList,pEntry);
	pHash->nEntry--;
	if (ppUserData) {

		*ppUserData = pEntry->pUserData;
	}

	rc = SyMemBackendPoolFree(pHash->pAllocator,pEntry);
	return rc;
}
PHP_PRIVATE sxi32 SyHashDeleteEntry(SyHash* pHash,const void* pKey,sxu32 nKeyLen,void** ppUserData)
{
	SyHashEntry_Pr* pEntry;
	sxi32 rc;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return SXERR_CORRUPT;
	}
#endif
	pEntry = HashGetEntry(&(*pHash),pKey,nKeyLen);
	if (pEntry == 0) {
		return SXERR_NOTFOUND;
	}
	rc = HashDeleteEntry(&(*pHash),pEntry,ppUserData);
	return rc;
}
PHP_PRIVATE sxi32 SyHashDeleteEntry2(SyHashEntry* pEntry)
{
	SyHashEntry_Pr* pPtr = (SyHashEntry_Pr*)pEntry;
	sxi32 rc;
#if defined(UNTRUST)
	if (pPtr == 0 || INVALID_HASH(pPtr->pHash)) {
		return SXERR_CORRUPT;
	}
#endif
	rc = HashDeleteEntry(pPtr->pHash,pPtr,0);
	return rc;
}
PHP_PRIVATE sxi32 SyHashResetLoopCursor(SyHash* pHash)
{
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return SXERR_CORRUPT;
	}
#endif
	pHash->pCurrent = pHash->pList;
	return SXRET_OK;
}
PHP_PRIVATE SyHashEntry* SyHashGetNextEntry(SyHash* pHash)
{
	SyHashEntry_Pr* pEntry;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return 0;
	}
#endif
	if (pHash->pCurrent == 0 || pHash->nEntry <= 0) {
		pHash->pCurrent = pHash->pList;
		return 0;
	}
	pEntry = pHash->pCurrent;

	pHash->pCurrent = pEntry->pNext;

	return (SyHashEntry*)pEntry;
}
PHP_PRIVATE sxi32 SyHashForEach(SyHash* pHash,sxi32(*xStep)(SyHashEntry*,void*),void* pUserData)
{
	SyHashEntry_Pr* pEntry;
	sxi32 rc;
	sxu32 n;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash) || xStep == 0) {
		return 0;
	}
#endif
	pEntry = pHash->pList;
	for (n = 0; n < pHash->nEntry; n++) {

		rc = xStep((SyHashEntry*)pEntry,pUserData);
		if (rc != SXRET_OK) {
			return rc;
		}

		pEntry = pEntry->pNext;
	}
	return SXRET_OK;
}
static sxi32 HashGrowTable(SyHash* pHash)
{
	sxu32 nNewSize = pHash->nBucketSize * 2;
	SyHashEntry_Pr* pEntry;
	SyHashEntry_Pr** apNew;
	sxu32 n,iBucket;


	apNew = (SyHashEntry_Pr**)SyMemBackendAlloc(pHash->pAllocator,nNewSize * sizeof(SyHashEntry_Pr*));
	if (apNew == 0) {

		return SXRET_OK;
	}

	SyZero((void*)apNew,nNewSize * sizeof(SyHashEntry_Pr*));

	for (n = 0,pEntry = pHash->pList; n < pHash->nEntry; n++) {
		pEntry->pNextCollide = pEntry->pPrevCollide = 0;

		iBucket = pEntry->nHash & (nNewSize - 1);
		pEntry->pNextCollide = apNew[iBucket];
		if (apNew[iBucket] != 0) {
			apNew[iBucket]->pPrevCollide = pEntry;
		}
		apNew[iBucket] = pEntry;

		pEntry = pEntry->pNext;
	}

	SyMemBackendFree(pHash->pAllocator,(void*)pHash->apBucket);
	pHash->apBucket = apNew;
	pHash->nBucketSize = nNewSize;
	return SXRET_OK;
}
static sxi32 HashInsert(SyHash* pHash,SyHashEntry_Pr* pEntry)
{
	sxu32 iBucket = pEntry->nHash & (pHash->nBucketSize - 1);

	pEntry->pNextCollide = pHash->apBucket[iBucket];
	if (pHash->apBucket[iBucket] != 0) {
		pHash->apBucket[iBucket]->pPrevCollide = pEntry;
	}
	pHash->apBucket[iBucket] = pEntry;

	MACRO_LD_PUSH(pHash->pList,pEntry);
	if (pHash->nEntry == 0) {
		pHash->pCurrent = pHash->pList;
	}
	pHash->nEntry++;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyHashInsert(SyHash* pHash,const void* pKey,sxu32 nKeyLen,void* pUserData)
{
	SyHashEntry_Pr* pEntry;
	sxi32 rc;
#if defined(UNTRUST)
	if (INVALID_HASH(pHash) || pKey == 0) {
		return SXERR_CORRUPT;
	}
#endif
	if (pHash->nEntry >= pHash->nBucketSize * SXHASH_FILL_FACTOR) {
		rc = HashGrowTable(&(*pHash));
		if (rc != SXRET_OK) {
			return rc;
		}
	}

	pEntry = (SyHashEntry_Pr*)SyMemBackendPoolAlloc(pHash->pAllocator,sizeof(SyHashEntry_Pr));
	if (pEntry == 0) {
		return SXERR_MEM;
	}

	SyZero(pEntry,sizeof(SyHashEntry_Pr));
	pEntry->pHash = pHash;
	pEntry->pKey = pKey;
	pEntry->nKeyLen = nKeyLen;
	pEntry->pUserData = pUserData;
	pEntry->nHash = pHash->xHash(pEntry->pKey,pEntry->nKeyLen);

	rc = HashInsert(&(*pHash),pEntry);
	return rc;
}
PHP_PRIVATE SyHashEntry* SyHashLastEntry(SyHash* pHash)
{
#if defined(UNTRUST)
	if (INVALID_HASH(pHash)) {
		return 0;
	}
#endif

	return (SyHashEntry*)pHash->pList;
}

PHP_PRIVATE sxi32 SyStrIsNumeric(const char* zSrc,sxu32 nLen,sxu8* pReal,const char** pzTail)
{
	const char* zCur,* zEnd;
#ifdef UNTRUST
	if (SX_EMPTY_STR(zSrc)) {
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];

	while (zSrc < zEnd && (unsigned char)zSrc[0] < 0xc0 && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '+' || zSrc[0] == '-')) {
		zSrc++;
	}
	zCur = zSrc;
	if (pReal) {
		*pReal = FALSE;
	}
	for (;;) {
		if (zSrc >= zEnd || (unsigned char)zSrc[0] >= 0xc0 || !SyisDigit(zSrc[0])) { break; } zSrc++;
		if (zSrc >= zEnd || (unsigned char)zSrc[0] >= 0xc0 || !SyisDigit(zSrc[0])) { break; } zSrc++;
		if (zSrc >= zEnd || (unsigned char)zSrc[0] >= 0xc0 || !SyisDigit(zSrc[0])) { break; } zSrc++;
		if (zSrc >= zEnd || (unsigned char)zSrc[0] >= 0xc0 || !SyisDigit(zSrc[0])) { break; } zSrc++;
	};
	if (zSrc < zEnd && zSrc > zCur) {
		int c = zSrc[0];
		if (c == '.') {
			zSrc++;
			if (pReal) {
				*pReal = TRUE;
			}
			if (pzTail) {
				while (zSrc < zEnd && (unsigned char)zSrc[0] < 0xc0 && SyisDigit(zSrc[0])) {
					zSrc++;
				}
				if (zSrc < zEnd && (zSrc[0] == 'e' || zSrc[0] == 'E')) {
					zSrc++;
					if (zSrc < zEnd && (zSrc[0] == '+' || zSrc[0] == '-')) {
						zSrc++;
					}
					while (zSrc < zEnd && (unsigned char)zSrc[0] < 0xc0 && SyisDigit(zSrc[0])) {
						zSrc++;
					}
				}
			}
		}
		else if (c == 'e' || c == 'E') {
			zSrc++;
			if (pReal) {
				*pReal = TRUE;
			}
			if (pzTail) {
				if (zSrc < zEnd && (zSrc[0] == '+' || zSrc[0] == '-')) {
					zSrc++;
				}
				while (zSrc < zEnd && (unsigned char)zSrc[0] < 0xc0 && SyisDigit(zSrc[0])) {
					zSrc++;
				}
			}
		}
	}
	if (pzTail) {

		*pzTail = zSrc;
	}
	return zSrc > zCur ? SXRET_OK  : SXERR_INVALID ;
}
#define SXINT32_MIN_STR		"2147483648"
#define SXINT32_MAX_STR		"2147483647"
#define SXINT64_MIN_STR		"9223372036854775808"
#define SXINT64_MAX_STR		"9223372036854775807"
PHP_PRIVATE sxi32 SyStrToInt32(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
	int isNeg = FALSE;
	const char* zEnd;
	sxi32 nVal = 0;
	sxi16 i;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxi32*)pOutVal = 0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
		isNeg = (zSrc[0] == '-') ? TRUE : FALSE;
		zSrc++;
	}

	while (zSrc < zEnd && zSrc[0] == '0') {
		zSrc++;
	}
	i = 10;
	if ((sxu32)(zEnd - zSrc) >= 10) {

		i = SyMemcmp(zSrc,(isNeg == TRUE) ? SXINT32_MIN_STR : SXINT32_MAX_STR,nLen) <= 0 ? 10 : 9;
	}
	for (;;) {
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
	}

	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = (char*)zSrc;
	}
	if (pOutVal) {
		if (isNeg == TRUE && nVal != 0) {
			nVal = -nVal;
		}
		*(sxi32*)pOutVal = nVal;
	}
	return (zSrc >= zEnd) ? SXRET_OK : SXERR_SYNTAX;
}
PHP_PRIVATE sxi32 SyStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
	int isNeg = FALSE;
	const char* zEnd;
	sxi64 nVal;
	sxi16 i;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxi32*)pOutVal = 0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
		isNeg = (zSrc[0] == '-') ? TRUE : FALSE;
		zSrc++;
	}

	while (zSrc < zEnd && zSrc[0] == '0') {
		zSrc++;
	}
	i = 19;
	if ((sxu32)(zEnd - zSrc) >= 19) {
		i = SyMemcmp(zSrc,isNeg ? SXINT64_MIN_STR : SXINT64_MAX_STR,19) <= 0 ? 19 : 18;
	}
	nVal = 0;
	for (;;) {
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
		if (zSrc >= zEnd || !i || !SyisDigit(zSrc[0])) { break; } nVal = nVal * 10 + (zSrc[0] - '0'); --i; zSrc++;
	}

	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = (char*)zSrc;
	}
	if (pOutVal) {
		if (isNeg == TRUE && nVal != 0) {
			nVal = -nVal;
		}
		*(sxi64*)pOutVal = nVal;
	}
	return (zSrc >= zEnd) ? SXRET_OK : SXERR_SYNTAX;
}
PHP_PRIVATE sxi32 SyHexToint(sxi32 c)
{
	switch (c) {
	case '0': return 0;
	case '1': return 1;
	case '2': return 2;
	case '3': return 3;
	case '4': return 4;
	case '5': return 5;
	case '6': return 6;
	case '7': return 7;
	case '8': return 8;
	case '9': return 9;
	case 'A': case 'a': return 10;
	case 'B': case 'b': return 11;
	case 'C': case 'c': return 12;
	case 'D': case 'd': return 13;
	case 'E': case 'e': return 14;
	case 'F': case 'f': return 15;
	}
	return -1;
}
PHP_PRIVATE sxi32 SyHexStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
	const char* zIn,* zEnd; int isNeg = FALSE;
	sxi64 nVal = 0;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxi32*)pOutVal = 0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (*zSrc == '-' || *zSrc == '+')) {
		isNeg = (zSrc[0] == '-') ? TRUE : FALSE;
		zSrc++;
	}
	if (zSrc < &zEnd[-2] && zSrc[0] == '0' && (zSrc[1] == 'x' || zSrc[1] == 'X')) {

		zSrc += sizeof(char) * 2;
	}

	while (zSrc < zEnd && zSrc[0] == '0') {
		zSrc++;
	}
	zIn = zSrc;
	for (;;) {
		if (zSrc >= zEnd || !SyisHex(zSrc[0]) || (int)(zSrc - zIn) > 15) break; nVal = nVal * 16 + SyHexToint(zSrc[0]);  zSrc++;
		if (zSrc >= zEnd || !SyisHex(zSrc[0]) || (int)(zSrc - zIn) > 15) break; nVal = nVal * 16 + SyHexToint(zSrc[0]);  zSrc++;
		if (zSrc >= zEnd || !SyisHex(zSrc[0]) || (int)(zSrc - zIn) > 15) break; nVal = nVal * 16 + SyHexToint(zSrc[0]);  zSrc++;
		if (zSrc >= zEnd || !SyisHex(zSrc[0]) || (int)(zSrc - zIn) > 15) break; nVal = nVal * 16 + SyHexToint(zSrc[0]);  zSrc++;
	}
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = zSrc;
	}
	if (pOutVal) {
		if (isNeg == TRUE && nVal != 0) {
			nVal = -nVal;
		}
		*(sxi64*)pOutVal = nVal;
	}
	return zSrc >= zEnd ? SXRET_OK : SXERR_SYNTAX;
}
PHP_PRIVATE sxi32 SyOctalStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
	const char* zIn,* zEnd; int isNeg = FALSE;
	sxi64 nVal = 0; int c;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxi32*)pOutVal = 0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
		isNeg = (zSrc[0] == '-') ? TRUE : FALSE;
		zSrc++;
	}

	while (zSrc < zEnd && zSrc[0] == '0') {
		zSrc++;
	}
	zIn = zSrc;
	for (;;) {
		if (zSrc >= zEnd || !SyisDigit(zSrc[0])) { break; } if ((c = zSrc[0] - '0') > 7 || (int)(zSrc - zIn) > 20) { break; } nVal = nVal * 8 + c; zSrc++;
		if (zSrc >= zEnd || !SyisDigit(zSrc[0])) { break; } if ((c = zSrc[0] - '0') > 7 || (int)(zSrc - zIn) > 20) { break; } nVal = nVal * 8 + c; zSrc++;
		if (zSrc >= zEnd || !SyisDigit(zSrc[0])) { break; } if ((c = zSrc[0] - '0') > 7 || (int)(zSrc - zIn) > 20) { break; } nVal = nVal * 8 + c; zSrc++;
		if (zSrc >= zEnd || !SyisDigit(zSrc[0])) { break; } if ((c = zSrc[0] - '0') > 7 || (int)(zSrc - zIn) > 20) { break; } nVal = nVal * 8 + c; zSrc++;
	}

	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = zSrc;
	}
	if (pOutVal) {
		if (isNeg == TRUE && nVal != 0) {
			nVal = -nVal;
		}
		*(sxi64*)pOutVal = nVal;
	}
	return (zSrc >= zEnd) ? SXRET_OK : SXERR_SYNTAX;
}
PHP_PRIVATE sxi32 SyBinaryStrToInt64(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
	const char* zIn,* zEnd; int isNeg = FALSE;
	sxi64 nVal = 0; int c;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxi32*)pOutVal = 0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
		isNeg = (zSrc[0] == '-') ? TRUE : FALSE;
		zSrc++;
	}
	if (zSrc < &zEnd[-2] && zSrc[0] == '0' && (zSrc[1] == 'b' || zSrc[1] == 'B')) {

		zSrc += sizeof(char) * 2;
	}

	while (zSrc < zEnd && zSrc[0] == '0') {
		zSrc++;
	}
	zIn = zSrc;
	for (;;) {
		if (zSrc >= zEnd || (zSrc[0] != '1' && zSrc[0] != '0') || (int)(zSrc - zIn) > 62) { break; } c = zSrc[0] - '0'; nVal = (nVal << 1) + c; zSrc++;
		if (zSrc >= zEnd || (zSrc[0] != '1' && zSrc[0] != '0') || (int)(zSrc - zIn) > 62) { break; } c = zSrc[0] - '0'; nVal = (nVal << 1) + c; zSrc++;
		if (zSrc >= zEnd || (zSrc[0] != '1' && zSrc[0] != '0') || (int)(zSrc - zIn) > 62) { break; } c = zSrc[0] - '0'; nVal = (nVal << 1) + c; zSrc++;
		if (zSrc >= zEnd || (zSrc[0] != '1' && zSrc[0] != '0') || (int)(zSrc - zIn) > 62) { break; } c = zSrc[0] - '0'; nVal = (nVal << 1) + c; zSrc++;
	}

	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = zSrc;
	}
	if (pOutVal) {
		if (isNeg == TRUE && nVal != 0) {
			nVal = -nVal;
		}
		*(sxi64*)pOutVal = nVal;
	}
	return (zSrc >= zEnd) ? SXRET_OK : SXERR_SYNTAX;
}
PHP_PRIVATE sxi32 SyStrToReal(const char* zSrc,sxu32 nLen,void* pOutVal,const char** zRest)
{
#define SXDBL_DIG        15
#define SXDBL_MAX_EXP    308
#define SXDBL_MIN_EXP_PLUS	307
	static const sxreal aTab[] = {
	10,
	1.0e2,
	1.0e4,
	1.0e8,
	1.0e16,
	1.0e32,
	1.0e64,
	1.0e128,
	1.0e256
	};
	sxu8 neg = FALSE;
	sxreal Val = 0.0;
	const char* zEnd;
	sxi32 Lim,exp;
	sxreal* p = 0;
#ifdef UNTRUST
	if (SX_EMPTY_STR(zSrc)) {
		if (pOutVal) {
			*(sxreal*)pOutVal = 0.0;
		}
		return SXERR_EMPTY;
	}
#endif
	zEnd = &zSrc[nLen];
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
		neg = zSrc[0] == '-' ? TRUE : FALSE;
		zSrc++;
	}
	Lim = SXDBL_DIG;
	for (;;) {
		if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;
		if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;
		if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;
		if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); zSrc++; --Lim;
	}
	if (zSrc < zEnd && (zSrc[0] == '.' || zSrc[0] == ',')) {
		sxreal dec = 1.0;
		zSrc++;
		for (;;) {
			if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;
			if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;
			if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;
			if (zSrc >= zEnd || !Lim || !SyisDigit(zSrc[0])) break; Val = Val * 10.0 + (zSrc[0] - '0'); dec *= 10.0; zSrc++; --Lim;
		}
		Val /= dec;
	}
	if (neg == TRUE && Val != 0.0) {
		Val = -Val;
	}
	if (Lim <= 0) {

		while (zSrc < zEnd) {
			if (zSrc[0] == 'e' || zSrc[0] == 'E') {
				break;
			}
			zSrc++;
		}
	}
	neg = FALSE;
	if (zSrc < zEnd && (zSrc[0] == 'e' || zSrc[0] == 'E')) {
		zSrc++;
		if (zSrc < zEnd && (zSrc[0] == '-' || zSrc[0] == '+')) {
			neg = zSrc[0] == '-' ? TRUE : FALSE;
			zSrc++;
		}
		exp = 0;
		while (zSrc < zEnd && SyisDigit(zSrc[0]) && exp < SXDBL_MAX_EXP) {
			exp = exp * 10 + (zSrc[0] - '0');
			zSrc++;
		}
		if (neg) {
			if (exp > SXDBL_MIN_EXP_PLUS) exp = SXDBL_MIN_EXP_PLUS;
		}
		else if (exp > SXDBL_MAX_EXP) {
			exp = SXDBL_MAX_EXP;
		}
		for (p = (sxreal*)aTab; exp; exp >>= 1,p++) {
			if (exp & 01) {
				if (neg) {
					Val /= *p;
				}
				else {
					Val *= *p;
				}
			}
		}
	}
	while (zSrc < zEnd && SyisSpace(zSrc[0])) {
		zSrc++;
	}
	if (zRest) {
		*zRest = zSrc;
	}
	if (pOutVal) {
		*(sxreal*)pOutVal = Val;
	}
	return zSrc >= zEnd ? SXRET_OK : SXERR_SYNTAX;
}

static sxu32 SyBinHash(const void* pSrc,sxu32 nLen)
{
	register unsigned char* zIn = (unsigned char*)pSrc;
	unsigned char* zEnd;
	sxu32 nH = 5381;
	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
	}
	return nH;
}
PHP_PRIVATE sxu32 SyStrHash(const void* pSrc,sxu32 nLen)
{
	register unsigned char* zIn = (unsigned char*)pSrc;
	unsigned char* zEnd;
	sxu32 nH = 5381;
	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; } nH = nH * 33 + SyToLower(zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + SyToLower(zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + SyToLower(zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + SyToLower(zIn[0]); zIn++;
	}
	return nH;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBase64Encode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData)
{
	static const unsigned char zBase64[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	unsigned char* zIn = (unsigned char*)zSrc;
	unsigned char z64[4];
	sxu32 i;
	sxi32 rc;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc) || xConsumer == 0) {
		return SXERR_EMPTY;
	}
#endif
	for (i = 0; i + 2 < nLen; i += 3) {
		z64[0] = zBase64[(zIn[i] >> 2) & 0x3F];
		z64[1] = zBase64[(((zIn[i] & 0x03) << 4) | (zIn[i + 1] >> 4)) & 0x3F];
		z64[2] = zBase64[(((zIn[i + 1] & 0x0F) << 2) | (zIn[i + 2] >> 6)) & 0x3F];
		z64[3] = zBase64[zIn[i + 2] & 0x3F];

		rc = xConsumer((const void*)z64,sizeof(z64),pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }

	}
	if (i + 1 < nLen) {
		z64[0] = zBase64[(zIn[i] >> 2) & 0x3F];
		z64[1] = zBase64[(((zIn[i] & 0x03) << 4) | (zIn[i + 1] >> 4)) & 0x3F];
		z64[2] = zBase64[(zIn[i + 1] & 0x0F) << 2];
		z64[3] = '=';

		rc = xConsumer((const void*)z64,sizeof(z64),pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }

	}
	else if (i < nLen) {
		z64[0] = zBase64[(zIn[i] >> 2) & 0x3F];
		z64[1] = zBase64[(zIn[i] & 0x03) << 4];
		z64[2] = '=';
		z64[3] = '=';

		rc = xConsumer((const void*)z64,sizeof(z64),pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }
	}

	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyBase64Decode(const char* zB64,sxu32 nLen,ProcConsumer xConsumer,void* pUserData)
{
	static const sxu32 aBase64Trans[] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,62,0,0,0,63,52,53,54,55,56,57,58,59,60,61,0,0,0,0,0,0,0,0,1,2,3,4,
	5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,0,0,0,0,0,0,26,27,
	28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,0,0,
	0,0,0
	};
	sxu32 n,w,x,y,z;
	sxi32 rc;
	unsigned char zOut[10];
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zB64) || xConsumer == 0) {
		return SXERR_EMPTY;
	}
#endif
	while (nLen > 0 && zB64[nLen - 1] == '=') {
		nLen--;
	}
	for (n = 0; n + 3 < nLen; n += 4) {
		w = aBase64Trans[zB64[n] & 0x7F];
		x = aBase64Trans[zB64[n + 1] & 0x7F];
		y = aBase64Trans[zB64[n + 2] & 0x7F];
		z = aBase64Trans[zB64[n + 3] & 0x7F];
		zOut[0] = ((w << 2) & 0xFC) | ((x >> 4) & 0x03);
		zOut[1] = ((x << 4) & 0xF0) | ((y >> 2) & 0x0F);
		zOut[2] = ((y << 6) & 0xC0) | (z & 0x3F);

		rc = xConsumer((const void*)zOut,sizeof(unsigned char) * 3,pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }
	}
	if (n + 2 < nLen) {
		w = aBase64Trans[zB64[n] & 0x7F];
		x = aBase64Trans[zB64[n + 1] & 0x7F];
		y = aBase64Trans[zB64[n + 2] & 0x7F];

		zOut[0] = ((w << 2) & 0xFC) | ((x >> 4) & 0x03);
		zOut[1] = ((x << 4) & 0xF0) | ((y >> 2) & 0x0F);

		rc = xConsumer((const void*)zOut,sizeof(unsigned char) * 2,pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }
	}
	else if (n + 1 < nLen) {
		w = aBase64Trans[zB64[n] & 0x7F];
		x = aBase64Trans[zB64[n + 1] & 0x7F];

		zOut[0] = ((w << 2) & 0xFC) | ((x >> 4) & 0x03);

		rc = xConsumer((const void*)zOut,sizeof(unsigned char) * 1,pUserData);
		if (rc != SXRET_OK) { return SXERR_ABORT; }
	}
	return SXRET_OK;
}
#endif
#define INVALID_LEXER(LEX)	(  LEX == 0  || LEX->xTokenizer == 0 )
PHP_PRIVATE sxi32 SyLexInit(SyLex* pLex,SySet* pSet,ProcTokenizer xTokenizer,void* pUserData)
{
	SyStream* pStream;
#if defined (UNTRUST)
	if (pLex == 0 || xTokenizer == 0) {
		return SXERR_CORRUPT;
	}
#endif
	pLex->pTokenSet = 0;

	if (pSet) {
		if (SySetElemSize(pSet) != sizeof(SyToken)) {
			return SXERR_INVALID;
		}
		pLex->pTokenSet = pSet;
	}
	pStream = &pLex->sStream;
	pLex->xTokenizer = xTokenizer;
	pLex->pUserData = pUserData;

	pStream->nLine = 1;
	pStream->nIgn = 0;
	pStream->zText = pStream->zEnd = 0;
	pStream->pSet = pSet;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyLexTokenizeInput(SyLex* pLex,const char* zInput,sxu32 nLen,void* pCtxData,ProcSort xSort,ProcCmp xCmp)
{
	const unsigned char* zCur;
	SyStream* pStream;
	SyToken sToken;
	sxi32 rc;
#if defined (UNTRUST)
	if (INVALID_LEXER(pLex) || zInput == 0) {
		return SXERR_CORRUPT;
	}
#endif
	pStream = &pLex->sStream;

	pStream->zText = pStream->zInput = (const unsigned char*)zInput;

	pStream->zEnd = &pStream->zInput[nLen];
	for (;;) {
		if (pStream->zText >= pStream->zEnd) {

			break;
		}
		zCur = pStream->zText;

		rc = pLex->xTokenizer(pStream,&sToken,pLex->pUserData,pCtxData);
		if (rc != SXRET_OK && rc != SXERR_CONTINUE) {

			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			break;
		}
		if (rc == SXERR_CONTINUE) {

			pStream->nIgn++;
		}
		else if (pLex->pTokenSet) {

			rc = SySetPut(pLex->pTokenSet,(const void*)&sToken);
			if (rc != SXRET_OK) {
				break;
			}
		}
		if (zCur >= pStream->zText) {

			pStream->zText = &zCur[1];
		}
	}
	if (xSort && pLex->pTokenSet) {
		SyToken* aToken = (SyToken*)SySetBasePtr(pLex->pTokenSet);

		if (xCmp == 0) {

			xCmp = SyMemcmp;
		}
		xSort(aToken,SySetUsed(pLex->pTokenSet),sizeof(SyToken),xCmp);
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyLexRelease(SyLex* pLex)
{
	sxi32 rc = SXRET_OK;
#if defined (UNTRUST)
	if (INVALID_LEXER(pLex)) {
		return SXERR_CORRUPT;
	}
#else
	SXUNUSED(pLex);
#endif
	return rc;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
#define SAFE_HTTP(C)	(SyisAlphaNum(c) || c == '_' || c == '-' || c == '$' || c == '.' )
PHP_PRIVATE sxi32 SyUriEncode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData)
{
	unsigned char* zIn = (unsigned char*)zSrc;
	unsigned char zHex[3] = { '%',0,0 };
	unsigned char zOut[2];
	unsigned char* zCur,* zEnd;
	sxi32 c;
	sxi32 rc;
#ifdef UNTRUST
	if (SX_EMPTY_STR(zSrc) || xConsumer == 0) {
		return SXERR_EMPTY;
	}
#endif
	rc = SXRET_OK;
	zEnd = &zIn[nLen]; zCur = zIn;
	for (;;) {
		if (zCur >= zEnd) {
			if (zCur != zIn) {
				rc = xConsumer(zIn,(sxu32)(zCur - zIn),pUserData);
			}
			break;
		}
		c = zCur[0];
		if (SAFE_HTTP(c)) {
			zCur++; continue;
		}
		if (zCur != zIn && SXRET_OK != (rc = xConsumer(zIn,(sxu32)(zCur - zIn),pUserData))) {
			break;
		}
		if (c == ' ') {
			zOut[0] = '+';
			rc = xConsumer((const void*)zOut,sizeof(unsigned char),pUserData);
		}
		else {
			zHex[1] = "0123456789ABCDEF"[(c >> 4) & 0x0F];
			zHex[2] = "0123456789ABCDEF"[c & 0x0F];
			rc = xConsumer(zHex,sizeof(zHex),pUserData);
		}
		if (SXRET_OK != rc) {
			break;
		}
		zIn = &zCur[1]; zCur = zIn;
	}
	return rc == SXRET_OK ? SXRET_OK : SXERR_ABORT;
}
#endif
static sxi32 SyAsciiToHex(sxi32 c)
{
	if (c >= 'a' && c <= 'f') {
		c += 10 - 'a';
		return c;
	}
	if (c >= '0' && c <= '9') {
		c -= '0';
		return c;
	}
	if (c >= 'A' && c <= 'F') {
		c += 10 - 'A';
		return c;
	}
	return 0;
}
PHP_PRIVATE sxi32 SyUriDecode(const char* zSrc,sxu32 nLen,ProcConsumer xConsumer,void* pUserData,int bUTF8)
{
	static const sxu8 Utf8Trans[] = {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x01,0x02,0x03,0x00,0x01,0x00,0x00};
	const char* zIn = zSrc;const char* zEnd;const char* zCur;sxu8* zOutPtr;sxu8 zOut[10];sxi32 c,d;sxi32 rc;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zSrc) || xConsumer == 0) {
		return SXERR_EMPTY;
	}
#endif
	rc = SXRET_OK;
	zEnd = &zSrc[nLen];
	zCur = zIn;
	for (;;) {
		while (zCur < zEnd && zCur[0] != '%' && zCur[0] != '+') {
			zCur++;
		}
		if (zCur != zIn) {

			rc = xConsumer(zIn,(unsigned int)(zCur - zIn),pUserData);
			if (rc != SXRET_OK) {

				break;
			}
		}
		if (zCur >= zEnd) {
			rc = SXRET_OK;
			break;
		}

		zOutPtr = zOut;
		if (zCur[0] == '+') {
			*zOutPtr++ = ' ';
			zCur++;
		}
		else {
			if (&zCur[2] >= zEnd) {
				rc = SXERR_OVERFLOW;
				break;
			}
			c = (SyAsciiToHex(zCur[1]) << 4) | SyAsciiToHex(zCur[2]);
			zCur += 3;
			if (c < 0x000C0) {
				*zOutPtr++ = (sxu8)c;
			}
			else {
				c = Utf8Trans[c - 0xC0];
				while (zCur[0] == '%') {
					d = (SyAsciiToHex(zCur[1]) << 4) | SyAsciiToHex(zCur[2]);
					if ((d & 0xC0) != 0x80) {
						break;
					}
					c = (c << 6) + (0x3f & d);
					zCur += 3;
				}
				if (bUTF8 == FALSE) {
					*zOutPtr++ = (sxu8)c;
				}
				else {
					SX_WRITE_UTF8(zOutPtr,c);
				}
			}

		}

		rc = xConsumer((const void*)zOut,(unsigned int)(zOutPtr - zOut),pUserData);
		if (rc != SXRET_OK) {
			break;
		}

		zIn = zCur;
	}
	return rc;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
static const char* zEngDay[] = {
	"Sunday","Monday","Tuesday","Wednesday",
	"Thursday","Friday","Saturday"
};
static const char* zEngMonth[] = {
	"January","February","March","April",
	"May","June","July","August",
	"September","October","November","December"
};
static const char* GetDay(sxi32 i)
{
	return zEngDay[i % 7];
}
static const char* GetMonth(sxi32 i)
{
	return zEngMonth[i % 12];
}
PHP_PRIVATE const char* SyTimeGetDay(sxi32 iDay)
{
	return GetDay(iDay);
}
PHP_PRIVATE const char* SyTimeGetMonth(sxi32 iMonth)
{
	return GetMonth(iMonth);
}
#endif

#define SXFMT_BUFSIZ 1024

#define SXFMT_RADIX       1
#define SXFMT_FLOAT       2
#define SXFMT_EXP         3
#define SXFMT_GENERIC     4
#define SXFMT_SIZE        5
#define SXFMT_STRING      6
#define SXFMT_PERCENT     7
#define SXFMT_CHARX       8
#define SXFMT_ERROR       9

#define SXFMT_RAWSTR     13
#define SXFMT_UNUSED     15

#define SXFLAG_SIGNED	0x01
#define SXFLAG_UNSIGNED 0x02

#define SXFMT_CONS_PROC		1
#define SXFMT_CONS_STR		2
#define SXFMT_CONS_FILE		5
#define SXFMT_CONS_BLOB		6

typedef struct SyFmtInfo SyFmtInfo;
struct SyFmtInfo
{
	char fmttype;
	sxu8 base; int flags;
	sxu8 type;
	char* charset;
	char* prefix;
};typedef struct SyFmtConsumer SyFmtConsumer;
struct SyFmtConsumer
{
	sxu32 nLen;
	sxi32 nType;
	sxi32 rc;
	union {
		struct {
			ProcConsumer xUserConsumer;
			void* pUserData;
		}sFunc;
		SyBlob* pBlob;
	}uConsumer;
};
#ifndef SX_OMIT_FLOATINGPOINT
static int getdigit(sxlongreal* val,int* cnt)
{
	sxlongreal d; int digit;

	if ((*cnt)++ >= 16) {
		return '0';
	}
	digit = (int)*val;
	d = digit;
	*val = (*val - d) * 10.0;
	return digit + '0';
}
#endif

static sxi32 InternFormat(ProcConsumer xConsumer,void* pUserData,const char* zFormat,va_list ap)
{

	static const SyFmtInfo aFmt[] = {
		{  'd',10,SXFLAG_SIGNED,SXFMT_RADIX,"0123456789",0},{  's',0,0,SXFMT_STRING,0,0},{  'c',0,0,SXFMT_CHARX,0,0},{  'x',16,0,SXFMT_RADIX,"0123456789abcdef","x0"},{  'X',16,0,SXFMT_RADIX,"0123456789ABCDEF","X0"},
{  'z',0,0,SXFMT_RAWSTR,0,0   },
{  'B',2,0,SXFMT_RADIX,"01","b0"},{  'o',8,0,SXFMT_RADIX,"01234567","0"},
{  'u',10,0,SXFMT_RADIX,"0123456789",0},
#ifndef SX_OMIT_FLOATINGPOINT
	{  'f',0,SXFLAG_SIGNED,SXFMT_FLOAT,0,0},{  'e',0,SXFLAG_SIGNED,SXFMT_EXP,"e",0},{  'E',0,SXFLAG_SIGNED,SXFMT_EXP,"E",0},{  'g',0,SXFLAG_SIGNED,SXFMT_GENERIC,"e",0},{  'G',0,SXFLAG_SIGNED,SXFMT_GENERIC,"E",0},
#endif
	{  'i',10,SXFLAG_SIGNED,SXFMT_RADIX,"0123456789",0},{  'n',0,0,SXFMT_SIZE,0,0},{  '%',0,0,SXFMT_PERCENT,0,0},{  'p',10,0,SXFMT_RADIX,"0123456789",0    }
	}; int c;
	char* bufpt; int precision; int length; int idx; int width;
	sxu8 flag_leftjustify;
	sxu8 flag_plussign;
	sxu8 flag_blanksign;
	sxu8 flag_alternateform;
	sxu8 flag_zeropad;
	sxu8 flag_long;
	sxi64 longvalue;
	const SyFmtInfo* infop;
	char buf[SXFMT_BUFSIZ];
	char prefix;
	sxu8 errorflag = 0;
	sxu8 xtype;
	char* zExtra;
	static char spaces[] = "                                                  ";
#define etSPACESIZE ((int)sizeof(spaces)-1)
#ifndef SX_OMIT_FLOATINGPOINT
	sxlongreal realvalue; int  exp;
	double rounder;
	sxu8 flag_dp;
	sxu8 flag_rtz;
	sxu8 flag_exp; int nsd;
#endif
	int rc;

	length = 0;
	bufpt = 0;
	for (; (c = (*zFormat)) != 0; ++zFormat) {
		if (c != '%') {
			unsigned int amt;
			bufpt = (char*)zFormat;
			amt = 1;
			while ((c = (*++zFormat)) != '%' && c != 0) amt++;
			rc = xConsumer((const void*)bufpt,amt,pUserData);
			if (rc != SXRET_OK) {
				return SXERR_ABORT;
			}
			if (c == 0) {
				return errorflag > 0 ? SXERR_FORMAT : SXRET_OK;
			}
		}
		if ((c = (*++zFormat)) == 0) {
			errorflag = 1;
			rc = xConsumer("%",sizeof("%") - 1,pUserData);
			if (rc != SXRET_OK) {
				return SXERR_ABORT;
			}
			return errorflag > 0 ? SXERR_FORMAT : SXRET_OK;
		}

		flag_leftjustify = flag_plussign = flag_blanksign =
			flag_alternateform = flag_zeropad = 0;
		do {
			switch (c) {
			case '-':   flag_leftjustify = 1;     c = 0;   break;
			case '+':   flag_plussign = 1;        c = 0;   break;
			case ' ':   flag_blanksign = 1;       c = 0;   break;
			case '#':   flag_alternateform = 1;   c = 0;   break;
			case '0':   flag_zeropad = 1;         c = 0;   break;
			default:                                       break;
			}
		} while (c == 0 && (c = (*++zFormat)) != 0);

		width = 0;
		if (c == '*') {
			width = va_arg(ap,int);
			if (width < 0) {
				flag_leftjustify = 1;
				width = -width;
			}
			c = *++zFormat;
		}
		else {
			while (c >= '0' && c <= '9') {
				width = width * 10 + c - '0';
				c = *++zFormat;
			}
		}
		if (width > SXFMT_BUFSIZ - 10) {
			width = SXFMT_BUFSIZ - 10;
		}

		precision = -1;
		if (c == '.') {
			precision = 0;
			c = *++zFormat;
			if (c == '*') {
				precision = va_arg(ap,int);
				if (precision < 0) precision = -precision;
				c = *++zFormat;
			}
			else {
				while (c >= '0' && c <= '9') {
					precision = precision * 10 + c - '0';
					c = *++zFormat;
				}
			}
		}

		flag_long = 0;
		if (c == 'l' || c == 'q' ) {
			flag_long = (c == 'q') ? 2 : 1;
			c = *++zFormat;
			if (c == 'l') {

				flag_long = 2;
			}
		}

		infop = 0;
		xtype = SXFMT_ERROR;
		for (idx = 0; idx < (int)SX_ARRAYSIZE(aFmt); idx++) {
			if (c == aFmt[idx].fmttype) {
				infop = &aFmt[idx];
				xtype = infop->type;
				break;
			}
		}
		zExtra = 0;


		switch (xtype) {
		case SXFMT_RADIX:
			if (flag_long > 0) {
				if (flag_long > 1) {

					longvalue = va_arg(ap,sxi64);
				}
				else {
					longvalue = va_arg(ap,sxlong);
				}
			}
			else {
				if (infop->flags & SXFLAG_SIGNED) {
					longvalue = va_arg(ap,sxi32);
				}
				else {
					longvalue = va_arg(ap,sxu32);
				}
			}

			if (precision > SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;
#if 1

			if (longvalue == 0) flag_alternateform = 0;
#else

			if (longvalue == 0 && infop->base == 8) flag_alternateform = 0;
#endif
			if (infop->flags & SXFLAG_SIGNED) {
				if (longvalue < 0) {
					longvalue = -longvalue;

					if (longvalue < 0) {

						longvalue = 0x7FFFFFFFFFFFFFFF;
					}
					prefix = '-';
				}
				else if (flag_plussign)  prefix = '+';
				else if (flag_blanksign)  prefix = ' ';
				else                       prefix = 0;
			}
			else {
				if (longvalue < 0) {
					longvalue = -longvalue;

					if (longvalue < 0) {

						longvalue = 0x7FFFFFFFFFFFFFFF;
					}
				}
				prefix = 0;
			}
			if (flag_zeropad && precision < width - (prefix != 0)) {
				precision = width - (prefix != 0);
			}
			bufpt = &buf[SXFMT_BUFSIZ - 1];
			{
				register char* cset;
				register int base;
				cset = infop->charset;
				base = infop->base;
				do {
					*(--bufpt) = cset[longvalue % base];
					longvalue = longvalue / base;
				} while (longvalue > 0);
			}
			length = &buf[SXFMT_BUFSIZ - 1] - bufpt;
			for (idx = precision - length; idx > 0; idx--) {
				*(--bufpt) = '0';
			}
			if (prefix) *(--bufpt) = prefix;
			if (flag_alternateform && infop->prefix) {
				char* pre,x;
				pre = infop->prefix;
				if (*bufpt != pre[0]) {
					for (pre = infop->prefix; (x = (*pre)) != 0; pre++) *(--bufpt) = x;
				}
			}
			length = &buf[SXFMT_BUFSIZ - 1] - bufpt;
			break;
		case SXFMT_FLOAT:
		case SXFMT_EXP:
		case SXFMT_GENERIC:
#ifndef SX_OMIT_FLOATINGPOINT
			realvalue = va_arg(ap,double);
			if (precision < 0) precision = 6;
			if (precision > SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;
			if (realvalue < 0.0) {
				realvalue = -realvalue;
				prefix = '-';
			}
			else {
				if (flag_plussign)          prefix = '+';
				else if (flag_blanksign)    prefix = ' ';
				else                         prefix = 0;
			}
			if (infop->type == SXFMT_GENERIC && precision > 0) precision--;
			rounder = 0.0;
#if 0

			for (idx = precision,rounder = 0.4999; idx > 0; idx--,rounder *= 0.1);
#else

			for (idx = precision,rounder = 0.5; idx > 0; idx--,rounder *= 0.1);
#endif
			if (infop->type == SXFMT_FLOAT) realvalue += rounder;

			exp = 0;
			if (realvalue > 0.0) {
				while (realvalue >= 1e8 && exp <= 350) { realvalue *= 1e-8; exp += 8; }
				while (realvalue >= 10.0 && exp <= 350) { realvalue *= 0.1; exp++; }
				while (realvalue < 1e-8 && exp >= -350) { realvalue *= 1e8; exp -= 8; }
				while (realvalue < 1.0 && exp >= -350) { realvalue *= 10.0; exp--; }
				if (exp > 350 || exp < -350) {
					bufpt = "NaN";
					length = 3;
					break;
				}
			}
			bufpt = buf;

			flag_exp = xtype == SXFMT_EXP;
			if (xtype != SXFMT_FLOAT) {
				realvalue += rounder;
				if (realvalue >= 10.0) { realvalue *= 0.1; exp++; }
			}
			if (xtype == SXFMT_GENERIC) {
				flag_rtz = !flag_alternateform;
				if (exp<-4 || exp>precision) {
					xtype = SXFMT_EXP;
				}
				else {
					precision = precision - exp;
					xtype = SXFMT_FLOAT;
				}
			}
			else {
				flag_rtz = 0;
			}

			nsd = 0;
			if (xtype == SXFMT_FLOAT && exp + precision < SXFMT_BUFSIZ - 30) {
				flag_dp = (precision > 0 || flag_alternateform);
				if (prefix) *(bufpt++) = prefix;
				if (exp < 0)  *(bufpt++) = '0';
				else for (; exp >= 0; exp--) *(bufpt++) = (char)getdigit(&realvalue,&nsd);
				if (flag_dp) *(bufpt++) = '.';
				for (exp++; exp < 0 && precision>0; precision--,exp++) {
					*(bufpt++) = '0';
				}
				while ((precision--) > 0) *(bufpt++) = (char)getdigit(&realvalue,&nsd);
				*(bufpt--) = 0;
				if (flag_rtz && flag_dp) {
					while (bufpt >= buf && *bufpt == '0') *(bufpt--) = 0;
					if (bufpt >= buf && *bufpt == '.') *(bufpt--) = 0;
				}
				bufpt++;
			}
			else {
				flag_dp = (precision > 0 || flag_alternateform);
				if (prefix) *(bufpt++) = prefix;
				*(bufpt++) = (char)getdigit(&realvalue,&nsd);
				if (flag_dp) *(bufpt++) = '.';
				while ((precision--) > 0) *(bufpt++) = (char)getdigit(&realvalue,&nsd);
				bufpt--;
				if (flag_rtz && flag_dp) {
					while (bufpt >= buf && *bufpt == '0') *(bufpt--) = 0;
					if (bufpt >= buf && *bufpt == '.') *(bufpt--) = 0;
				}
				bufpt++;
				if (exp || flag_exp) {
					*(bufpt++) = infop->charset[0];
					if (exp < 0) { *(bufpt++) = '-'; exp = -exp; }
					else { *(bufpt++) = '+'; }
					if (exp >= 100) {
						*(bufpt++) = (char)((exp / 100) + '0');
						exp %= 100;
					}
					*(bufpt++) = (char)(exp / 10 + '0');
					*(bufpt++) = (char)(exp % 10 + '0');
				}
			}

			length = bufpt - buf;
			bufpt = buf;


			if (flag_zeropad && !flag_leftjustify && length < width) {
				int i; int nPad = width - length;
				for (i = width; i >= nPad; i--) {
					bufpt[i] = bufpt[i - nPad];
				}
				i = prefix != 0;
				while (nPad--) bufpt[i++] = '0';
				length = width;
			}
#else
			bufpt = " ";
			length = (int)sizeof(" ") - 1;
#endif
			break;
		case SXFMT_SIZE: {
			int* pSize = va_arg(ap,int*);
			*pSize = ((SyFmtConsumer*)pUserData)->nLen;
			length = width = 0;
		}
					   break;
		case SXFMT_PERCENT:
			buf[0] = '%';
			bufpt = buf;
			length = 1;
			break;
		case SXFMT_CHARX:
			c = va_arg(ap,int);
			buf[0] = (char)c;

			if (precision > SXFMT_BUFSIZ - 40) precision = SXFMT_BUFSIZ - 40;
			if (precision >= 0) {
				for (idx = 1; idx < precision; idx++) buf[idx] = (char)c;
				length = precision;
			}
			else {
				length = 1;
			}
			bufpt = buf;
			break;
		case SXFMT_STRING:
			bufpt = va_arg(ap,char*);
			if (bufpt == 0) {
				bufpt = " ";
				length = (int)sizeof(" ") - 1;
				break;
			}
			length = precision;
			if (precision < 0) {

				length = (int)SyStrlen(bufpt);
			}
			if (precision >= 0 && precision < length) length = precision;
			break;
		case SXFMT_RAWSTR: {

			SyString* pStr = va_arg(ap,SyString*);
			if (pStr == 0 || pStr->zString == 0) {
				bufpt = " ";
				length = (int)sizeof(char);
				break;
			}
			bufpt = (char*)pStr->zString;
			length = (int)pStr->nByte;
			break;
		}
		case SXFMT_ERROR:
			buf[0] = '?';
			bufpt = buf;
			length = (int)sizeof(char);
			if (c == 0) zFormat--;
			break;
		}

		if (!flag_leftjustify) {
			register int nspace;
			nspace = width - length;
			if (nspace > 0) {
				while (nspace >= etSPACESIZE) {
					rc = xConsumer(spaces,etSPACESIZE,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
					nspace -= etSPACESIZE;
				}
				if (nspace > 0) {
					rc = xConsumer(spaces,(unsigned int)nspace,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
				}
			}
		}
		if (length > 0) {
			rc = xConsumer(bufpt,(unsigned int)length,pUserData);
			if (rc != SXRET_OK) {
				return SXERR_ABORT;
			}
		}
		if (flag_leftjustify) {
			register int nspace;
			nspace = width - length;
			if (nspace > 0) {
				while (nspace >= etSPACESIZE) {
					rc = xConsumer(spaces,etSPACESIZE,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
					nspace -= etSPACESIZE;
				}
				if (nspace > 0) {
					rc = xConsumer(spaces,(unsigned int)nspace,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
				}
			}
		}
	}
	return errorflag ? SXERR_FORMAT : SXRET_OK;
}
static sxi32 FormatConsumer(const void* pSrc,unsigned int nLen,void* pData)
{
	SyFmtConsumer* pConsumer = (SyFmtConsumer*)pData;
	sxi32 rc = SXERR_ABORT;
	switch (pConsumer->nType) {
	case SXFMT_CONS_PROC:

		rc = pConsumer->uConsumer.sFunc.xUserConsumer(pSrc,nLen,pConsumer->uConsumer.sFunc.pUserData);
		break;
	case SXFMT_CONS_BLOB:

		rc = SyBlobAppend(pConsumer->uConsumer.pBlob,pSrc,(sxu32)nLen);
		break;
	default:

		break;
	}

	pConsumer->nLen += nLen;
	pConsumer->rc = rc;
	return rc;
}
static sxi32 FormatMount(sxi32 nType,void* pConsumer,ProcConsumer xUserCons,void* pUserData,sxu32* pOutLen,const char* zFormat,va_list ap)
{
	SyFmtConsumer sCons;
	sCons.nType = nType;
	sCons.rc = SXRET_OK;
	sCons.nLen = 0;
	if (pOutLen) {
		*pOutLen = 0;
	}
	switch (nType) {
	case SXFMT_CONS_PROC:
#if defined(UNTRUST)
		if (xUserCons == 0) {
			return SXERR_EMPTY;
		}
#endif
		sCons.uConsumer.sFunc.xUserConsumer = xUserCons;
		sCons.uConsumer.sFunc.pUserData = pUserData;
		break;
	case SXFMT_CONS_BLOB:
		sCons.uConsumer.pBlob = (SyBlob*)pConsumer;
		break;
	default:
		return SXERR_UNKNOWN;
	}
	InternFormat(FormatConsumer,&sCons,zFormat,ap);
	if (pOutLen) {
		*pOutLen = sCons.nLen;
	}
	return sCons.rc;
}
PHP_PRIVATE sxi32 SyProcFormat(ProcConsumer xConsumer,void* pData,const char* zFormat,...)
{
	va_list ap;
	sxi32 rc;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zFormat)) {
		return SXERR_EMPTY;
	}
#endif
	va_start(ap,zFormat);
	rc = FormatMount(SXFMT_CONS_PROC,0,xConsumer,pData,0,zFormat,ap);
	va_end(ap);
	return rc;
}
PHP_PRIVATE sxu32 SyBlobFormat(SyBlob* pBlob,const char* zFormat,...)
{
	va_list ap;
	sxu32 n;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zFormat)) {
		return 0;
	}
#endif
	va_start(ap,zFormat);
	FormatMount(SXFMT_CONS_BLOB,&(*pBlob),0,0,&n,zFormat,ap);
	va_end(ap);
	return n;
}
PHP_PRIVATE sxu32 SyBlobFormatAp(SyBlob* pBlob,const char* zFormat,va_list ap)
{
	sxu32 n = 0;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zFormat)) {
		return 0;
	}
#endif
	FormatMount(SXFMT_CONS_BLOB,&(*pBlob),0,0,&n,zFormat,ap);
	return n;
}
PHP_PRIVATE sxu32 SyBufferFormat(char* zBuf,sxu32 nLen,const char* zFormat,...)
{
	SyBlob sBlob;
	va_list ap;
	sxu32 n;
#if defined(UNTRUST)
	if (SX_EMPTY_STR(zFormat)) {
		return 0;
	}
#endif
	if (SXRET_OK != SyBlobInitFromBuf(&sBlob,zBuf,nLen - 1)) {
		return 0;
	}
	va_start(ap,zFormat);
	FormatMount(SXFMT_CONS_BLOB,&sBlob,0,0,0,zFormat,ap);
	va_end(ap);
	n = SyBlobLength(&sBlob);

	sBlob.mByte++;
	SyBlobAppend(&sBlob,"\0",sizeof(char));
	return n;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC


typedef struct SyXMLRawStrNS SyXMLRawStrNS;
struct SyXMLRawStrNS
{

	const char* zString;
	sxu32 nByte;
	sxu32 nLine;

	SySet sNSset;
};

#define SXML_TOK_INVALID	0xFFFF
#define SXML_TOK_COMMENT	0x01
#define SXML_TOK_PI	        0x02
#define SXML_TOK_DOCTYPE	0x04
#define SXML_TOK_RAW		0x08
#define SXML_TOK_START_TAG	0x10
#define SXML_TOK_CDATA		0x20
#define SXML_TOK_END_TAG	0x40
#define SXML_TOK_START_END	0x80
#define SXML_TOK_SPACE		0x100
#define IS_XML_DIRTY(c) \
			( c == '<' || c == '$'|| c == '"' || c == '\''|| c == '&'|| c == '(' || c == ')' || c == '*' ||\
			c == '%'  || c == '#' || c == '|' || c == '/'|| c == '~' || c == '{' || c == '}' ||\
			c == '['  || c == ']' || c == '\\'|| c == ';'||c == '^'  || c == '`' )

static sxi32 XML_Tokenize(SyStream* pStream,SyToken* pToken,void* pUserData,void* pUnused2)
{
	SyXMLParser* pParse = (SyXMLParser*)pUserData;
	SyString* pStr;
	sxi32 rc; int c;

	while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisSpace(pStream->zText[0])) {

		if (pStream->zText[0] == '\n') {

			pStream->nLine++;
		}
		pStream->zText++;
	}
	if (pStream->zText >= pStream->zEnd) {
		SXUNUSED(pUnused2);

		return SXERR_EOF;
	}

	pToken->nLine = pStream->nLine;
	pToken->pUserData = 0;
	pStr = &pToken->sData;
	SyStringInitFromBuf(pStr,pStream->zText,0);

	c = pStream->zText[0];
	if (c == '<') {
		pStream->zText++;
		pStr->zString++;
		if (pStream->zText >= pStream->zEnd) {
			if (pParse->xError) {
				rc = pParse->xError("Illegal syntax,expecting valid start name character",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}

			return SXERR_EOF;
		}
		c = pStream->zText[0];
		if (c == '?') {

			pStream->zText++;
			pStr->zString++;
			pToken->nType = SXML_TOK_PI;
			while (XLEX_IN_LEN(pStream) >= sizeof("?>") - 1 &&
				SyMemcmp((const void*)pStream->zText,"?>",sizeof("?>") - 1) != 0) {
				if (pStream->zText[0] == '\n') {

					pStream->nLine++;
				}
				pStream->zText++;
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			if (XLEX_IN_LEN(pStream) < sizeof("?>") - 1) {
				if (pParse->xError) {
					rc = pParse->xError("End of input found,but processing instruction was not found",SXML_ERROR_UNCLOSED_TOKEN,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				return SXERR_EOF;
			}
			pStream->zText += sizeof("?>") - 1;
		}
		else if (c == '!') {
			pStream->zText++;
			if (XLEX_IN_LEN(pStream) >= sizeof("--") - 1 && pStream->zText[0] == '-' && pStream->zText[1] == '-') {

				pStream->zText += sizeof("--") - 1;
				while (XLEX_IN_LEN(pStream) >= sizeof("-->") - 1 &&
					SyMemcmp((const void*)pStream->zText,"-->",sizeof("-->") - 1) != 0) {
					if (pStream->zText[0] == '\n') {

						pStream->nLine++;
					}
					pStream->zText++;
				}
				pStream->zText += sizeof("-->") - 1;

				return SXERR_CONTINUE;
			}
			if (XLEX_IN_LEN(pStream) >= sizeof("[CDATA[") - 1 && SyMemcmp((const void*)pStream->zText,"[CDATA[",sizeof("[CDATA[") - 1) == 0) {

				pStream->zText += sizeof("[CDATA[") - 1;
				pStr->zString = (const char*)pStream->zText;
				while (XLEX_IN_LEN(pStream) >= sizeof("]]>") - 1 &&
					SyMemcmp((const void*)pStream->zText,"]]>",sizeof("]]>") - 1) != 0) {
					if (pStream->zText[0] == '\n') {

						pStream->nLine++;
					}
					pStream->zText++;
				}

				pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
				pToken->nType = SXML_TOK_CDATA;
				if (XLEX_IN_LEN(pStream) < sizeof("]]>") - 1) {
					if (pParse->xError) {
						rc = pParse->xError("End of input found,but ]]> was not found",SXML_ERROR_UNCLOSED_TOKEN,pToken,pParse->pUserData);
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
					}
					return SXERR_EOF;
				}
				pStream->zText += sizeof("]]>") - 1;
				return SXRET_OK;
			}
			if (XLEX_IN_LEN(pStream) >= sizeof("DOCTYPE") - 1 && SyMemcmp((const void*)pStream->zText,"DOCTYPE",sizeof("DOCTYPE") - 1) == 0) {
				SyString sDelim = { ">" ,sizeof(char) }; int c = 0;

				pStream->zText += sizeof("DOCTYPE") - 1;
				pStr->zString = (const char*)pStream->zText;

				while (pStream->zText < pStream->zEnd && pStream->zText[0] != '\n') {
					if (pStream->zText[0] >= 0xc0 || !SyisSpace(pStream->zText[0])) {
						c = pStream->zText[0];
						if (c == '>') {
							break;
						}
					}
					pStream->zText++;
				}
				if (c == '[') {

					SyStringInitFromBuf(&sDelim,"]>",sizeof("]>") - 1);
				}
				if (c != '>') {
					while (XLEX_IN_LEN(pStream) >= sDelim.nByte &&
						SyMemcmp((const void*)pStream->zText,sDelim.zString,sDelim.nByte) != 0) {
						if (pStream->zText[0] == '\n') {

							pStream->nLine++;
						}
						pStream->zText++;
					}
				}

				pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
				pToken->nType = SXML_TOK_DOCTYPE;
				if (XLEX_IN_LEN(pStream) < sDelim.nByte) {
					if (pParse->xError) {
						rc = pParse->xError("End of input found,but ]> or > was not found",SXML_ERROR_UNCLOSED_TOKEN,pToken,pParse->pUserData);
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
					}
					return SXERR_EOF;
				}
				pStream->zText += sDelim.nByte;
				return SXRET_OK;
			}
		}
		else {
			int c;
			c = pStream->zText[0];
			rc = SXRET_OK;
			pToken->nType = SXML_TOK_START_TAG;
			if (c == '/') {

				pToken->nType = SXML_TOK_END_TAG;
				pStream->zText++;
				pStr->zString++;
				if (pStream->zText >= pStream->zEnd) {
					if (pParse->xError) {
						rc = pParse->xError("Illegal syntax,expecting valid start name character",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
					}
					return SXERR_EOF;
				}
				c = pStream->zText[0];
			}
			if (c == '>') {

				if (pParse->xError) {
					rc = pParse->xError("Illegal syntax,expecting valid start name character",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}

				return SXERR_CONTINUE;
			}
			if (c < 0xc0 && (SyisSpace(c) || SyisDigit(c) || c == '.' || c == '-' || IS_XML_DIRTY(c))) {
				if (pParse->xError) {
					rc = pParse->xError("Illegal syntax,expecting valid start name character",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				rc = SXERR_INVALID;
			}
			pStream->zText++;

			while (pStream->zText < pStream->zEnd && pStream->zText[0] != '>') {
				c = pStream->zText[0];
				if (c >= 0xc0) {

					pStream->zText++;
					SX_JMP_UTF8(pStream->zText,pStream->zEnd);
				}
				else {
					if (c == '/' && &pStream->zText[1] < pStream->zEnd && pStream->zText[1] == '>') {
						pStream->zText++;
						if (pToken->nType != SXML_TOK_START_TAG) {
							if (pParse->xError) {
								rc = pParse->xError("Unexpected closing tag,expecting '>'",
									SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
								if (rc == SXERR_ABORT) {
									return SXERR_ABORT;
								}
							}

							rc = SXERR_INVALID;
						}
						else {
							pToken->nType = SXML_TOK_START_END;
						}
						break;
					}
					if (pStream->zText[0] == '\n') {

						pStream->nLine++;
					}

					pStream->zText++;
				}
			}
			if (rc != SXRET_OK) {

				return SXERR_CONTINUE;
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			if (pToken->nType == SXML_TOK_START_END && pStr->nByte > 0) {
				pStr->nByte -= sizeof(char);
			}
			if (pStream->zText < pStream->zEnd) {
				pStream->zText++;
			}
			else {
				if (pParse->xError) {
					rc = pParse->xError("End of input found,but closing tag '>' was not found",SXML_ERROR_UNCLOSED_TOKEN,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
			}
		}
	}
	else {

		while (pStream->zText < pStream->zEnd) {
			c = pStream->zText[0];
			if (c < 0xc0) {
				if (c == '<') {
					break;
				}
				else if (c == '\n') {

					pStream->nLine++;
				}

				pStream->zText++;
			}
			else {

				pStream->zText++;
				SX_JMP_UTF8(pStream->zText,pStream->zEnd);
			}
		}

		pToken->nType = SXML_TOK_RAW;
		pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
	}

	return SXRET_OK;
}
static int XMLCheckDuplicateAttr(SyXMLRawStr* aSet,sxu32 nEntry,SyXMLRawStr* pEntry)
{
	sxu32 n;
	for (n = 0; n < nEntry; n += 2) {
		SyXMLRawStr* pAttr = &aSet[n];
		if (pAttr->nByte == pEntry->nByte && SyMemcmp(pAttr->zString,pEntry->zString,pEntry->nByte) == 0) {

			return 1;
		}
	}

	return 0;
}
static sxi32 XMLProcessNamesSpace(SyXMLParser* pParse,SyXMLRawStrNS* pTag,SyToken* pToken,SySet* pAttr)
{
	SyXMLRawStr* pPrefix,* pUri;
	SyHashEntry* pEntry;
	SyXMLRawStr* pDup;
	sxi32 rc;

	pUri = (SyXMLRawStr*)SySetPeek(pAttr);

	pPrefix = (SyXMLRawStr*)SySetAt(pAttr,SySetUsed(pAttr) - 2);

	if (pPrefix->nByte == sizeof("xmlns") - 1) {

		pPrefix->nByte = 0;
		pPrefix->zString = "";
	}
	else {
		pPrefix->nByte -= sizeof("xmlns") - 1;
		pPrefix->zString += sizeof("xmlns") - 1;
		if (pPrefix->zString[0] != ':') {
			return SXRET_OK;
		}
		pPrefix->nByte--;
		pPrefix->zString++;
		if (pPrefix->nByte < 1) {
			if (pParse->xError) {
				rc = pParse->xError("Invalid namespace name",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}

			(void)SySetPop(pAttr);
			(void)SySetPop(pAttr);
			return SXERR_SYNTAX;
		}
	}

	if (pParse->xNameSpace) {
		rc = pParse->xNameSpace(pPrefix,pUri,pParse->pUserData);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}

	pDup = (SyXMLRawStr*)SyMemBackendAlloc(pParse->pAllocator,sizeof(SyXMLRawStr));
	if (pDup == 0) {
		if (pParse->xError) {
			pParse->xError("Out of memory",SXML_ERROR_NO_MEMORY,pToken,pParse->pUserData);
		}

		return SXERR_ABORT;
	}
	*pDup = *pUri;

	if (pPrefix->nByte == 0) {
		pPrefix->zString = "Default";
		pPrefix->nByte = sizeof("Default") - 1;
	}
	SyHashInsert(&pParse->hns,(const void*)pPrefix->zString,pPrefix->nByte,pDup);

	pEntry = SyHashLastEntry(&pParse->hns);

	SySetPut(&pTag->sNSset,(const void*)&pEntry);

	(void)SySetPop(pAttr);
	(void)SySetPop(pAttr);
	return SXRET_OK;
}
static sxi32 XMLProcessStartTag(SyXMLParser* pParse,SyToken* pToken,SyXMLRawStrNS* pTag,SySet* pAttrSet,SySet* pTagStack)
{
	SyString* pIn = &pToken->sData;
	const char* zIn,* zCur,* zEnd;
	SyXMLRawStr sEntry;
	sxi32 rc; int c;

	SySetReset(pAttrSet);

	zIn = pIn->zString;
	zEnd = &zIn[pIn->nByte];
	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}

	sEntry.nLine = pTag->nLine = pToken->nLine;
	zCur = zIn;
	while (zIn < zEnd) {
		if ((unsigned char)zIn[0] >= 0xc0) {

			zIn++;
			SX_JMP_UTF8(zIn,zEnd);
		}
		else if (SyisSpace(zIn[0])) {
			break;
		}
		else {
			if (IS_XML_DIRTY(zIn[0])) {
				if (pParse->xError) {
					rc = pParse->xError("Illegal character in XML name",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
			}
			zIn++;
		}
	}
	if (zCur >= zIn) {
		if (pParse->xError) {
			rc = pParse->xError("Invalid XML name",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		return SXERR_SYNTAX;
	}
	pTag->zString = zCur;
	pTag->nByte = (sxu32)(zIn - zCur);

	for (;;) {
		int is_ns = 0;
		while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd) {
			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '=') {
			if ((unsigned char)zIn[0] >= 0xc0) {

				zIn++;
				SX_JMP_UTF8(zIn,zEnd);
			}
			else if (SyisSpace(zIn[0])) {
				break;
			}
			else {
				zIn++;
			}
		}
		if (zCur >= zIn) {
			if (pParse->xError) {
				rc = pParse->xError("Missing attribute name",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			return SXERR_SYNTAX;
		}

		sEntry.zString = zCur;
		sEntry.nByte = (sxu32)(zIn - zCur);
		if ((pParse->nFlags & SXML_ENABLE_NAMESPACE) && sEntry.nByte >= sizeof("xmlns") - 1 &&
			SyMemcmp(sEntry.zString,"xmlns",sizeof("xmlns") - 1) == 0) {
			is_ns = 1;
		}
		while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd || zIn[0] != '=') {
			if (pParse->xError) {
				rc = pParse->xError("Missing attribute value",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			return SXERR_SYNTAX;
		}
		while (sEntry.nByte > 0 && (unsigned char)zCur[sEntry.nByte - 1] < 0xc0
			&& SyisSpace(zCur[sEntry.nByte - 1])) {
			sEntry.nByte--;
		}

		if (XMLCheckDuplicateAttr((SyXMLRawStr*)SySetBasePtr(pAttrSet),SySetUsed(pAttrSet),&sEntry)) {
			if (pParse->xError) {
				rc = pParse->xError("Duplicate attribute",SXML_ERROR_DUPLICATE_ATTRIBUTE,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			return SXERR_SYNTAX;
		}
		if (SXRET_OK != SySetPut(pAttrSet,(const void*)&sEntry)) {
			return SXERR_ABORT;
		}

		zIn++;
		while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd) {
			if (pParse->xError) {
				rc = pParse->xError("Missing attribute value",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			(void)SySetPop(pAttrSet);
			return SXERR_SYNTAX;
		}
		if (zIn[0] != '\'' && zIn[0] != '"') {
			if (pParse->xError) {
				rc = pParse->xError("Missing quotes on attribute value",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			(void)SySetPop(pAttrSet);
			return SXERR_SYNTAX;
		}
		c = zIn[0];
		zIn++;
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != c) {
			zIn++;
		}
		if (zIn >= zEnd) {
			if (pParse->xError) {
				rc = pParse->xError("Missing quotes on attribute value",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			(void)SySetPop(pAttrSet);
			return SXERR_SYNTAX;
		}

		sEntry.zString = zCur;
		sEntry.nByte = (sxu32)(zIn - zCur);
		if (SXRET_OK != SySetPut(pAttrSet,(const void*)&sEntry)) {
			return SXERR_ABORT;
		}
		zIn++;
		if (is_ns) {

			XMLProcessNamesSpace(pParse,pTag,pToken,pAttrSet);
		}
	}

	if (pToken->nType == SXML_TOK_START_TAG) {
		rc = SySetPut(pTagStack,(const void*)pTag);
	}
	return SXRET_OK;
}
static void XMLExtactPI(SyToken* pToken,SyXMLRawStr* pTarget,SyXMLRawStr* pData,int* pXML)
{
	SyString* pIn = &pToken->sData;
	const char* zIn,* zCur,* zEnd;

	pTarget->nLine = pData->nLine = pToken->nLine;

	pTarget->zString = pData->zString = 0;

	SyStringFullTrim(pIn);

	zIn = pIn->zString;
	zEnd = &zIn[pIn->nByte];
	if (pXML) {
		*pXML = 0;
	}

	zCur = zIn;
	while (zIn < zEnd) {
		if ((unsigned char)zIn[0] >= 0xc0) {

			zIn++;
			SX_JMP_UTF8(zIn,zEnd);
		}
		else if (SyisSpace(zIn[0])) {
			break;
		}
		else {
			zIn++;
		}
	}
	if (zIn > zCur) {
		pTarget->zString = zCur;
		pTarget->nByte = (sxu32)(zIn - zCur);
		if (pXML && pTarget->nByte == sizeof("xml") - 1 && SyStrnicmp(pTarget->zString,"xml",sizeof("xml") - 1) == 0) {
			*pXML = 1;
		}
	}

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}
	if (zIn < zEnd) {
		pData->zString = zIn;
		pData->nByte = (sxu32)(zEnd - zIn);
	}
}
static sxi32 XMLExtractEndTag(SyXMLParser* pParse,SyToken* pToken,SyXMLRawStrNS* pOut)
{
	SyString* pIn = &pToken->sData;
	const char* zEnd = &pIn->zString[pIn->nByte];
	const char* zIn = pIn->zString;

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}
	pOut->nLine = pToken->nLine;
	pOut->zString = zIn;
	pOut->nByte = (sxu32)(zEnd - zIn);

	while (pOut->nByte > 0 && (unsigned char)pOut->zString[pOut->nByte - 1] < 0xc0
		&& SyisSpace(pOut->zString[pOut->nByte - 1])) {
		pOut->nByte--;
	}
	if (pOut->nByte < 1) {
		if (pParse->xError) {
			sxi32 rc;
			rc = pParse->xError("Invalid end tag name",SXML_ERROR_INVALID_TOKEN,pToken,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		return SXERR_SYNTAX;
	}
	return SXRET_OK;
}
static void TokenToXMLString(SyToken* pTok,SyXMLRawStrNS* pOut)
{

	SyStringFullTrim(&pTok->sData);
	pOut->zString = SyStringData(&pTok->sData);
	pOut->nByte = SyStringLength(&pTok->sData);
}
static sxi32 XMLExtractNS(SyXMLParser* pParse,SyToken* pToken,SyXMLRawStrNS* pTag,SyXMLRawStr* pnsUri)
{
	SyXMLRawStr* pUri,sPrefix;
	SyHashEntry* pEntry;
	sxu32 nOfft;
	sxi32 rc;

	rc = SyByteFind(pTag->zString,pTag->nByte,':',&nOfft);
	if (rc != SXRET_OK) {

		pEntry = SyHashGet(&pParse->hns,"Default",sizeof("Default") - 1);
		if (pEntry) {

			pUri = (SyXMLRawStr*)pEntry->pUserData;

			pnsUri->zString = pUri->zString;
			pnsUri->nByte = pUri->nByte;
		}
		return SXRET_OK;
	}
	if (nOfft < 1) {
		if (pParse->xError) {
			rc = pParse->xError("Empty prefix is not allowed according to XML namespace specification",
				SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		return SXERR_SYNTAX;
	}
	sPrefix.zString = pTag->zString;
	sPrefix.nByte = nOfft;
	sPrefix.nLine = pTag->nLine;
	pTag->zString += nOfft + 1;
	pTag->nByte -= nOfft;
	if (pTag->nByte < 1) {
		if (pParse->xError) {
			rc = pParse->xError("Missing tag name",SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		return SXERR_SYNTAX;
	}

	pEntry = SyHashGet(&pParse->hns,sPrefix.zString,sPrefix.nByte);
	if (pEntry == 0) {
		if (pParse->xError) {
			rc = pParse->xError("Namespace prefix is not defined",SXML_ERROR_SYNTAX,
				pToken,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		return SXERR_SYNTAX;
	}

	pUri = (SyXMLRawStr*)pEntry->pUserData;

	pnsUri->zString = pUri->zString;
	pnsUri->nByte = pUri->nByte;

	return SXRET_OK;
}
static sxi32 XMLnsUnlink(SyXMLParser* pParse,SyXMLRawStrNS* pLast,SyToken* pToken)
{
	SyHashEntry** apEntry,* pEntry;
	void* pUserData;
	sxu32 n;

	apEntry = (SyHashEntry**)SySetBasePtr(&pLast->sNSset);
	for (n = 0; n < SySetUsed(&pLast->sNSset); ++n) {
		pEntry = apEntry[n];

		if (pParse->xNameSpaceEnd && (pParse->nFlags & SXML_ENABLE_NAMESPACE) && pToken) {
			SyXMLRawStr sPrefix;
			sxi32 rc;
			sPrefix.zString = (const char*)pEntry->pKey;
			sPrefix.nByte = pEntry->nKeyLen;
			sPrefix.nLine = pToken->nLine;
			rc = pParse->xNameSpaceEnd(&sPrefix,pParse->pUserData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		pUserData = pEntry->pUserData;

		SyHashDeleteEntry2(pEntry);
		SyMemBackendFree(pParse->pAllocator,pUserData);
	}
	SySetRelease(&pLast->sNSset);
	return SXRET_OK;
}

static sxi32  ProcessXML(SyXMLParser* pParse,SySet* pTagStack,SySet* pWorker)
{
	SySet* pTokenSet = &pParse->sToken;
	SyXMLRawStrNS sEntry;
	SyXMLRawStr sNs;
	SyToken* pToken; int bGotTag;
	sxi32 rc;

	bGotTag = 0;

	if (pParse->xStartDoc && (SXERR_ABORT == pParse->xStartDoc(pParse->pUserData))) {

		return SXERR_ABORT;
	}

	SySetResetCursor(pTokenSet);

	while (SXRET_OK == (SySetGetNextEntry(&(*pTokenSet),(void**)&pToken))) {
		SyZero(&sEntry,sizeof(SyXMLRawStrNS));
		SyZero(&sNs,sizeof(SyXMLRawStr));
		SySetInit(&sEntry.sNSset,pParse->pAllocator,sizeof(SyHashEntry*));
		sEntry.nLine = sNs.nLine = pToken->nLine;
		switch (pToken->nType) {
		case SXML_TOK_DOCTYPE:
			if (SySetUsed(pTagStack) > 1 || bGotTag) {
				if (pParse->xError) {
					rc = pParse->xError("DOCTYPE must be declared first",SXML_ERROR_MISPLACED_XML_PI,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				break;
			}

			if (pParse->xDoctype) {
				TokenToXMLString(pToken,&sEntry);
				rc = pParse->xDoctype((SyXMLRawStr*)&sEntry,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			break;
		case SXML_TOK_CDATA:
			if (SySetUsed(pTagStack) < 1) {
				if (pParse->xError) {
					rc = pParse->xError("CDATA without matching tag",SXML_ERROR_TAG_MISMATCH,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
			}

			if (pParse->xRaw) {
				TokenToXMLString(pToken,&sEntry);
				rc = pParse->xRaw((SyXMLRawStr*)&sEntry,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			break;
		case SXML_TOK_PI: {
			SyXMLRawStr sTarget,sData; int isXML = 0;

			XMLExtactPI(pToken,&sTarget,&sData,&isXML);
			if (isXML && SySetCursor(pTokenSet) - 1 > 0) {
				if (pParse->xError) {
					rc = pParse->xError("Unexpected XML declaration. The XML declaration must be the first node in the document",
						SXML_ERROR_MISPLACED_XML_PI,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
			}
			else if (pParse->xPi) {

				rc = pParse->xPi(&sTarget,&sData,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			break;
		}
		case SXML_TOK_RAW:
			if (SySetUsed(pTagStack) < 1) {
				if (pParse->xError) {
					rc = pParse->xError("Text (Raw data) without matching tag",SXML_ERROR_TAG_MISMATCH,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				break;
			}

			if (pParse->xRaw) {
				TokenToXMLString(pToken,&sEntry);
				rc = pParse->xRaw((SyXMLRawStr*)&sEntry,pParse->pUserData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			break;
		case SXML_TOK_END_TAG: {
			SyXMLRawStrNS* pLast = 0;
			if (SySetUsed(pTagStack) < 1) {
				if (pParse->xError) {
					rc = pParse->xError("Unexpected closing tag",SXML_ERROR_TAG_MISMATCH,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				break;
			}
			rc = XMLExtractEndTag(pParse,pToken,&sEntry);
			if (rc == SXRET_OK) {

				pLast = (SyXMLRawStrNS*)SySetPeek(pTagStack);
				if (pLast == 0 || pLast->nByte != sEntry.nByte ||
					SyMemcmp(pLast->zString,sEntry.zString,sEntry.nByte) != 0) {
					if (pParse->xError) {
						rc = pParse->xError("Unexpected closing tag",SXML_ERROR_TAG_MISMATCH,pToken,pParse->pUserData);
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
					}
				}
				else {

					if (pParse->xEndTag) {
						rc = SXRET_OK;
						if (pParse->nFlags & SXML_ENABLE_NAMESPACE) {

							rc = XMLExtractNS(pParse,pToken,&sEntry,&sNs);
							if (rc == SXERR_ABORT) {
								return SXERR_ABORT;
							}
						}
						if (rc == SXRET_OK) {
							rc = pParse->xEndTag((SyXMLRawStr*)&sEntry,&sNs,pParse->pUserData);
							if (rc == SXERR_ABORT) {
								return SXERR_ABORT;
							}
						}
					}
				}
			}
			else if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			if (pLast) {
				rc = XMLnsUnlink(pParse,pLast,pToken);
				(void)SySetPop(pTagStack);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			break;
		}
		case SXML_TOK_START_TAG:
		case SXML_TOK_START_END:
			if (SySetUsed(pTagStack) < 1 && bGotTag) {
				if (pParse->xError) {
					rc = pParse->xError("XML document cannot contain multiple root level elements documents",
						SXML_ERROR_SYNTAX,pToken,pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				break;
			}
			bGotTag = 1;

			rc = XMLProcessStartTag(pParse,pToken,&sEntry,pWorker,pTagStack);
			if (rc == SXRET_OK) {
				if (pParse->nFlags & SXML_ENABLE_NAMESPACE) {

					rc = XMLExtractNS(pParse,pToken,&sEntry,&sNs);
				}
			}
			if (rc == SXRET_OK) {

				if (pParse->xStartTag) {
					rc = pParse->xStartTag((SyXMLRawStr*)&sEntry,&sNs,SySetUsed(pWorker),
						(SyXMLRawStr*)SySetBasePtr(pWorker),pParse->pUserData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
				if (pToken->nType == SXML_TOK_START_END) {
					if (pParse->xEndTag) {
						rc = pParse->xEndTag((SyXMLRawStr*)&sEntry,&sNs,pParse->pUserData);
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
					}
					rc = XMLnsUnlink(pParse,&sEntry,pToken);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
				}
			}
			else if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			break;
		default:

			break;
		}
	}
	if (SySetUsed(pTagStack) > 0 && pParse->xError) {
		pParse->xError("Missing closing tag",SXML_ERROR_SYNTAX,
			(SyToken*)SySetPeek(&pParse->sToken),pParse->pUserData);
	}
	if (pParse->xEndDoc) {
		pParse->xEndDoc(pParse->pUserData);
	}
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyXMLParserInit(SyXMLParser* pParser,SyMemBackend* pAllocator,sxi32 iFlags)
{

	SyZero(pParser,sizeof(SyXMLParser));

	SySetInit(&pParser->sToken,pAllocator,sizeof(SyToken));
	SyLexInit(&pParser->sLex,&pParser->sToken,XML_Tokenize,pParser);
	SyHashInit(&pParser->hns,pAllocator,0,0);
	pParser->pAllocator = pAllocator;
	pParser->nFlags = iFlags;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyXMLParserSetEventHandler(SyXMLParser* pParser,
	void* pUserData,
	ProcXMLStartTagHandler xStartTag,
	ProcXMLTextHandler xRaw,
	ProcXMLSyntaxErrorHandler xErr,
	ProcXMLStartDocument xStartDoc,
	ProcXMLEndTagHandler xEndTag,
	ProcXMLPIHandler   xPi,
	ProcXMLEndDocument xEndDoc,
	ProcXMLDoctypeHandler xDoctype,
	ProcXMLNameSpaceStart xNameSpace,
	ProcXMLNameSpaceEnd   xNameSpaceEnd
) {

	if (xErr) {
		pParser->xError = xErr;
	}
	if (xStartDoc) {
		pParser->xStartDoc = xStartDoc;
	}
	if (xStartTag) {
		pParser->xStartTag = xStartTag;
	}
	if (xRaw) {
		pParser->xRaw = xRaw;
	}
	if (xEndTag) {
		pParser->xEndTag = xEndTag;
	}
	if (xPi) {
		pParser->xPi = xPi;
	}
	if (xEndDoc) {
		pParser->xEndDoc = xEndDoc;
	}
	if (xDoctype) {
		pParser->xDoctype = xDoctype;
	}
	if (xNameSpace) {
		pParser->xNameSpace = xNameSpace;
	}
	if (xNameSpaceEnd) {
		pParser->xNameSpaceEnd = xNameSpaceEnd;
	}
	pParser->pUserData = pUserData;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 SyXMLProcess(SyXMLParser* pParser,const char* zInput,sxu32 nByte)
{
	SySet sTagStack;
	SySet sWorker;
	sxi32 rc;

	SySetInit(&sWorker,pParser->pAllocator,sizeof(SyXMLRawStr));
	SySetInit(&sTagStack,pParser->pAllocator,sizeof(SyXMLRawStrNS));

	rc = SyLexTokenizeInput(&pParser->sLex,zInput,nByte,0,0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}
	if (SySetUsed(&pParser->sToken) < 1) {

		rc = SXRET_OK;
	}
	else {

		rc = ProcessXML(&(*pParser),&sTagStack,&sWorker);
		if (pParser->nFlags & SXML_ENABLE_NAMESPACE) {
			if (SySetUsed(&sTagStack) > 0) {
				SyXMLRawStrNS* pEntry;
				SyHashEntry** apEntry;
				sxu32 n;
				SySetResetCursor(&sTagStack);
				while (SySetGetNextEntry(&sTagStack,(void**)&pEntry) == SXRET_OK) {

					apEntry = (SyHashEntry**)SySetBasePtr(&pEntry->sNSset);
					for (n = 0; n < SySetUsed(&pEntry->sNSset); ++n) {
						SyMemBackendFree(pParser->pAllocator,apEntry[n]->pUserData);
					}
					SySetRelease(&pEntry->sNSset);
				}
			}
		}
	}

	SySetRelease(&sWorker);
	SySetRelease(&sTagStack);

	return rc;
}
PHP_PRIVATE sxi32 SyXMLParserRelease(SyXMLParser* pParser)
{
	SyLexRelease(&pParser->sLex);
	SySetRelease(&pParser->sToken);
	SyHashRelease(&pParser->hns);
	return SXRET_OK;
}


#define SXMAKE_ZIP_WORKBUF	(SXU16_HIGH/2)
#define SXMAKE_ZIP_EXTRACT_VER	0x000a
#define SXMAKE_ZIP_VER	0x003

#define SXZIP_CENTRAL_MAGIC			0x02014b50
#define SXZIP_END_CENTRAL_MAGIC		0x06054b50
#define SXZIP_LOCAL_MAGIC			0x04034b50


#define SXZIP_LOCAL_HDRSZ		30
#define SXZIP_LOCAL_EXT_HDRZ	16
#define SXZIP_CENTRAL_HDRSZ		46
#define SXZIP_END_CENTRAL_HDRSZ	22

#define SXARCHIVE_HASH_SIZE	64
static sxi32 SyLittleEndianUnpack32(sxu32* uNB,const unsigned char* buf,sxu32 Len)
{
	if (Len < sizeof(sxu32)) {
		return SXERR_SHORT;
	}
	*uNB = buf[0] + (buf[1] << 8) + (buf[2] << 16) + (buf[3] << 24);
	return SXRET_OK;
}
static sxi32 SyLittleEndianUnpack16(sxu16* pOut,const unsigned char* zBuf,sxu32 nLen)
{
	if (nLen < sizeof(sxu16)) {
		return SXERR_SHORT;
	}
	*pOut = zBuf[0] + (zBuf[1] << 8);

	return SXRET_OK;
}
static sxi32 SyDosTimeFormat(sxu32 nDosDate,Sytm* pOut)
{
	sxu16 nDate;
	sxu16 nTime;
	nDate = nDosDate >> 16;
	nTime = nDosDate & 0xFFFF;
	pOut->tm_isdst = 0;
	pOut->tm_year = 1980 + (nDate >> 9);
	pOut->tm_mon = (nDate % (1 << 9)) >> 5;
	pOut->tm_mday = (nDate % (1 << 9)) & 0x1F;
	pOut->tm_hour = nTime >> 11;
	pOut->tm_min = (nTime % (1 << 11)) >> 5;
	pOut->tm_sec = ((nTime % (1 << 11)) & 0x1F) << 1;
	return SXRET_OK;
}

static sxi32 ArchiveHashGetEntry(SyArchive* pArch,const char* zName,sxu32 nLen,SyArchiveEntry** ppEntry)
{
	SyArchiveEntry* pBucketEntry;
	SyString sEntry;
	sxu32 nHash;

	nHash = pArch->xHash(zName,nLen);
	pBucketEntry = pArch->apHash[nHash & (pArch->nSize - 1)];

	SyStringInitFromBuf(&sEntry,zName,nLen);

	for (;;) {
		if (pBucketEntry == 0) {
			break;
		}
		if (nHash == pBucketEntry->nHash && pArch->xCmp(&sEntry,&pBucketEntry->sFileName) == 0) {
			if (ppEntry) {
				*ppEntry = pBucketEntry;
			}
			return SXRET_OK;
		}
		pBucketEntry = pBucketEntry->pNextHash;
	}
	return SXERR_NOTFOUND;
}
static void ArchiveHashBucketInstall(SyArchiveEntry** apTable,sxu32 nBucket,SyArchiveEntry* pEntry)
{
	pEntry->pNextHash = apTable[nBucket];
	if (apTable[nBucket] != 0) {
		apTable[nBucket]->pPrevHash = pEntry;
	}
	apTable[nBucket] = pEntry;
}
static sxi32 ArchiveHashGrowTable(SyArchive* pArch)
{
	sxu32 nNewSize = pArch->nSize * 2;
	SyArchiveEntry** apNew;
	SyArchiveEntry* pEntry;
	sxu32 n;


	apNew = (SyArchiveEntry**)SyMemBackendAlloc(pArch->pAllocator,nNewSize * sizeof(SyArchiveEntry*));
	if (apNew == 0) {
		return SXRET_OK;
	}
	SyZero(apNew,nNewSize * sizeof(SyArchiveEntry*));

	for (n = 0,pEntry = pArch->pList; n < pArch->nLoaded; n++,pEntry = pEntry->pNext) {
		pEntry->pNextHash = pEntry->pPrevHash = 0;
		ArchiveHashBucketInstall(apNew,pEntry->nHash & (nNewSize - 1),pEntry);
	}

	SyMemBackendFree(pArch->pAllocator,pArch->apHash);
	pArch->apHash = apNew;
	pArch->nSize = nNewSize;

	return SXRET_OK;
}
static sxi32 ArchiveHashInstallEntry(SyArchive* pArch,SyArchiveEntry* pEntry)
{
	if (pArch->nLoaded > pArch->nSize * 3) {
		ArchiveHashGrowTable(&(*pArch));
	}
	pEntry->nHash = pArch->xHash(SyStringData(&pEntry->sFileName),SyStringLength(&pEntry->sFileName));

	ArchiveHashBucketInstall(pArch->apHash,pEntry->nHash & (pArch->nSize - 1),pEntry);
	MACRO_LD_PUSH(pArch->pList,pEntry);
	pArch->nLoaded++;

	return SXRET_OK;
}

static sxi32 ParseEndOfCentralDirectory(SyArchive* pArch,const unsigned char* zBuf)
{
	sxu32 nMagic = 0;
	sxi32 rc;


	rc = SyLittleEndianUnpack32(&nMagic,zBuf,sizeof(sxu32));
	if ( nMagic != SXZIP_END_CENTRAL_MAGIC) {
		return SXERR_CORRUPT;
	}

	rc = SyLittleEndianUnpack16((sxu16*)&pArch->nEntry,&zBuf[8],sizeof(sxu16));
	if (  pArch->nEntry > SXI16_HIGH ) {
		return SXERR_CORRUPT;
	}

	rc = SyLittleEndianUnpack32(&pArch->nCentralSize,&zBuf[12],sizeof(sxu32));
	if (  pArch->nCentralSize > SXI32_HIGH) {
		return SXERR_CORRUPT;
	}

	rc = SyLittleEndianUnpack32(&pArch->nCentralOfft,&zBuf[16],sizeof(sxu32));
	if (  pArch->nCentralSize > SXI32_HIGH) {
		return SXERR_CORRUPT;
	}

	return SXRET_OK;
}

static sxi32 GetCentralDirectoryEntry(SyArchive* pArch,SyArchiveEntry* pEntry,const unsigned char* zCentral,sxu32* pNextOffset)
{
	SyString* pName = &pEntry->sFileName;
	sxu16 nDosDate,nDosTime;
	sxu16 nComment = 0;
	sxu32 nMagic = 0;
	sxi32 rc;
	nDosDate = nDosTime = 0;
	SXUNUSED(pArch);

	rc = SyLittleEndianUnpack32(&nMagic,zCentral,sizeof(sxu32));
	if (  nMagic != SXZIP_CENTRAL_MAGIC) {
		rc = SXERR_CORRUPT;



		goto update;
	}

	SyLittleEndianUnpack16((sxu16*)&pName->nByte,&zCentral[28],sizeof(sxu16));
	if (pName->nByte > SXI16_HIGH ) {
		rc = SXERR_BIG;
		goto update;
	}

	SyLittleEndianUnpack16(&pEntry->nExtra,&zCentral[30],sizeof(sxu16));

	SyLittleEndianUnpack16(&nComment,&zCentral[32],sizeof(sxu16));

	rc = SyLittleEndianUnpack16(&pEntry->nComprMeth,&zCentral[10],sizeof(sxu16));

	SyLittleEndianUnpack16(&nDosTime,&zCentral[12],sizeof(sxu16));
	SyLittleEndianUnpack16(&nDosDate,&zCentral[14],sizeof(sxu16));
	SyDosTimeFormat((nDosDate << 16 | nDosTime),&pEntry->sFmt);

	pEntry->sFmt.tm_mon--;

	rc = SyLittleEndianUnpack32(&pEntry->nCrc,&zCentral[16],sizeof(sxu32));

	rc = SyLittleEndianUnpack32(&pEntry->nByte,&zCentral[24],sizeof(sxu32));
	if (pEntry->nByte > SXI32_HIGH) {
		rc = SXERR_BIG;
		goto update;
	}

	rc = SyLittleEndianUnpack32(&pEntry->nByteCompr,&zCentral[20],sizeof(sxu32));
	if (pEntry->nByteCompr > SXI32_HIGH) {
		rc = SXERR_BIG;
		goto update;
	}

	SyLittleEndianUnpack32(&pEntry->nOfft,&zCentral[42],sizeof(sxu32));
	if (pEntry->nOfft > SXI32_HIGH) {
		rc = SXERR_BIG;
		goto update;
	}
	rc = SXRET_OK;
update:

	*pNextOffset = SXZIP_CENTRAL_HDRSZ + pName->nByte + pEntry->nExtra + nComment;
	return rc;
}
static sxi32 ZipFixOffset(SyArchiveEntry* pEntry,void* pSrc)
{
	sxu16 nExtra,nNameLen;
	unsigned char* zHdr;
	nExtra = nNameLen = 0;
	zHdr = (unsigned char*)pSrc;
	zHdr = &zHdr[pEntry->nOfft];
	if (SyMemcmp(zHdr,"PK\003\004",sizeof(sxu32)) != 0) {
		return SXERR_CORRUPT;
	}
	SyLittleEndianUnpack16(&nNameLen,&zHdr[26],sizeof(sxu16));
	SyLittleEndianUnpack16(&nExtra,&zHdr[28],sizeof(sxu16));

	pEntry->nOfft += SXZIP_LOCAL_HDRSZ + nExtra + nNameLen;
	return SXRET_OK;
}

static sxi32 ZipExtract(SyArchive* pArch,const unsigned char* zCentral,sxu32 nLen,void* pSrc)
{
	SyArchiveEntry* pEntry,* pDup;
	const unsigned char* zEnd;
	sxu32 nIncr,nOfft;
	SyString* pName;
	char* zName;
	sxi32 rc;

	nOfft = nIncr = 0;
	zEnd = &zCentral[nLen];

	for (;;) {
		if (&zCentral[nOfft] >= zEnd) {
			break;
		}

		pEntry = (SyArchiveEntry*)SyMemBackendPoolAlloc(pArch->pAllocator,sizeof(SyArchiveEntry));
		if (pEntry == 0) {
			break;
		}
		SyZero(pEntry,sizeof(SyArchiveEntry));
		pEntry->nMagic = SXARCH_MAGIC;
		nIncr = 0;
		rc = GetCentralDirectoryEntry(&(*pArch),pEntry,&zCentral[nOfft],&nIncr);
		if (rc == SXRET_OK) {

			rc = ZipFixOffset(pEntry,pSrc);
		}
		if (rc != SXRET_OK) {
			sxu32 nJmp = 0;
			SyMemBackendPoolFree(pArch->pAllocator,pEntry);

			if (SXRET_OK == SyBlobSearch((const void*)&zCentral[nOfft + nIncr],(sxu32)(zEnd - &zCentral[nOfft + nIncr]),
				(const void*)"PK\001\002",sizeof(sxu32),&nJmp)) {
				nOfft += nIncr + nJmp;
				continue;
			}
			break;
		}
		pName = &pEntry->sFileName;
		pName->zString = (const char*)&zCentral[nOfft + SXZIP_CENTRAL_HDRSZ];
		if (pName->nByte <= 0 || (pEntry->nByte <= 0 && pName->zString[pName->nByte - 1] != '/')) {

			SyMemBackendPoolFree(pArch->pAllocator,pEntry);
			nOfft += nIncr;
			continue;
		}
		zName = SyMemBackendStrDup(pArch->pAllocator,pName->zString,pName->nByte);
		if (zName == 0) {
			SyMemBackendPoolFree(pArch->pAllocator,pEntry);
			nOfft += nIncr;
			continue;
		}
		pName->zString = (const char*)zName;

		rc = ArchiveHashGetEntry(&(*pArch),pName->zString,pName->nByte,&pDup);
		if (rc == SXRET_OK) {

			pEntry->pNextName = pDup->pNextName;
			pDup->pNextName = pEntry;
			pDup->nDup++;
		}
		else {

			ArchiveHashInstallEntry(pArch,pEntry);
		}
		nOfft += nIncr;
	}
	pArch->pCursor = pArch->pList;

	return pArch->nLoaded > 0 ? SXRET_OK : SXERR_EMPTY;
}
PHP_PRIVATE sxi32 SyZipExtractFromBuf(SyArchive* pArch,const char* zBuf,sxu32 nLen)
{
	const unsigned char* zCentral,* zEnd;
	sxi32 rc;
#if defined(UNTRUST)
	if (SXARCH_INVALID(pArch) || zBuf == 0) {
		return SXERR_INVALID;
	}
#endif

	if (nLen < SXZIP_LOCAL_HDRSZ + SXZIP_CENTRAL_HDRSZ + SXZIP_END_CENTRAL_HDRSZ) {
		return SXERR_CORRUPT;
	}

	zEnd = (unsigned char*)&zBuf[nLen - SXZIP_END_CENTRAL_HDRSZ];

	while (((sxu32)((unsigned char*)&zBuf[nLen] - zEnd) < (SXZIP_END_CENTRAL_HDRSZ + SXI16_HIGH)) &&
		zEnd > (unsigned char*)zBuf && SyMemcmp(zEnd,"PK\005\006",sizeof(sxu32)) != 0) {
		zEnd--;
	}

	rc = ParseEndOfCentralDirectory(&(*pArch),zEnd);
	if (rc != SXRET_OK) {
		return rc;
	}


	zCentral = &zEnd[-(sxi32)pArch->nCentralSize];
	if (zCentral <= (unsigned char*)zBuf || SyMemcmp(zCentral,"PK\001\002",sizeof(sxu32)) != 0) {
		if (pArch->nCentralOfft >= nLen) {

			return SXERR_CORRUPT;
		}
		zCentral = (unsigned char*)&zBuf[pArch->nCentralOfft];
		if (SyMemcmp(zCentral,"PK\001\002",sizeof(sxu32)) != 0) {

			return SXERR_CORRUPT;
		}

	}
	rc = ZipExtract(&(*pArch),zCentral,(sxu32)(zEnd - zCentral),(void*)zBuf);
	return rc;
}

static sxi32 ArchiveHashCmp(const SyString* pStr1,const SyString* pStr2)
{
	sxi32 rc;
	rc = SyStringCmp(pStr1,pStr2,SyMemcmp);
	return rc;
}
PHP_PRIVATE sxi32 SyArchiveInit(SyArchive* pArch,SyMemBackend* pAllocator,ProcHash xHash,ProcRawStrCmp xCmp)
{
	SyArchiveEntry** apHash;
#if defined(UNTRUST)
	if (pArch == 0) {
		return SXERR_EMPTY;
	}
#endif
	SyZero(pArch,sizeof(SyArchive));

	apHash = (SyArchiveEntry**)SyMemBackendAlloc(&(*pAllocator),SXARCHIVE_HASH_SIZE * sizeof(SyArchiveEntry*));
	if (apHash == 0) {
		return SXERR_MEM;
	}
	SyZero(apHash,SXARCHIVE_HASH_SIZE * sizeof(SyArchiveEntry*));
	pArch->apHash = apHash;
	pArch->xHash = xHash ? xHash : SyBinHash;
	pArch->xCmp = xCmp ? xCmp : ArchiveHashCmp;
	pArch->nSize = SXARCHIVE_HASH_SIZE;
	pArch->pAllocator = &(*pAllocator);
	pArch->nMagic = SXARCH_MAGIC;
	return SXRET_OK;
}
static sxi32 ArchiveReleaseEntry(SyMemBackend* pAllocator,SyArchiveEntry* pEntry)
{
	SyArchiveEntry* pDup = pEntry->pNextName;
	SyArchiveEntry* pNextDup;


	for (;;) {
		if (pEntry->nDup == 0) {
			break;
		}
		pNextDup = pDup->pNextName;
		pDup->nMagic = 0x2661;
		SyMemBackendFree(pAllocator,(void*)SyStringData(&pDup->sFileName));
		SyMemBackendPoolFree(pAllocator,pDup);
		pDup = pNextDup;
		pEntry->nDup--;
	}
	pEntry->nMagic = 0x2661;
	SyMemBackendFree(pAllocator,(void*)SyStringData(&pEntry->sFileName));
	SyMemBackendPoolFree(pAllocator,pEntry);
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyArchiveRelease(SyArchive* pArch)
{
	SyArchiveEntry* pEntry,* pNext;
	pEntry = pArch->pList;
	for (;;) {
		if (pArch->nLoaded < 1) {
			break;
		}
		pNext = pEntry->pNext;
		MACRO_LD_REMOVE(pArch->pList,pEntry);
		ArchiveReleaseEntry(pArch->pAllocator,pEntry);
		pEntry = pNext;
		pArch->nLoaded--;
	}
	SyMemBackendFree(pArch->pAllocator,pArch->apHash);
	pArch->pCursor = 0;
	pArch->nMagic = 0x2626;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyArchiveResetLoopCursor(SyArchive* pArch)
{
	pArch->pCursor = pArch->pList;
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyArchiveGetNextEntry(SyArchive* pArch,SyArchiveEntry** ppEntry)
{
	SyArchiveEntry* pNext;
	if (pArch->pCursor == 0) {

		pArch->pCursor = pArch->pList;
		return SXERR_EOF;
	}
	*ppEntry = pArch->pCursor;
	pNext = pArch->pCursor->pNext;

	pArch->pCursor = pNext;
	return SXRET_OK;
}
#endif

#define SXPRNG_MAGIC	0x13C4
#ifdef __UNIXES__
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#endif
static sxi32 SyOSUtilRandomSeed(void* pBuf,sxu32 nLen,void* pUnused)
{
	char* zBuf = (char*)pBuf;
#ifdef __WINNT__
	DWORD nProcessID;
#elif defined(__UNIXES__)
	pid_t pid; int fd;
#else
	char zGarbage[128];
#endif
	SXUNUSED(pUnused);
#ifdef __WINNT__
#ifndef __MINGW32__
	nProcessID = GetProcessId(GetCurrentProcess());
#endif
	SyMemcpy((const void*)&nProcessID,zBuf,SXMIN(nLen,sizeof(DWORD)));
	if ((sxu32)(&zBuf[nLen] - &zBuf[sizeof(DWORD)]) >= sizeof(SYSTEMTIME)) {
		GetSystemTime((LPSYSTEMTIME)&zBuf[sizeof(DWORD)]);
	}
#elif defined(__UNIXES__)
	fd = open("/dev/urandom",O_RDONLY);
	if (fd >= 0) {
		if (read(fd,zBuf,nLen) > 0) {
			close(fd);
			return SXRET_OK;
		}

	}
	close(fd);
	pid = getpid();
	SyMemcpy((const void*)&pid,zBuf,SXMIN(nLen,sizeof(pid_t)));
	if (&zBuf[nLen] - &zBuf[sizeof(pid_t)] >= (int)sizeof(struct timeval)) {
		gettimeofday((struct timeval*)&zBuf[sizeof(pid_t)],0);
	}
#else

	SyMemcpy(zGarbage,zBuf,SXMIN(nLen,sizeof(zGarbage)));
#endif
	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyRandomnessInit(SyPRNGCtx* pCtx,ProcRandomSeed xSeed,void* pUserData)
{
	char zSeed[256];
	sxu8 t;
	sxi32 rc;
	sxu32 i;
	if (pCtx->nMagic == SXPRNG_MAGIC) {
		return SXRET_OK;
	}

	if (xSeed == 0) {
		xSeed = SyOSUtilRandomSeed;
	}
	rc = xSeed(zSeed,sizeof(zSeed),pUserData);
	if (rc != SXRET_OK) {
		return rc;
	}
	pCtx->i = pCtx->j = 0;
	for (i = 0; i < SX_ARRAYSIZE(pCtx->s); i++) {
		pCtx->s[i] = (unsigned char)i;
	}
	for (i = 0; i < sizeof(zSeed); i++) {
		pCtx->j += pCtx->s[i] + zSeed[i];
		t = pCtx->s[pCtx->j];
		pCtx->s[pCtx->j] = pCtx->s[i];
		pCtx->s[i] = t;
	}
	pCtx->nMagic = SXPRNG_MAGIC;

	return SXRET_OK;
}

static sxu8 randomByte(SyPRNGCtx* pCtx)
{
	sxu8 t;


	pCtx->i++;
	t = pCtx->s[pCtx->i];
	pCtx->j += t;
	pCtx->s[pCtx->i] = pCtx->s[pCtx->j];
	pCtx->s[pCtx->j] = t;
	t += pCtx->s[pCtx->i];
	return pCtx->s[t];
}
PHP_PRIVATE sxi32 SyRandomness(SyPRNGCtx* pCtx,void* pBuf,sxu32 nLen)
{
	unsigned char* zBuf = (unsigned char*)pBuf;
	unsigned char* zEnd = &zBuf[nLen];
#if defined(UNTRUST)
	if (pCtx == 0 || pBuf == 0 || nLen <= 0) {
		return SXERR_EMPTY;
	}
#endif
	if (pCtx->nMagic != SXPRNG_MAGIC) {
		return SXERR_CORRUPT;
	}
	for (;;) {
		if (zBuf >= zEnd) { break; }	zBuf[0] = randomByte(pCtx);	zBuf++;
		if (zBuf >= zEnd) { break; }	zBuf[0] = randomByte(pCtx);	zBuf++;
		if (zBuf >= zEnd) { break; }	zBuf[0] = randomByte(pCtx);	zBuf++;
		if (zBuf >= zEnd) { break; }	zBuf[0] = randomByte(pCtx);	zBuf++;
	}
	return SXRET_OK;
}
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifndef PHP_DISABLE_HASH_FUNC


#define SX_MD5_BINSZ	16
#define SX_MD5_HEXSZ	32

static void byteReverse(unsigned char* buf,unsigned longs)
{
	sxu32 t;
	do {
		t = (sxu32)((unsigned)buf[3] << 8 | buf[2]) << 16 |
			((unsigned)buf[1] << 8 | buf[0]);
		*(sxu32*)buf = t;
		buf += 4;
	} while (--longs);
}



#ifdef F1
#undef F1
#endif
#ifdef F2
#undef F2
#endif
#ifdef F3
#undef F3
#endif
#ifdef F4
#undef F4
#endif

#define F1(x,y,z) (z ^ (x & (y ^ z)))
#define F2(x,y,z) F1(z,x,y)
#define F3(x,y,z) (x ^ y ^ z)
#define F4(x,y,z) (y ^ (x | ~z))


#define SX_MD5STEP(f,w,x,y,z,data,s) \
				( w += f(x,y,z) + data,w = w<<s | w>>(32-s),w += x )


static void MD5Transform(sxu32 buf[4],const sxu32 in[16])
{
	register sxu32 a,b,c,d;
	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];
	SX_MD5STEP(F1,a,b,c,d,in[0] + 0xd76aa478,7);SX_MD5STEP(F1,d,a,b,c,in[1] + 0xe8c7b756,12);SX_MD5STEP(F1,c,d,a,b,in[2] + 0x242070db,17);SX_MD5STEP(F1,b,c,d,a,in[3] + 0xc1bdceee,22);SX_MD5STEP(F1,a,b,c,d,in[4] + 0xf57c0faf,7);SX_MD5STEP(F1,d,a,b,c,in[5] + 0x4787c62a,12);SX_MD5STEP(F1,c,d,a,b,in[6] + 0xa8304613,17);SX_MD5STEP(F1,b,c,d,a,in[7] + 0xfd469501,22);SX_MD5STEP(F1,a,b,c,d,in[8] + 0x698098d8,7);SX_MD5STEP(F1,d,a,b,c,in[9] + 0x8b44f7af,12);SX_MD5STEP(F1,c,d,a,b,in[10] + 0xffff5bb1,17);SX_MD5STEP(F1,b,c,d,a,in[11] + 0x895cd7be,22);SX_MD5STEP(F1,a,b,c,d,in[12] + 0x6b901122,7);SX_MD5STEP(F1,d,a,b,c,in[13] + 0xfd987193,12);SX_MD5STEP(F1,c,d,a,b,in[14] + 0xa679438e,17);SX_MD5STEP(F1,b,c,d,a,in[15] + 0x49b40821,22);SX_MD5STEP(F2,a,b,c,d,in[1] + 0xf61e2562,5);SX_MD5STEP(F2,d,a,b,c,in[6] + 0xc040b340,9);SX_MD5STEP(F2,c,d,a,b,in[11] + 0x265e5a51,14);SX_MD5STEP(F2,b,c,d,a,in[0] + 0xe9b6c7aa,20);SX_MD5STEP(F2,a,b,c,d,in[5] + 0xd62f105d,5);SX_MD5STEP(F2,d,a,b,c,in[10] + 0x02441453,9);SX_MD5STEP(F2,c,d,a,b,in[15] + 0xd8a1e681,14);SX_MD5STEP(F2,b,c,d,a,in[4] + 0xe7d3fbc8,20);SX_MD5STEP(F2,a,b,c,d,in[9] + 0x21e1cde6,5);SX_MD5STEP(F2,d,a,b,c,in[14] + 0xc33707d6,9);SX_MD5STEP(F2,c,d,a,b,in[3] + 0xf4d50d87,14);SX_MD5STEP(F2,b,c,d,a,in[8] + 0x455a14ed,20);SX_MD5STEP(F2,a,b,c,d,in[13] + 0xa9e3e905,5);SX_MD5STEP(F2,d,a,b,c,in[2] + 0xfcefa3f8,9);SX_MD5STEP(F2,c,d,a,b,in[7] + 0x676f02d9,14);SX_MD5STEP(F2,b,c,d,a,in[12] + 0x8d2a4c8a,20);SX_MD5STEP(F3,a,b,c,d,in[5] + 0xfffa3942,4);SX_MD5STEP(F3,d,a,b,c,in[8] + 0x8771f681,11);SX_MD5STEP(F3,c,d,a,b,in[11] + 0x6d9d6122,16);SX_MD5STEP(F3,b,c,d,a,in[14] + 0xfde5380c,23);SX_MD5STEP(F3,a,b,c,d,in[1] + 0xa4beea44,4);SX_MD5STEP(F3,d,a,b,c,in[4] + 0x4bdecfa9,11);SX_MD5STEP(F3,c,d,a,b,in[7] + 0xf6bb4b60,16);SX_MD5STEP(F3,b,c,d,a,in[10] + 0xbebfbc70,23);SX_MD5STEP(F3,a,b,c,d,in[13] + 0x289b7ec6,4);SX_MD5STEP(F3,d,a,b,c,in[0] + 0xeaa127fa,11);SX_MD5STEP(F3,c,d,a,b,in[3] + 0xd4ef3085,16);SX_MD5STEP(F3,b,c,d,a,in[6] + 0x04881d05,23);SX_MD5STEP(F3,a,b,c,d,in[9] + 0xd9d4d039,4);SX_MD5STEP(F3,d,a,b,c,in[12] + 0xe6db99e5,11);SX_MD5STEP(F3,c,d,a,b,in[15] + 0x1fa27cf8,16);SX_MD5STEP(F3,b,c,d,a,in[2] + 0xc4ac5665,23);SX_MD5STEP(F4,a,b,c,d,in[0] + 0xf4292244,6);SX_MD5STEP(F4,d,a,b,c,in[7] + 0x432aff97,10);SX_MD5STEP(F4,c,d,a,b,in[14] + 0xab9423a7,15);SX_MD5STEP(F4,b,c,d,a,in[5] + 0xfc93a039,21);SX_MD5STEP(F4,a,b,c,d,in[12] + 0x655b59c3,6);SX_MD5STEP(F4,d,a,b,c,in[3] + 0x8f0ccc92,10);SX_MD5STEP(F4,c,d,a,b,in[10] + 0xffeff47d,15);SX_MD5STEP(F4,b,c,d,a,in[1] + 0x85845dd1,21);SX_MD5STEP(F4,a,b,c,d,in[8] + 0x6fa87e4f,6);SX_MD5STEP(F4,d,a,b,c,in[15] + 0xfe2ce6e0,10);SX_MD5STEP(F4,c,d,a,b,in[6] + 0xa3014314,15);SX_MD5STEP(F4,b,c,d,a,in[13] + 0x4e0811a1,21);SX_MD5STEP(F4,a,b,c,d,in[4] + 0xf7537e82,6);SX_MD5STEP(F4,d,a,b,c,in[11] + 0xbd3af235,10);SX_MD5STEP(F4,c,d,a,b,in[2] + 0x2ad7d2bb,15);SX_MD5STEP(F4,b,c,d,a,in[9] + 0xeb86d391,21);
	buf[0] += a;
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
}

PHP_PRIVATE void MD5Update(MD5Context* ctx,const unsigned char* buf,unsigned int len)
{
	sxu32 t;
	t = ctx->bits[0];
	if ((ctx->bits[0] = t + ((sxu32)len << 3)) < t)
		ctx->bits[1]++;
	ctx->bits[1] += len >> 29;
	t = (t >> 3) & 0x3f;
	if (t) {
		unsigned char* p = (unsigned char*)ctx->in + t;
		t = 64 - t;
		if (len < t) {
			SyMemcpy(buf,p,len);
			return;
		}
		SyMemcpy(buf,p,t);
		byteReverse(ctx->in,16);
		MD5Transform(ctx->buf,(sxu32*)ctx->in);
		buf += t;
		len -= t;
	}
	while (len >= 64) {
		SyMemcpy(buf,ctx->in,64);
		byteReverse(ctx->in,16);
		MD5Transform(ctx->buf,(sxu32*)ctx->in);
		buf += 64;
		len -= 64;
	}
	SyMemcpy(buf,ctx->in,len);
}
PHP_PRIVATE void MD5Final(unsigned char digest[16],MD5Context* ctx) {
	unsigned count;unsigned char* p;count = (ctx->bits[0] >> 3) & 0x3F;p = ctx->in + count;*p++ = 0x80;count = 64 - 1 - count;if (count < 8) {SyZero(p,count);byteReverse(ctx->in,16);MD5Transform(ctx->buf,(sxu32*)ctx->in);SyZero(ctx->in,56);}else {SyZero(p,count - 8);}byteReverse(ctx->in,14);((sxu32*)ctx->in)[14] = ctx->bits[0];((sxu32*)ctx->in)[15] = ctx->bits[1];MD5Transform(ctx->buf,(sxu32*)ctx->in);byteReverse((unsigned char*)ctx->buf,4);SyMemcpy(ctx->buf,digest,0x10);SyZero(ctx,sizeof(ctx));}
#undef F1
#undef F2
#undef F3
#undef F4
PHP_PRIVATE sxi32 MD5Init(MD5Context* pCtx)
{
	pCtx->buf[0] = 0x67452301;
	pCtx->buf[1] = 0xefcdab89;
	pCtx->buf[2] = 0x98badcfe;
	pCtx->buf[3] = 0x10325476;
	pCtx->bits[0] = 0;
	pCtx->bits[1] = 0;

	return SXRET_OK;
}
PHP_PRIVATE sxi32 SyMD5Compute(const void* pIn,sxu32 nLen,unsigned char zDigest[16])
{
	MD5Context sCtx;
	MD5Init(&sCtx);
	MD5Update(&sCtx,(const unsigned char*)pIn,nLen);
	MD5Final(zDigest,&sCtx);
	return SXRET_OK;
}


#if __GNUC__ && (defined(__i386__) || defined(__x86_64__))

#define SHA_ROT(op,x,k) \
				({ unsigned int y; asm(op " %1,%0" : "=r" (y) : "I" (k),"0" (x)); y; })
#define rol(x,k) SHA_ROT("roll",x,k)
#define ror(x,k) SHA_ROT("rorl",x,k)

#else

#define SHA_ROT(x,l,r) ((x) << (l) | (x) >> (r))
#define rol(x,k) SHA_ROT(x,k,32-(k))
#define ror(x,k) SHA_ROT(x,32-(k),k)
#endif

#define blk0le(i) (block[i] = (ror(block[i],8)&0xFF00FF00) \
			|(rol(block[i],8)&0x00FF00FF))
#define blk0be(i) block[i]
#define blk(i) (block[i&15] = rol(block[(i+13)&15]^block[(i+8)&15] \
			^block[(i+2)&15]^block[i&15],1))


#define Rl0(v,w,x,y,z,i) \
			z+=((w&(x^y))^y)+blk0le(i)+0x5A827999+rol(v,5);w=ror(w,2);
#define Rb0(v,w,x,y,z,i) \
			z+=((w&(x^y))^y)+blk0be(i)+0x5A827999+rol(v,5);w=ror(w,2);
#define R1(v,w,x,y,z,i) \
			z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=ror(w,2);
#define R2(v,w,x,y,z,i) \
			z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=ror(w,2);
#define R3(v,w,x,y,z,i) \
			z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=ror(w,2);
#define R4(v,w,x,y,z,i) \
			z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=ror(w,2);


#define a qq[0]
#define b qq[1]
#define c qq[2]
#define d qq[3]
#define e qq[4]

static void SHA1Transform(unsigned int state[5],const unsigned char buffer[64])
{
	unsigned int qq[5]; static int one = 1;unsigned int block[16];SyMemcpy(buffer,(void*)block,64);SyMemcpy(state,qq,5 * sizeof(unsigned int));if (1 == *(unsigned char*)&one) {Rl0(a,b,c,d,e,0); Rl0(e,a,b,c,d,1); Rl0(d,e,a,b,c,2); Rl0(c,d,e,a,b,3);Rl0(b,c,d,e,a,4); Rl0(a,b,c,d,e,5); Rl0(e,a,b,c,d,6); Rl0(d,e,a,b,c,7);Rl0(c,d,e,a,b,8); Rl0(b,c,d,e,a,9); Rl0(a,b,c,d,e,10); Rl0(e,a,b,c,d,11);Rl0(d,e,a,b,c,12); Rl0(c,d,e,a,b,13); Rl0(b,c,d,e,a,14); Rl0(a,b,c,d,e,15);}else {Rb0(a,b,c,d,e,0); Rb0(e,a,b,c,d,1); Rb0(d,e,a,b,c,2); Rb0(c,d,e,a,b,3);Rb0(b,c,d,e,a,4); Rb0(a,b,c,d,e,5); Rb0(e,a,b,c,d,6); Rb0(d,e,a,b,c,7);Rb0(c,d,e,a,b,8); Rb0(b,c,d,e,a,9); Rb0(a,b,c,d,e,10); Rb0(e,a,b,c,d,11);Rb0(d,e,a,b,c,12); Rb0(c,d,e,a,b,13); Rb0(b,c,d,e,a,14); Rb0(a,b,c,d,e,15);}R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);state[0] += a;state[1] += b;state[2] += c;state[3] += d;state[4] += e;
}
#undef a
#undef b
#undef c
#undef d
#undef e

PHP_PRIVATE void SHA1Init(SHA1Context* context) {
	context->state[0] = 0x67452301;context->state[1] = 0xEFCDAB89;context->state[2] = 0x98BADCFE;context->state[3] = 0x10325476;context->state[4] = 0xC3D2E1F0;context->count[0] = context->count[1] = 0;
}

PHP_PRIVATE void SHA1Update(SHA1Context* context,const unsigned char* data,unsigned int len) {
	unsigned int i,j;

	j = context->count[0];
	if ((context->count[0] += len << 3) < j)
		context->count[1] += (len >> 29) + 1;
	j = (j >> 3) & 63;
	if ((j + len) > 63) {
		(void)SyMemcpy(data,&context->buffer[j],(i = 64 - j));
		SHA1Transform(context->state,context->buffer);
		for (; i + 63 < len; i += 64)
			SHA1Transform(context->state,&data[i]);
		j = 0;
	}
	else {
		i = 0;
	}
	(void)SyMemcpy(&data[i],&context->buffer[j],len - i);
}

PHP_PRIVATE void SHA1Final(SHA1Context* context,unsigned char digest[20]) {
	unsigned int i;
	unsigned char finalcount[8];

	for (i = 0; i < 8; i++) {
		finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
			>> ((3 - (i & 3)) * 8)) & 255);
	}
	SHA1Update(context,(const unsigned char*)"\200",1);
	while ((context->count[0] & 504) != 448)
		SHA1Update(context,(const unsigned char*)"\0",1);
	SHA1Update(context,finalcount,8);

	if (digest) {
		for (i = 0; i < 20; i++)
			digest[i] = (unsigned char)
			((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
	}
}
#undef Rl0
#undef Rb0
#undef R1
#undef R2
#undef R3
#undef R4

PHP_PRIVATE sxi32 SySha1Compute(const void* pIn,sxu32 nLen,unsigned char zDigest[20])
{
	SHA1Context sCtx;SHA1Init(&sCtx);SHA1Update(&sCtx,(const unsigned char*)pIn,nLen);SHA1Final(&sCtx,zDigest);return SXRET_OK;
}
static const sxu32 crc32_table[] = {0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d,};
#define CRC32C(c,d) (c = ( crc32_table[(c ^ (d)) & 0xFF] ^ (c>>8) ) )
static sxu32 SyCrc32Update(sxu32 crc32,const void* pSrc,sxu32 nLen){register unsigned char* zIn = (unsigned char*)pSrc;unsigned char* zEnd;
	if (zIn == 0) {
		return crc32;
	}
	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; } CRC32C(crc32,zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } CRC32C(crc32,zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } CRC32C(crc32,zIn[0]); zIn++;
		if (zIn >= zEnd) { break; } CRC32C(crc32,zIn[0]); zIn++;
	}

	return crc32;
}
PHP_PRIVATE sxu32 SyCrc32(const void* pSrc,sxu32 nLen)
{
	return SyCrc32Update(SXU32_HIGH,pSrc,nLen);
}
#endif
#endif
#ifndef PHP_DISABLE_BUILTIN_FUNC
PHP_PRIVATE sxi32 SyBinToHexConsumer(const void* pIn,sxu32 nLen,ProcConsumer xConsumer,void* pConsumerData)
{
	static const unsigned char zHexTab[] = "0123456789abcdef";
	const unsigned char* zIn,* zEnd;
	unsigned char zOut[3];
	sxi32 rc;
#if defined(UNTRUST)
	if (pIn == 0 || xConsumer == 0) {
		return SXERR_EMPTY;
	}
#endif
	zIn = (const unsigned char*)pIn;
	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) {
			break;
		}
		zOut[0] = zHexTab[zIn[0] >> 4];  zOut[1] = zHexTab[zIn[0] & 0x0F];
		rc = xConsumer((const void*)zOut,sizeof(char) * 2,pConsumerData);
		if (rc != SXRET_OK) {
			return rc;
		}
		zIn++;
	}
	return SXRET_OK;
}
#endif



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


static sxu32 KeywordCode(const char* z,int n);
static sxi32 LexExtractHeredoc(SyStream* pStream,SyToken* pToken);

static sxi32 TokenizePHP(SyStream* pStream,SyToken* pToken,void* pUserData,void* pCtxData)
{
	SyString* pStr;
	sxi32 rc;

	while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisSpace(pStream->zText[0])) {

		if (pStream->zText[0] == '\n') {

			pStream->nLine++;
		}
		pStream->zText++;
	}
	if (pStream->zText >= pStream->zEnd) {

		return SXERR_EOF;
	}

	pToken->nLine = pStream->nLine;
	pToken->pUserData = 0;
	pStr = &pToken->sData;
	SyStringInitFromBuf(pStr,pStream->zText,0);
	if (pStream->zText[0] >= 0xc0 || SyisAlpha(pStream->zText[0]) || pStream->zText[0] == '_') {

		const unsigned char* zIn;
		sxu32 nKeyword;

		if (pStream->zText[0] < 0xc0) {
			pStream->zText++;
		}
		for (;;) {
			zIn = pStream->zText;
			if (zIn[0] >= 0xc0) {
				zIn++;

				while (zIn < pStream->zEnd && ((zIn[0] & 0xc0) == 0x80)) {
					zIn++;
				}
			}

			while (zIn < pStream->zEnd && zIn[0] < 0xc0 && (SyisAlphaNum(zIn[0]) || zIn[0] == '_')) {
				zIn++;
			}
			if (zIn == pStream->zText) {

				break;
			}

			pStream->zText = zIn;
		}

		pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
		nKeyword = KeywordCode(pStr->zString,(int)pStr->nByte);
		if (nKeyword != PHP_TK_ID) {
			if (nKeyword &
				(PHP_TKWRD_NEW | PHP_TKWRD_CLONE | PHP_TKWRD_AND | PHP_TKWRD_XOR | PHP_TKWRD_OR | PHP_TKWRD_INSTANCEOF | PHP_TKWRD_SEQ | PHP_TKWRD_SNE)) {

				pToken->pUserData = (void*)PHP_ExprExtractOperator(pStr,0);

				pToken->nType = PHP_TK_ID | PHP_TK_OP;
			}
			else {

				pToken->nType = PHP_TK_KEYWORD;
				pToken->pUserData = SX_INT_TO_PTR(nKeyword);
			}
		}
		else {

			pToken->nType = PHP_TK_ID;
		}
	}
	else {
		sxi32 c;

		if (pStream->zText[0] == '#' ||
			(pStream->zText[0] == '/' && &pStream->zText[1] < pStream->zEnd && pStream->zText[1] == '/')) {
			pStream->zText++;

			while (pStream->zText < pStream->zEnd && pStream->zText[0] != '\n') {
				pStream->zText++;
			}

			return SXERR_CONTINUE;
		}
		else if (pStream->zText[0] == '/' && &pStream->zText[1] < pStream->zEnd && pStream->zText[1] == '*') {
			pStream->zText += 2;

			while (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '*') {
					if (&pStream->zText[1] >= pStream->zEnd || pStream->zText[1] == '/') {
						break;
					}
				}
				if (pStream->zText[0] == '\n') {
					pStream->nLine++;
				}
				pStream->zText++;
			}
			pStream->zText += 2;

			return SXERR_CONTINUE;
		}
		else if (SyisDigit(pStream->zText[0])) {
			pStream->zText++;

			while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
				pStream->zText++;
			}

			pToken->nType = PHP_TK_INTEGER;
			if (pStream->zText < pStream->zEnd) {
				c = pStream->zText[0];
				if (c == '.') {

					pStream->zText++;
					while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
						pStream->zText++;
					}
					if (pStream->zText < pStream->zEnd) {
						c = pStream->zText[0];
						if (c == 'e' || c == 'E') {
							pStream->zText++;
							if (pStream->zText < pStream->zEnd) {
								c = pStream->zText[0];
								if ((c == '+' || c == '-') && &pStream->zText[1] < pStream->zEnd &&
									pStream->zText[1] < 0xc0 && SyisDigit(pStream->zText[1])) {
									pStream->zText++;
								}
								while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
									pStream->zText++;
								}
							}
						}
					}
					pToken->nType = PHP_TK_REAL;
				}
				else if (c == 'e' || c == 'E') {
					SXUNUSED(pUserData);
					SXUNUSED(pCtxData);
					pStream->zText++;
					if (pStream->zText < pStream->zEnd) {
						c = pStream->zText[0];
						if ((c == '+' || c == '-') && &pStream->zText[1] < pStream->zEnd &&
							pStream->zText[1] < 0xc0 && SyisDigit(pStream->zText[1])) {
							pStream->zText++;
						}
						while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisDigit(pStream->zText[0])) {
							pStream->zText++;
						}
					}
					pToken->nType = PHP_TK_REAL;
				}
				else if (c == 'x' || c == 'X') {

					pStream->zText++;
					while (pStream->zText < pStream->zEnd && pStream->zText[0] < 0xc0 && SyisHex(pStream->zText[0])) {
						pStream->zText++;
					}
				}
				else if (c == 'b' || c == 'B') {

					pStream->zText++;
					while (pStream->zText < pStream->zEnd && (pStream->zText[0] == '0' || pStream->zText[0] == '1')) {
						pStream->zText++;
					}
				}
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			return SXRET_OK;
		}
		c = pStream->zText[0];
		pStream->zText++;

		pToken->nType = PHP_TK_OP;
		switch (c) {
		case '$': pToken->nType = PHP_TK_DOLLAR; break;
		case '{': pToken->nType = PHP_TK_OCB;    break;
		case '}': pToken->nType = PHP_TK_CCB;    break;
		case '(': pToken->nType = PHP_TK_LPAREN; break;
		case '[': pToken->nType |= PHP_TK_OSB;   break;
		case ']': pToken->nType = PHP_TK_CSB;    break;
		case ')': {
			SySet* pTokSet = pStream->pSet;

			if (pTokSet->nUsed >= 2) {
				SyToken* pTmp;

				pTmp = (SyToken*)SySetPeek(pTokSet);
				if (pTmp->nType & PHP_TK_KEYWORD) {
					sxi32 nID = SX_PTR_TO_INT(pTmp->pUserData);
					if ((sxu32)nID & (PHP_TKWRD_ARRAY | PHP_TKWRD_INT | PHP_TKWRD_FLOAT | PHP_TKWRD_STRING | PHP_TKWRD_OBJECT | PHP_TKWRD_BOOL | PHP_TKWRD_UNSET)) {
						pTmp = (SyToken*)SySetAt(pTokSet,pTokSet->nUsed - 2);
						if (pTmp->nType & PHP_TK_LPAREN) {

							const char* zTypeCast = "(int)";
							if (nID & PHP_TKWRD_FLOAT) {
								zTypeCast = "(float)";
							}
							else if (nID & PHP_TKWRD_BOOL) {
								zTypeCast = "(bool)";
							}
							else if (nID & PHP_TKWRD_STRING) {
								zTypeCast = "(string)";
							}
							else if (nID & PHP_TKWRD_ARRAY) {
								zTypeCast = "(array)";
							}
							else if (nID & PHP_TKWRD_OBJECT) {
								zTypeCast = "(object)";
							}
							else if (nID & PHP_TKWRD_UNSET) {
								zTypeCast = "(unset)";
							}

							pToken->nType = PHP_TK_OP;
							SyStringInitFromBuf(&pToken->sData,zTypeCast,SyStrlen(zTypeCast));

							pToken->pUserData = (void*)PHP_ExprExtractOperator(&pToken->sData,0);

							pTokSet->nUsed -= 2;
							return SXRET_OK;
						}
					}
				}
			}
			pToken->nType = PHP_TK_RPAREN;
			break;
		}
		case '\'': {

			pStr->zString++;
			while (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '\'') {
					if (pStream->zText[-1] != '\\') {
						break;
					}
					else {
						const unsigned char* zPtr = &pStream->zText[-2];
						sxi32 i = 1;
						while (zPtr > pStream->zInput && zPtr[0] == '\\') {
							zPtr--;
							i++;
						}
						if ((i & 1) == 0) {
							break;
						}
					}
				}
				if (pStream->zText[0] == '\n') {
					pStream->nLine++;
				}
				pStream->zText++;
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			pToken->nType = PHP_TK_SSTR;

			pStream->zText++;
			return SXRET_OK;
		}
		case '"': {
			sxi32 iNest;

			pStr->zString++;
			while (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '{' && &pStream->zText[1] < pStream->zEnd && pStream->zText[1] == '$') {
					iNest = 1;
					pStream->zText++;

					while (pStream->zText < pStream->zEnd) {
						if (pStream->zText[0] == '{') {
							iNest++;
						}
						else if (pStream->zText[0] == '}') {
							iNest--;
							if (iNest <= 0) {
								pStream->zText++;
								break;
							}
						}
						else if (pStream->zText[0] == '\n') {
							pStream->nLine++;
						}
						pStream->zText++;
					}
					if (pStream->zText >= pStream->zEnd) {
						break;
					}
				}
				if (pStream->zText[0] == '"') {
					if (pStream->zText[-1] != '\\') {
						break;
					}
					else {
						const unsigned char* zPtr = &pStream->zText[-2];
						sxi32 i = 1;
						while (zPtr > pStream->zInput && zPtr[0] == '\\') {
							zPtr--;
							i++;
						}
						if ((i & 1) == 0) {
							break;
						}
					}
				}
				if (pStream->zText[0] == '\n') {
					pStream->nLine++;
				}
				pStream->zText++;
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			pToken->nType = PHP_TK_DSTR;

			pStream->zText++;
			return SXRET_OK;
		}
		case '`': {

			pStr->zString++;
			while (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '`' && pStream->zText[-1] != '\\') {
					break;
				}
				if (pStream->zText[0] == '\n') {
					pStream->nLine++;
				}
				pStream->zText++;
			}

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
			pToken->nType = PHP_TK_BSTR;

			pStream->zText++;
			return SXRET_OK;
		}
		case '\\': pToken->nType = PHP_TK_NSSEP;  break;
		case ':':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == ':') {

				pStream->zText++;
			}
			else {
				pToken->nType = PHP_TK_COLON;
			}
			break;
		case ',': pToken->nType |= PHP_TK_COMMA;  break;
		case ';': pToken->nType = PHP_TK_SEMI;    break;

		case '=':
			pToken->nType |= PHP_TK_EQUAL;
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '=') {
					pToken->nType &= ~PHP_TK_EQUAL;

					pStream->zText++;
					if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

						pStream->zText++;
					}
				}
				else if (pStream->zText[0] == '>') {

					pToken->nType = PHP_TK_ARRAY_OP;
					pStream->zText++;
				}
				else {

					const unsigned char* zCur = pStream->zText;
					sxu32 nLine = 0;
					while (zCur < pStream->zEnd && zCur[0] < 0xc0 && SyisSpace(zCur[0])) {
						if (zCur[0] == '\n') {
							nLine++;
						}
						zCur++;
					}
					if (zCur < pStream->zEnd && zCur[0] == '&') {

						pToken->nType &= ~PHP_TK_EQUAL;
						SyStringInitFromBuf(pStr,"=&",sizeof("=&") - 1);

						pStream->zText = &zCur[1];
						pStream->nLine += nLine;
					}
				}
			}
			break;
		case '!':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
				if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

					pStream->zText++;
				}
			}
			break;
		case '&':
			pToken->nType |= PHP_TK_AMPER;
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '&') {
					pToken->nType &= ~PHP_TK_AMPER;

					pStream->zText++;
				}
				else if (pStream->zText[0] == '=') {
					pToken->nType &= ~PHP_TK_AMPER;

					pStream->zText++;
				}
			}
			break;
		case '|':
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '|') {

					pStream->zText++;
				}
				else if (pStream->zText[0] == '=') {

					pStream->zText++;
				}
			}
			break;
		case '+':
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '+') {

					pStream->zText++;
				}
				else if (pStream->zText[0] == '=') {

					pStream->zText++;
				}
			}
			break;
		case '-':
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '-') {

					pStream->zText++;
				}
				else if (pStream->zText[0] == '=') {

					pStream->zText++;
				}
				else if (pStream->zText[0] == '>') {

					pStream->zText++;
				}
			}
			break;
		case '*':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
			}
			break;
		case '/':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
			}
			break;
		case '%':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
			}
			break;
		case '^':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
			}
			break;
		case '.':
			if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

				pStream->zText++;
			}
			break;
		case '<':
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '<') {

					pStream->zText++;
					if (pStream->zText < pStream->zEnd) {
						if (pStream->zText[0] == '=') {

							pStream->zText++;
						}
						else if (pStream->zText[0] == '<') {

							pStream->zText++;

							rc = LexExtractHeredoc(&(*pStream),&(*pToken));
							if (rc == SXRET_OK) {

								return SXRET_OK;
							}
						}
					}
				}
				else if (pStream->zText[0] == '>') {

					pStream->zText++;
				}
				else if (pStream->zText[0] == '=') {

					pStream->zText++;
				}
			}
			break;
		case '>':
			if (pStream->zText < pStream->zEnd) {
				if (pStream->zText[0] == '>') {

					pStream->zText++;
					if (pStream->zText < pStream->zEnd && pStream->zText[0] == '=') {

						pStream->zText++;
					}
				}
				else if (pStream->zText[0] == '=') {

					pStream->zText++;
				}
			}
			break;
		default:
			break;
		}
		if (pStr->nByte <= 0) {

			pStr->nByte = (sxu32)((const char*)pStream->zText - pStr->zString);
		}
		if (pToken->nType & PHP_TK_OP) {
			const php_expr_op* pOp;

			pOp = PHP_ExprExtractOperator(pStr,(SyToken*)SySetPeek(pStream->pSet));
			if (pOp == 0) {

				pToken->nType &= ~PHP_TK_OP;
				if (pToken->nType <= 0) {
					pToken->nType = PHP_TK_OTHER;
				}
			}
			else {

				pToken->pUserData = (void*)pOp;
			}
		}
	}

	return SXRET_OK;
}


static sxu32 KeywordCode(const char* z,int n) {
	static const char zText[332] = {
		'e','x','t','e','n','d','s','w','i','t','c','h','p','r','i','n','t','e','g','e','r','e','q','u','i','r','e','_','o','n','c','e','n','d','d','e','c','l','a','r','e','t','u','r','n','a','m','e','s','p','a','c','e','c','h','o','b','j','e','c','t','h','r','o','w','b','o','o','l','e','a','n','d','e','f','a','u','l','t','r','y','c','a','s','e','l','f','i','n','a','l','i','s','t','a','t','i','c','l','o','n','e','w','c','o','n','s','t','r','i','n','g','l','o','b','a','l','u','s','e','l','s','e','i','f','l','o','a','t','v','a','r','r','a','y','A','N','D','I','E','c','h','o','U','S','E','C','H','O','a','b','s','t','r','a','c','t','c','l','a','s','s','c','o','n','t','i','n','u','e','n','d','i','f','u','n','c','t','i','o','n','d','i','e','n','d','w','h','i','l','e','v','a','l','d','o','e','x','i','t','g','o','t','o','i','m','p','l','e','m','e','n','t','s','i','n','c','l','u','d','e','_','o','n','c','e','m','p','t','y','i','n','s','t','a','n','c','e','o','f','i','n','t','e','r','f','a','c','e','n','d','f','o','r','e','a','c','h','i','s','s','e','t','p','a','r','e','n','t','p','r','i','v','a','t','e','p','r','o','t','e','c','t','e','d','p','u','b','l','i','c','a','t','c','h','u','n','s','e','t','x','o','r','A','R','R','A','Y','A','S','A','r','r','a','y','E','X','I','T','U','N','S','E','T','X','O','R','b','r','e','a','k'
	};
	static const unsigned char aHash[151] = {
		0,0,4,83,0,61,39,12,0,33,77,0,48,0,2,65,67,0,0,0,47,0,0,40,0,15,74,0,51,0,76,0,0,20,0,0,0,50,0,80,34,0,36,0,0,64,16,0,0,17,0,1,19,84,66,0,43,45,78,0,0,53,56,0,0,0,23,49,0,0,13,31,54,7,0,0,25,0,72,14,0,71,0,38,6,0,0,0,73,0,0,3,0,41,5,52,57,32,0,60,63,0,69,82,30,0,79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,81,0,0,62,0,11,0,0,58,0,0,0,0,59,75,0,0,0,0,0,0,35,27,0
	};
	static const unsigned char aNext[84] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,10,0,0,0,0,0,0,0,0,0,0,28,0,0,0,0,0,0,0,0,0,0,0,0,0,44,0,18,0,0,0,0,0,0,46,0,29,0,0,0,22,0,0,0,0,26,0,21,24,0,0,68,0,0,9,37,0,0,0,42,0,0,0,70,55
	};
	static const unsigned char aLen[84] = {
			7,9,6,5,7,12,7,2,10,7,6,9,4,6,5,7,4,3,7,3,4,4,5,4,6,5,2,3,5,6,6,3,6,4,2,5,3,5,3,3,4,3,4,8,5,2,8,5,8,3,8,5,4,2,4,4,10,12,7,5,10,9,3,6,10,3,7,2,5,6,7,9,6,5,5,3,5,2,5,4,5,3,2,5
	};
	static const sxu16 aOffset[84] = {
		0,3,6,12,14,20,20,21,31,34,39,44,52,55,60,65,65,70,72,78,81,83,86,90,92,97,100,100,103,106,111,117,119,119,123,124,129,130,135,137,139,143,145,149,157,159,162,169,173,181,183,186,190,194,196,200,204,214,214,225,230,240,240,248,248,251,251,252,258,263,269,276,285,290,295,300,303,308,310,315,319,324,325,327
	};
	static const sxu32 aCode[84] = {
		PHP_TKWRD_EXTENDS,PHP_TKWRD_ENDSWITCH,PHP_TKWRD_SWITCH,PHP_TKWRD_PRINT,PHP_TKWRD_INT,PHP_TKWRD_REQONCE,PHP_TKWRD_REQUIRE,PHP_TKWRD_SEQ,PHP_TKWRD_ENDDEC,PHP_TKWRD_DECLARE,PHP_TKWRD_RETURN,PHP_TKWRD_NAMESPACE,PHP_TKWRD_ECHO,PHP_TKWRD_OBJECT,PHP_TKWRD_THROW,PHP_TKWRD_BOOL,PHP_TKWRD_BOOL,PHP_TKWRD_AND,PHP_TKWRD_DEFAULT,PHP_TKWRD_TRY,PHP_TKWRD_CASE,PHP_TKWRD_SELF,PHP_TKWRD_FINAL,PHP_TKWRD_LIST,PHP_TKWRD_STATIC,PHP_TKWRD_CLONE,PHP_TKWRD_SNE,PHP_TKWRD_NEW,PHP_TKWRD_CONST,PHP_TKWRD_STRING,PHP_TKWRD_GLOBAL,PHP_TKWRD_USE,PHP_TKWRD_ELIF,PHP_TKWRD_ELSE,PHP_TKWRD_IF,PHP_TKWRD_FLOAT,PHP_TKWRD_VAR,PHP_TKWRD_ARRAY,PHP_TKWRD_AND,PHP_TKWRD_DIE,PHP_TKWRD_ECHO,PHP_TKWRD_USE,PHP_TKWRD_ECHO,PHP_TKWRD_ABSTRACT,PHP_TKWRD_CLASS,PHP_TKWRD_AS,PHP_TKWRD_CONTINUE,PHP_TKWRD_ENDIF,PHP_TKWRD_FUNCTION,PHP_TKWRD_DIE,PHP_TKWRD_ENDWHILE,PHP_TKWRD_WHILE,PHP_TKWRD_EVAL,PHP_TKWRD_DO,PHP_TKWRD_EXIT,PHP_TKWRD_GOTO,PHP_TKWRD_IMPLEMENTS,PHP_TKWRD_INCONCE,PHP_TKWRD_INCLUDE,PHP_TKWRD_EMPTY,PHP_TKWRD_INSTANCEOF,PHP_TKWRD_INTERFACE,PHP_TKWRD_INT,PHP_TKWRD_ENDFOR,PHP_TKWRD_END4EACH,PHP_TKWRD_FOR,PHP_TKWRD_FOREACH,PHP_TKWRD_OR,PHP_TKWRD_ISSET,PHP_TKWRD_PARENT,PHP_TKWRD_PRIVATE,PHP_TKWRD_PROTECTED,PHP_TKWRD_PUBLIC,PHP_TKWRD_CATCH,PHP_TKWRD_UNSET,PHP_TKWRD_XOR,PHP_TKWRD_ARRAY,PHP_TKWRD_AS,PHP_TKWRD_ARRAY,PHP_TKWRD_EXIT,PHP_TKWRD_UNSET,PHP_TKWRD_XOR,PHP_TKWRD_OR,PHP_TKWRD_BREAK
	}; int h,i;
	if (n < 2) return PHP_TK_ID;
	h = (((int)z[0] * 4) ^ ((int)z[n - 1] * 3) ^ n) % 151;
	for (i = ((int)aHash[h]) - 1; i >= 0; i = ((int)aNext[i]) - 1) {
		if ((int)aLen[i] == n && SyMemcmp(&zText[aOffset[i]],z,n) == 0) {
			return aCode[i];
		}
	}
	return PHP_TK_ID;
}


static sxi32 LexExtractHeredoc(SyStream* pStream,SyToken* pToken)
{
	const unsigned char* zIn = pStream->zText;
	const unsigned char* zEnd = pStream->zEnd;
	const unsigned char* zPtr;
	sxu8 bNowDoc = FALSE;
	SyString sDelim;
	SyString sStr;

	while (zIn < zEnd && zIn[0] < 0xc0 && SyisSpace(zIn[0]) && zIn[0] != '\n') {
		zIn++;
	}
	if (zIn >= zEnd) {

		return SXERR_CONTINUE;
	}
	if (zIn[0] == '\'' || zIn[0] == '"') {

		bNowDoc = zIn[0] == '\'' ? TRUE : FALSE;
		zIn++;
	}
	if (zIn[0] < 0xc0 && !SyisAlphaNum(zIn[0]) && zIn[0] != '_') {

		return SXERR_CONTINUE;
	}

	sDelim.zString = (const char*)zIn;
	for (;;) {
		zPtr = zIn;

		while (zPtr < zEnd && zPtr[0] < 0xc0 && (SyisAlphaNum(zPtr[0]) || zPtr[0] == '_')) {
			zPtr++;
		}
		if (zPtr < zEnd && zPtr[0] >= 0xc0) {
			zPtr++;

			while (zPtr < zEnd && ((zPtr[0] & 0xc0) == 0x80)) {
				zPtr++;
			}
		}
		if (zPtr == zIn) {

			break;
		}

		zIn = zPtr;
	}

	sDelim.nByte = (sxu32)((const char*)zIn - sDelim.zString);
	if (zIn[0] == '"' || (bNowDoc && zIn[0] == '\'')) {

		zIn++;
	}

	while (zIn < zEnd && zIn[0] < 0xc0 && SyisSpace(zIn[0]) && zIn[0] != '\n') {
		zIn++;
	}
	if (sDelim.nByte <= 0 || zIn >= zEnd || zIn[0] != '\n') {

		return SXERR_CONTINUE;
	}
	pStream->nLine++;
	zIn++;

	sStr.zString = (const char*)zIn;

	for (;;) {

		while (zIn < zEnd && zIn[0] != '\n') {
			zIn++;
		}
		if (zIn >= zEnd) {

			pStream->zText = pStream->zEnd;
			break;
		}
		pStream->nLine++;
		zIn++;
		if ((sxu32)(zEnd - zIn) >= sDelim.nByte && SyMemcmp((const void*)sDelim.zString,(const void*)zIn,sDelim.nByte) == 0) {
			zPtr = &zIn[sDelim.nByte];
			while (zPtr < zEnd && zPtr[0] < 0xc0 && SyisSpace(zPtr[0]) && zPtr[0] != '\n') {
				zPtr++;
			}
			if (zPtr >= zEnd) {

				pStream->zText = zPtr;
				break;
			}
			if (zPtr[0] == ';') {
				const unsigned char* zCur = zPtr;
				zPtr++;
				while (zPtr < zEnd && zPtr[0] < 0xc0 && SyisSpace(zPtr[0]) && zPtr[0] != '\n') {
					zPtr++;
				}
				if (zPtr >= zEnd || zPtr[0] == '\n') {

					pStream->zText = zCur;
					break;
				}
			}
			else if (zPtr[0] == '\n') {

				pStream->zText = zPtr;
				break;
			}

			zIn = zPtr;
		}
	}

	sStr.nByte = (sxu32)((const char*)zIn - sStr.zString);

	pToken->nType = bNowDoc ? PHP_TK_NOWDOC : PHP_TK_HEREDOC;
	SyStringDupPtr(&pToken->sData,&sStr);

	SyStringRightTrim(&pToken->sData);

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_TokenizePHP(const char* zInput,sxu32 nLen,sxu32 nLineStart,SySet* pOut)
{
	SyLex sLexer;
	sxi32 rc;

	rc = SyLexInit(&sLexer,&(*pOut),TokenizePHP,0);
	if (rc != SXRET_OK) {
		return rc;
	}
	sLexer.sStream.nLine = nLineStart;

	rc = SyLexTokenizeInput(&sLexer,zInput,nLen,0,0,0);

	SyLexRelease(&sLexer);

	return rc;
}

PHP_PRIVATE sxi32 PHP_TokenizeRawText(const char* zInput,sxu32 nLen,SySet* pOut)
{
	const char* zEnd = &zInput[nLen];
	const char* zIn = zInput;
	const char* zCur,* zCurEnd;
	SyString sCtag = { 0,0 };
	SyToken sToken;
	SyString sDoc;
	sxu32 nLine;
	sxi32 iNest;
	sxi32 rc;

	nLine = 1;
	zCur = zCurEnd = 0;
	sToken.pUserData = 0;
	iNest = 0;
	sDoc.nByte = 0;
	sDoc.zString = "";
	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		sToken.nLine = nLine;
		zCur = zIn;
		zCurEnd = 0;
		while (zIn < zEnd) {
			if (zIn[0] == '<') {
				const char* zTmp = zIn;
				zIn++;
				if (zIn < zEnd) {
					if (zIn[0] == '?') {
						zIn++;
						if ((sxu32)(zEnd - zIn) >= sizeof("php") - 1 && SyStrnicmp(zIn,"php",sizeof("php") - 1) == 0) {

							zIn += sizeof("php") - 1;
						}

						SyStringInitFromBuf(&sCtag,"?>",sizeof("?>") - 1);
						zCurEnd = zTmp;
						break;
					}
				}
			}
			else {
				if (zIn[0] == '\n') {
					nLine++;
				}
				zIn++;
			}
		}
		if (zCurEnd == 0) {
			zCurEnd = zIn;
		}

		SyStringInitFromBuf(&sToken.sData,zCur,zCurEnd - zCur);
		sToken.nType = PHP_TOKEN_RAW;
		rc = SySetPut(&(*pOut),(const void*)&sToken);
		if (rc != SXRET_OK) {
			return rc;
		}
		if (zIn >= zEnd) {
			break;
		}

		while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
			if (zIn[0] == '\n') {
				nLine++;
			}
			zIn++;
		}

		sToken.nLine = nLine;
		zCur = zIn;
		while ((sxu32)(zEnd - zIn) >= sCtag.nByte) {
			const char* zPtr;
			if (SyMemcmp(zIn,sCtag.zString,sCtag.nByte) == 0 && iNest < 1) {
				break;
			}
			for (;;) {
				if (zIn[0] != '/' || (zIn[1] != '*' && zIn[1] != '/') ) {
					break;
				}
				zIn += 2;
				if (zIn[-1] == '/') {

					while (zIn < zEnd && zIn[0] != '\n') {
						zIn++;
					}
					if (zIn >= zEnd) {
						zIn--;
					}
				}
				else {

					while ((sxu32)(zEnd - zIn) >= sizeof("*/") - 1) {
						if (zIn[0] == '*' && zIn[1] == '/') {
							zIn += 2;
							break;
						}
						if (zIn[0] == '\n') {
							nLine++;
						}
						zIn++;
					}
				}
			}
			if (zIn[0] == '\n') {
				nLine++;
				if (iNest > 0) {
					zIn++;
					while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0]) && zIn[0] != '\n') {
						zIn++;
					}
					zPtr = zIn;
					while (zIn < zEnd) {
						if ((unsigned char)zIn[0] >= 0xc0) {

							zIn++;
							SX_JMP_UTF8(zIn,zEnd);
						}
						else if (!SyisAlphaNum(zIn[0]) && zIn[0] != '_') {
							break;
						}
						else {
							zIn++;
						}
					}
					if ((sxu32)(zIn - zPtr) == sDoc.nByte && SyMemcmp(sDoc.zString,zPtr,sDoc.nByte) == 0) {
						iNest = 0;
					}
					continue;
				}
			}
			else if ((sxu32)(zEnd - zIn) >= sizeof("<<<") && zIn[0] == '<' && zIn[1] == '<' && zIn[2] == '<' && iNest < 1) {
				zIn += sizeof("<<<") - 1;
				while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0]) && zIn[0] != '\n') {
					zIn++;
				}
				if (zIn[0] == '"' || zIn[0] == '\'') {
					zIn++;
				}
				zPtr = zIn;
				while (zIn < zEnd) {
					if ((unsigned char)zIn[0] >= 0xc0) {

						zIn++;
						SX_JMP_UTF8(zIn,zEnd);
					}
					else if (!SyisAlphaNum(zIn[0]) && zIn[0] != '_') {
						break;
					}
					else {
						zIn++;
					}
				}
				SyStringInitFromBuf(&sDoc,zPtr,zIn - zPtr);
				SyStringFullTrim(&sDoc);
				if (sDoc.nByte > 0) {
					iNest++;
				}
				continue;
			}
			zIn++;

			if (zIn >= zEnd)
				break;
		}
		if ((sxu32)(zEnd - zIn) < sCtag.nByte) {
			zIn = zEnd;
		}
		if (zCur < zIn) {

			sToken.nType = PHP_TOKEN_PHP;
			SyStringInitFromBuf(&sToken.sData,zCur,zIn - zCur);
			SyStringRightTrim(&sToken.sData);
			rc = SySetPut(&(*pOut),(const void*)&sToken);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
		if (zIn < zEnd) {

			zIn += sCtag.nByte;
		}
	}

	return SXRET_OK;
}




#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


#define HASHMAP_INT_NODE   1
#define HASHMAP_BLOB_NODE  2

#define HASHMAP_NODE_FOREIGN_OBJ 0x001

static sxu32 IntHash(sxi64 iKey)
{
	return (sxu32)(iKey ^ (iKey << 8) ^ (iKey >> 8));
}

static sxu32 BinHash(const void* pSrc,sxu32 nLen)
{
	register unsigned char* zIn = (unsigned char*)pSrc;
	unsigned char* zEnd;
	sxu32 nH = 5381;
	zEnd = &zIn[nLen];
	for (;;) {
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
		if (zIn >= zEnd) { break; } nH = nH * 33 + zIn[0]; zIn++;
	}
	return nH;
}

static sxi64 HashmapCount(php_hashmap* pMap,int bRecursive,int iRecCount)
{
	sxi64 iCount = 0;
	if (!bRecursive) {
		iCount = pMap->nEntry;
	}
	else {

		php_hashmap_node* pEntry = pMap->pLast;
		php_value* pElem;
		sxu32 n = 0;
		for (;;) {
			if (n >= pMap->nEntry) {
				break;
			}

			pElem = (php_value*)SySetAt(&pMap->pVm->aMemObj,pEntry->nValIdx);
			if (pElem) {
				if (pElem->iFlags & MEMOBJ_HASHMAP) {
					if (iRecCount > 31) {

						return iCount;
					}

					iRecCount++;
					iCount += HashmapCount((php_hashmap*)pElem->x.pOther,TRUE,iRecCount);
					iRecCount--;
				}
			}

			pEntry = pEntry->pNext;
			++n;
		}

		iCount += pMap->nEntry;
	}
	return iCount;
}

static php_hashmap_node* HashmapNewIntNode(php_hashmap* pMap,sxi64 iKey,sxu32 nHash,sxu32 nValIdx)
{
	php_hashmap_node* pNode;

	pNode = (php_hashmap_node*)SyMemBackendPoolAlloc(&pMap->pVm->sAllocator,sizeof(php_hashmap_node));
	if (pNode == 0) {
		return 0;
	}

	SyZero(pNode,sizeof(php_hashmap_node));

	pNode->pMap = &(*pMap);
	pNode->iType = HASHMAP_INT_NODE;
	pNode->nHash = nHash;
	pNode->xKey.iKey = iKey;
	pNode->nValIdx = nValIdx;
	return pNode;
}

static php_hashmap_node* HashmapNewBlobNode(php_hashmap* pMap,const void* pKey,sxu32 nKeyLen,sxu32 nHash,sxu32 nValIdx)
{
	php_hashmap_node* pNode;

	pNode = (php_hashmap_node*)SyMemBackendPoolAlloc(&pMap->pVm->sAllocator,sizeof(php_hashmap_node));
	if (pNode == 0) {
		return 0;
	}

	SyZero(pNode,sizeof(php_hashmap_node));

	pNode->pMap = &(*pMap);
	pNode->iType = HASHMAP_BLOB_NODE;
	pNode->nHash = nHash;
	SyBlobInit(&pNode->xKey.sKey,&pMap->pVm->sAllocator);
	SyBlobAppend(&pNode->xKey.sKey,pKey,nKeyLen);
	pNode->nValIdx = nValIdx;
	return pNode;
}

static void HashmapNodeLink(php_hashmap* pMap,php_hashmap_node* pNode,sxu32 nBucketIdx)
{

	if (pMap->apBucket[nBucketIdx] != 0) {
		pNode->pNextCollide = pMap->apBucket[nBucketIdx];
		pMap->apBucket[nBucketIdx]->pPrevCollide = pNode;
	}
	pMap->apBucket[nBucketIdx] = pNode;

	if (pMap->pFirst == 0) {
		pMap->pFirst = pMap->pLast = pNode;

		pMap->pCur = pNode;
	}
	else {
		MACRO_LD_PUSH(pMap->pLast,pNode);
	}
	++pMap->nEntry;
}

PHP_PRIVATE void PHP_HashmapUnlinkNode(php_hashmap_node* pNode,int bRestore)
{
	php_hashmap* pMap = pNode->pMap;
	php_vm* pVm = pMap->pVm;

	if (pNode->pPrevCollide == 0) {
		pMap->apBucket[pNode->nHash & (pMap->nSize - 1)] = pNode->pNextCollide;
	}
	else {
		pNode->pPrevCollide->pNextCollide = pNode->pNextCollide;
	}
	if (pNode->pNextCollide) {
		pNode->pNextCollide->pPrevCollide = pNode->pPrevCollide;
	}
	if (pMap->pFirst == pNode) {
		pMap->pFirst = pNode->pPrev;
	}
	if (pMap->pCur == pNode) {

		pMap->pCur = pMap->pCur->pPrev;
	}

	MACRO_LD_REMOVE(pMap->pLast,pNode);
	if (bRestore) {

		PHP_VmRefObjRemove(pVm,pNode->nValIdx,0,pNode);

		if ((pNode->iFlags & HASHMAP_NODE_FOREIGN_OBJ) == 0) {
			PHP_VmUnsetMemObj(pVm,pNode->nValIdx,FALSE);
		}
	}
	if (pNode->iType == HASHMAP_BLOB_NODE) {
		SyBlobRelease(&pNode->xKey.sKey);
	}
	SyMemBackendPoolFree(&pVm->sAllocator,pNode);
	pMap->nEntry--;
	if (pMap->nEntry < 1 && pMap != pVm->pGlobal) {

		SyMemBackendFree(&pVm->sAllocator,pMap->apBucket);
		pMap->apBucket = 0;
		pMap->nSize = 0;
		pMap->pFirst = pMap->pLast = pMap->pCur = 0;
	}
}
#define HASHMAP_FILL_FACTOR 3

static sxi32 HashmapGrowBucket(php_hashmap* pMap)
{
	if (pMap->nEntry >= pMap->nSize * HASHMAP_FILL_FACTOR) {
		php_hashmap_node** apOld = pMap->apBucket;
		php_hashmap_node* pEntry,** apNew;
		sxu32 nNew = pMap->nSize << 1;
		sxu32 nBucket;
		sxu32 n;
		if (nNew < 1) {
			nNew = 16;
		}

		apNew = (php_hashmap_node**)SyMemBackendAlloc(&pMap->pVm->sAllocator,nNew * sizeof(php_hashmap_node*));
		if (apNew == 0) {
			if (pMap->nSize < 1) {
				return SXERR_MEM;
			}

			return SXRET_OK;
		}

		SyZero((void*)apNew,nNew * sizeof(php_hashmap_node*));

		pMap->apBucket = apNew;
		pMap->nSize = nNew;
		if (apOld == 0) {

			return SXRET_OK;
		}

		pEntry = pMap->pFirst;
		n = 0;
		for (;; ) {
			if (n >= pMap->nEntry) {
				break;
			}

			pEntry->pNextCollide = pEntry->pPrevCollide = 0;

			nBucket = pEntry->nHash & (nNew - 1);
			if (pMap->apBucket[nBucket] != 0) {
				pEntry->pNextCollide = pMap->apBucket[nBucket];
				pMap->apBucket[nBucket]->pPrevCollide = pEntry;
			}
			pMap->apBucket[nBucket] = pEntry;

			pEntry = pEntry->pPrev;
			n++;
		}

		SyMemBackendFree(&pMap->pVm->sAllocator,(void*)apOld);
	}
	return SXRET_OK;
}

static sxi32 HashmapInsertIntKey(php_hashmap* pMap,sxi64 iKey,php_value* pValue,sxu32 nRefIdx,int isForeign)
{
	php_hashmap_node* pNode;
	sxu32 nIdx;
	sxu32 nHash;
	sxi32 rc;
	if (!isForeign) {
		php_value* pObj;

		pObj = PHP_ReserveMemObj(pMap->pVm);
		if (pObj == 0) {
			return SXERR_MEM;
		}
		if (pValue) {

			PHP_MemObjStore(pValue,pObj);
		}
		nIdx = pObj->nIdx;
	}
	else {
		nIdx = nRefIdx;
	}

	nHash = pMap->xIntHash(iKey);

	pNode = HashmapNewIntNode(&(*pMap),iKey,nHash,nIdx);
	if (pNode == 0) {
		return SXERR_MEM;
	}
	if (isForeign) {

		pNode->iFlags |= HASHMAP_NODE_FOREIGN_OBJ;
	}

	rc = HashmapGrowBucket(&(*pMap));
	if (rc != SXRET_OK) {
		SyMemBackendPoolFree(&pMap->pVm->sAllocator,pNode);
		return rc;
	}

	HashmapNodeLink(&(*pMap),pNode,nHash & (pMap->nSize - 1));

	PHP_VmRefObjInstall(pMap->pVm,nIdx,0,pNode,0);

	return SXRET_OK;
}

static sxi32 HashmapInsertBlobKey(php_hashmap* pMap,const void* pKey,sxu32 nKeyLen,php_value* pValue,sxu32 nRefIdx,int isForeign)
{
	php_hashmap_node* pNode;
	sxu32 nHash;
	sxu32 nIdx;
	sxi32 rc;
	if (!isForeign) {
		php_value* pObj;

		pObj = PHP_ReserveMemObj(pMap->pVm);
		if (pObj == 0) {
			return SXERR_MEM;
		}
		if (pValue) {

			PHP_MemObjStore(pValue,pObj);
		}
		nIdx = pObj->nIdx;
	}
	else {
		nIdx = nRefIdx;
	}

	nHash = pMap->xBlobHash(pKey,nKeyLen);

	pNode = HashmapNewBlobNode(&(*pMap),pKey,nKeyLen,nHash,nIdx);
	if (pNode == 0) {
		return SXERR_MEM;
	}
	if (isForeign) {

		pNode->iFlags |= HASHMAP_NODE_FOREIGN_OBJ;
	}

	rc = HashmapGrowBucket(&(*pMap));
	if (rc != SXRET_OK) {
		SyMemBackendPoolFree(&pMap->pVm->sAllocator,pNode);
		return rc;
	}

	HashmapNodeLink(&(*pMap),pNode,nHash & (pMap->nSize - 1));

	PHP_VmRefObjInstall(pMap->pVm,nIdx,0,pNode,0);

	return SXRET_OK;
}

static sxi32 HashmapLookupIntKey(
	php_hashmap* pMap,
	sxi64 iKey,
	php_hashmap_node** ppNode
)
{
	php_hashmap_node* pNode;
	sxu32 nHash;
	if (pMap->nEntry < 1) {

		return SXERR_NOTFOUND;
	}

	nHash = pMap->xIntHash(iKey);

	pNode = pMap->apBucket[nHash & (pMap->nSize - 1)];

	for (;;) {
		if (pNode == 0) {
			break;
		}
		if (pNode->iType == HASHMAP_INT_NODE
			&& pNode->nHash == nHash
			&& pNode->xKey.iKey == iKey) {

			if (ppNode) {
				*ppNode = pNode;
			}
			return SXRET_OK;
		}

		pNode = pNode->pNextCollide;
	}

	return SXERR_NOTFOUND;
}

static sxi32 HashmapLookupBlobKey(
	php_hashmap* pMap,
	const void* pKey,
	sxu32 nKeyLen,
	php_hashmap_node** ppNode
)
{
	php_hashmap_node* pNode;
	sxu32 nHash;
	if (pMap->nEntry < 1) {

		return SXERR_NOTFOUND;
	}

	nHash = pMap->xBlobHash(pKey,nKeyLen);

	pNode = pMap->apBucket[nHash & (pMap->nSize - 1)];

	for (;;) {
		if (pNode == 0) {
			break;
		}
		if (pNode->iType == HASHMAP_BLOB_NODE
			&& pNode->nHash == nHash
			&& SyBlobLength(&pNode->xKey.sKey) == nKeyLen
			&& SyMemcmp(SyBlobData(&pNode->xKey.sKey),pKey,nKeyLen) == 0) {

			if (ppNode) {
				*ppNode = pNode;
			}
			return SXRET_OK;
		}

		pNode = pNode->pNextCollide;
	}

	return SXERR_NOTFOUND;
}

static int HashmapIsIntKey(SyBlob* pKey)
{
	const char* zIn = (const char*)SyBlobData(pKey);
	const char* zEnd = &zIn[SyBlobLength(pKey)];
	if ((int)(zEnd - zIn) > 1 && zIn[0] == '0') {

		return FALSE;
	}
	if ((zIn[0] == '-' || zIn[0] == '+') && &zIn[1] < zEnd) {
		zIn++;
	}
	for (;;) {
		if (zIn >= zEnd) {
			return TRUE;
		}
		if ((unsigned char)zIn[0] >= 0xc0  || !SyisDigit(zIn[0])) {
			break;
		}
		zIn++;
	}

	return FALSE;
}

static sxi32 HashmapLookup(
	php_hashmap* pMap,
	php_value* pKey,
	php_hashmap_node** ppNode
)
{
	php_hashmap_node* pNode = 0;
	sxi32 rc;
	if (pKey->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) {
		if ((pKey->iFlags & MEMOBJ_STRING) == 0) {

			PHP_MemObjToString(&(*pKey));
		}
		if (SyBlobLength(&pKey->sBlob) > 0 && !HashmapIsIntKey(&pKey->sBlob)) {

			rc = HashmapLookupBlobKey(&(*pMap),SyBlobData(&pKey->sBlob),SyBlobLength(&pKey->sBlob),&pNode);
			goto result;
		}
	}

	if ((pKey->iFlags & MEMOBJ_INT) == 0) {

		PHP_MemObjToInteger(pKey);
	}

	rc = HashmapLookupIntKey(&(*pMap),pKey->x.iVal,&pNode);
result:
	if (rc == SXRET_OK) {

		if (ppNode) {
			*ppNode = pNode;
		}
		return SXRET_OK;
	}

	return SXERR_NOTFOUND;
}

static sxi32 HashmapInsert(
	php_hashmap* pMap,
	php_value* pKey,
	php_value* pVal
)
{
	php_hashmap_node* pNode = 0;
	sxi32 rc = SXRET_OK;
	if (pKey && pKey->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) {
		if ((pKey->iFlags & MEMOBJ_STRING) == 0) {

			PHP_MemObjToString(&(*pKey));
		}
		if (SyBlobLength(&pKey->sBlob) < 1 || HashmapIsIntKey(&pKey->sBlob)) {
			if (SyBlobLength(&pKey->sBlob) < 1) {

				pKey = 0;
			}
			goto IntKey;
		}
		if (SXRET_OK == HashmapLookupBlobKey(&(*pMap),SyBlobData(&pKey->sBlob),
			SyBlobLength(&pKey->sBlob),&pNode)) {

			php_value* pElem;
			pElem = (php_value*)SySetAt(&pMap->pVm->aMemObj,pNode->nValIdx);
			if (pElem) {
				if (pVal) {
					PHP_MemObjStore(pVal,pElem);
				}
				else {

					PHP_MemObjToNull(pElem);
				}
			}
			return SXRET_OK;
		}
		if (pMap == pMap->pVm->pGlobal) {

			PHP_VmThrowError(pMap->pVm,0,PHP_CTX_NOTICE,"$GLOBALS is a read-only array,insertion is forbidden");
			return SXRET_OK;
		}

		rc = HashmapInsertBlobKey(&(*pMap),SyBlobData(&pKey->sBlob),SyBlobLength(&pKey->sBlob),&(*pVal),0,FALSE);
		return rc;
	}
IntKey:
	if (pKey) {
		if ((pKey->iFlags & MEMOBJ_INT) == 0) {

			PHP_MemObjToInteger(pKey);
		}
		if (SXRET_OK == HashmapLookupIntKey(&(*pMap),pKey->x.iVal,&pNode)) {

			php_value* pElem;
			pElem = (php_value*)SySetAt(&pMap->pVm->aMemObj,pNode->nValIdx);
			if (pElem) {
				if (pVal) {
					PHP_MemObjStore(pVal,pElem);
				}
				else {

					PHP_MemObjToNull(pElem);
				}
			}
			return SXRET_OK;
		}
		if (pMap == pMap->pVm->pGlobal) {

			PHP_VmThrowError(pMap->pVm,0,PHP_CTX_NOTICE,"$GLOBALS is a read-only array,insertion is forbidden");
			return SXRET_OK;
		}

		rc = HashmapInsertIntKey(&(*pMap),pKey->x.iVal,&(*pVal),0,FALSE);
		if (rc == SXRET_OK) {
			if (pKey->x.iVal >= pMap->iNextIdx) {

				pMap->iNextIdx = pKey->x.iVal + 1;

				while (SXRET_OK == HashmapLookupIntKey(&(*pMap),pMap->iNextIdx,0)) {
					pMap->iNextIdx++;
				}
			}
		}
	}
	else {
		if (pMap == pMap->pVm->pGlobal) {

			PHP_VmThrowError(pMap->pVm,0,PHP_CTX_NOTICE,"$GLOBALS is a read-only array,insertion is forbidden");
			return SXRET_OK;
		}

		rc = HashmapInsertIntKey(&(*pMap),pMap->iNextIdx,&(*pVal),0,FALSE);
		if (rc == SXRET_OK) {
			++pMap->iNextIdx;
		}
	}

	return rc;
}

static sxi32 HashmapInsertByRef(
	php_hashmap* pMap,
	php_value* pKey,
	sxu32 nRefIdx
)
{
	php_hashmap_node* pNode = 0;
	sxi32 rc = SXRET_OK;
	if (pKey && pKey->iFlags & (MEMOBJ_STRING | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) {
		if ((pKey->iFlags & MEMOBJ_STRING) == 0) {

			PHP_MemObjToString(&(*pKey));
		}
		if (SyBlobLength(&pKey->sBlob) < 1 || HashmapIsIntKey(&pKey->sBlob)) {
			if (SyBlobLength(&pKey->sBlob) < 1) {

				pKey = 0;
			}
			goto IntKey;
		}
		if (SXRET_OK == HashmapLookupBlobKey(&(*pMap),SyBlobData(&pKey->sBlob),
			SyBlobLength(&pKey->sBlob),&pNode)) {

			PHP_VmRefObjRemove(pMap->pVm,pNode->nValIdx,0,pNode);
			pNode->nValIdx = nRefIdx;

			PHP_VmRefObjInstall(pMap->pVm,nRefIdx,0,pNode,0);
			return SXRET_OK;
		}

		rc = HashmapInsertBlobKey(&(*pMap),SyBlobData(&pKey->sBlob),SyBlobLength(&pKey->sBlob),0,nRefIdx,TRUE);
		return rc;
	}
IntKey:
	if (pKey) {
		if ((pKey->iFlags & MEMOBJ_INT) == 0) {

			PHP_MemObjToInteger(pKey);
		}
		if (SXRET_OK == HashmapLookupIntKey(&(*pMap),pKey->x.iVal,&pNode)) {

			PHP_VmRefObjRemove(pMap->pVm,pNode->nValIdx,0,pNode);
			pNode->nValIdx = nRefIdx;

			PHP_VmRefObjInstall(pMap->pVm,nRefIdx,0,pNode,0);
			return SXRET_OK;
		}

		rc = HashmapInsertIntKey(&(*pMap),pKey->x.iVal,0,nRefIdx,TRUE);
		if (rc == SXRET_OK) {
			if (pKey->x.iVal >= pMap->iNextIdx) {

				pMap->iNextIdx = pKey->x.iVal + 1;

				while (SXRET_OK == HashmapLookupIntKey(&(*pMap),pMap->iNextIdx,0)) {
					pMap->iNextIdx++;
				}
			}
		}
	}
	else {

		rc = HashmapInsertIntKey(&(*pMap),pMap->iNextIdx,0,nRefIdx,TRUE);
		if (rc == SXRET_OK) {
			++pMap->iNextIdx;
		}
	}

	return rc;
}

static php_value* HashmapExtractNodeValue(php_hashmap_node* pNode)
{

	php_value* pObj;
	pObj = (php_value*)SySetAt(&pNode->pMap->pVm->aMemObj,pNode->nValIdx);
	return pObj;
}

static sxi32 HashmapInsertNode(php_hashmap* pMap,php_hashmap_node* pNode,int bPreserve)
{
	php_value* pObj;
	sxi32 rc;

	pObj = HashmapExtractNodeValue(&(*pNode));
	if (pObj == 0) {
		return SXERR_EMPTY;
	}

	if (pNode->iType == HASHMAP_INT_NODE) {

		if (!bPreserve) {

			rc = HashmapInsert(&(*pMap),0,pObj);
		}
		else {
			rc = HashmapInsertIntKey(&(*pMap),pNode->xKey.iKey,pObj,0,FALSE);
		}
	}
	else {

		rc = HashmapInsertBlobKey(&(*pMap),SyBlobData(&pNode->xKey.sKey),
			SyBlobLength(&pNode->xKey.sKey),pObj,0,FALSE);
	}
	return rc;
}

static sxi32 HashmapNodeCmp(php_hashmap_node* pLeft,php_hashmap_node* pRight,int bStrict)
{
	php_value sObj1,sObj2;
	sxi32 rc;
	if (pLeft == pRight) {

		return 0;
	}

	PHP_MemObjInit(pLeft->pMap->pVm,&sObj1);
	PHP_MemObjInit(pLeft->pMap->pVm,&sObj2);
	PHP_HashmapExtractNodeValue(pLeft,&sObj1,FALSE);
	PHP_HashmapExtractNodeValue(pRight,&sObj2,FALSE);
	rc = PHP_MemObjCmp(&sObj1,&sObj2,bStrict,0);
	PHP_MemObjRelease(&sObj1);
	PHP_MemObjRelease(&sObj2);
	return rc;
}

static void HashmapRehashIntNode(php_hashmap_node* pEntry)
{
	php_hashmap* pMap = pEntry->pMap;
	sxu32 nBucket;

	if (pEntry->pPrevCollide) {
		pEntry->pPrevCollide->pNextCollide = pEntry->pNextCollide;
	}
	else {
		pMap->apBucket[pEntry->nHash & (pMap->nSize - 1)] = pEntry->pNextCollide;
	}
	if (pEntry->pNextCollide) {
		pEntry->pNextCollide->pPrevCollide = pEntry->pPrevCollide;
	}
	pEntry->pNextCollide = pEntry->pPrevCollide = 0;

	pEntry->nHash = pMap->xIntHash(pMap->iNextIdx);
	pEntry->xKey.iKey = pMap->iNextIdx;
	nBucket = pEntry->nHash & (pMap->nSize - 1);

	pEntry->pNextCollide = pMap->apBucket[nBucket];
	if (pMap->apBucket[nBucket]) {
		pMap->apBucket[nBucket]->pPrevCollide = pEntry;
	}
	pEntry->pNextCollide = pMap->apBucket[nBucket];
	pMap->apBucket[nBucket] = pEntry;

	pMap->iNextIdx++;
}

static int HashmapFindValue(
	php_hashmap* pMap,
	php_value* pNeedle,
	php_hashmap_node** ppNode,
	int bStrict
)
{
	php_hashmap_node* pEntry;
	php_value sVal,* pVal;
	php_value sNeedle;
	sxi32 rc;
	sxu32 n;

	pEntry = pMap->pFirst;
	n = pMap->nEntry;
	PHP_MemObjInit(pMap->pVm,&sVal);
	PHP_MemObjInit(pMap->pVm,&sNeedle);
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			if ((pVal->iFlags | pNeedle->iFlags) & MEMOBJ_NULL) {
				sxi32 iF1 = pVal->iFlags & ~MEMOBJ_AUX;
				sxi32 iF2 = pNeedle->iFlags & ~MEMOBJ_AUX;
				if (iF1 == iF2) {

					if (ppNode) {
						*ppNode = pEntry;
					}
					return SXRET_OK;
				}
			}
			else {

				PHP_MemObjLoad(pVal,&sVal);
				PHP_MemObjLoad(pNeedle,&sNeedle);
				rc = PHP_MemObjCmp(&sNeedle,&sVal,bStrict,0);
				PHP_MemObjRelease(&sVal);
				PHP_MemObjRelease(&sNeedle);
				if (rc == 0) {
					if (ppNode) {
						*ppNode = pEntry;
					}

					return SXRET_OK;
				}
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	return SXERR_NOTFOUND;
}

static int HashmapFindValueByCallback(
	php_hashmap* pMap,
	php_value* pNeedle,
	php_value* pCallback,
	php_hashmap_node** ppNode
)
{
	php_hashmap_node* pEntry;
	php_value sResult,* pVal;
	php_value* apArg[2];
	sxi32 rc;
	sxu32 n;

	pEntry = pMap->pFirst;
	n = pMap->nEntry;

	PHP_MemObjInit(pMap->pVm,&sResult);

	apArg[0] = pNeedle;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {

			apArg[1] = pVal;
			rc = PHP_VmCallUserFunction(pMap->pVm,pCallback,2,apArg,&sResult);
			if (rc == SXRET_OK) {

				if ((sResult.iFlags & MEMOBJ_INT) == 0) {

					PHP_MemObjToInteger(&sResult);
				}
				rc = (sxi32)sResult.x.iVal;
				PHP_MemObjRelease(&sResult);
				if (rc == 0) {

					if (ppNode) {
						*ppNode = pEntry;
					}
					return SXRET_OK;
				}
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	return SXERR_NOTFOUND;
}

PHP_PRIVATE sxi32 PHP_HashmapCmp(
	php_hashmap* pLeft,
	php_hashmap* pRight,
	int bStrict
)
{
	php_hashmap_node* pLe,* pRe;
	sxi32 rc;
	sxu32 n;
	if (pLeft == pRight) {

		return 0;
	}
	if (pLeft->nEntry != pRight->nEntry) {

		return pLeft->nEntry > pRight->nEntry ? 1 : -1;
	}

	pLe = pLeft->pFirst;
	pRe = 0;

	n = pLeft->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}
		if (pLe->iType == HASHMAP_INT_NODE) {

			rc = HashmapLookupIntKey(&(*pRight),pLe->xKey.iKey,&pRe);
		}
		else {
			SyBlob* pKey = &pLe->xKey.sKey;

			rc = HashmapLookupBlobKey(&(*pRight),SyBlobData(pKey),SyBlobLength(pKey),&pRe);
		}
		if (rc != SXRET_OK) {

			return 1;
		}
		rc = 0;
		if (bStrict) {

			if (pLe->iType != pRe->iType) {
				rc = 1;
			}
		}
		if (!rc) {

			rc = HashmapNodeCmp(pLe,pRe,bStrict);
		}
		if (rc != 0) {

			return rc;
		}

		pLe = pLe->pPrev;
		n--;
	}
	return 0;
}

static sxi32 HashmapMerge(php_hashmap* pSrc,php_hashmap* pDest)
{
	php_hashmap_node* pEntry;
	php_value sKey,* pVal;
	sxi32 rc;
	sxu32 n;
	if (pSrc == pDest) {

		return SXRET_OK;
	}

	pEntry = pSrc->pFirst;

	for (n = 0; n < pSrc->nEntry; ++n) {

		pVal = HashmapExtractNodeValue(pEntry);
		if (pEntry->iType == HASHMAP_BLOB_NODE) {

			PHP_MemObjInitFromString(pDest->pVm,&sKey,0);
			PHP_MemObjStringAppend(&sKey,(const char*)SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey));
			rc = PHP_HashmapInsert(&(*pDest),&sKey,pVal);
			PHP_MemObjRelease(&sKey);
		}
		else {
			rc = HashmapInsert(&(*pDest),0,pVal);
		}
		if (rc != SXRET_OK) {
			return rc;
		}

		pEntry = pEntry->pPrev;
	}
	return SXRET_OK;
}

static sxi32 HashmapOverwrite(php_hashmap* pSrc,php_hashmap* pDest)
{
	php_hashmap_node* pEntry;
	php_value sKey,* pVal;
	sxi32 rc;
	sxu32 n;
	if (pSrc == pDest) {

		return SXRET_OK;
	}

	pEntry = pSrc->pFirst;

	for (n = 0; n < pSrc->nEntry; ++n) {

		pVal = HashmapExtractNodeValue(pEntry);
		if (pEntry->iType == HASHMAP_BLOB_NODE) {

			PHP_MemObjInitFromString(pDest->pVm,&sKey,0);
			PHP_MemObjStringAppend(&sKey,(const char*)SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey));
		}
		else {

			PHP_MemObjInitFromInt(pDest->pVm,&sKey,pEntry->xKey.iKey);
		}
		rc = PHP_HashmapInsert(&(*pDest),&sKey,pVal);
		PHP_MemObjRelease(&sKey);
		if (rc != SXRET_OK) {
			return rc;
		}

		pEntry = pEntry->pPrev;
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_HashmapDup(php_hashmap* pSrc,php_hashmap* pDest)
{
	php_hashmap_node* pEntry;
	php_value sKey,* pVal;
	sxi32 rc;
	sxu32 n;
	if (pSrc == pDest) {

		return SXRET_OK;
	}

	pEntry = pSrc->pFirst;

	for (n = 0; n < pSrc->nEntry; ++n) {

		pVal = HashmapExtractNodeValue(pEntry);
		if (pEntry->iType == HASHMAP_BLOB_NODE) {

			PHP_MemObjInitFromString(pDest->pVm,&sKey,0);
			PHP_MemObjStringAppend(&sKey,(const char*)SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey));
			rc = PHP_HashmapInsert(&(*pDest),&sKey,pVal);
			PHP_MemObjRelease(&sKey);
		}
		else {

			rc = HashmapInsertIntKey(&(*pDest),pEntry->xKey.iKey,pVal,0,FALSE);
		}
		if (rc != SXRET_OK) {
			return rc;
		}

		pEntry = pEntry->pPrev;
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_HashmapUnion(php_hashmap* pLeft,php_hashmap* pRight)
{
	php_hashmap_node* pEntry;
	sxi32 rc = SXRET_OK;
	php_value* pObj;
	sxu32 n;
	if (pLeft == pRight) {

		return SXRET_OK;
	}

	pEntry = pRight->pFirst;
	for (n = 0; n < pRight->nEntry; ++n) {

		if (pEntry->iType == HASHMAP_BLOB_NODE) {

			if (SXRET_OK !=
				HashmapLookupBlobKey(&(*pLeft),SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey),0)) {
				pObj = HashmapExtractNodeValue(pEntry);
				if (pObj) {

					rc = HashmapInsertBlobKey(&(*pLeft),SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey),
						pObj,0,FALSE);
					if (rc != SXRET_OK) {
						return rc;
					}
				}
			}
		}
		else {

			if (SXRET_OK != HashmapLookupIntKey(&(*pLeft),pEntry->xKey.iKey,0)) {
				pObj = HashmapExtractNodeValue(pEntry);
				if (pObj) {

					rc = HashmapInsertIntKey(&(*pLeft),pEntry->xKey.iKey,pObj,0,FALSE);
					if (rc != SXRET_OK) {
						return rc;
					}
				}
			}
		}

		pEntry = pEntry->pPrev;
	}
	return SXRET_OK;
}

PHP_PRIVATE php_hashmap* PHP_NewHashmap(
	php_vm* pVm,
	sxu32(*xIntHash)(sxi64),
	sxu32(*xBlobHash)(const void*,sxu32)
)
{
	php_hashmap* pMap;

	pMap = (php_hashmap*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_hashmap));
	if (pMap == 0) {
		return 0;
	}

	SyZero(pMap,sizeof(php_hashmap));

	pMap->pVm = &(*pVm);
	pMap->iRef = 1;

	pMap->xIntHash = xIntHash ? xIntHash : IntHash;
	pMap->xBlobHash = xBlobHash ? xBlobHash : BinHash;
	return pMap;
}

PHP_PRIVATE sxi32 PHP_HashmapCreateSuper(php_vm* pVm)
{
	static const char* azSuper[] = {
		"_SERVER",
		"_GET",
		"_POST",
		"_FILES",
		"_COOKIE",
		"_SESSION",
		"_REQUEST",
		"_ENV",
		"_HEADER",
		"argv"
	};
	php_hashmap* pMap;
	php_value* pObj;
	SyString* pFile;
	sxi32 rc;
	sxu32 n;

	pMap = PHP_NewHashmap(&(*pVm),0,0);
	if (pMap == 0) {
		return SXERR_MEM;
	}
	pVm->pGlobal = pMap;

	pObj = PHP_ReserveMemObj(&(*pVm));
	if (pObj == 0) {
		return SXERR_MEM;
	}
	PHP_MemObjInitFromArray(&(*pVm),pObj,pMap);

	pVm->nGlobalIdx = pObj->nIdx;

	rc = SyHashInsert(&pVm->hSuper,(const void*)"GLOBALS",sizeof("GLOBALS") - 1,SX_INT_TO_PTR(pVm->nGlobalIdx));
	if (rc != SXRET_OK) {
		return rc;
	}

	for (n = 0; n < SX_ARRAYSIZE(azSuper); n++) {
		php_value* pSuper;

		pSuper = php_new_array(&(*pVm));
		if (pSuper == 0) {
			return SXERR_MEM;
		}

		rc = php_vm_config(&(*pVm),PHP_VM_CONFIG_CREATE_SUPER,azSuper[n],pSuper);
		if (rc != SXRET_OK) {
			return rc;
		}

		php_release_value(&(*pVm),pSuper);
	}

	pFile = (SyString*)SySetPeek(&pVm->aFiles);

	php_vm_config(pVm,PHP_VM_CONFIG_SERVER_ATTR,
		"SCRIPT_FILENAME",
		pFile ? pFile->zString : ":Memory:",
		pFile ? pFile->nByte : sizeof(":Memory:") - 1
	);

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_HashmapRelease(php_hashmap* pMap,int FreeDS)
{
	php_hashmap_node* pEntry,* pNext;
	php_vm* pVm = pMap->pVm;
	sxu32 n;
	if (pMap == pVm->pGlobal) {

		PHP_VmThrowError(pMap->pVm,0,PHP_CTX_NOTICE,"$GLOBALS is a read-only array,deletion is forbidden");
		return SXRET_OK;
	}

	n = 0;
	pEntry = pMap->pFirst;
	for (;;) {
		if (n >= pMap->nEntry) {
			break;
		}
		pNext = pEntry->pPrev;

		PHP_VmRefObjRemove(pVm,pEntry->nValIdx,0,pEntry);
		if ((pEntry->iFlags & HASHMAP_NODE_FOREIGN_OBJ) == 0) {

			PHP_VmUnsetMemObj(pVm,pEntry->nValIdx,FALSE);
		}

		if (pEntry->iType == HASHMAP_BLOB_NODE) {
			SyBlobRelease(&pEntry->xKey.sKey);
		}
		SyMemBackendPoolFree(&pVm->sAllocator,pEntry);

		pEntry = pNext;
		n++;
	}
	if (pMap->nEntry > 0) {

		SyMemBackendFree(&pVm->sAllocator,pMap->apBucket);
	}
	if (FreeDS) {

		SyMemBackendPoolFree(&pVm->sAllocator,pMap);
	}
	else {

		pMap->apBucket = 0;
		pMap->iNextIdx = 0;
		pMap->nEntry = pMap->nSize = 0;
		pMap->pFirst = pMap->pLast = pMap->pCur = 0;
	}
	return SXRET_OK;
}

PHP_PRIVATE void  PHP_HashmapUnref(php_hashmap* pMap)
{
	php_vm* pVm = pMap->pVm;

	pMap->iRef--;
	if (pMap->iRef < 1 && pMap != pVm->pGlobal) {
		PHP_HashmapRelease(pMap,TRUE);
	}
}

PHP_PRIVATE sxi32 PHP_HashmapLookup(
	php_hashmap* pMap,
	php_value* pKey,
	php_hashmap_node** ppNode
)
{
	sxi32 rc;
	if (pMap->nEntry < 1) {

		return SXERR_NOTFOUND;
	}
	rc = HashmapLookup(&(*pMap),&(*pKey),ppNode);
	return rc;
}

PHP_PRIVATE sxi32 PHP_HashmapInsert(
	php_hashmap* pMap,
	php_value* pKey,
	php_value* pVal
)
{
	sxi32 rc;
	if (pVal && (pVal->iFlags & MEMOBJ_HASHMAP) && (php_hashmap*)pVal->x.pOther == pMap->pVm->pGlobal) {

		PHP_VmThrowError(pMap->pVm,0,PHP_CTX_ERR,"$GLOBALS is a read-only array,insertion is forbidden");
		return SXRET_OK;
	}
	rc = HashmapInsert(&(*pMap),&(*pKey),&(*pVal));
	return rc;
}

PHP_PRIVATE sxi32 PHP_HashmapInsertByRef(
	php_hashmap* pMap,
	php_value* pKey,
	sxu32 nRefIdx
)
{
	sxi32 rc;
	if (nRefIdx == pMap->pVm->nGlobalIdx) {

		PHP_VmThrowError(pMap->pVm,0,PHP_CTX_ERR,"$GLOBALS is a read-only array,insertion is forbidden");
		return SXRET_OK;
	}
	rc = HashmapInsertByRef(&(*pMap),&(*pKey),nRefIdx);
	return rc;
}

PHP_PRIVATE void PHP_HashmapResetLoopCursor(php_hashmap* pMap)
{

	pMap->pCur = pMap->pFirst;
}

PHP_PRIVATE php_hashmap_node* PHP_HashmapGetNextEntry(php_hashmap* pMap)
{
	php_hashmap_node* pCur = pMap->pCur;
	if (pCur == 0) {

		return 0;
	}

	pMap->pCur = pCur->pPrev;
	return pCur;
}

PHP_PRIVATE void PHP_HashmapExtractNodeValue(php_hashmap_node* pNode,php_value* pValue,int bStore)
{
	php_value* pEntry = HashmapExtractNodeValue(pNode);
	if (pEntry) {
		if (bStore) {
			PHP_MemObjStore(pEntry,pValue);
		}
		else {
			PHP_MemObjLoad(pEntry,pValue);
		}
	}
	else {
		PHP_MemObjRelease(pValue);
	}
}

PHP_PRIVATE void PHP_HashmapExtractNodeKey(php_hashmap_node* pNode,php_value* pKey)
{

	if (pNode->iType == HASHMAP_INT_NODE) {
		if (SyBlobLength(&pKey->sBlob) > 0) {
			SyBlobRelease(&pKey->sBlob);
		}
		pKey->x.iVal = pNode->xKey.iKey;
		MemObjSetType(pKey,MEMOBJ_INT);
	}
	else {
		SyBlobReset(&pKey->sBlob);
		SyBlobAppend(&pKey->sBlob,SyBlobData(&pNode->xKey.sKey),SyBlobLength(&pNode->xKey.sKey));
		MemObjSetType(pKey,MEMOBJ_STRING);
	}
}
#ifndef PHP_DISABLE_BUILTIN_FUNC

PHP_PRIVATE int PHP_HashmapValuesToSet(php_hashmap* pMap,SySet* pOut)
{
	php_hashmap_node* pEntry = pMap->pFirst;
	php_value* pValue;
	sxu32 n;

	SySetInit(pOut,&pMap->pVm->sAllocator,sizeof(php_value*));
	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);
		if (pValue) {
			SySetPut(pOut,(const void*)&pValue);
		}

		pEntry = pEntry->pPrev;
	}

	return (int)SySetUsed(pOut);
}
#endif


typedef sxi32(*ProcNodeCmp)(php_hashmap_node*,php_hashmap_node*,void*);

static php_hashmap_node* HashmapNodeMerge(php_hashmap_node* pA,php_hashmap_node* pB,ProcNodeCmp xCmp,void* pCmpData)
{
	php_hashmap_node result,* pTail;

	result.pNext = result.pPrev = 0;
	pTail = &result;
	while (pA && pB) {
		if (xCmp(pA,pB,pCmpData) < 0) {
			pTail->pPrev = pA;
			pA->pNext = pTail;
			pTail = pA;
			pA = pA->pPrev;
		}
		else {
			pTail->pPrev = pB;
			pB->pNext = pTail;
			pTail = pB;
			pB = pB->pPrev;
		}
	}
	if (pA) {
		pTail->pPrev = pA;
		pA->pNext = pTail;
	}
	else if (pB) {
		pTail->pPrev = pB;
		pB->pNext = pTail;
	}
	else {
		pTail->pPrev = pTail->pNext = 0;
	}
	return result.pPrev;
}

#define N_SORT_BUCKET  32
static sxi32 HashmapMergeSort(php_hashmap* pMap,ProcNodeCmp xCmp,void* pCmpData)
{
	php_hashmap_node* a[N_SORT_BUCKET],* p,* pIn;
	sxu32 i;
	SyZero(a,sizeof(a));

	pIn = pMap->pFirst;
	while (pIn) {
		p = pIn;
		pIn = p->pPrev;
		p->pPrev = 0;
		for (i = 0; i < N_SORT_BUCKET - 1; i++) {
			if (a[i] == 0) {
				a[i] = p;
				break;
			}
			else {
				p = HashmapNodeMerge(a[i],p,xCmp,pCmpData);
				a[i] = 0;
			}
		}
		if (i == N_SORT_BUCKET - 1) {

			a[i] = HashmapNodeMerge(a[i],p,xCmp,pCmpData);
		}
	}
	p = a[0];
	for (i = 1; i < N_SORT_BUCKET; i++) {
		p = HashmapNodeMerge(p,a[i],xCmp,pCmpData);
	}
	p->pNext = 0;

	pMap->pFirst = p;

	pMap->pCur = pMap->pFirst;
	return SXRET_OK;
}

static sxi32 HashmapCmpCallback1(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	php_value sA,sB;
	sxi32 iFlags; int rc;
	if (pCmpData == 0) {

		rc = HashmapNodeCmp(pA,pB,FALSE);
		return rc;
	}
	iFlags = SX_PTR_TO_INT(pCmpData);

	PHP_MemObjInit(pA->pMap->pVm,&sA);
	PHP_MemObjInit(pA->pMap->pVm,&sB);
	PHP_HashmapExtractNodeValue(pA,&sA,FALSE);
	PHP_HashmapExtractNodeValue(pB,&sB,FALSE);
	if (iFlags == 5) {

		if ((sA.iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(&sA);
		}
		if ((sB.iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(&sB);
		}
	}
	else {

		PHP_MemObjToNumeric(&sA);
		PHP_MemObjToNumeric(&sB);
	}

	rc = PHP_MemObjCmp(&sA,&sB,FALSE,0);
	PHP_MemObjRelease(&sA);
	PHP_MemObjRelease(&sB);
	return rc;
}

static sxi32 HashmapCmpCallback2(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	sxi32 rc;
	SXUNUSED(pCmpData);
	if (pA->iType == HASHMAP_BLOB_NODE && pB->iType == HASHMAP_BLOB_NODE) {

		rc = SyBlobCmp(&pA->xKey.sKey,&pB->xKey.sKey);
	}
	else {
		SyString sStr;
		sxi64 iA,iB;

		if (pA->iType == HASHMAP_BLOB_NODE) {

			SyStringInitFromBuf(&sStr,SyBlobData(&pA->xKey.sKey),SyBlobLength(&pA->xKey.sKey));
			if (sStr.nByte < 1) {
				iA = 0;
			}
			else {
				SyStrToInt64(sStr.zString,sStr.nByte,(void*)&iA,0);
			}
		}
		else {
			iA = pA->xKey.iKey;
		}
		if (pB->iType == HASHMAP_BLOB_NODE) {

			SyStringInitFromBuf(&sStr,SyBlobData(&pB->xKey.sKey),SyBlobLength(&pB->xKey.sKey));
			if (sStr.nByte < 1) {
				iB = 0;
			}
			else {
				SyStrToInt64(sStr.zString,sStr.nByte,(void*)&iB,0);
			}
		}
		else {
			iB = pB->xKey.iKey;
		}
		rc = (sxi32)(iA - iB);
	}

	return rc;
}

static sxi32 HashmapCmpCallback3(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	php_value sA,sB;
	sxi32 iFlags; int rc;
	if (pCmpData == 0) {

		rc = HashmapNodeCmp(pA,pB,FALSE);
		return -rc;
	}
	iFlags = SX_PTR_TO_INT(pCmpData);

	PHP_MemObjInit(pA->pMap->pVm,&sA);
	PHP_MemObjInit(pA->pMap->pVm,&sB);
	PHP_HashmapExtractNodeValue(pA,&sA,FALSE);
	PHP_HashmapExtractNodeValue(pB,&sB,FALSE);
	if (iFlags == 5) {

		if ((sA.iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(&sA);
		}
		if ((sB.iFlags & MEMOBJ_STRING) == 0) {
			PHP_MemObjToString(&sB);
		}
	}
	else {

		PHP_MemObjToNumeric(&sA);
		PHP_MemObjToNumeric(&sB);
	}

	rc = PHP_MemObjCmp(&sA,&sB,FALSE,0);
	PHP_MemObjRelease(&sA);
	PHP_MemObjRelease(&sB);
	return -rc;
}

static sxi32 HashmapCmpCallback4(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	php_value sResult,* pCallback;
	php_value* pV1,* pV2;
	php_value* apArg[2];
	sxi32 rc;

	pCallback = (php_value*)pCmpData;

	PHP_MemObjInit(pA->pMap->pVm,&sResult);

	pV1 = HashmapExtractNodeValue(pA);
	pV2 = HashmapExtractNodeValue(pB);
	apArg[0] = pV1;
	apArg[1] = pV2;

	rc = PHP_VmCallUserFunction(pA->pMap->pVm,pCallback,2,apArg,&sResult);
	if (rc != SXRET_OK) {

		rc = -1;
	}
	else {

		if ((sResult.iFlags & MEMOBJ_INT) == 0) {

			PHP_MemObjToInteger(&sResult);
		}
		rc = (sxi32)sResult.x.iVal;
	}
	PHP_MemObjRelease(&sResult);

	return rc;
}

static sxi32 HashmapCmpCallback5(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	sxi32 rc;
	SXUNUSED(pCmpData);
	if (pA->iType == HASHMAP_BLOB_NODE && pB->iType == HASHMAP_BLOB_NODE) {

		rc = SyBlobCmp(&pA->xKey.sKey,&pB->xKey.sKey);
	}
	else {
		SyString sStr;
		sxi64 iA,iB;

		if (pA->iType == HASHMAP_BLOB_NODE) {

			SyStringInitFromBuf(&sStr,SyBlobData(&pA->xKey.sKey),SyBlobLength(&pA->xKey.sKey));
			if (sStr.nByte < 1) {
				iA = 0;
			}
			else {
				SyStrToInt64(sStr.zString,sStr.nByte,(void*)&iA,0);
			}
		}
		else {
			iA = pA->xKey.iKey;
		}
		if (pB->iType == HASHMAP_BLOB_NODE) {

			SyStringInitFromBuf(&sStr,SyBlobData(&pB->xKey.sKey),SyBlobLength(&pB->xKey.sKey));
			if (sStr.nByte < 1) {
				iB = 0;
			}
			else {
				SyStrToInt64(sStr.zString,sStr.nByte,(void*)&iB,0);
			}
		}
		else {
			iB = pB->xKey.iKey;
		}
		rc = (sxi32)(iA - iB);
	}
	return -rc;
}

static sxi32 HashmapCmpCallback6(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	php_value sResult,* pCallback;
	php_value* apArg[2];
	php_value sK1,sK2;
	sxi32 rc;

	pCallback = (php_value*)pCmpData;

	PHP_MemObjInit(pA->pMap->pVm,&sResult);
	PHP_MemObjInit(pA->pMap->pVm,&sK1);
	PHP_MemObjInit(pA->pMap->pVm,&sK2);

	PHP_HashmapExtractNodeKey(pA,&sK1);
	PHP_HashmapExtractNodeKey(pB,&sK2);
	apArg[0] = &sK1;
	apArg[1] = &sK2;

	sK1.nIdx = SXU32_HIGH;
	sK2.nIdx = SXU32_HIGH;

	rc = PHP_VmCallUserFunction(pA->pMap->pVm,pCallback,2,apArg,&sResult);
	if (rc != SXRET_OK) {

		rc = -1;
	}
	else {

		if ((sResult.iFlags & MEMOBJ_INT) == 0) {

			PHP_MemObjToInteger(&sResult);
		}
		rc = (sxi32)sResult.x.iVal;
	}
	PHP_MemObjRelease(&sResult);
	PHP_MemObjRelease(&sK1);
	PHP_MemObjRelease(&sK2);

	return rc;
}

static sxi32 HashmapCmpCallback7(php_hashmap_node* pA,php_hashmap_node* pB,void* pCmpData)
{
	sxu32 n;
	SXUNUSED(pB);
	SXUNUSED(pCmpData);

	n = PHP_VmRandomNum(pA->pMap->pVm);

	return n & 1 ? 1 : -1;
}

static void HashmapSortRehash(php_hashmap* pMap)
{
	php_hashmap_node* p,* pLast;
	sxu32 i;

	pLast = p = pMap->pFirst;
	pMap->iNextIdx = 0;
	i = 0;
	for (;; ) {
		if (i >= pMap->nEntry) {
			pMap->pLast = pLast;
			break;
		}
		if (p->iType == HASHMAP_BLOB_NODE) {

			SyBlobRelease(&p->xKey.sKey);

			p->iType = HASHMAP_INT_NODE;
		}
		HashmapRehashIntNode(p);

		i++;
		pLast = p;
		p = p->pPrev;
	}
}


static int php_hashmap_sort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback1,SX_INT_TO_PTR(iCmpFlags));

		HashmapSortRehash(pMap);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_asort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback1,SX_INT_TO_PTR(iCmpFlags));

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_arsort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback3,SX_INT_TO_PTR(iCmpFlags));

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_ksort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback2,SX_INT_TO_PTR(iCmpFlags));

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_krsort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback5,SX_INT_TO_PTR(iCmpFlags));

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_rsort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		sxi32 iCmpFlags = 0;
		if (nArg > 1) {

			iCmpFlags = php_value_to_int(apArg[1]);
			if (iCmpFlags == 3 ) {
				iCmpFlags = 0;
			}
		}

		HashmapMergeSort(pMap,HashmapCmpCallback3,SX_INT_TO_PTR(iCmpFlags));

		HashmapSortRehash(pMap);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_usort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		php_value* pCallback = 0;
		ProcNodeCmp xCmp;
		xCmp = HashmapCmpCallback4;
		if (nArg > 1 && php_value_is_callable(apArg[1])) {

			pCallback = apArg[1];
		}
		else {

			xCmp = HashmapCmpCallback1;
		}

		HashmapMergeSort(pMap,xCmp,pCallback);

		HashmapSortRehash(pMap);
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_uasort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		php_value* pCallback = 0;
		ProcNodeCmp xCmp;
		xCmp = HashmapCmpCallback4;
		if (nArg > 1 && php_value_is_callable(apArg[1])) {

			pCallback = apArg[1];
		}
		else {

			xCmp = HashmapCmpCallback1;
		}

		HashmapMergeSort(pMap,xCmp,pCallback);

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_uksort(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {
		php_value* pCallback = 0;
		ProcNodeCmp xCmp;
		xCmp = HashmapCmpCallback6;
		if (nArg > 1 && php_value_is_callable(apArg[1])) {

			pCallback = apArg[1];
		}
		else {

			xCmp = HashmapCmpCallback2;
		}

		HashmapMergeSort(pMap,xCmp,pCallback);

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_shuffle(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;

	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry > 1) {

		HashmapMergeSort(pMap,HashmapCmpCallback7,0);

		while (pMap->pLast->pPrev) {
			pMap->pLast = pMap->pLast->pPrev;
		}
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int php_hashmap_count(php_context* pCtx,int nArg,php_value** apArg)
{
	int bRecursive = FALSE;
	sxi64 iCount;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (!php_value_is_array(apArg[0])) {

		int res = !php_value_is_null(apArg[0]);
		php_result_int(pCtx,res);
		return PHP_OK;
	}
	if (nArg > 1) {

		bRecursive = php_value_to_int(apArg[1]) == 1 ;
	}

	iCount = HashmapCount((php_hashmap*)apArg[0]->x.pOther,bRecursive,0);
	php_result_int64(pCtx,iCount);
	return PHP_OK;
}

static int php_hashmap_key_exists(php_context* pCtx,int nArg,php_value** apArg)
{
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	rc = PHP_HashmapLookup((php_hashmap*)apArg[1]->x.pOther,apArg[0],0);

	php_result_bool(pCtx,rc == SXRET_OK ? 1 : 0);
	return PHP_OK;
}

static int php_hashmap_pop(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_null(pCtx);
	}
	else {
		php_hashmap_node* pLast = pMap->pLast;
		php_value* pObj;
		pObj = HashmapExtractNodeValue(pLast);
		if (pObj) {

			php_result_value(pCtx,pObj);

			PHP_HashmapUnlinkNode(pLast,TRUE);
		}
		else {
			php_result_null(pCtx);
		}

		pMap->pCur = pMap->pFirst;
	}
	return PHP_OK;
}

static int php_hashmap_push(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	sxi32 rc; int i;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	for (i = 1; i < nArg; ++i) {
		rc = PHP_HashmapInsert(pMap,0,apArg[i]);
		if (rc != SXRET_OK) {
			break;
		}
	}

	php_result_int64(pCtx,(sxi64)pMap->nEntry);
	return PHP_OK;
}

static int php_hashmap_shift(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_null(pCtx);
	}
	else {
		php_hashmap_node* pEntry = pMap->pFirst;
		php_value* pObj;
		sxu32 n;
		pObj = HashmapExtractNodeValue(pEntry);
		if (pObj) {

			php_result_value(pCtx,pObj);

			PHP_HashmapUnlinkNode(pEntry,TRUE);
		}
		else {
			php_result_null(pCtx);
		}

		n = pMap->nEntry;
		pEntry = pMap->pFirst;
		pMap->iNextIdx = 0;
		for (;;) {
			if (n < 1) {
				break;
			}
			if (pEntry->iType == HASHMAP_INT_NODE) {
				HashmapRehashIntNode(pEntry);
			}

			pEntry = pEntry->pPrev;
			n--;
		}

		pMap->pCur = pMap->pFirst;
	}
	return PHP_OK;
}

static sxi32 HashmapCurrentValue(php_context* pCtx,php_hashmap* pMap,int iDirection)
{
	php_hashmap_node* pCur = pMap->pCur;
	php_value* pVal;
	if (pCur == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (iDirection != 0) {
		if (iDirection > 0) {

			pMap->pCur = pCur->pPrev;
			pCur = pMap->pCur;
		}
		else {

			pMap->pCur = pCur->pNext;
			pCur = pMap->pCur;
		}
		if (pCur == 0) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
	}

	pVal = HashmapExtractNodeValue(pCur);
	if (pVal) {
		php_result_value(pCtx,pVal);
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int php_hashmap_current(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	HashmapCurrentValue(&(*pCtx),(php_hashmap*)apArg[0]->x.pOther,0);
	return PHP_OK;
}

static int php_hashmap_next(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	HashmapCurrentValue(&(*pCtx),(php_hashmap*)apArg[0]->x.pOther,1);
	return PHP_OK;
}

static int php_hashmap_prev(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	HashmapCurrentValue(&(*pCtx),(php_hashmap*)apArg[0]->x.pOther,-1);
	return PHP_OK;
}

static int php_hashmap_end(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	pMap->pCur = pMap->pLast;

	HashmapCurrentValue(&(*pCtx),pMap,0);
	return PHP_OK;
}

static int php_hashmap_reset(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	pMap->pCur = pMap->pFirst;

	HashmapCurrentValue(&(*pCtx),pMap,0);
	return PHP_OK;
}

static int php_hashmap_simple_key(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pCur;
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	pMap = (php_hashmap*)apArg[0]->x.pOther;
	pCur = pMap->pCur;
	if (pCur == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (pCur->iType == HASHMAP_INT_NODE) {

		php_result_int64(pCtx,pCur->xKey.iKey);
	}
	else {

		php_result_string(pCtx,
			(const char*)SyBlobData(&pCur->xKey.sKey),(int)SyBlobLength(&pCur->xKey.sKey));
	}
	return PHP_OK;
}

static int php_hashmap_each(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pCur;
	php_hashmap* pMap;
	php_value* pArray;
	php_value* pVal;
	php_value sKey;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->pCur == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pCur = pMap->pCur;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pVal = HashmapExtractNodeValue(pCur);

	php_array_add_intkey_elem(pArray,1,pVal);
	php_array_add_strkey_elem(pArray,"value",pVal);

	if (pCur->iType == HASHMAP_INT_NODE) {
		PHP_MemObjInitFromInt(pMap->pVm,&sKey,pCur->xKey.iKey);
	}
	else {
		PHP_MemObjInitFromString(pMap->pVm,&sKey,0);
		PHP_MemObjStringAppend(&sKey,(const char*)SyBlobData(&pCur->xKey.sKey),SyBlobLength(&pCur->xKey.sKey));
	}

	php_array_add_intkey_elem(pArray,0,&sKey);
	php_array_add_strkey_elem(pArray,"key",&sKey);
	PHP_MemObjRelease(&sKey);

	pMap->pCur = pCur->pPrev;

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_range(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pValue,* pArray;
	sxi64 iOfft,iLimit; int iStep = 1;

	iOfft = iLimit = 0;
	if (nArg > 0) {

		iOfft = php_value_to_int64(apArg[0]);
		if (nArg > 1) {

			iLimit = php_value_to_int64(apArg[1]);
			if (nArg > 2) {

				iStep = php_value_to_int(apArg[2]);
				if (iStep < 1) {

					iStep = 1;
				}
			}
		}
	}

	pValue = php_context_new_scalar(pCtx);

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	while (iOfft <= iLimit) {
		php_value_int64(pValue,iOfft);

		php_array_add_elem(pArray,0,pValue);

		iOfft += iStep;
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int php_hashmap_values(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pNode;
	php_hashmap* pMap;
	php_value* pArray;
	php_value* pObj;
	sxu32 n;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pNode = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; ++n) {
		pObj = HashmapExtractNodeValue(pNode);
		if (pObj) {

			php_array_add_elem(pArray,0,pObj);
		}

		pNode = pNode->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_keys(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pNode;
	php_hashmap* pMap;
	php_value* pArray;
	php_value sObj;
	php_value sVal;
	SyString sKey; int bStrict;
	sxi32 rc;
	sxu32 n;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}
	bStrict = FALSE;
	if (nArg > 2 && php_value_is_bool(apArg[2])) {
		bStrict = php_value_to_bool(apArg[2]);
	}

	pNode = pMap->pFirst;
	PHP_MemObjInit(pMap->pVm,&sVal);
	for (n = 0; n < pMap->nEntry; ++n) {
		if (pNode->iType == HASHMAP_INT_NODE) {
			PHP_MemObjInitFromInt(pMap->pVm,&sObj,pNode->xKey.iKey);
		}
		else {
			SyStringInitFromBuf(&sKey,SyBlobData(&pNode->xKey.sKey),SyBlobLength(&pNode->xKey.sKey));
			PHP_MemObjInitFromString(pMap->pVm,&sObj,&sKey);
		}
		rc = 0;
		if (nArg > 1) {
			php_value* pValue = HashmapExtractNodeValue(pNode);
			if (pValue) {
				PHP_MemObjLoad(pValue,&sVal);

				rc = php_value_compare(&sVal,apArg[1],bStrict);
				PHP_MemObjRelease(pValue);
			}
		}
		if (rc == 0) {

			php_array_add_elem(pArray,0,&sObj);
		}
		PHP_MemObjRelease(&sObj);

		pNode = pNode->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_same(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* p1,* p2; int rc;
	if (nArg < 2 || !php_value_is_array(apArg[0]) || !php_value_is_array(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	p1 = (php_hashmap*)apArg[0]->x.pOther;
	p2 = (php_hashmap*)apArg[1]->x.pOther;
	rc = (p1 == p2);

	php_result_bool(pCtx,rc);
	return PHP_OK;
}

static int php_hashmap_merge(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap,* pSrc;
	php_value* pArray; int i;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)pArray->x.pOther;

	for (i = 0; i < nArg; i++) {

		if (!php_value_is_array(apArg[i])) {

			php_array_add_elem(pArray,0,apArg[i]);
		}
		else {
			pSrc = (php_hashmap*)apArg[i]->x.pOther;

			HashmapMerge(pSrc,pMap);
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_copy(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	php_value* pArray;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)pArray->x.pOther;
	if (php_value_is_array(apArg[0])) {

		php_hashmap* pSrc = (php_hashmap*)apArg[0]->x.pOther;

		PHP_HashmapDup(pSrc,pMap);
	}
	else {

		PHP_HashmapInsert(pMap,0,apArg[0]);
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_erase(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	PHP_HashmapRelease(pMap,FALSE);
	return PHP_OK;
}

static int php_hashmap_slice(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap,* pSrc;
	php_hashmap_node* pCur;
	php_value* pArray; int iLength,iOfft; int bPreserve;
	sxi32 rc;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;
	bPreserve = FALSE;

	iOfft = php_value_to_int(apArg[1]);
	if (iOfft < 0) {
		iOfft = (int)pSrc->nEntry + iOfft;
	}
	if (iOfft < 0 || iOfft >(int)pSrc->nEntry) {

		iOfft = (int)pSrc->nEntry - 1;
	}

	iLength = (int)pSrc->nEntry - iOfft;
	if (nArg > 2) {
		iLength = php_value_to_int(apArg[2]);
		if (iLength < 0) {
			iLength = ((int)pSrc->nEntry + iLength) - iOfft;
		}
		if (iLength < 0 || iOfft + iLength >= (int)pSrc->nEntry) {
			iLength = (int)pSrc->nEntry - iOfft;
		}
		if (nArg > 3 && php_value_is_bool(apArg[3])) {
			bPreserve = php_value_to_bool(apArg[3]);
		}
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}
	if (iLength < 1) {

		php_result_value(pCtx,pArray);
		return PHP_OK;
	}

	pCur = pSrc->pFirst;
	for (;;) {
		if (iOfft < 1) {
			break;
		}

		pCur = pCur->pPrev;
		iOfft--;
	}

	pMap = (php_hashmap*)pArray->x.pOther;
	for (;;) {
		if (iLength < 1) {
			break;
		}
		rc = HashmapInsertNode(pMap,pCur,bPreserve);
		if (rc != SXRET_OK) {
			break;
		}

		pCur = pCur->pPrev;
		iLength--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_splice(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pCur,* pPrev,* pRnode;
	php_value* pArray,* pRvalue,* pOld;
	php_hashmap* pMap,* pSrc,* pRep; int iLength,iOfft;
	sxi32 rc;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	iOfft = php_value_to_int(apArg[1]);
	if (iOfft < 0) {
		iOfft = (int)pSrc->nEntry + iOfft;
	}
	if (iOfft < 0 || iOfft >(int)pSrc->nEntry) {

		iOfft = (int)pSrc->nEntry - 1;
	}

	iLength = (int)pSrc->nEntry - iOfft;
	if (nArg > 2) {
		iLength = php_value_to_int(apArg[2]);
		if (iLength < 0) {
			iLength = ((int)pSrc->nEntry + iLength) - iOfft;
		}
		if (iLength < 0 || iOfft + iLength >= (int)pSrc->nEntry) {
			iLength = (int)pSrc->nEntry - iOfft;
		}
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}
	if (iLength < 1) {

		php_result_value(pCtx,pArray);
		return PHP_OK;
	}

	pCur = pSrc->pFirst;
	for (;;) {
		if (iOfft < 1) {
			break;
		}

		pCur = pCur->pPrev;
		iOfft--;
	}
	pRep = 0;
	if (nArg > 3) {
		if (!php_value_is_array(apArg[3])) {

			PHP_MemObjToHashmap(apArg[3]);
			if (php_value_is_array(apArg[3])) {
				pRep = (php_hashmap*)apArg[3]->x.pOther;
			}
		}
		else {
			pRep = (php_hashmap*)apArg[3]->x.pOther;
		}
		if (pRep) {

			pRep->pCur = pRep->pFirst;
		}
	}

	pMap = (php_hashmap*)pArray->x.pOther;
	for (;;) {
		if (iLength < 1) {
			break;
		}
		pPrev = pCur->pPrev;
		rc = HashmapInsertNode(pMap,pCur,FALSE);
		if (pRep && (pRnode = PHP_HashmapGetNextEntry(pRep)) != 0) {

			pRvalue = HashmapExtractNodeValue(pRnode);

			pOld = HashmapExtractNodeValue(pCur);
			if (pRvalue && pOld) {
				PHP_MemObjStore(pRvalue,pOld);
			}
		}
		else {

			PHP_HashmapUnlinkNode(pCur,TRUE);
		}
		if (rc != SXRET_OK) {
			break;
		}

		pCur = pPrev;
		iLength--;
	}
	if (pRep) {
		while ((pRnode = PHP_HashmapGetNextEntry(pRep)) != 0) {
			HashmapInsertNode(pSrc,pRnode,FALSE);
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_in_array(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pNeedle; int bStrict; int rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pNeedle = apArg[0];
	bStrict = 0;
	if (nArg > 2) {
		bStrict = php_value_to_bool(apArg[2]);
	}
	if (!php_value_is_array(apArg[1])) {

		rc = php_value_compare(pNeedle,apArg[1],bStrict);

		php_result_bool(pCtx,rc == 0);
		return PHP_OK;
	}

	rc = HashmapFindValue((php_hashmap*)apArg[1]->x.pOther,pNeedle,0,bStrict);

	php_result_bool(pCtx,rc == SXRET_OK);
	return PHP_OK;
}

static int php_hashmap_search(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_value* pVal,sNeedle;
	php_hashmap* pMap;
	php_value sVal; int bStrict;
	sxu32 n; int rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	bStrict = FALSE;
	if (!php_value_is_array(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 2 && php_value_is_bool(apArg[2])) {
		bStrict = php_value_to_bool(apArg[2]);
	}

	pMap = (php_hashmap*)apArg[1]->x.pOther;

	PHP_MemObjInit(pMap->pVm,&sVal);
	PHP_MemObjInit(pMap->pVm,&sNeedle);
	pEntry = pMap->pFirst;
	n = pMap->nEntry;
	for (;;) {
		if (!n) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {

			PHP_MemObjLoad(pVal,&sVal);
			PHP_MemObjLoad(apArg[0],&sNeedle);
			rc = PHP_MemObjCmp(&sNeedle,&sVal,bStrict,0);
			PHP_MemObjRelease(&sVal);
			PHP_MemObjRelease(&sNeedle);
			if (rc == 0) {

				if (pEntry->iType == HASHMAP_INT_NODE) {

					php_result_int64(pCtx,pEntry->xKey.iKey);
				}
				else {
					SyBlob* pKey = &pEntry->xKey.sKey;

					php_result_string(pCtx,(const char*)SyBlobData(pKey),(int)SyBlobLength(pKey));
				}
				return PHP_OK;
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int php_hashmap_diff(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			for (i = 1; i < nArg; i++) {
				if (!php_value_is_array(apArg[i])) {

					continue;
				}

				pMap = (php_hashmap*)apArg[i]->x.pOther;

				rc = HashmapFindValue(pMap,pVal,0,TRUE);
				if (rc == SXRET_OK) {

					break;
				}
			}
			if (i >= nArg) {

				HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_udiff(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pCallback;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pCallback = apArg[nArg - 1];
	if (nArg == 2) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			for (i = 1; i < nArg - 1; i++) {
				if (!php_value_is_array(apArg[i])) {

					continue;
				}

				pMap = (php_hashmap*)apArg[i]->x.pOther;

				rc = HashmapFindValueByCallback(pMap,pVal,pCallback,0);
				if (rc == SXRET_OK) {

					break;
				}
			}
			if (i >= (nArg - 1)) {

				HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_diff_assoc(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pN1,* pN2,* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	pN1 = pN2 = 0;
	for (;;) {
		if (n < 1) {
			break;
		}
		for (i = 1; i < nArg; i++) {
			if (!php_value_is_array(apArg[i])) {

				continue;
			}

			pMap = (php_hashmap*)apArg[i]->x.pOther;

			if (pEntry->iType == HASHMAP_INT_NODE) {
				rc = HashmapLookupIntKey(pMap,pEntry->xKey.iKey,&pN1);
			}
			else {
				rc = HashmapLookupBlobKey(pMap,SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey),&pN1);
			}
			if (rc != SXRET_OK) {

				break;
			}

			pVal = HashmapExtractNodeValue(pEntry);
			if (pVal) {

				rc = HashmapFindValue(pMap,pVal,&pN2,TRUE);
				if (rc != SXRET_OK || pN1 != pN2) {

					break;
				}
			}
		}
		if (i < nArg) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_diff_uassoc(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pN1,* pN2,* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pCallback;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;

	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pCallback = apArg[nArg - 1];
	if (nArg == 2) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	pN1 = pN2 = 0;
	for (;;) {
		if (n < 1) {
			break;
		}
		for (i = 1; i < nArg - 1; i++) {
			if (!php_value_is_array(apArg[i])) {

				continue;
			}

			pMap = (php_hashmap*)apArg[i]->x.pOther;

			if (pEntry->iType == HASHMAP_INT_NODE) {
				rc = HashmapLookupIntKey(pMap,pEntry->xKey.iKey,&pN1);
			}
			else {
				rc = HashmapLookupBlobKey(pMap,SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey),&pN1);
			}
			if (rc != SXRET_OK) {

				break;
			}

			pVal = HashmapExtractNodeValue(pEntry);
			if (pVal) {

				rc = HashmapFindValueByCallback(pMap,pVal,pCallback,&pN2);
				if (rc != SXRET_OK || pN1 != pN2) {

					break;
				}
			}
		}
		if (i < (nArg - 1)) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_diff_key(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}
		for (i = 1; i < nArg; i++) {
			if (!php_value_is_array(apArg[i])) {

				continue;
			}
			pMap = (php_hashmap*)apArg[i]->x.pOther;
			if (pEntry->iType == HASHMAP_BLOB_NODE) {
				SyBlob* pKey = &pEntry->xKey.sKey;

				rc = HashmapLookupBlobKey(pMap,SyBlobData(pKey),SyBlobLength(pKey),0);
			}
			else {

				rc = HashmapLookupIntKey(pMap,pEntry->xKey.iKey,0);
			}
			if (rc == SXRET_OK) {

				break;
			}
		}
		if (i >= nArg) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_intersect(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			for (i = 1; i < nArg; i++) {
				if (!php_value_is_array(apArg[i])) {

					continue;
				}

				pMap = (php_hashmap*)apArg[i]->x.pOther;

				rc = HashmapFindValue(pMap,pVal,0,TRUE);
				if (rc != SXRET_OK) {

					break;
				}
			}
			if (i >= nArg) {

				HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_intersect_assoc(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry,* pN1,* pN2;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	pN1 = pN2 = 0;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			for (i = 1; i < nArg; i++) {
				if (!php_value_is_array(apArg[i])) {

					continue;
				}

				pMap = (php_hashmap*)apArg[i]->x.pOther;

				if (pEntry->iType == HASHMAP_INT_NODE) {
					rc = HashmapLookupIntKey(pMap,pEntry->xKey.iKey,&pN1);
				}
				else {
					rc = HashmapLookupBlobKey(pMap,SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey),&pN1);
				}
				if (rc != SXRET_OK) {

					break;
				}

				rc = HashmapFindValue(pMap,pVal,&pN2,TRUE);
				if (rc != SXRET_OK || pN1 != pN2) {

					break;
				}
			}
			if (i >= nArg) {

				HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_intersect_key(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pArray;
	sxi32 rc;
	sxu32 n; int i;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg == 1) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}
		for (i = 1; i < nArg; i++) {
			if (!php_value_is_array(apArg[i])) {

				continue;
			}
			pMap = (php_hashmap*)apArg[i]->x.pOther;
			if (pEntry->iType == HASHMAP_BLOB_NODE) {
				SyBlob* pKey = &pEntry->xKey.sKey;

				rc = HashmapLookupBlobKey(pMap,SyBlobData(pKey),SyBlobLength(pKey),0);
			}
			else {

				rc = HashmapLookupIntKey(pMap,pEntry->xKey.iKey,0);
			}
			if (rc != SXRET_OK) {

				break;
			}
		}
		if (i >= nArg) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_uintersect(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc,* pMap;
	php_value* pCallback;
	php_value* pArray;
	php_value* pVal;
	sxi32 rc;
	sxu32 n; int i;

	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pCallback = apArg[nArg - 1];
	if (nArg == 2) {

		php_result_value(pCtx,apArg[0]);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pEntry = pSrc->pFirst;
	n = pSrc->nEntry;
	for (;;) {
		if (n < 1) {
			break;
		}

		pVal = HashmapExtractNodeValue(pEntry);
		if (pVal) {
			for (i = 1; i < nArg - 1; i++) {
				if (!php_value_is_array(apArg[i])) {

					continue;
				}

				pMap = (php_hashmap*)apArg[i]->x.pOther;

				rc = HashmapFindValueByCallback(pMap,pVal,pCallback,0);
				if (rc != SXRET_OK) {

					break;
				}
			}
			if (i >= (nArg - 1)) {

				HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
			}
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_fill(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray; int i,nEntry;
	if (nArg < 3) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	nEntry = php_value_to_int(apArg[1]);

	php_array_add_intkey_elem(pArray,php_value_to_int(apArg[0]),apArg[2]);

	for (i = 1; i < nEntry; i++) {
		php_array_add_elem(pArray,0,apArg[2]);
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_fill_keys(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc;
	php_value* pArray;
	sxu32 n;
	if (nArg < 2) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pEntry = pSrc->pFirst;
	for (n = 0; n < pSrc->nEntry; n++) {
		php_array_add_elem(pArray,HashmapExtractNodeValue(pEntry),apArg[1]);

		pEntry = pEntry->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_combine(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pKe,* pVe;
	php_hashmap* pKey,* pValue;
	php_value* pArray;
	sxu32 n;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0]) || !php_value_is_array(apArg[1])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pKey = (php_hashmap*)apArg[0]->x.pOther;
	pValue = (php_hashmap*)apArg[1]->x.pOther;
	if (pKey->nEntry != pValue->nEntry) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pKe = pKey->pFirst;
	pVe = pValue->pFirst;
	for (n = 0; n < pKey->nEntry; n++) {
		php_array_add_elem(pArray,HashmapExtractNodeValue(pKe),HashmapExtractNodeValue(pVe));

		pKe = pKe->pPrev;
		pVe = pVe->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_reverse(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc;
	php_value* pArray; int bPreserve;
	sxu32 n;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	bPreserve = FALSE;
	if (nArg > 1 && php_value_is_bool(apArg[1])) {
		bPreserve = php_value_to_bool(apArg[1]);
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pEntry = pSrc->pLast;
	for (n = 0; n < pSrc->nEntry; n++) {
		HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,bPreserve);

		pEntry = pEntry->pNext;
	}
	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_unique(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_value* pNeedle;
	php_hashmap* pSrc;
	php_value* pArray; int bStrict;
	sxi32 rc;
	sxu32 n;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	bStrict = FALSE;
	if (nArg > 1) {
		bStrict = php_value_to_int(apArg[1]) == 3  ? 1 : 0;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pEntry = pSrc->pFirst;
	for (n = 0; n < pSrc->nEntry; n++) {
		pNeedle = HashmapExtractNodeValue(pEntry);
		rc = SXERR_NOTFOUND;
		if (pNeedle) {
			rc = HashmapFindValue((php_hashmap*)pArray->x.pOther,pNeedle,0,bStrict);
		}
		if (rc != SXRET_OK) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_flip(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pSrc;
	php_value* pArray;
	php_value* pKey;
	php_value sVal;
	sxu32 n;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pSrc = (php_hashmap*)apArg[0]->x.pOther;

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pEntry = pSrc->pFirst;
	for (n = 0; n < pSrc->nEntry; n++) {

		pKey = HashmapExtractNodeValue(pEntry);
		if (pKey && (pKey->iFlags & MEMOBJ_NULL) == 0) {

			if (pEntry->iType == HASHMAP_INT_NODE) {
				PHP_MemObjInitFromInt(pSrc->pVm,&sVal,pEntry->xKey.iKey);
			}
			else {
				SyString sStr;
				SyStringInitFromBuf(&sStr,SyBlobData(&pEntry->xKey.sKey),SyBlobLength(&pEntry->xKey.sKey));
				PHP_MemObjInitFromString(pSrc->pVm,&sVal,&sStr);
			}

			php_array_add_elem(pArray,pKey,&sVal);

			PHP_MemObjRelease(&sVal);
		}

		pEntry = pEntry->pPrev;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static void DoubleSum(php_context* pCtx,php_hashmap* pMap)
{
	php_hashmap_node* pEntry;
	php_value* pObj;
	double dSum = 0;
	sxu32 n;
	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {
		pObj = HashmapExtractNodeValue(pEntry);
		if (pObj && (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) == 0) {
			if (pObj->iFlags & MEMOBJ_REAL) {
				dSum += pObj->rVal;
			}
			else if (pObj->iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
				dSum += (double)pObj->x.iVal;
			}
			else if (pObj->iFlags & MEMOBJ_STRING) {
				if (SyBlobLength(&pObj->sBlob) > 0) {
					double dv = 0;
					SyStrToReal((const char*)SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob),(void*)&dv,0);
					dSum += dv;
				}
			}
		}

		pEntry = pEntry->pPrev;
	}

	php_result_double(pCtx,dSum);
}
static void Int64Sum(php_context* pCtx,php_hashmap* pMap)
{
	php_hashmap_node* pEntry;
	php_value* pObj;
	sxi64 nSum = 0;
	sxu32 n;
	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {
		pObj = HashmapExtractNodeValue(pEntry);
		if (pObj && (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) == 0) {
			if (pObj->iFlags & MEMOBJ_REAL) {
				nSum += (sxi64)pObj->rVal;
			}
			else if (pObj->iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
				nSum += pObj->x.iVal;
			}
			else if (pObj->iFlags & MEMOBJ_STRING) {
				if (SyBlobLength(&pObj->sBlob) > 0) {
					sxi64 nv = 0;
					SyStrToInt64((const char*)SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob),(void*)&nv,0);
					nSum += nv;
				}
			}
		}

		pEntry = pEntry->pPrev;
	}

	php_result_int64(pCtx,nSum);
}

static int php_hashmap_sum(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	php_value* pObj;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pObj = HashmapExtractNodeValue(pMap->pFirst);
	if (pObj == 0) {
		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (pObj->iFlags & MEMOBJ_REAL) {
		DoubleSum(pCtx,pMap);
	}
	else {
		Int64Sum(pCtx,pMap);
	}
	return PHP_OK;
}

static void DoubleProd(php_context* pCtx,php_hashmap* pMap)
{
	php_hashmap_node* pEntry;
	php_value* pObj;
	double dProd;
	sxu32 n;
	pEntry = pMap->pFirst;
	dProd = 1;
	for (n = 0; n < pMap->nEntry; n++) {
		pObj = HashmapExtractNodeValue(pEntry);
		if (pObj && (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) == 0) {
			if (pObj->iFlags & MEMOBJ_REAL) {
				dProd *= pObj->rVal;
			}
			else if (pObj->iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
				dProd *= (double)pObj->x.iVal;
			}
			else if (pObj->iFlags & MEMOBJ_STRING) {
				if (SyBlobLength(&pObj->sBlob) > 0) {
					double dv = 0;
					SyStrToReal((const char*)SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob),(void*)&dv,0);
					dProd *= dv;
				}
			}
		}

		pEntry = pEntry->pPrev;
	}

	php_result_double(pCtx,dProd);
}
static void Int64Prod(php_context* pCtx,php_hashmap* pMap)
{
	php_hashmap_node* pEntry;
	php_value* pObj;
	sxi64 nProd;
	sxu32 n;
	pEntry = pMap->pFirst;
	nProd = 1;
	for (n = 0; n < pMap->nEntry; n++) {
		pObj = HashmapExtractNodeValue(pEntry);
		if (pObj && (pObj->iFlags & (MEMOBJ_NULL | MEMOBJ_HASHMAP | MEMOBJ_OBJ | MEMOBJ_RES)) == 0) {
			if (pObj->iFlags & MEMOBJ_REAL) {
				nProd *= (sxi64)pObj->rVal;
			}
			else if (pObj->iFlags & (MEMOBJ_INT | MEMOBJ_BOOL)) {
				nProd *= pObj->x.iVal;
			}
			else if (pObj->iFlags & MEMOBJ_STRING) {
				if (SyBlobLength(&pObj->sBlob) > 0) {
					sxi64 nv = 0;
					SyStrToInt64((const char*)SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob),(void*)&nv,0);
					nProd *= nv;
				}
			}
		}

		pEntry = pEntry->pPrev;
	}

	php_result_int64(pCtx,nProd);
}

static int php_hashmap_product(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	php_value* pObj;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pObj = HashmapExtractNodeValue(pMap->pFirst);
	if (pObj == 0) {
		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (pObj->iFlags & MEMOBJ_REAL) {
		DoubleProd(pCtx,pMap);
	}
	else {
		Int64Prod(pCtx,pMap);
	}
	return PHP_OK;
}

static int php_hashmap_rand(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pNode;
	php_hashmap* pMap; int nItem = 1;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	if (!php_value_is_array(apArg[0])) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	if (pMap->nEntry < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg > 1) {
		nItem = php_value_to_int(apArg[1]);
	}
	if (nItem < 2) {
		sxu32 nEntry;

		nEntry = PHP_VmRandomNum(pMap->pVm) % pMap->nEntry;

		if (nEntry > pMap->nEntry / 2) {
			pNode = pMap->pLast;
			nEntry = pMap->nEntry - nEntry;
			if (nEntry > 1) {
				for (;;) {
					if (nEntry == 0) {
						break;
					}

					pNode = pNode->pNext;
					nEntry--;
				}
			}
		}
		else {
			pNode = pMap->pFirst;
			for (;;) {
				if (nEntry == 0) {
					break;
				}

				pNode = pNode->pPrev;
				nEntry--;
			}
		}
		if (pNode->iType == HASHMAP_INT_NODE) {

			php_result_int64(pCtx,pNode->xKey.iKey);
		}
		else {

			php_result_string(pCtx,(const char*)SyBlobData(&pNode->xKey.sKey),(int)SyBlobLength(&pNode->xKey.sKey));
		}
	}
	else {
		php_value sKey,* pArray;
		php_hashmap* pDest;

		pArray = php_context_new_array(pCtx);
		if (pArray == 0) {
			php_result_null(pCtx);
			return PHP_OK;
		}

		pDest = (php_hashmap*)pArray->x.pOther;
		PHP_MemObjInit(pDest->pVm,&sKey);

		pNode = pMap->pFirst;
		if (nItem > (int)pMap->nEntry) {
			nItem = (int)pMap->nEntry;
		}
		while (nItem > 0) {
			PHP_HashmapExtractNodeKey(pNode,&sKey);
			PHP_HashmapInsert(pDest,0,&sKey);
			PHP_MemObjRelease(&sKey);

			pNode = pNode->pPrev;
			nItem--;
		}

		HashmapMergeSort(pDest,HashmapCmpCallback7,0);

		HashmapSortRehash(pDest);

		php_result_value(pCtx,pArray);
	}
	return PHP_OK;
}

static int php_hashmap_chunk(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pChunk;
	php_hashmap_node* pEntry;
	php_hashmap* pMap; int bPreserve;
	sxu32 nChunk;
	sxu32 nSize;
	sxu32 n;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	nSize = (sxu32)php_value_to_int(apArg[1]);
	if (nSize < 1) {
		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nSize >= pMap->nEntry) {

		php_array_add_elem(pArray,0,apArg[0]);
		php_result_value(pCtx,pArray);
		return PHP_OK;
	}
	bPreserve = 0;
	if (nArg > 2) {
		bPreserve = php_value_to_bool(apArg[2]);
	}

	pEntry = pMap->pFirst;
	nChunk = 0;
	pChunk = 0;
	n = pMap->nEntry;
	for (;; ) {
		if (n < 1) {
			if (nChunk > 0) {

				php_array_add_elem(pArray,0,pChunk);
			}
			break;
		}
		if (nChunk < 1) {
			if (pChunk) {

				php_array_add_elem(pArray,0,pChunk);
			}

			pChunk = php_context_new_array(pCtx);
			if (pChunk == 0) {
				break;
			}
			nChunk = nSize;
		}

		HashmapInsertNode((php_hashmap*)pChunk->x.pOther,pEntry,bPreserve);

		pEntry = pEntry->pPrev;
		nChunk--;
		n--;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_pad(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	php_value* pArray; int nEntry;
	if (nArg < 3 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	nEntry = php_value_to_int(apArg[1]);
	if (nEntry < 0) {
		nEntry = -nEntry;
		if (nEntry > 1048576) {
			nEntry = 1048576;
		}
		if (nEntry > (int)pMap->nEntry) {
			nEntry -= (int)pMap->nEntry;

			while (nEntry > 0) {
				php_array_add_elem(pArray,0,apArg[2]);
				nEntry--;
			}

			HashmapMerge(pMap,(php_hashmap*)pArray->x.pOther);
		}
		else {
			PHP_HashmapDup(pMap,(php_hashmap*)pArray->x.pOther);
		}
	}
	else if (nEntry > 0) {
		if (nEntry > 1048576) {
			nEntry = 1048576;
		}
		if (nEntry > (int)pMap->nEntry) {
			nEntry -= (int)pMap->nEntry;

			HashmapMerge(pMap,(php_hashmap*)pArray->x.pOther);

			while (nEntry > 0) {
				php_array_add_elem(pArray,0,apArg[2]);
				nEntry--;
			}
		}
		else {
			PHP_HashmapDup(pMap,(php_hashmap*)pArray->x.pOther);
		}
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_replace(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	php_value* pArray; int i;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	for (i = 0; i < nArg; i++) {
		if (!php_value_is_array(apArg[i])) {
			continue;
		}

		pMap = (php_hashmap*)apArg[i]->x.pOther;
		HashmapOverwrite(pMap,(php_hashmap*)pArray->x.pOther);
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_filter(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pMap;
	php_value* pArray;
	php_value sResult;
	php_value* pValue;
	sxi32 rc; int keep;
	sxu32 n;
	if (nArg < 1 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	pEntry = pMap->pFirst;
	PHP_MemObjInit(pMap->pVm,&sResult);
	sResult.nIdx = SXU32_HIGH;

	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);
		if (nArg > 1 && pValue) {

			keep = FALSE;
			rc = PHP_VmCallUserFunction(pMap->pVm,apArg[1],1,&pValue,&sResult);
			if (rc == SXRET_OK) {

				keep = php_value_to_bool(&sResult);
			}
			PHP_MemObjRelease(&sResult);
		}
		else {

			keep = !PHP_MemObjIsEmpty(pValue);
		}
		if (keep) {

			HashmapInsertNode((php_hashmap*)pArray->x.pOther,pEntry,TRUE);
		}

		pEntry = pEntry->pPrev;
	}
	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_map(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pValue,sKey,sResult;
	php_hashmap_node* pEntry;
	php_hashmap* pMap;
	sxu32 n;
	if (nArg < 2 || !php_value_is_array(apArg[1])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[1]->x.pOther;
	PHP_MemObjInit(pMap->pVm,&sResult);
	PHP_MemObjInit(pMap->pVm,&sKey);
	sResult.nIdx = SXU32_HIGH;
	sKey.nIdx = SXU32_HIGH;

	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);
		if (pValue) {
			sxi32 rc;

			rc = PHP_VmCallUserFunction(pMap->pVm,apArg[0],1,&pValue,&sResult);

			PHP_HashmapExtractNodeKey(pEntry,&sKey);
			if (rc != SXRET_OK) {

				php_array_add_elem(pArray,&sKey,pValue);
			}
			else {

				php_array_add_elem(pArray,&sKey,&sResult);
			}
			PHP_MemObjRelease(&sKey);
			PHP_MemObjRelease(&sResult);
		}

		pEntry = pEntry->pPrev;
	}
	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int php_hashmap_reduce(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap_node* pEntry;
	php_hashmap* pMap;
	php_value* pValue;
	php_value sResult;
	sxu32 n;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	PHP_MemObjInit(pMap->pVm,&sResult);
	sResult.nIdx = SXU32_HIGH;
	if (nArg > 2) {

		PHP_MemObjLoad(apArg[2],&sResult);
	}

	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);

		PHP_VmCallUserFunctionAp(pMap->pVm,apArg[1],&sResult,&sResult,pValue,0);

		pEntry = pEntry->pPrev;
	}
	php_result_value(pCtx,&sResult);
	PHP_MemObjRelease(&sResult);
	return PHP_OK;
}

static int php_hashmap_walk(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pValue,* pUserData,sKey;
	php_hashmap_node* pEntry;
	php_hashmap* pMap;
	sxi32 rc;
	sxu32 n;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	pUserData = nArg > 2 ? apArg[2] : 0;

	pMap = (php_hashmap*)apArg[0]->x.pOther;
	PHP_MemObjInit(pMap->pVm,&sKey);
	sKey.nIdx = SXU32_HIGH;

	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);
		if (pValue) {

			PHP_HashmapExtractNodeKey(pEntry,&sKey);

			rc = PHP_VmCallUserFunctionAp(pMap->pVm,apArg[1],0,pValue,&sKey,pUserData,0);
			PHP_MemObjRelease(&sKey);
			if (rc != SXRET_OK) {

				php_result_bool(pCtx,0);
				return PHP_OK;
			}
		}

		pEntry = pEntry->pPrev;
	}

	php_result_bool(pCtx,1);
	return PHP_OK;
}

static int HashmapWalkRecursive(
	php_hashmap* pMap,
	php_value* pCallback,
	php_value* pUserData,
	int iNest
)
{
	php_hashmap_node* pEntry;
	php_value* pValue,sKey;
	sxi32 rc;
	sxu32 n;

	PHP_MemObjInit(pMap->pVm,&sKey);
	sKey.nIdx = SXU32_HIGH;
	pEntry = pMap->pFirst;
	for (n = 0; n < pMap->nEntry; n++) {

		pValue = HashmapExtractNodeValue(pEntry);
		if (pValue) {
			if (pValue->iFlags & MEMOBJ_HASHMAP) {
				if (iNest < 32) {

					iNest++;
					HashmapWalkRecursive((php_hashmap*)pValue->x.pOther,pCallback,pUserData,iNest);
					iNest--;
				}
			}
			else {

				PHP_HashmapExtractNodeKey(pEntry,&sKey);

				rc = PHP_VmCallUserFunctionAp(pMap->pVm,pCallback,0,pValue,&sKey,pUserData,0);
				PHP_MemObjRelease(&sKey);
				if (rc != SXRET_OK) {
					return rc;
				}
			}
		}

		pEntry = pEntry->pPrev;
	}
	return SXRET_OK;
}

static int php_hashmap_walk_recursive(php_context* pCtx,int nArg,php_value** apArg)
{
	php_hashmap* pMap;
	sxi32 rc;
	if (nArg < 2 || !php_value_is_array(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[0]->x.pOther;

	rc = HashmapWalkRecursive(pMap,apArg[1],nArg > 2 ? apArg[2] : 0,0);

	php_result_bool(pCtx,rc == SXRET_OK);
	return PHP_OK;
}

static const php_builtin_func aHashmapFunc[] = {
	{"count",php_hashmap_count},{"sizeof",php_hashmap_count},{"array_key_exists",php_hashmap_key_exists},{"array_pop",php_hashmap_pop},{"array_push",php_hashmap_push},{"array_shift",php_hashmap_shift},{"array_product",php_hashmap_product},{"array_sum",php_hashmap_sum},{"array_keys",php_hashmap_keys},{"array_values",php_hashmap_values},{"array_same",php_hashmap_same},
	{"array_merge",php_hashmap_merge},{"array_slice",php_hashmap_slice},{"array_splice",php_hashmap_splice},{"array_search",php_hashmap_search},{"array_diff",php_hashmap_diff},{"array_udiff",php_hashmap_udiff},{"array_diff_assoc",php_hashmap_diff_assoc},{"array_diff_uassoc",php_hashmap_diff_uassoc},{"array_diff_key",php_hashmap_diff_key},{"array_intersect",php_hashmap_intersect},{"array_intersect_assoc",php_hashmap_intersect_assoc},{"array_uintersect",php_hashmap_uintersect},{"array_intersect_key",php_hashmap_intersect_key},{"array_copy",php_hashmap_copy},{"array_erase",php_hashmap_erase},{"array_fill",php_hashmap_fill},{"array_fill_keys",php_hashmap_fill_keys},{"array_combine",php_hashmap_combine},{"array_reverse",php_hashmap_reverse},{"array_unique",php_hashmap_unique},{"array_flip",php_hashmap_flip},{"array_rand",php_hashmap_rand},{"array_chunk",php_hashmap_chunk},{"array_pad",php_hashmap_pad},{"array_replace",php_hashmap_replace},{"array_filter",php_hashmap_filter},{"array_map",php_hashmap_map},{"array_reduce",php_hashmap_reduce},{"array_walk",php_hashmap_walk},{"array_walk_recursive",php_hashmap_walk_recursive},{"in_array",php_hashmap_in_array},{"sort",php_hashmap_sort},{"asort",php_hashmap_asort},{"arsort",php_hashmap_arsort},{"ksort",php_hashmap_ksort},{"krsort",php_hashmap_krsort},{"rsort",php_hashmap_rsort},{"usort",php_hashmap_usort},{"uasort",php_hashmap_uasort},{"uksort",php_hashmap_uksort},{"shuffle",php_hashmap_shuffle},{"range",php_hashmap_range},{"current",php_hashmap_current},{"each",php_hashmap_each},{"pos",php_hashmap_current},{"next",php_hashmap_next},{"prev",php_hashmap_prev},{"end",php_hashmap_end},{"reset",php_hashmap_reset},{"key",php_hashmap_simple_key}
};

PHP_PRIVATE void PHP_RegisterHashmapFunctions(php_vm* pVm)
{
	sxu32 n;
	for (n = 0; n < SX_ARRAYSIZE(aHashmapFunc); n++) {
		php_create_function(&(*pVm),aHashmapFunc[n].zName,aHashmapFunc[n].xFunc,0);
	}
}

PHP_PRIVATE sxi32 PHP_HashmapDump(SyBlob* pOut,php_hashmap* pMap,int ShowType,int nTab,int nDepth)
{
	php_hashmap_node* pEntry;
	php_value* pObj;
	sxu32 n = 0; int isRef;
	sxi32 rc; int i;
	if (nDepth > 31) {
		static const char zInfinite[] = "Nesting limit reached: Infinite recursion?";

		SyBlobAppend(&(*pOut),zInfinite,sizeof(zInfinite) - 1);
		if (ShowType) {
			SyBlobAppend(&(*pOut),")",sizeof(char));
		}
		return SXERR_LIMIT;
	}

	pEntry = pMap->pFirst;
	rc = SXRET_OK;
	if (!ShowType) {
		SyBlobAppend(&(*pOut),"Array(",sizeof("Array(") - 1);
	}

	SyBlobFormat(&(*pOut),"%u) {",pMap->nEntry);
#ifdef __WINNT__
	SyBlobAppend(&(*pOut),"\r\n",sizeof("\r\n") - 1);
#else
	SyBlobAppend(&(*pOut),"\n",sizeof(char));
#endif
	for (;;) {
		if (n >= pMap->nEntry) {
			break;
		}
		for (i = 0; i < nTab; i++) {
			SyBlobAppend(&(*pOut)," ",sizeof(char));
		}

		if (pEntry->iType == HASHMAP_INT_NODE) {
			SyBlobFormat(&(*pOut),"[%qd] =>",pEntry->xKey.iKey);
		}
		else {
			SyBlobFormat(&(*pOut),"[%.*s] =>",
				SyBlobLength(&pEntry->xKey.sKey),SyBlobData(&pEntry->xKey.sKey));
		}
#ifdef __WINNT__
		SyBlobAppend(&(*pOut),"\r\n",sizeof("\r\n") - 1);
#else
		SyBlobAppend(&(*pOut),"\n",sizeof(char));
#endif

		pObj = HashmapExtractNodeValue(pEntry);
		isRef = 0;
		if (pObj) {
			if (pEntry->iFlags & HASHMAP_NODE_FOREIGN_OBJ) {

				isRef = 1;
			}
			rc = PHP_MemObjDump(&(*pOut),pObj,ShowType,nTab + 1,nDepth,isRef);
			if (rc == SXERR_LIMIT) {
				break;
			}
		}

		n++;
		pEntry = pEntry->pPrev;
	}
	for (i = 0; i < nTab; i++) {
		SyBlobAppend(&(*pOut)," ",sizeof(char));
	}
	SyBlobAppend(&(*pOut),"}",sizeof(char));
	return rc;
}

PHP_PRIVATE sxi32 PHP_HashmapWalk(
	php_hashmap* pMap,
	int (*xWalk)(php_value*,php_value*,void*),
	void* pUserData
)
{
	php_hashmap_node* pEntry;
	php_value sKey,sValue;
	sxi32 rc;
	sxu32 n;

	rc = SXRET_OK;
	PHP_MemObjInit(pMap->pVm,&sKey);
	PHP_MemObjInit(pMap->pVm,&sValue);
	n = pMap->nEntry;
	pEntry = pMap->pFirst;

	for (;;) {
		if (n < 1) {
			break;
		}

		PHP_HashmapExtractNodeKey(pEntry,&sKey);
		PHP_HashmapExtractNodeValue(pEntry,&sValue,FALSE);

		rc = xWalk(&sKey,&sValue,pUserData);

		PHP_MemObjRelease(&sKey);
		PHP_MemObjRelease(&sValue);
		if (rc != PHP_OK) {

			return SXERR_ABORT;
		}

		pEntry = pEntry->pPrev;
		n--;
	}

	return SXRET_OK;
}



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


static void PHP_VER_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
	php_value_string(pVal,php_lib_signature(),-1);
}
#ifdef __WINNT__
#include <Windows.h>
#elif defined(__UNIXES__)
#include <sys/utsname.h>
#endif

static void PHP_OS_Const(php_value* pVal,void* pUnused)
{
#if defined(__WINNT__)
	php_value_string(pVal,"WINNT",(int)sizeof("WINNT") - 1);
#elif defined(__UNIXES__)
	struct utsname sInfo;
	if (uname(&sInfo) != 0) {
		php_value_string(pVal,"Unix",(int)sizeof("Unix") - 1);
	}
	else {
		php_value_string(pVal,sInfo.sysname,-1);
	}
#else
	php_value_string(pVal,"Host OS",(int)sizeof("Host OS") - 1);
#endif
	SXUNUSED(pUnused);
}

static void PHP_EOL_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
#ifdef __WINNT__
	php_value_string(pVal,"\r\n",(int)sizeof("\r\n") - 1);
#else
	php_value_string(pVal,"\n",(int)sizeof(char));
#endif
}

static void PHP_INTMAX_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
	php_value_int64(pVal,SXI64_HIGH);
}

static void PHP_INTSIZE_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
	php_value_int64(pVal,sizeof(sxi64));
}

static void PHP_DIRSEP_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
#ifdef __WINNT__
	php_value_string(pVal,"\\",(int)sizeof(char));
#else
	php_value_string(pVal,"/",(int)sizeof(char));
#endif
}

static void PHP_PATHSEP_Const(php_value* pVal,void* pUnused)
{
	SXUNUSED(pUnused);
#ifdef __WINNT__
	php_value_string(pVal,";",(int)sizeof(char));
#else
	php_value_string(pVal,":",(int)sizeof(char));
#endif
}
#ifndef __WINNT__
#include <time.h>
#endif

static void PHP_TIME_Const(php_value* pVal,void* pUnused)
{
	Sytm sTm;
#ifdef __WINNT__
	SYSTEMTIME sOS;
	GetSystemTime(&sOS);
	SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
	struct tm* pTm;
	time_t t;
	time(&t);
	pTm = gmtime(&t);
	STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	SXUNUSED(pUnused);

	php_value_string_format(pVal,"%02d:%02d:%02d",sTm.tm_hour,sTm.tm_min,sTm.tm_sec);
}

static void PHP_DATE_Const(php_value* pVal,void* pUnused)
{
	Sytm sTm;
#ifdef __WINNT__
	SYSTEMTIME sOS;
	GetSystemTime(&sOS);
	SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
	struct tm* pTm;
	time_t t;
	time(&t);
	pTm = gmtime(&t);
	STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	SXUNUSED(pUnused);

	php_value_string_format(pVal,"%04d-%02d-%02d",sTm.tm_year,sTm.tm_mon + 1,sTm.tm_mday);
}

static void PHP_FILE_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	SyString* pFile;

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile == 0) {

		php_value_string(pVal,":MEMORY:",(int)sizeof(":MEMORY:") - 1);
	}
	else {
		php_value_string(pVal,pFile->zString,pFile->nByte);
	}
}

static void PHP_DIR_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	SyString* pFile;

	pFile = (SyString*)SySetPeek(&pVm->aFiles);
	if (pFile == 0) {

		php_value_string(pVal,":MEMORY:",(int)sizeof(":MEMORY:") - 1);
	}
	else {
		if (pFile->nByte > 0) {
			const char* zDir; int nLen;
			zDir = PHP_ExtractDirName(pFile->zString,(int)pFile->nByte,&nLen);
			php_value_string(pVal,zDir,nLen);
		}
		else {

			php_value_string(pVal,".",(int)sizeof(char));
		}
	}
}

static void PHP_PHP_SHLIB_SUFFIX_Const(php_value* pVal,void* pUserData)
{
#ifdef __WINNT__
	php_value_string(pVal,"dll",(int)sizeof("dll") - 1);
#else
	php_value_string(pVal,"so",(int)sizeof("so") - 1);
#endif
	SXUNUSED(pUserData);
}

static void PHP_E_ERROR_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_E_WARNING_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,2);
	SXUNUSED(pUserData);
}

static void PHP_E_PARSE_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,4);
	SXUNUSED(pUserData);
}

static void PHP_E_NOTICE_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,8);
	SXUNUSED(pUserData);
}

static void PHP_E_CORE_ERROR_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,16);
	SXUNUSED(pUserData);
}

static void PHP_E_CORE_WARNING_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,32);
	SXUNUSED(pUserData);
}

static void PHP_E_COMPILE_ERROR_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,64);
	SXUNUSED(pUserData);
}

static void PHP_E_COMPILE_WARNING_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,128);
	SXUNUSED(pUserData);
}

static void PHP_E_USER_ERROR_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,256);
	SXUNUSED(pUserData);
}

static void PHP_E_USER_WARNING_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,512);
	SXUNUSED(pUserData);
}

static void PHP_E_USER_NOTICE_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1024);
	SXUNUSED(pUserData);
}

static void PHP_E_STRICT_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,2048);
	SXUNUSED(pUserData);
}

static void PHP_E_RECOVERABLE_ERROR_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,4096);
	SXUNUSED(pUserData);
}

static void PHP_E_DEPRECATED_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,8192);
	SXUNUSED(pUserData);
}

static void PHP_E_USER_DEPRECATED_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,16384);
	SXUNUSED(pUserData);
}

static void PHP_E_ALL_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,32767);
	SXUNUSED(pUserData);
}

static void PHP_CASE_LOWER_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,0);
	SXUNUSED(pUserData);
}

static void PHP_CASE_UPPER_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_STR_PAD_LEFT_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,0);
	SXUNUSED(pUserData);
}

static void PHP_STR_PAD_RIGHT_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_STR_PAD_BOTH_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,2);
	SXUNUSED(pUserData);
}

static void PHP_COUNT_NORMAL_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,0);
	SXUNUSED(pUserData);
}

static void PHP_COUNT_RECURSIVE_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_SORT_ASC_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_SORT_DESC_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,2);
	SXUNUSED(pUserData);
}

static void PHP_SORT_REG_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,3);
	SXUNUSED(pUserData);
}

static void PHP_SORT_NUMERIC_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,4);
	SXUNUSED(pUserData);
}

static void PHP_SORT_STRING_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,5);
	SXUNUSED(pUserData);
}

static void PHP_PHP_ROUND_HALF_UP_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,1);
	SXUNUSED(pUserData);
}

static void PHP_PHP_ROUND_HALF_DOWN_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,2);
	SXUNUSED(pUserData);
}

static void PHP_PHP_ROUND_HALF_EVEN_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,3);
	SXUNUSED(pUserData);
}

static void PHP_PHP_ROUND_HALF_ODD_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,4);
	SXUNUSED(pUserData);
}

static void PHP_DBPO_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,0x01);
	SXUNUSED(pUserData);
}

static void PHP_DBIA_Const(php_value* pVal,void* pUserData)
{
	php_value_int(pVal,0x02);
	SXUNUSED(pUserData);
}
#ifdef PHP_ENABLE_MATH_FUNC

static void PHP_M_PI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,PHP_PI);
}

static void PHP_M_E_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,2.7182818284590452354);
}

static void PHP_M_LOG2E_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.4426950408889634074);
}

static void PHP_M_LOG10E_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.4342944819032518276);
}

static void PHP_M_LN2_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.69314718055994530942);
}

static void PHP_M_LN10_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,2.30258509299404568402);
}

static void PHP_M_PI_2_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.57079632679489661923);
}

static void PHP_M_PI_4_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.78539816339744830962);
}

static void PHP_M_1_PI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.31830988618379067154);
}

static void PHP_M_2_PI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.63661977236758134308);
}

static void PHP_M_SQRTPI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.77245385090551602729);
}

static void PHP_M_2_SQRTPI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.12837916709551257390);
}

static void PHP_M_SQRT2_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.41421356237309504880);
}

static void PHP_M_SQRT3_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.73205080756887729352);
}

static void PHP_M_SQRT1_2_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.70710678118654752440);
}

static void PHP_M_LNPI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,1.14472988584940017414);
}

static void PHP_M_EULER_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_double(pVal,0.57721566490153286061);
}
#endif

static void PHP_DATE_ATOM_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"Y-m-d\\TH:i:sP",-1);
}

static void PHP_DATE_COOKIE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"l,d-M-y H:i:s T",-1);
}

static void PHP_DATE_ISO8601_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"Y-m-d\\TH:i:sO",-1);
}

static void PHP_DATE_RFC822_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"D,d M y H:i:s O",-1);
}

static void PHP_DATE_RFC850_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"l,d-M-y H:i:s T",-1);
}

static void PHP_DATE_RFC1036_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"D,d M y H:i:s O",-1);
}

static void PHP_DATE_RFC1123_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"D,d M Y H:i:s O",-1);
}

static void PHP_DATE_RFC2822_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"D,d M Y H:i:s O",-1);
}

static void PHP_DATE_RSS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"D,d M Y H:i:s O",-1);
}

static void PHP_DATE_W3C_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"Y-m-d\\TH:i:sP",-1);
}

static void PHP_ENT_COMPAT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x01);
}

static void PHP_ENT_QUOTES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x02);
}

static void PHP_ENT_NOQUOTES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x04);
}

static void PHP_ENT_IGNORE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x08);
}

static void PHP_ENT_SUBSTITUTE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x10);
}

static void PHP_ENT_DISALLOWED_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x20);
}

static void PHP_ENT_HTML401_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x40);
}

static void PHP_ENT_XML1_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x80);
}

static void PHP_ENT_XHTML_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x100);
}

static void PHP_ENT_HTML5_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x200);
}

static void PHP_ISO88591_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_UTF8_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_HTML_ENTITIES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_HTML_SPECIALCHARS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_PHP_URL_SCHEME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_PHP_URL_HOST_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_PHP_URL_PORT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,3);
}

static void PHP_PHP_URL_USER_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,4);
}

static void PHP_PHP_URL_PASS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,5);
}

static void PHP_PHP_URL_PATH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,6);
}

static void PHP_PHP_URL_QUERY_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,7);
}

static void PHP_PHP_URL_FRAGMENT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,8);
}

static void PHP_PHP_QUERY_RFC1738_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_PHP_QUERY_RFC3986_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_FNM_NOESCAPE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x01);
}

static void PHP_FNM_PATHNAME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x02);
}

static void PHP_FNM_PERIOD_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x04);
}

static void PHP_FNM_CASEFOLD_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x08);
}

static void PHP_PATHINFO_DIRNAME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_PATHINFO_BASENAME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_PATHINFO_EXTENSION_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,3);
}

static void PHP_PATHINFO_FILENAME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,4);
}

static void PHP_ASSERT_ACTIVE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,PHP_ASSERT_DISABLE);
}

static void PHP_ASSERT_WARNING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,PHP_ASSERT_WARNING);
}

static void PHP_ASSERT_BAIL_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,PHP_ASSERT_BAIL);
}

static void PHP_ASSERT_QUIET_EVAL_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,PHP_ASSERT_QUIET_EVAL);
}

static void PHP_ASSERT_CALLBACK_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,PHP_ASSERT_CALLBACK);
}

static void PHP_SEEK_SET_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0);
}

static void PHP_SEEK_CUR_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_SEEK_END_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_LOCK_SH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_LOCK_NB_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,5);
}

static void PHP_LOCK_EX_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x01);
}

static void PHP_LOCK_UN_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0);
}

static void PHP_FILE_USE_INCLUDE_PATH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x1);
}

static void PHP_FILE_IGNORE_NEW_LINES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x2);
}

static void PHP_FILE_SKIP_EMPTY_LINES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x4);
}

static void PHP_FILE_APPEND_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x08);
}

static void PHP_SCANDIR_SORT_ASCENDING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0);
}

static void PHP_SCANDIR_SORT_DESCENDING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_SCANDIR_SORT_NONE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_GLOB_MARK_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x01);
}

static void PHP_GLOB_NOSORT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x02);
}

static void PHP_GLOB_NOCHECK_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x04);
}

static void PHP_GLOB_NOESCAPE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x08);
}

static void PHP_GLOB_BRACE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x10);
}

static void PHP_GLOB_ONLYDIR_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x20);
}

static void PHP_GLOB_ERR_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x40);
}

static void PHP_STDIN_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	void* pResource;
	pResource = PHP_ExportStdin(pVm);
	php_value_resource(pVal,pResource);
}

static void PHP_STDOUT_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	void* pResource;
	pResource = PHP_ExportStdout(pVm);
	php_value_resource(pVal,pResource);
}

static void PHP_STDERR_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	void* pResource;
	pResource = PHP_ExportStderr(pVm);
	php_value_resource(pVal,pResource);
}

static void PHP_INI_SCANNER_NORMAL_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,1);
}

static void PHP_INI_SCANNER_RAW_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,2);
}

static void PHP_EXTR_OVERWRITE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x1);
}

static void PHP_EXTR_SKIP_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x2);
}

static void PHP_EXTR_PREFIX_SAME_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x4);
}

static void PHP_EXTR_PREFIX_ALL_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x8);
}

static void PHP_EXTR_PREFIX_INVALID_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x10);
}

static void PHP_EXTR_IF_EXISTS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x20);
}

static void PHP_EXTR_PREFIX_IF_EXISTS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,0x40);
}
#ifndef PHP_DISABLE_BUILTIN_FUNC

static void PHP_XML_ERROR_NONE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_NO_MEMORY);
}

static void PHP_XML_ERROR_NO_MEMORY_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_NO_MEMORY);
}

static void PHP_XML_ERROR_SYNTAX_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_SYNTAX);
}

static void PHP_XML_ERROR_NO_ELEMENTS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_NO_ELEMENTS);
}

static void PHP_XML_ERROR_INVALID_TOKEN_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_INVALID_TOKEN);
}

static void PHP_XML_ERROR_UNCLOSED_TOKEN_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_UNCLOSED_TOKEN);
}

static void PHP_XML_ERROR_PARTIAL_CHAR_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_PARTIAL_CHAR);
}

static void PHP_XML_ERROR_TAG_MISMATCH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_TAG_MISMATCH);
}

static void PHP_XML_ERROR_DUPLICATE_ATTRIBUTE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_DUPLICATE_ATTRIBUTE);
}

static void PHP_XML_ERROR_JUNK_AFTER_DOC_ELEMENT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_JUNK_AFTER_DOC_ELEMENT);
}

static void PHP_XML_ERROR_PARAM_ENTITY_REF_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_PARAM_ENTITY_REF);
}

static void PHP_XML_ERROR_UNDEFINED_ENTITY_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_UNDEFINED_ENTITY);
}

static void PHP_XML_ERROR_RECURSIVE_ENTITY_REF_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_RECURSIVE_ENTITY_REF);
}

static void PHP_XML_ERROR_ASYNC_ENTITY_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_ASYNC_ENTITY);
}

static void PHP_XML_ERROR_BAD_CHAR_REF_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_BAD_CHAR_REF);
}

static void PHP_XML_ERROR_BINARY_ENTITY_REF_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_BINARY_ENTITY_REF);
}

static void PHP_XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF);
}

static void PHP_XML_ERROR_MISPLACED_XML_PI_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_MISPLACED_XML_PI);
}

static void PHP_XML_ERROR_UNKNOWN_ENCODING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_UNKNOWN_ENCODING);
}

static void PHP_XML_ERROR_INCORRECT_ENCODING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_INCORRECT_ENCODING);
}

static void PHP_XML_ERROR_UNCLOSED_CDATA_SECTION_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_UNCLOSED_CDATA_SECTION);
}

static void PHP_XML_ERROR_EXTERNAL_ENTITY_HANDLING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_ERROR_EXTERNAL_ENTITY_HANDLING);
}

static void PHP_XML_OPTION_CASE_FOLDING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_OPTION_CASE_FOLDING);
}

static void PHP_XML_OPTION_TARGET_ENCODING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_OPTION_TARGET_ENCODING);
}

static void PHP_XML_OPTION_SKIP_TAGSTART_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_OPTION_SKIP_TAGSTART);
}

static void PHP_XML_OPTION_SKIP_WHITE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,SXML_OPTION_SKIP_WHITE);
}

static void PHP_XML_SAX_IMP_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_string(pVal,"Symisc XML engine",(int)sizeof("Symisc XML engine") - 1);
}
#endif

static void PHP_JSON_HEX_TAG_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_HEX_TAG);
}

static void PHP_JSON_HEX_AMP_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_HEX_AMP);
}

static void PHP_JSON_HEX_APOS_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_HEX_APOS);
}

static void PHP_JSON_HEX_QUOT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_HEX_QUOT);
}

static void PHP_JSON_FORCE_OBJECT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_FORCE_OBJECT);
}

static void PHP_JSON_NUMERIC_CHECK_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_NUMERIC_CHECK);
}

static void PHP_JSON_BIGINT_AS_STRING_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_BIGINT_AS_STRING);
}

static void PHP_JSON_PRETTY_PRINT_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_PRETTY_PRINT);
}

static void PHP_JSON_UNESCAPED_SLASHES_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_UNESCAPED_SLASHES);
}

static void PHP_JSON_UNESCAPED_UNICODE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_UNESCAPED_UNICODE);
}

static void PHP_JSON_ERROR_NONE_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_NONE);
}

static void PHP_JSON_ERROR_DEPTH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_DEPTH);
}

static void PHP_JSON_ERROR_STATE_MISMATCH_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_STATE_MISMATCH);
}

static void PHP_JSON_ERROR_CTRL_CHAR_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_CTRL_CHAR);
}

static void PHP_JSON_ERROR_SYNTAX_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_SYNTAX);
}

static void PHP_JSON_ERROR_UTF8_Const(php_value* pVal,void* pUserData)
{
	SXUNUSED(pUserData);
	php_value_int(pVal,JSON_ERROR_UTF8);
}

static void PHP_static_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	php_class* pClass;

	pClass = PHP_VmPeekTopClass(pVm);
	if (pClass) {
		SyString* pName = &pClass->sName;

		php_value_string(pVal,pName->zString,(int)pName->nByte);
	}
	else {

		php_value_string(pVal,"static",sizeof("static") - 1);
	}
}

static void PHP_self_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	php_class* pClass;

	pClass = PHP_VmPeekTopClass(pVm);
	if (pClass) {
		SyString* pName = &pClass->sName;

		php_value_string(pVal,pName->zString,(int)pName->nByte);
	}
	else {

		php_value_null(pVal);
	}
}

static void PHP_parent_Const(php_value* pVal,void* pUserData)
{
	php_vm* pVm = (php_vm*)pUserData;
	php_class* pClass;

	pClass = PHP_VmPeekTopClass(pVm);
	if (pClass && pClass->pBase) {
		SyString* pName = &pClass->pBase->sName;

		php_value_string(pVal,pName->zString,(int)pName->nByte);
	}
	else {

		php_value_null(pVal);
	}
}

static const php_builtin_constant aBuiltIn[] = {
	{"PHP_VERSION",PHP_VER_Const},{"PHP_ENGINE",PHP_VER_Const},{"__PHP__",PHP_VER_Const},{"PHP_OS",PHP_OS_Const},{"PHP_EOL",PHP_EOL_Const},{"PHP_INT_MAX",PHP_INTMAX_Const},{"MAXINT",PHP_INTMAX_Const},{"PHP_INT_SIZE",PHP_INTSIZE_Const},{"PATH_SEPARATOR",PHP_PATHSEP_Const},{"DIRECTORY_SEPARATOR",PHP_DIRSEP_Const},{"DIR_SEP",PHP_DIRSEP_Const},{"__TIME__",PHP_TIME_Const},{"__DATE__",PHP_DATE_Const},{"__FILE__",PHP_FILE_Const},{"__DIR__",PHP_DIR_Const},{"PHP_SHLIB_SUFFIX",PHP_PHP_SHLIB_SUFFIX_Const},{"E_ERROR",PHP_E_ERROR_Const},{"E_WARNING",PHP_E_WARNING_Const},{"E_PARSE",PHP_E_PARSE_Const},{"E_NOTICE",PHP_E_NOTICE_Const},{"E_CORE_ERROR",PHP_E_CORE_ERROR_Const},{"E_CORE_WARNING",PHP_E_CORE_WARNING_Const},{"E_COMPILE_ERROR",PHP_E_COMPILE_ERROR_Const},{"E_COMPILE_WARNING",PHP_E_COMPILE_WARNING_Const},{"E_USER_ERROR",PHP_E_USER_ERROR_Const},{"E_USER_WARNING",PHP_E_USER_WARNING_Const},{"E_USER_NOTICE ",PHP_E_USER_NOTICE_Const},{"E_STRICT",PHP_E_STRICT_Const},{"E_RECOVERABLE_ERROR",PHP_E_RECOVERABLE_ERROR_Const},{"E_DEPRECATED",PHP_E_DEPRECATED_Const},{"E_USER_DEPRECATED",PHP_E_USER_DEPRECATED_Const},{"E_ALL",PHP_E_ALL_Const},{"CASE_LOWER",PHP_CASE_LOWER_Const},{"CASE_UPPER",PHP_CASE_UPPER_Const},{"STR_PAD_LEFT",PHP_STR_PAD_LEFT_Const},{"STR_PAD_RIGHT",PHP_STR_PAD_RIGHT_Const},{"STR_PAD_BOTH",PHP_STR_PAD_BOTH_Const},{"COUNT_NORMAL",PHP_COUNT_NORMAL_Const},{"COUNT_RECURSIVE",PHP_COUNT_RECURSIVE_Const},{"SORT_ASC",PHP_SORT_ASC_Const},{"SORT_DESC",PHP_SORT_DESC_Const},{"SORT_REGULAR",PHP_SORT_REG_Const},{"SORT_NUMERIC",PHP_SORT_NUMERIC_Const},{"SORT_STRING",PHP_SORT_STRING_Const},{"PHP_ROUND_HALF_DOWN",PHP_PHP_ROUND_HALF_DOWN_Const},{"PHP_ROUND_HALF_EVEN",PHP_PHP_ROUND_HALF_EVEN_Const},{"PHP_ROUND_HALF_UP",PHP_PHP_ROUND_HALF_UP_Const},{"PHP_ROUND_HALF_ODD",PHP_PHP_ROUND_HALF_ODD_Const},{"DEBUG_BACKTRACE_IGNORE_ARGS",PHP_DBIA_Const},{"DEBUG_BACKTRACE_PROVIDE_OBJECT",PHP_DBPO_Const},
#ifdef PHP_ENABLE_MATH_FUNC
	{"M_PI",PHP_M_PI_Const},{"M_E",PHP_M_E_Const},{"M_LOG2E",PHP_M_LOG2E_Const},{"M_LOG10E",PHP_M_LOG10E_Const},{"M_LN2",PHP_M_LN2_Const},{"M_LN10",PHP_M_LN10_Const},{"M_PI_2",PHP_M_PI_2_Const},{"M_PI_4",PHP_M_PI_4_Const},{"M_1_PI",PHP_M_1_PI_Const},{"M_2_PI",PHP_M_2_PI_Const},{"M_SQRTPI",PHP_M_SQRTPI_Const},{"M_2_SQRTPI",PHP_M_2_SQRTPI_Const},{"M_SQRT2",PHP_M_SQRT2_Const},{"M_SQRT3",PHP_M_SQRT3_Const},{"M_SQRT1_2",PHP_M_SQRT1_2_Const},{"M_LNPI",PHP_M_LNPI_Const},{"M_EULER",PHP_M_EULER_Const},
#endif
	{"DATE_ATOM",PHP_DATE_ATOM_Const},{"DATE_COOKIE",PHP_DATE_COOKIE_Const},{"DATE_ISO8601",PHP_DATE_ISO8601_Const},{"DATE_RFC822",PHP_DATE_RFC822_Const},{"DATE_RFC850",PHP_DATE_RFC850_Const},{"DATE_RFC1036",PHP_DATE_RFC1036_Const},{"DATE_RFC1123",PHP_DATE_RFC1123_Const},{"DATE_RFC2822",PHP_DATE_RFC2822_Const},{"DATE_RFC3339",PHP_DATE_ATOM_Const},{"DATE_RSS",PHP_DATE_RSS_Const},{"DATE_W3C",PHP_DATE_W3C_Const},{"ENT_COMPAT",PHP_ENT_COMPAT_Const},{"ENT_QUOTES",PHP_ENT_QUOTES_Const},{"ENT_NOQUOTES",PHP_ENT_NOQUOTES_Const},{"ENT_IGNORE",PHP_ENT_IGNORE_Const},{"ENT_SUBSTITUTE",PHP_ENT_SUBSTITUTE_Const},{"ENT_DISALLOWED",PHP_ENT_DISALLOWED_Const},{"ENT_HTML401",PHP_ENT_HTML401_Const},{"ENT_XML1",PHP_ENT_XML1_Const},{"ENT_XHTML",PHP_ENT_XHTML_Const},{"ENT_HTML5",PHP_ENT_HTML5_Const},{"ISO-8859-1",PHP_ISO88591_Const},{"ISO_8859_1",PHP_ISO88591_Const},{"UTF-8",PHP_UTF8_Const},{"UTF8",PHP_UTF8_Const},{"HTML_ENTITIES",PHP_HTML_ENTITIES_Const},{"HTML_SPECIALCHARS",PHP_HTML_SPECIALCHARS_Const},{"PHP_URL_SCHEME",PHP_PHP_URL_SCHEME_Const},{"PHP_URL_HOST",PHP_PHP_URL_HOST_Const},{"PHP_URL_PORT",PHP_PHP_URL_PORT_Const},{"PHP_URL_USER",PHP_PHP_URL_USER_Const},{"PHP_URL_PASS",PHP_PHP_URL_PASS_Const},{"PHP_URL_PATH",PHP_PHP_URL_PATH_Const},{"PHP_URL_QUERY",PHP_PHP_URL_QUERY_Const},{"PHP_URL_FRAGMENT",PHP_PHP_URL_FRAGMENT_Const},{"PHP_QUERY_RFC1738",PHP_PHP_QUERY_RFC1738_Const},{"PHP_QUERY_RFC3986",PHP_PHP_QUERY_RFC3986_Const},{"FNM_NOESCAPE",PHP_FNM_NOESCAPE_Const},{"FNM_PATHNAME",PHP_FNM_PATHNAME_Const},{"FNM_PERIOD",PHP_FNM_PERIOD_Const},{"FNM_CASEFOLD",PHP_FNM_CASEFOLD_Const},{"PATHINFO_DIRNAME",PHP_PATHINFO_DIRNAME_Const},{"PATHINFO_BASENAME",PHP_PATHINFO_BASENAME_Const},{"PATHINFO_EXTENSION",PHP_PATHINFO_EXTENSION_Const},{"PATHINFO_FILENAME",PHP_PATHINFO_FILENAME_Const},{"ASSERT_ACTIVE",PHP_ASSERT_ACTIVE_Const},{"ASSERT_WARNING",PHP_ASSERT_WARNING_Const},{"ASSERT_BAIL",PHP_ASSERT_BAIL_Const},{"ASSERT_QUIET_EVAL",PHP_ASSERT_QUIET_EVAL_Const},{"ASSERT_CALLBACK",PHP_ASSERT_CALLBACK_Const},{"SEEK_SET",PHP_SEEK_SET_Const},{"SEEK_CUR",PHP_SEEK_CUR_Const},{"SEEK_END",PHP_SEEK_END_Const},{"LOCK_EX",PHP_LOCK_EX_Const},{"LOCK_SH",PHP_LOCK_SH_Const},{"LOCK_NB",PHP_LOCK_NB_Const},{"LOCK_UN",PHP_LOCK_UN_Const},{"FILE_USE_INCLUDE_PATH",PHP_FILE_USE_INCLUDE_PATH_Const},{"FILE_IGNORE_NEW_LINES",PHP_FILE_IGNORE_NEW_LINES_Const},{"FILE_SKIP_EMPTY_LINES",PHP_FILE_SKIP_EMPTY_LINES_Const},{"FILE_APPEND",PHP_FILE_APPEND_Const},{"SCANDIR_SORT_ASCENDING",PHP_SCANDIR_SORT_ASCENDING_Const},{"SCANDIR_SORT_DESCENDING",PHP_SCANDIR_SORT_DESCENDING_Const},{"SCANDIR_SORT_NONE",PHP_SCANDIR_SORT_NONE_Const},{"GLOB_MARK",PHP_GLOB_MARK_Const},{"GLOB_NOSORT",PHP_GLOB_NOSORT_Const},{"GLOB_NOCHECK",PHP_GLOB_NOCHECK_Const},{"GLOB_NOESCAPE",PHP_GLOB_NOESCAPE_Const},{"GLOB_BRACE",PHP_GLOB_BRACE_Const},{"GLOB_ONLYDIR",PHP_GLOB_ONLYDIR_Const},{"GLOB_ERR",PHP_GLOB_ERR_Const},{"STDIN",PHP_STDIN_Const},{"stdin",PHP_STDIN_Const},{"STDOUT",PHP_STDOUT_Const},{"stdout",PHP_STDOUT_Const},{"INI_SCANNER_NORMAL",PHP_INI_SCANNER_NORMAL_Const},{"INI_SCANNER_RAW",PHP_INI_SCANNER_RAW_Const},{"EXTR_OVERWRITE",PHP_EXTR_OVERWRITE_Const},{"EXTR_SKIP",PHP_EXTR_SKIP_Const},{"EXTR_PREFIX_SAME",PHP_EXTR_PREFIX_SAME_Const},{"EXTR_PREFIX_ALL",PHP_EXTR_PREFIX_ALL_Const},{"EXTR_PREFIX_INVALID",PHP_EXTR_PREFIX_INVALID_Const},{"EXTR_IF_EXISTS",PHP_EXTR_IF_EXISTS_Const},{"EXTR_PREFIX_IF_EXISTS",PHP_EXTR_PREFIX_IF_EXISTS_Const},
#ifndef PHP_DISABLE_BUILTIN_FUNC
	{"XML_ERROR_NONE",PHP_XML_ERROR_NONE_Const},{"XML_ERROR_NO_MEMORY",PHP_XML_ERROR_NO_MEMORY_Const},{"XML_ERROR_SYNTAX",PHP_XML_ERROR_SYNTAX_Const},{"XML_ERROR_NO_ELEMENTS",PHP_XML_ERROR_NO_ELEMENTS_Const},{"XML_ERROR_INVALID_TOKEN",PHP_XML_ERROR_INVALID_TOKEN_Const},{"XML_ERROR_UNCLOSED_TOKEN",PHP_XML_ERROR_UNCLOSED_TOKEN_Const},{"XML_ERROR_PARTIAL_CHAR",PHP_XML_ERROR_PARTIAL_CHAR_Const},{"XML_ERROR_TAG_MISMATCH",PHP_XML_ERROR_TAG_MISMATCH_Const},{"XML_ERROR_DUPLICATE_ATTRIBUTE",PHP_XML_ERROR_DUPLICATE_ATTRIBUTE_Const},{"XML_ERROR_JUNK_AFTER_DOC_ELEMENT",PHP_XML_ERROR_JUNK_AFTER_DOC_ELEMENT_Const},{"XML_ERROR_PARAM_ENTITY_REF",PHP_XML_ERROR_PARAM_ENTITY_REF_Const},{"XML_ERROR_UNDEFINED_ENTITY",PHP_XML_ERROR_UNDEFINED_ENTITY_Const},{"XML_ERROR_RECURSIVE_ENTITY_REF",PHP_XML_ERROR_RECURSIVE_ENTITY_REF_Const},{"XML_ERROR_ASYNC_ENTITY",PHP_XML_ERROR_ASYNC_ENTITY_Const},{"XML_ERROR_BAD_CHAR_REF",PHP_XML_ERROR_BAD_CHAR_REF_Const},{"XML_ERROR_BINARY_ENTITY_REF",PHP_XML_ERROR_BINARY_ENTITY_REF_Const},{"XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF",PHP_XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF_Const},{"XML_ERROR_MISPLACED_XML_PI",PHP_XML_ERROR_MISPLACED_XML_PI_Const},{"XML_ERROR_UNKNOWN_ENCODING",PHP_XML_ERROR_UNKNOWN_ENCODING_Const},{"XML_ERROR_INCORRECT_ENCODING",PHP_XML_ERROR_INCORRECT_ENCODING_Const},{"XML_ERROR_UNCLOSED_CDATA_SECTION",PHP_XML_ERROR_UNCLOSED_CDATA_SECTION_Const},{"XML_ERROR_EXTERNAL_ENTITY_HANDLING",PHP_XML_ERROR_EXTERNAL_ENTITY_HANDLING_Const},{"XML_OPTION_CASE_FOLDING",PHP_XML_OPTION_CASE_FOLDING_Const},{"XML_OPTION_TARGET_ENCODING",PHP_XML_OPTION_TARGET_ENCODING_Const},{"XML_OPTION_SKIP_TAGSTART",PHP_XML_OPTION_SKIP_TAGSTART_Const},{"XML_OPTION_SKIP_WHITE",PHP_XML_OPTION_SKIP_WHITE_Const},{"XML_SAX_IMPL",PHP_XML_SAX_IMP_Const},
#endif
	{"JSON_HEX_TAG",PHP_JSON_HEX_TAG_Const},{"JSON_HEX_AMP",PHP_JSON_HEX_AMP_Const},{"JSON_HEX_APOS",PHP_JSON_HEX_APOS_Const},{"JSON_HEX_QUOT",PHP_JSON_HEX_QUOT_Const},{"JSON_FORCE_OBJECT",PHP_JSON_FORCE_OBJECT_Const},{"JSON_NUMERIC_CHECK",PHP_JSON_NUMERIC_CHECK_Const},{"JSON_BIGINT_AS_STRING",PHP_JSON_BIGINT_AS_STRING_Const},{"JSON_PRETTY_PRINT",PHP_JSON_PRETTY_PRINT_Const},{"JSON_UNESCAPED_SLASHES",PHP_JSON_UNESCAPED_SLASHES_Const},{"JSON_UNESCAPED_UNICODE",PHP_JSON_UNESCAPED_UNICODE_Const},{"JSON_ERROR_NONE",PHP_JSON_ERROR_NONE_Const},{"JSON_ERROR_DEPTH",PHP_JSON_ERROR_DEPTH_Const},{"JSON_ERROR_STATE_MISMATCH",PHP_JSON_ERROR_STATE_MISMATCH_Const},{"JSON_ERROR_CTRL_CHAR",PHP_JSON_ERROR_CTRL_CHAR_Const},{"JSON_ERROR_SYNTAX",PHP_JSON_ERROR_SYNTAX_Const},{"JSON_ERROR_UTF8",PHP_JSON_ERROR_UTF8_Const},{"static",PHP_static_Const},{"self",PHP_self_Const},{"__CLASS__",PHP_self_Const},{"parent",PHP_parent_Const       }
};

PHP_PRIVATE void PHP_RegisterBuiltInConstant(php_vm* pVm)
{
	sxu32 n;

	for (n = 0; n < SX_ARRAYSIZE(aBuiltIn); ++n) {
		php_create_constant(&(*pVm),aBuiltIn[n].zName,aBuiltIn[n].xExpand,&(*pVm));
	}
}



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif


typedef struct LangConstruct LangConstruct;typedef struct JumpFixup     JumpFixup;typedef struct Label         Label;

#define GEN_BLOCK_LOOP        0x001
#define GEN_BLOCK_PROTECTED   0x002
#define GEN_BLOCK_COND        0x004
#define GEN_BLOCK_FUNC        0x008
#define GEN_BLOCK_GLOBAL      0x010
#define GEN_BLOC_NESTED_FUNC  0x020
#define GEN_BLOCK_EXPR        0x040
#define GEN_BLOCK_STD         0x080
#define GEN_BLOCK_EXCEPTION   0x100
#define GEN_BLOCK_SWITCH      0x200

struct Label
{
	php_vm_func* pFunc;
	sxu32 nJumpDest;
	SyString sName;
	sxu32 nLine;
	sxu8 bRef;
};

struct JumpFixup
{
	sxi32 nJumpType;
	sxu32 nInstrIdx;

	SyString sLabel;
	php_vm_func* pFunc;
	sxu32 nLine;
};

struct LangConstruct
{
	sxu32 nID;
	ProcLangConstruct xConstruct;
};

#define PHP_COMPILE_SINGLE_STMT 0x001

#define SWAP_TOKEN_STREAM(GEN,START,END)\
			pTmp  = GEN->pEnd;\
			pGen->pIn  = START;\
			pGen->pEnd = END
#define UPDATE_TOKEN_STREAM(GEN)\
			if( GEN->pIn < pTmp ){\
				GEN->pIn++;\
			}\
			GEN->pEnd = pTmp
#define SWAP_DELIMITER(GEN,START,END)\
			pTmpIn  = GEN->pIn;\
			pTmpEnd = GEN->pEnd;\
			GEN->pIn = START;\
			GEN->pEnd = END
#define RE_SWAP_DELIMITER(GEN)\
			GEN->pIn  = pTmpIn;\
			GEN->pEnd = pTmpEnd

#define EXPR_FLAG_LOAD_IDX_STORE    0x001
#define EXPR_FLAG_RDONLY_LOAD       0x002
#define EXPR_FLAG_COMMA_STATEMENT   0x004

static sxi32 PHP_CompileExpr(php_gen_state* pGen,sxi32 iFlags,sxi32(*xTreeValidator)(php_gen_state*,php_expr_node*));


static sxi32 GenStateGetLabel(php_gen_state* pGen,SyString* pName,Label** ppOut)
{
	Label* aLabel;
	sxu32 n;

	aLabel = (Label*)SySetBasePtr(&pGen->aLabel);
	for (n = 0; n < SySetUsed(&pGen->aLabel); ++n) {
		if (SyStringCmp(&aLabel[n].sName,pName,SyMemcmp) == 0) {

			aLabel[n].bRef = TRUE;
			if (ppOut) {
				*ppOut = &aLabel[n];
			}
			return SXRET_OK;
		}
	}

	return SXERR_NOTFOUND;
}

static GenBlock* GenStateFetchBlock(GenBlock* pCurrent,sxi32 iBlockType,sxi32 iCount)
{
	GenBlock* pBlock = pCurrent;
	for (;;) {
		if (pBlock->iFlags & iBlockType) {
			iCount--;
			if (iCount < 1) {

				return pBlock;
			}
		}

		pBlock = pBlock->pParent;
		if (pBlock == 0 || (pBlock->iFlags & (GEN_BLOCK_PROTECTED | GEN_BLOCK_FUNC))) {

			break;
		}
	}

	return 0;
}

static void GenStateInitBlock(
	php_gen_state* pGen,
	GenBlock* pBlock,
	sxi32 iType,
	sxu32 nFirstInstr,
	void* pUserData
)
{

	pBlock->nFirstInstr = nFirstInstr;
	pBlock->pUserData = pUserData;
	pBlock->pGen = pGen;
	pBlock->iFlags = iType;
	pBlock->pParent = 0;
	SySetInit(&pBlock->aJumpFix,&pGen->pVm->sAllocator,sizeof(JumpFixup));
	SySetInit(&pBlock->aPostContFix,&pGen->pVm->sAllocator,sizeof(JumpFixup));
}

static sxi32 GenStateEnterBlock(
	php_gen_state* pGen,
	sxi32 iType,
	sxu32 nFirstInstr,
	void* pUserData,
	GenBlock** ppBlock
)
{
	GenBlock* pBlock;

	pBlock = (GenBlock*)SyMemBackendPoolAlloc(&pGen->pVm->sAllocator,sizeof(GenBlock));
	if (pBlock == 0) {

		PHP_GenCompileError(&(*pGen),E_ERROR,1,"Fatal,PHP engine is running out-of-memory");

		return SXERR_ABORT;
	}

	SyZero(pBlock,sizeof(GenBlock));
	GenStateInitBlock(&(*pGen),pBlock,iType,nFirstInstr,pUserData);

	pBlock->pParent = pGen->pCurrent;

	pGen->pCurrent = pBlock;
	if (ppBlock) {

		*ppBlock = pBlock;
	}
	return SXRET_OK;
}

static void GenStateReleaseBlock(GenBlock* pBlock)
{
	SySetRelease(&pBlock->aPostContFix);
	SySetRelease(&pBlock->aJumpFix);
}

static void GenStateFreeBlock(GenBlock* pBlock)
{
	php_gen_state* pGen = pBlock->pGen;
	GenStateReleaseBlock(&(*pBlock));

	SyMemBackendPoolFree(&pGen->pVm->sAllocator,pBlock);
}

static sxi32 GenStateLeaveBlock(php_gen_state* pGen,GenBlock** ppBlock)
{
	GenBlock* pBlock = pGen->pCurrent;
	if (pBlock == 0) {

		return SXERR_EMPTY;
	}

	pGen->pCurrent = pBlock->pParent;
	if (ppBlock) {

		*ppBlock = pBlock;
	}
	else {

		GenStateFreeBlock(&(*pBlock));
	}
	return SXRET_OK;
}

static sxi32 GenStateNewJumpFixup(GenBlock* pBlock,sxi32 nJumpType,sxu32 nInstrIdx)
{
	JumpFixup sJumpFix;
	sxi32 rc;

	sJumpFix.nJumpType = nJumpType;
	sJumpFix.nInstrIdx = nInstrIdx;

	rc = SySetPut(&pBlock->aJumpFix,(const void*)&sJumpFix);
	return rc;
}

static sxu32 GenStateFixJumps(GenBlock* pBlock,sxi32 nJumpType,sxu32 nJumpDest)
{
	JumpFixup* aFix;
	VmInstr* pInstr;
	sxu32 nFixed;
	sxu32 n;

	aFix = (JumpFixup*)SySetBasePtr(&pBlock->aJumpFix);

	for (nFixed = n = 0; n < SySetUsed(&pBlock->aJumpFix); ++n) {
		if (aFix[n].nJumpType < 0) {

			continue;
		}
		if (nJumpType > 0 && aFix[n].nJumpType != nJumpType) {

			continue;
		}

		pInstr = PHP_VmGetInstr(pBlock->pGen->pVm,aFix[n].nInstrIdx);
		if (pInstr) {
			pInstr->iP2 = nJumpDest;
			nFixed++;

			aFix[n].nJumpType = -1;
		}
	}

	return nFixed;
}

static sxi32 GenStateFixGoto(php_gen_state* pGen,sxu32 nOfft)
{
	JumpFixup* pJump,* aJumps;
	Label* pLabel,* aLabel;
	VmInstr* pInstr;
	sxi32 rc;
	sxu32 n;

	aJumps = (JumpFixup*)SySetBasePtr(&pGen->aGoto);

	for (n = nOfft; n < SySetUsed(&pGen->aGoto); ++n) {
		pJump = &aJumps[n];

		rc = GenStateGetLabel(&(*pGen),&pJump->sLabel,&pLabel);
		if (rc != SXRET_OK) {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pJump->nLine,"Label '%z' was referenced but not defined",&pJump->sLabel);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			continue;
		}

		if (pLabel->pFunc != pJump->pFunc) {
			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pJump->nLine,"Label '%z' is unreachable",&pJump->sLabel);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}

		pInstr = PHP_VmGetInstr(pGen->pVm,pJump->nInstrIdx);
		if (pInstr) {
			pInstr->iP2 = pLabel->nJumpDest;
		}
	}
	aLabel = (Label*)SySetBasePtr(&pGen->aLabel);
	for (n = 0; n < SySetUsed(&pGen->aLabel); ++n) {
		if (aLabel[n].bRef == FALSE) {

			PHP_GenCompileError(&(*pGen),E_WARNING,aLabel[n].nLine,
				"Label '%z' is defined but not referenced",&aLabel[n].sName);
		}
	}
	return SXRET_OK;
}

static sxi32 GenStateFindLiteral(php_gen_state* pGen,const SyString* pValue,sxu32* pIdx)
{
	SyHashEntry* pEntry;
	pEntry = SyHashGet(&pGen->hLiteral,(const void*)pValue->zString,pValue->nByte);
	if (pEntry == 0) {
		return SXERR_NOTFOUND;
	}
	*pIdx = (sxu32)SX_PTR_TO_INT(pEntry->pUserData);
	return SXRET_OK;
}

static sxi32 GenStateInstallLiteral(php_gen_state* pGen,php_value* pObj,sxu32 nIdx)
{
	if (SyBlobLength(&pObj->sBlob) > 0) {
		SyHashInsert(&pGen->hLiteral,SyBlobData(&pObj->sBlob),SyBlobLength(&pObj->sBlob),SX_INT_TO_PTR(nIdx));
	}
	return SXRET_OK;
}

static php_value* GenStateInstallNumLiteral(php_gen_state* pGen,sxu32* pIdx)
{
	php_value* pObj;
	sxu32 nIdx = 0;

	pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
	if (pObj == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,1,"PHP engine is running out of memory");
		return 0;
	}
	*pIdx = nIdx;

	return pObj;
}


static sxi32 GenStateCompileChunk(php_gen_state* pGen,sxi32 iFlags);

static sxi32 PHP_CompileNumLiteral(php_gen_state* pGen,sxi32 iCompileFlag)
{
	SyToken* pToken = pGen->pIn;
	sxu32 nIdx = 0;
	if (pToken->nType & PHP_TK_INTEGER) {
		php_value* pObj;
		sxi64 iValue;
		iValue = PHP_TokenValueToInt64(&pToken->sData);
		pObj = GenStateInstallNumLiteral(&(*pGen),&nIdx);
		if (pObj == 0) {
			SXUNUSED(iCompileFlag);
			return SXERR_ABORT;
		}
		PHP_MemObjInitFromInt(pGen->pVm,pObj,iValue);
	}
	else {

		php_value* pObj;

		pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
		if (pObj == 0) {
			PHP_GenCompileError(&(*pGen),E_ERROR,1,"PHP engine is running out of memory");
			return SXERR_ABORT;
		}
		PHP_MemObjInitFromString(pGen->pVm,pObj,&pToken->sData);
		PHP_MemObjToReal(pObj);
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_CompileSimpleString(php_gen_state* pGen,sxi32 iCompileFlag)
{
	SyString* pStr = &pGen->pIn->sData;
	const char* zIn,* zCur,* zEnd;
	php_value* pObj;
	sxu32 nIdx;
	nIdx = 0;

	zIn = pStr->zString;
	zEnd = &zIn[pStr->nByte];
	if (zIn >= zEnd) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
		return SXRET_OK;
	}
	if (SXRET_OK == GenStateFindLiteral(&(*pGen),pStr,&nIdx)) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
		return SXRET_OK;
	}

	pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
	if (pObj == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,1,"PHP engine is running out of memory");
		SXUNUSED(iCompileFlag);
		return SXERR_ABORT;
	}
	PHP_MemObjInitFromString(pGen->pVm,pObj,0);

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '\\') {
			zIn++;
		}
		if (zIn > zCur) {

			PHP_MemObjStringAppend(pObj,zCur,(sxu32)(zIn - zCur));
		}
		zIn++;
		if (zIn < zEnd) {
			if (zIn[0] == '\\') {

				PHP_MemObjStringAppend(pObj,"\\",sizeof(char));
			}
			else if (zIn[0] == '\'') {

				PHP_MemObjStringAppend(pObj,"'",sizeof(char));
			}
			else {

				zIn--;
				PHP_MemObjStringAppend(pObj,zIn,sizeof(char) * 2);
				zIn++;
			}
		}

		zIn++;
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
	if (pStr->nByte < 1024) {

		GenStateInstallLiteral(pGen,pObj,nIdx);
	}

	return SXRET_OK;
}

static sxi32 PHP_CompileNowDoc(php_gen_state* pGen,sxi32 iCompileFlag)
{
	SyString* pStr = &pGen->pIn->sData;
	php_value* pObj;
	sxu32 nIdx;
	nIdx = 0;
	if (pStr->nByte <= 0) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
		return SXRET_OK;
	}

	pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
	if (pObj == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"PHP engine is running out of memory");
		SXUNUSED(iCompileFlag);
		return SXERR_ABORT;
	}

	PHP_MemObjInitFromString(pGen->pVm,pObj,pStr);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);

	return SXRET_OK;
}

static sxi32 GenStateProcessStringExpression(
	php_gen_state* pGen,
	sxu32 nLine,
	const char* zIn,
	const char* zEnd
)
{
	SyToken* pTmpIn,* pTmpEnd;
	SySet sToken;
	sxi32 rc;

	SySetInit(&sToken,&pGen->pVm->sAllocator,sizeof(SyToken));

	SySetAlloc(&sToken,0x08);

	PHP_TokenizePHP(zIn,(sxu32)(zEnd - zIn),nLine,&sToken);

	pTmpIn = pGen->pIn;
	pTmpEnd = pGen->pEnd;
	pGen->pIn = (SyToken*)SySetBasePtr(&sToken);
	pGen->pEnd = &pGen->pIn[SySetUsed(&sToken)];

	rc = PHP_CompileExpr(&(*pGen),0,0);

	pGen->pIn = pTmpIn;
	pGen->pEnd = pTmpEnd;

	SySetRelease(&sToken);

	return rc;
}

static php_value* GenStateNewStrObj(php_gen_state* pGen,sxi32* pCount)
{
	php_value* pConstObj;
	sxu32 nIdx = 0;

	pConstObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
	if (pConstObj == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"PHP engine is running out of memory");
		return 0;
	}
	(*pCount)++;
	PHP_MemObjInitFromString(pGen->pVm,pConstObj,0);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
	return pConstObj;
}

static sxi32 GenStateCompileString(php_gen_state* pGen)
{
	SyString* pStr = &pGen->pIn->sData;
	const char* zIn,* zCur,* zEnd;
	php_value* pObj = 0;
	sxi32 iCons;
	sxi32 rc;

	zIn = pStr->zString;
	zEnd = &zIn[pStr->nByte];
	if (zIn >= zEnd) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
		return SXRET_OK;
	}
	zCur = 0;

	iCons = 0;
	for (;;) {
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '\\') {
			if (zIn[0] == '{' && &zIn[1] < zEnd && zIn[1] == '$') {
				break;
			}
			else if (zIn[0] == '$' && &zIn[1] < zEnd &&
				(((unsigned char)zIn[1] >= 0xc0 || SyisAlpha(zIn[1]) || zIn[1] == '{' || zIn[1] == '_'))) {
				break;
			}
			zIn++;
		}
		if (zIn > zCur) {
			if (pObj == 0) {
				pObj = GenStateNewStrObj(&(*pGen),&iCons);
				if (pObj == 0) {
					return SXERR_ABORT;
				}
			}
			PHP_MemObjStringAppend(pObj,zCur,(sxu32)(zIn - zCur));
		}
		if (zIn >= zEnd) {
			break;
		}
		if (zIn[0] == '\\') {
			const char* zPtr = 0;
			sxu32 n;
			zIn++;
			if (zIn >= zEnd) {
				break;
			}
			if (pObj == 0) {
				pObj = GenStateNewStrObj(&(*pGen),&iCons);
				if (pObj == 0) {
					return SXERR_ABORT;
				}
			}
			n = sizeof(char);
			switch (zIn[0]) {
			case '$':

				PHP_MemObjStringAppend(pObj,"$",sizeof(char));
				break;
			case '\\':

				PHP_MemObjStringAppend(pObj,"\\",sizeof(char));
				break;
			case 'a':

				PHP_MemObjStringAppend(pObj,"\a",sizeof(char));
				break;
			case 'b':

				PHP_MemObjStringAppend(pObj,"\b",sizeof(char));
				break;
			case 'f':

				PHP_MemObjStringAppend(pObj,"\f",sizeof(char));
				break;
			case 'n':

				PHP_MemObjStringAppend(pObj,"\n",sizeof(char));
				break;
			case 'r':

				PHP_MemObjStringAppend(pObj,"\r",sizeof(char));
				break;
			case 't':

				PHP_MemObjStringAppend(pObj,"\t",sizeof(char));
				break;
			case 'v':

				PHP_MemObjStringAppend(pObj,"\v",sizeof(char));
				break;
			case '\'':

				PHP_MemObjStringAppend(pObj,"'",sizeof(char));
				break;
			case '"':

				PHP_MemObjStringAppend(pObj,"\"",sizeof(char));
				break;
			case '0':

				PHP_MemObjStringAppend(pObj,"\0",sizeof(char));
				break;
			case 'x':
				if ((unsigned char)zIn[1] < 0xc0 && SyisHex(zIn[1])) {
					int c;

					c = SyHexToint(zIn[1]) << 4;
					if (&zIn[2] < zEnd) {
						c += SyHexToint(zIn[2]);
					}

					PHP_MemObjStringAppend(pObj,(const char*)&c,sizeof(char));
					n += sizeof(char) * 2;
				}
				else {

					PHP_MemObjStringAppend(pObj,"x",sizeof(char));
				}
				break;
			case 'o':
				if (&zIn[1] < zEnd && (unsigned char)zIn[1] < 0xc0 && SyisDigit(zIn[1]) && (zIn[1] - '0') < 8) {

					int c;
					c = 0;
					zIn++;
					for (zPtr = zIn; zPtr < &zIn[3 * sizeof(char)]; zPtr++) {
						if (zPtr >= zEnd || (unsigned char)zPtr[0] >= 0xc0 || !SyisDigit(zPtr[0]) || (zPtr[0] - '0') > 7) {
							break;
						}
						c = c * 8 + (zPtr[0] - '0');
					}
					if (c > 0) {
						PHP_MemObjStringAppend(pObj,(const char*)&c,sizeof(char));
					}
					n = (sxu32)(zPtr - zIn);
				}
				else {

					PHP_MemObjStringAppend(pObj,"o",sizeof(char));
				}
				break;
			default:

				PHP_MemObjStringAppend(pObj,zIn,sizeof(char));
				break;
			}

			zIn += n;
			continue;
		}
		if (zIn[0] == '{') {

			const char* zExpr;
			sxi32 iNest = 1;
			zIn++;
			zExpr = zIn;

			while (zIn < zEnd) {
				if (zIn[0] == '{') {

					iNest++;
				}
				else if (zIn[0] == '}') {

					iNest--;
					if (iNest <= 0) {
						break;
					}
				}
				zIn++;
			}

			rc = GenStateProcessStringExpression(&(*pGen),pGen->pIn->nLine,zExpr,zIn);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			if (rc != SXERR_EMPTY) {
				++iCons;
			}
			if (zIn < zEnd) {

				zIn++;
			}
		}
		else {

			const char* zExpr = zIn;

			for (;;) {

				while (zIn < zEnd && zIn[0] == '$') {
					zIn++;
				}
				for (;;) {
					while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && (SyisAlphaNum(zIn[0]) || zIn[0] == '_')) {
						zIn++;
					}
					if ((unsigned char)zIn[0] >= 0xc0) {

						zIn++;
						while (zIn < zEnd && (((unsigned char)zIn[0] & 0xc0) == 0x80)) {
							zIn++;
						}
						continue;
					}
					break;
				}
				if (zIn >= zEnd) {
					break;
				}
				if (zIn[0] == '[') {
					sxi32 iSquare = 1;
					zIn++;
					while (zIn < zEnd) {
						if (zIn[0] == '[') {
							iSquare++;
						}
						else if (zIn[0] == ']') {
							iSquare--;
							if (iSquare <= 0) {
								break;
							}
						}
						zIn++;
					}
					if (zIn < zEnd) {
						zIn++;
					}
					break;
				}
				else if (zIn[0] == '{') {
					sxi32 iCurly = 1;
					zIn++;
					while (zIn < zEnd) {
						if (zIn[0] == '{') {
							iCurly++;
						}
						else if (zIn[0] == '}') {
							iCurly--;
							if (iCurly <= 0) {
								break;
							}
						}
						zIn++;
					}
					if (zIn < zEnd) {
						zIn++;
					}
					break;
				}
				else if (zIn[0] == '-' && &zIn[1] < zEnd && zIn[1] == '>') {

					zIn += 2;
				}
				else if (zIn[0] == ':' && &zIn[1] < zEnd && zIn[1] == ':') {

					zIn += 2;
				}
				else {
					break;
				}
			}

			rc = GenStateProcessStringExpression(&(*pGen),pGen->pIn->nLine,zExpr,zIn);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			if (rc != SXERR_EMPTY) {
				++iCons;
			}
		}

		pObj = 0;
	}
	if (iCons > 1) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_CAT,iCons,0,0,0);
	}

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_CompileString(php_gen_state* pGen,sxi32 iCompileFlag)
{
	sxi32 rc;
	rc = GenStateCompileString(&(*pGen));
	SXUNUSED(iCompileFlag);

	return rc;
}

static sxi32 PHP_CompileHereDoc(php_gen_state* pGen,sxi32 iCompileFlag)
{
	sxi32 rc;
	rc = GenStateCompileString(&(*pGen));
	SXUNUSED(iCompileFlag);

	return SXRET_OK;
}

static sxi32 GenStateCompileArrayEntry(
	php_gen_state* pGen,
	SyToken* pIn,
	SyToken* pEnd,
	sxi32 iFlags,
	sxi32(*xValidator)(php_gen_state*,php_expr_node*)
)
{
	SyToken* pTmpIn,* pTmpEnd;
	sxi32 rc;

	SWAP_DELIMITER(pGen,pIn,pEnd);

	rc = PHP_CompileExpr(&(*pGen),iFlags,xValidator);

	RE_SWAP_DELIMITER(pGen);
	return rc;
}

static sxi32 GenStateArrayNodeValidator(php_gen_state* pGen,php_expr_node* pRoot)
{
	sxi32 rc = SXRET_OK;
	if (pRoot->pOp) {
		if (pRoot->pOp->iOp != EXPR_OP_SUBSCRIPT  &&
			pRoot->pOp->iOp != EXPR_OP_FUNC_CALL
			&& pRoot->pOp->iOp != EXPR_OP_ARROW  && pRoot->pOp->iOp != EXPR_OP_DC ) {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
				"array(): Expecting a variable/array member/function call after reference operator '&'");
			if (rc != SXERR_ABORT) {
				rc = SXERR_INVALID;
			}
		}
	}
	else if (pRoot->xCode != PHP_CompileVariable) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
			"array(): Expecting a variable after reference operator '&'");
		if (rc != SXERR_ABORT) {
			rc = SXERR_INVALID;
		}
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_CompileArray(php_gen_state* pGen,sxi32 iCompileFlag)
{
	sxi32(*xValidator)(php_gen_state*,php_expr_node*);
	SyToken* pKey,* pCur;
	sxi32 iEmitRef = 0;
	sxi32 nPair = 0;
	sxi32 iNest;
	sxi32 rc;

	pGen->pIn += 2;
	pGen->pEnd--;
	xValidator = 0;
	SXUNUSED(iCompileFlag);
	for (;;) {

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA)) {
			pGen->pIn++;
		}
		pCur = pGen->pIn;
		if (SXRET_OK != PHP_GetNextExpr(pGen->pIn,pGen->pEnd,&pGen->pIn)) {

			break;
		}
		if (pCur >= pGen->pIn) {
			continue;
		}

		pKey = pCur;
		iNest = 0;
		while (pCur < pGen->pIn) {
			if ((pCur->nType & PHP_TK_ARRAY_OP) && iNest <= 0) {
				break;
			}
			if (pCur->nType & PHP_TK_LPAREN ) {
				iNest++;
			}
			else if (pCur->nType & PHP_TK_RPAREN ) {

				iNest--;
			}
			pCur++;
		}
		rc = SXERR_EMPTY;
		if (pCur < pGen->pIn) {
			if (&pCur[1] >= pGen->pIn) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pCur->nLine,"array(): Missing entry value");
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				return SXRET_OK;
			}

			rc = GenStateCompileArrayEntry(&(*pGen),pKey,pCur,
				EXPR_FLAG_RDONLY_LOAD,0);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			pCur++;
		}
		else if (pKey == pCur) {

			PHP_GenCompileError(&(*pGen),E_WARNING,pCur->nLine,"array(): Missing entry key");
			pCur++;
		}
		else {

			pCur = pKey;
		}
		if (rc == SXERR_EMPTY) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0 ,0,0);
		}
		if (pCur->nType & PHP_TK_AMPER ) {

			xValidator = GenStateArrayNodeValidator;
			iEmitRef = 1;
			pCur++;
			if (pCur >= pGen->pIn) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pCur->nLine,"array(): Missing referenced variable");
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				return SXRET_OK;
			}
		}

		rc = GenStateCompileArrayEntry(&(*pGen),pCur,pGen->pIn,EXPR_FLAG_RDONLY_LOAD,xValidator);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		if (iEmitRef) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD_REF,0,0,0,0);
		}
		xValidator = 0;
		iEmitRef = 0;
		nPair++;
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD_MAP,nPair * 2,0,0,0);

	return SXRET_OK;
}

static sxi32 GenStateListNodeValidator(php_gen_state* pGen,php_expr_node* pRoot)
{
	sxi32 rc = SXRET_OK;
	if (pRoot->pOp) {
		if (pRoot->pOp->iOp != EXPR_OP_SUBSCRIPT  && pRoot->pOp->iOp != EXPR_OP_ARROW
			&& pRoot->pOp->iOp != EXPR_OP_DC ) {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
				"list(): Expecting a variable not an expression");
			if (rc != SXERR_ABORT) {
				rc = SXERR_INVALID;
			}
		}
	}
	else if (pRoot->xCode != PHP_CompileVariable) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
			"list(): Expecting a variable not an expression");
		if (rc != SXERR_ABORT) {
			rc = SXERR_INVALID;
		}
	}
	return rc;
}

PHP_PRIVATE sxi32 PHP_CompileList(php_gen_state* pGen,sxi32 iCompileFlag)
{
	SyToken* pNext;
	sxi32 nExpr;
	sxi32 rc;
	nExpr = 0;

	pGen->pIn += 2;
	pGen->pEnd--;
	SXUNUSED(iCompileFlag);
	while (SXRET_OK == PHP_GetNextExpr(pGen->pIn,pGen->pEnd,&pNext)) {
		if (pGen->pIn < pNext) {

			rc = GenStateCompileArrayEntry(&(*pGen),pGen->pIn,pNext,EXPR_FLAG_LOAD_IDX_STORE,GenStateListNodeValidator);
			if (rc != SXRET_OK) {

				return SXRET_OK;
			}
		}
		else {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
		}
		nExpr++;

		pGen->pIn = &pNext[1];
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD_LIST,nExpr,0,0,0);

	return SXRET_OK;
}

static sxi32 GenStateCompileFunc(php_gen_state* pGen,SyString* pName,sxi32 iFlags,int bHandleClosure,php_vm_func** ppFunc);

PHP_PRIVATE sxi32 PHP_CompileAnnonFunc(php_gen_state* pGen,sxi32 iCompileFlag)
{
	php_vm_func* pAnnonFunc;
	char zName[512];
	static int iCnt = 1;
	php_value* pObj;
	SyString sName;
	sxu32 nIdx;
	sxu32 nLen;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD)) {
		pGen->pIn++;
	}

	pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
	if (pObj == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,1,"Fatal,PHP engine is running out of memory");
		SXUNUSED(iCompileFlag);
		return SXERR_ABORT;
	}

	nLen = SyBufferFormat(zName,sizeof(zName),"[lambda_%d]",iCnt++);

	while (SyHashGet(&pGen->pVm->hFunction,zName,nLen) != 0 && nLen < sizeof(zName) - 2) {
		nLen = SyBufferFormat(zName,sizeof(zName),"[lambda_%d]",iCnt++);
	}
	SyStringInitFromBuf(&sName,zName,nLen);
	PHP_MemObjInitFromString(pGen->pVm,pObj,&sName);

	rc = GenStateCompileFunc(&(*pGen),&sName,0,TRUE,&pAnnonFunc);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}
	if (pAnnonFunc->iFlags & VM_FUNC_CLOSURE) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD_CLOSURE,0,0,pAnnonFunc,0);
	}
	else {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
	}

	return SXRET_OK;
}

static sxi32 PHP_CompileBacktic(php_gen_state* pGen,sxi32 iCompileFlag)
{

	PHP_GenCompileError(&(*pGen),E_NOTICE,pGen->pIn->nLine,
		"Command line invocation is disabled in the current release of the PHP(%s) engine",
		php_lib_version()
	);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
	SXUNUSED(iCompileFlag);

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_CompileLangConstruct(php_gen_state* pGen,sxi32 iCompileFlag)
{
	SyString* pName;
	sxu32 nKeyID;
	sxi32 rc;

	pName = &pGen->pIn->sData;
	nKeyID = (sxu32)SX_PTR_TO_INT(pGen->pIn->pUserData);
	pGen->pIn++;
	if (nKeyID == PHP_TKWRD_ECHO) {
		SyToken* pTmp,* pNext = 0;

		pTmp = pGen->pEnd;

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,1 ,0,0);
		while (SXRET_OK == PHP_GetNextExpr(pGen->pIn,pTmp,&pNext)) {
			if (pGen->pIn < pNext) {
				pGen->pEnd = pNext;
				rc = PHP_CompileExpr(&(*pGen),EXPR_FLAG_RDONLY_LOAD,0);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				if (rc != SXERR_EMPTY) {

					PHP_VmEmitInstr(pGen->pVm,PHP_OP_CONSUME,1,0,0,0);
				}
			}

			while (pNext < pTmp && (pNext->nType & PHP_TK_COMMA)) {
				pNext++;
			}
			pGen->pIn = pNext;
		}

		pGen->pEnd = pTmp;
	}
	else {
		sxi32 nArg = 0;
		sxu32 nIdx = 0;
		rc = PHP_CompileExpr(&(*pGen),EXPR_FLAG_RDONLY_LOAD,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {
			nArg = 1;
		}
		if (SXRET_OK != GenStateFindLiteral(&(*pGen),pName,&nIdx)) {
			php_value* pObj;

			pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
			if (pObj == 0) {
				PHP_GenCompileError(&(*pGen),E_ERROR,1,"Fatal,PHP engine is running out of memory");
				SXUNUSED(iCompileFlag);
				return SXERR_ABORT;
			}
			PHP_MemObjInitFromString(pGen->pVm,pObj,pName);

			GenStateInstallLiteral(&(*pGen),pObj,nIdx);
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
		PHP_VmEmitInstr(pGen->pVm,PHP_OP_CALL,nArg,0,0,0);
	}

	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_CompileVariable(php_gen_state* pGen,sxi32 iCompileFlag)
{
	sxu32 nLine = pGen->pIn->nLine;
	sxi32 iVv;
	sxi32 iP1;
	void* p3;
	sxi32 rc;
	iVv = -1;
	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_DOLLAR)) {
		pGen->pIn++;
		iVv++;
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD | PHP_TK_OCB)) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Invalid variable name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}
	p3 = 0;
	if (pGen->pIn->nType & PHP_TK_OCB) {

		pGen->pIn++;
		pGen->pEnd--;
		if (pGen->pIn >= pGen->pEnd) {

			PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Invalid variable name");
			return SXRET_OK;
		}

		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc == SXERR_EMPTY) {
			PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Missing variable name");
			return SXRET_OK;
		}
	}
	else {
		SyHashEntry* pEntry;
		SyString* pName;
		char* zName = 0;

		pName = &pGen->pIn->sData;

		pGen->pIn++;
		pEntry = SyHashGet(&pGen->hVar,(const void*)pName->zString,pName->nByte);
		if (pEntry == 0) {

			zName = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
			if (zName == 0) {
				PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP engine is running out of memory");
				return SXERR_ABORT;
			}

			SyHashInsert(&pGen->hVar,zName,pName->nByte,zName);
		}
		else {

			zName = (char*)pEntry->pUserData;
		}
		p3 = (void*)zName;
	}
	iP1 = 0;
	if (iCompileFlag & EXPR_FLAG_RDONLY_LOAD) {
		if ((iCompileFlag & EXPR_FLAG_LOAD_IDX_STORE) == 0) {

			iP1 = 1;
		}
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD,iP1,0,p3,0);
	while (iVv > 0) {
		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD,iP1,0,0,0);
		iVv--;
	}

	return SXRET_OK;
}

static sxi32 GenStateLoadLiteral(php_gen_state* pGen)
{
	SyToken* pToken = pGen->pIn;
	php_value* pObj;
	SyString* pStr;
	sxu32 nIdx;

	pStr = &pToken->sData;

	if (pStr->nByte == sizeof("NULL") - 1) {
		if (SyStrnicmp(pStr->zString,"null",sizeof("NULL") - 1) == 0) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
			return SXRET_OK;
		}
		else if (SyStrnicmp(pStr->zString,"true",sizeof("TRUE") - 1) == 0) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,1,0,0);
			return SXRET_OK;
		}
	}
	else if (pStr->nByte == sizeof("FALSE") - 1 &&
		SyStrnicmp(pStr->zString,"false",sizeof("FALSE") - 1) == 0) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,2,0,0);
		return SXRET_OK;
	}
	else if (pStr->nByte == sizeof("__LINE__") - 1 &&
		SyMemcmp(pStr->zString,"__LINE__",sizeof("__LINE__") - 1) == 0) {

		pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
		if (pObj == 0) {
			PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,"Fatal,PHP engine is running out of memory");
			return SXERR_ABORT;
		}
		PHP_MemObjInitFromInt(pGen->pVm,pObj,pToken->nLine);

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
		return SXRET_OK;
	}
	else if ((pStr->nByte == sizeof("__FUNCTION__") - 1 &&
		SyMemcmp(pStr->zString,"__FUNCTION__",sizeof("__FUNCTION__") - 1) == 0) ||
		(pStr->nByte == sizeof("__METHOD__") - 1 &&
			SyMemcmp(pStr->zString,"__METHOD__",sizeof("__METHOD__") - 1) == 0)) {
		GenBlock* pBlock = pGen->pCurrent;

		while (pBlock && (pBlock->iFlags & GEN_BLOCK_FUNC) == 0) {

			pBlock = pBlock->pParent;
		}
		if (pBlock == 0) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
		}
		else {

			php_vm_func* pFunc = (php_vm_func*)pBlock->pUserData;
			if (pStr->zString[2] == 'M'  && (pFunc->iFlags & VM_FUNC_CLASS_METHOD) == 0) {

				PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,0,0,0);
			}
			else {
				pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
				if (pObj == 0) {
					PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,"Fatal,PHP engine is running out of memory");
					return SXERR_ABORT;
				}
				PHP_MemObjInitFromString(pGen->pVm,pObj,&pFunc->sName);

				PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nIdx,0,0);
			}
		}
		return SXRET_OK;
	}

	if (SXRET_OK != GenStateFindLiteral(&(*pGen),&pToken->sData,&nIdx)) {
		php_value* pObj;

		pObj = PHP_ReserveConstObj(pGen->pVm,&nIdx);
		if (pObj == 0) {
			PHP_GenCompileError(&(*pGen),E_ERROR,1,"PHP engine is running out of memory");
			return SXERR_ABORT;
		}
		PHP_MemObjInitFromString(pGen->pVm,pObj,&pToken->sData);
		GenStateInstallLiteral(&(*pGen),pObj,nIdx);
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,1,nIdx,0,0);
	return SXRET_OK;
}

static sxi32 GenStateResolveNamespaceLiteral(php_gen_state* pGen)
{
	int emit = 0;
	sxi32 rc;
	while (pGen->pIn < &pGen->pEnd[-1]) {

		if (!emit) {
			PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,
				"Namespace support is disabled in the current release of the PHP(%s) engine",
				php_lib_version()
			);
			emit = 1;
		}
		pGen->pIn++;
	}

	rc = GenStateLoadLiteral(&(*pGen));
	return rc;
}

PHP_PRIVATE sxi32 PHP_CompileLiteral(php_gen_state* pGen,sxi32 iCompileFlag)
{
	sxi32 rc;
	rc = GenStateResolveNamespaceLiteral(&(*pGen));
	if (rc != SXRET_OK) {
		SXUNUSED(iCompileFlag);
		return rc;
	}

	return SXRET_OK;
}

static sxi32 PHP_ErrorRecover(php_gen_state* pGen)
{

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI ) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static int GenStateIsReservedConstant(SyString* pName)
{
	if (pName->nByte == sizeof("null") - 1) {
		if (SyStrnicmp(pName->zString,"null",sizeof("null") - 1) == 0) {
			return TRUE;
		}
		else if (SyStrnicmp(pName->zString,"true",sizeof("true") - 1) == 0) {
			return TRUE;
		}
	}
	else if (pName->nByte == sizeof("false") - 1) {
		if (SyStrnicmp(pName->zString,"false",sizeof("false") - 1) == 0) {
			return TRUE;
		}
	}

	return FALSE;
}

static sxi32 PHP_CompileConstant(php_gen_state* pGen)
{
	SySet* pConsCode,* pInstrContainer;
	sxu32 nLine = pGen->pIn->nLine;
	SyString* pName;
	sxi32 rc;
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_SSTR | PHP_TK_DSTR | PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"const: Invalid constant name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pName = &pGen->pIn->sData;

	if (GenStateIsReservedConstant(pName)) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"const: Cannot redeclare a reserved constant '%z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_EQUAL ) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"const: Expected '=' after constant name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	pGen->pIn++;

	pConsCode = (SySet*)SyMemBackendPoolAlloc(&pGen->pVm->sAllocator,sizeof(SySet));
	if (pConsCode == 0) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP engine is running out of memory");
		return SXERR_ABORT;
	}
	SySetInit(pConsCode,&pGen->pVm->sAllocator,sizeof(VmInstr));

	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,pConsCode);

	rc = PHP_CompileExpr(&(*pGen),0,0);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,(rc != SXERR_EMPTY ? 1 : 0),0,0,0);
	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}
	SySetSetUserData(pConsCode,pGen->pVm);

	rc = PHP_VmRegisterConstant(pGen->pVm,pName,PHP_VmExpandConstantValue,pConsCode);
	if (rc != SXRET_OK) {
		SySetRelease(pConsCode);
		SyMemBackendPoolFree(&pGen->pVm->sAllocator,pConsCode);
	}
	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileContinue(php_gen_state* pGen)
{
	GenBlock* pLoop;
	sxi32 iLevel;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;
	iLevel = 0;

	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_NUM)) {

		iLevel = (sxi32)PHP_TokenValueToInt64(&pGen->pIn->sData);
		if (iLevel < 2) {
			iLevel = 0;
		}
		pGen->pIn++;
	}

	pLoop = GenStateFetchBlock(pGen->pCurrent,GEN_BLOCK_LOOP,iLevel);
	if (pLoop == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"A 'continue' statement may only be used within a loop or switch");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}
	else {
		sxu32 nInstrIdx = 0;
		if (pLoop->iFlags & GEN_BLOCK_SWITCH) {

			rc = PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,0,0,&nInstrIdx);
			if (rc == SXRET_OK) {
				GenStateNewJumpFixup(pLoop,PHP_OP_JMP,nInstrIdx);
			}
		}
		else {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,pLoop->nFirstInstr,0,&nInstrIdx);
			if (pLoop->bPostContinue == TRUE) {
				JumpFixup sJumpFix;

				sJumpFix.nJumpType = PHP_OP_JMP;
				sJumpFix.nInstrIdx = nInstrIdx;
				SySetPut(&pLoop->aPostContFix,(const void*)&sJumpFix);
			}
		}
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,"Expected semi-colon ';' after 'continue' statement");
	}

	return SXRET_OK;
}

static sxi32 PHP_CompileBreak(php_gen_state* pGen)
{
	GenBlock* pLoop;
	sxi32 iLevel;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;
	iLevel = 0;

	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_NUM)) {

		iLevel = (sxi32)PHP_TokenValueToInt64(&pGen->pIn->sData);
		if (iLevel < 2) {
			iLevel = 0;
		}
		pGen->pIn++;
	}

	pLoop = GenStateFetchBlock(pGen->pCurrent,GEN_BLOCK_LOOP,iLevel);
	if (pLoop == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"A 'break' statement may only be used within a loop or switch");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}
	else {
		sxu32 nInstrIdx;
		rc = PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,0,0,&nInstrIdx);
		if (rc == SXRET_OK) {

			GenStateNewJumpFixup(pLoop,PHP_OP_JMP,nInstrIdx);
		}
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,"Expected semi-colon ';' after 'break' statement");
	}

	return SXRET_OK;
}

static sxi32 PHP_CompileLabel(php_gen_state* pGen)
{
	GenBlock* pBlock;
	Label sLabel;

	pBlock = GenStateFetchBlock(pGen->pCurrent,GEN_BLOCK_LOOP | GEN_BLOCK_EXCEPTION,0);
	if (pBlock) {
		sxi32 rc;
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,
			"Label '%z' inside loop or try/catch block is disallowed",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	else {
		SyString* pTarget = &pGen->pIn->sData;
		char* zDup;

		sLabel.nJumpDest = PHP_VmInstrLength(pGen->pVm);

		zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pTarget->zString,pTarget->nByte);
		if (zDup == 0) {
			PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Fatal,PHP is running out of memory");
			return SXERR_ABORT;
		}
		SyStringInitFromBuf(&sLabel.sName,zDup,pTarget->nByte);
		sLabel.bRef = FALSE;
		sLabel.nLine = pGen->pIn->nLine;
		pBlock = pGen->pCurrent;
		while (pBlock) {
			if (pBlock->iFlags & (GEN_BLOCK_FUNC | GEN_BLOCK_EXCEPTION)) {
				break;
			}

			pBlock = pBlock->pParent;
		}
		if (pBlock) {
			sLabel.pFunc = (php_vm_func*)pBlock->pUserData;
		}
		else {
			sLabel.pFunc = 0;
		}

		SySetPut(&pGen->aLabel,(const void*)&sLabel);
	}
	pGen->pIn += 2;
	return SXRET_OK;
}

static sxi32 PHP_CompileGoto(php_gen_state* pGen)
{
	JumpFixup sJump;
	sxi32 rc;
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"goto: expecting a 'label_name'");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}
	if ((pGen->pIn->nType & (PHP_TK_KEYWORD | PHP_TK_ID)) == 0) {
		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"goto: Invalid label name: '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}
	else {
		SyString* pTarget = &pGen->pIn->sData;
		GenBlock* pBlock;
		char* zDup;

		sJump.nJumpType = PHP_OP_JMP;
		sJump.nLine = pGen->pIn->nLine;

		zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pTarget->zString,pTarget->nByte);
		if (zDup == 0) {
			PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Fatal,PHP is running out of memory");
			return SXERR_ABORT;
		}
		SyStringInitFromBuf(&sJump.sLabel,zDup,pTarget->nByte);
		pBlock = pGen->pCurrent;
		while (pBlock) {
			if (pBlock->iFlags & (GEN_BLOCK_FUNC | GEN_BLOCK_EXCEPTION)) {
				break;
			}

			pBlock = pBlock->pParent;
		}
		if (pBlock && pBlock->iFlags & GEN_BLOCK_EXCEPTION) {
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"goto inside try/catch block is disallowed");
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
		}
		if (pBlock && (pBlock->iFlags & GEN_BLOCK_FUNC)) {
			sJump.pFunc = (php_vm_func*)pBlock->pUserData;
		}
		else {
			sJump.pFunc = 0;
		}

		if (SXRET_OK == PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,0,0,&sJump.nInstrIdx)) {
			SySetPut(&pGen->aGoto,(const void*)&sJump);
		}
	}
	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Expected semi-colon ';' after 'goto' statement");
	}

	return SXRET_OK;
}

static sxi32 GenStateNextChunk(php_gen_state* pGen)
{
	php_value* pRawObj;
	sxu32 nRawObj;
	sxu32 nObjIdx;

Consume:
	nRawObj = nObjIdx = 0;
	while (pGen->pRawIn < pGen->pRawEnd && pGen->pRawIn->nType != PHP_TOKEN_PHP) {
		pRawObj = PHP_ReserveConstObj(pGen->pVm,&nObjIdx);
		if (pRawObj == 0) {
			PHP_GenCompileError(pGen,E_ERROR,1,"Fatal,PHP engine is running out of memory");
			return SXERR_ABORT;
		}

		PHP_MemObjInitFromString(pGen->pVm,pRawObj,&pGen->pRawIn->sData);
		PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOADC,0,nObjIdx,0,0);
		++nRawObj;
		pGen->pRawIn++;
	}
	if (nRawObj > 0) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_CONSUME,nRawObj,0,0,0);
	}
	if (pGen->pRawIn < pGen->pRawEnd) {
		SySet* pTokenSet = pGen->pTokenSet;

		SySetReset(pTokenSet);

		PHP_TokenizePHP(SyStringData(&pGen->pRawIn->sData),SyStringLength(&pGen->pRawIn->sData),
			pGen->pRawIn->nLine,pTokenSet);

		pGen->pIn = (SyToken*)SySetBasePtr(pTokenSet);
		pGen->pEnd = &pGen->pIn[SySetUsed(pTokenSet)];

		pGen->pRawIn++;

		if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_EQUAL)) {
			static const sxu32 nKeyID = PHP_TKWRD_ECHO;
			sxi32 rc;

			pGen->pIn->nType = PHP_TK_KEYWORD;
			pGen->pIn->pUserData = SX_INT_TO_PTR(nKeyID);
			SyStringInitFromBuf(&pGen->pIn->sData,"echo",sizeof("echo") - 1);
			rc = PHP_CompileExpr(pGen,0,0);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			else if (rc != SXERR_EMPTY) {
				PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
			}
			goto Consume;
		}
	}
	else {

		pGen->pIn = pGen->pEnd;
		return SXERR_EOF;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileBlock(
	php_gen_state* pGen,
	sxi32 nKeywordEnd
)
{
	sxi32 rc;
	if (pGen->pIn->nType & PHP_TK_OCB ) {
		sxu32 nLine = pGen->pIn->nLine;
		rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_STD,PHP_VmInstrLength(pGen->pVm),0,0);
		if (rc != SXRET_OK) {
			return SXERR_ABORT;
		}
		pGen->pIn++;

		for (;;) {
			if (pGen->pIn >= pGen->pEnd) {
				rc = GenStateNextChunk(&(*pGen));
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				if (rc == SXERR_EOF) {

					PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Missing closing braces '}'");
					break;
				}
			}
			if (pGen->pIn->nType & PHP_TK_CCB) {

				pGen->pIn++;
				break;
			}

			rc = GenStateCompileChunk(&(*pGen),PHP_COMPILE_SINGLE_STMT);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		GenStateLeaveBlock(&(*pGen),0);
	}
	else if ((pGen->pIn->nType & PHP_TK_COLON ) && nKeywordEnd > 0) {
		pGen->pIn++;
		rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_STD,PHP_VmInstrLength(pGen->pVm),0,0);
		if (rc != SXRET_OK) {
			return SXERR_ABORT;
		}

		for (;;) {
			if (pGen->pIn >= pGen->pEnd) {
				rc = GenStateNextChunk(&(*pGen));
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				if (rc == SXERR_EOF || pGen->pIn >= pGen->pEnd) {

					if (rc == SXERR_EOF) {
						PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pEnd[-1].nLine,
							"Missing 'endfor;','endwhile;','endswitch;' or 'endforeach;' keyword");
					}
					break;
				}
			}
			if (pGen->pIn->nType & PHP_TK_KEYWORD) {
				sxi32 nKwrd;

				nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
				if (nKwrd == nKeywordEnd ||
					(nKeywordEnd == PHP_TKWRD_ENDIF && (nKwrd == PHP_TKWRD_ELSE || nKwrd == PHP_TKWRD_ELIF))) {

					if (nKwrd != PHP_TKWRD_ELSE && nKwrd != PHP_TKWRD_ELIF) {
						pGen->pIn++;
					}
					break;
				}
			}

			rc = GenStateCompileChunk(&(*pGen),PHP_COMPILE_SINGLE_STMT);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		GenStateLeaveBlock(&(*pGen),0);
	}
	else {

		rc = GenStateCompileChunk(&(*pGen),PHP_COMPILE_SINGLE_STMT);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI)) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileWhile(php_gen_state* pGen)
{
	GenBlock* pWhileBlock = 0;
	SyToken* pTmp,* pEnd = 0;
	sxu32 nFalseJump;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after 'while' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_LOOP,PHP_VmInstrLength(pGen->pVm),0,&pWhileBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pGen->pIn == pEnd || pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected expression after 'while' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	rc = PHP_CompileExpr(&(*pGen),0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	while (pGen->pIn < pEnd) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		pGen->pIn++;
	}

	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_JZ,0,0,0,&nFalseJump);

	GenStateNewJumpFixup(pWhileBlock,PHP_OP_JZ,nFalseJump);

	rc = PHP_CompileBlock(&(*pGen),PHP_TKWRD_ENDWHILE);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,pWhileBlock->nFirstInstr,0,0);

	GenStateFixJumps(pWhileBlock,-1,PHP_VmInstrLength(pGen->pVm));

	GenStateLeaveBlock(pGen,0);

	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileDoWhile(php_gen_state* pGen)
{
	SyToken* pTmp,* pEnd = 0;
	GenBlock* pDoBlock = 0;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_LOOP,PHP_VmInstrLength(pGen->pVm),0,&pDoBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	pDoBlock->bPostContinue = TRUE;
	rc = PHP_CompileBlock(&(*pGen),0);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}
	if (pGen->pIn < pGen->pEnd) {
		nLine = pGen->pIn->nLine;
	}
	if (pGen->pIn >= pGen->pEnd || pGen->pIn->nType != PHP_TK_KEYWORD ||
		SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_WHILE) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Missing 'while' statement after 'do' block");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after 'while' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pGen->pIn == pEnd || pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected expression after 'while' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	if (SySetUsed(&pDoBlock->aPostContFix) > 0) {
		JumpFixup* aPost;
		VmInstr* pInstr;
		sxu32 nJumpDest;
		sxu32 n;
		aPost = (JumpFixup*)SySetBasePtr(&pDoBlock->aPostContFix);
		nJumpDest = PHP_VmInstrLength(pGen->pVm);
		for (n = 0; n < SySetUsed(&pDoBlock->aPostContFix); ++n) {
			pInstr = PHP_VmGetInstr(pGen->pVm,aPost[n].nInstrIdx);
			if (pInstr) {

				pInstr->iP2 = nJumpDest;
			}
		}
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	rc = PHP_CompileExpr(&(*pGen),0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	while (pGen->pIn < pEnd) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		pGen->pIn++;
	}
	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_JNZ,0,pDoBlock->nFirstInstr,0,0);

	GenStateFixJumps(pDoBlock,-1,PHP_VmInstrLength(pGen->pVm));

	GenStateLeaveBlock(pGen,0);

	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileFor(php_gen_state* pGen)
{
	SyToken* pTmp,* pPostStart,* pEnd = 0;
	GenBlock* pForBlock = 0;
	sxu32 nFalseJump;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after 'for' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pGen->pIn++;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pGen->pIn == pEnd || pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"for: Invalid expression");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}

		pGen->pIn = pEnd;
		if (pGen->pIn < pGen->pEnd) {
			pGen->pIn++;
		}
		return SXRET_OK;
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	rc = PHP_CompileExpr(&(*pGen),0,0);

	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}
	else if (rc != SXERR_EMPTY) {
		PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
	}
	if ((pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
			"for: Expected ';' after initialization expressions");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pGen->pIn++;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_LOOP,PHP_VmInstrLength(pGen->pVm),0,&pForBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	pForBlock->bPostContinue = TRUE;

	rc = PHP_CompileExpr(&(*pGen),0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}
	else if (rc != SXERR_EMPTY) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_JZ,0,0,0,&nFalseJump);

		GenStateNewJumpFixup(pForBlock,PHP_OP_JZ,nFalseJump);
	}
	if ((pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
			"for: Expected ';' after conditionals expressions");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pGen->pIn++;

	pPostStart = pGen->pIn;

	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;
	rc = PHP_CompileBlock(&(*pGen),PHP_TKWRD_ENDFOR);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}

	if (SySetUsed(&pForBlock->aPostContFix) > 0) {
		JumpFixup* aPost;
		VmInstr* pInstr;
		sxu32 nJumpDest;
		sxu32 n;
		aPost = (JumpFixup*)SySetBasePtr(&pForBlock->aPostContFix);
		nJumpDest = PHP_VmInstrLength(pGen->pVm);
		for (n = 0; n < SySetUsed(&pForBlock->aPostContFix); ++n) {
			pInstr = PHP_VmGetInstr(pGen->pVm,aPost[n].nInstrIdx);
			if (pInstr) {

				pInstr->iP2 = nJumpDest;
			}
		}
	}

	while (pPostStart < pEnd && (pPostStart->nType & PHP_TK_SEMI)) {
		pPostStart++;
	}
	if (pPostStart < pEnd) {
		SyToken* pTmpIn,* pTmpEnd;
		SWAP_DELIMITER(pGen,pPostStart,pEnd);
		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (pGen->pIn < pGen->pEnd) {

			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"for: Expected ')' after post-expressions");
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			return SXRET_OK;
		}
		RE_SWAP_DELIMITER(pGen);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
		}
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,pForBlock->nFirstInstr,0,0);

	GenStateFixJumps(pForBlock,-1,PHP_VmInstrLength(pGen->pVm));

	GenStateLeaveBlock(pGen,0);

	return SXRET_OK;
}

static sxi32 GenStateForEachNodeValidator(php_gen_state* pGen,php_expr_node* pRoot)
{
	sxi32 rc = SXRET_OK;
	if (pRoot->xCode != PHP_CompileVariable) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
			"foreach: Expecting a variable name");
		if (rc != SXERR_ABORT) {
			rc = SXERR_INVALID;
		}
	}
	return rc;
}

static sxi32 PHP_CompileForeach(php_gen_state* pGen)
{
	SyToken* pCur,* pTmp,* pEnd = 0;
	GenBlock* pForeachBlock = 0;
	php_foreach_info* pInfo;
	sxu32 nFalseJump;
	VmInstr* pInstr;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"foreach: Expected '('");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_LOOP,PHP_VmInstrLength(pGen->pVm),0,&pForeachBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pGen->pIn == pEnd || pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"foreach: Missing expression");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}

		pGen->pIn = pEnd;
		if (pGen->pIn < pGen->pEnd) {
			pGen->pIn++;
		}
		return SXRET_OK;
	}

	pCur = pGen->pIn;
	while (pCur < pEnd) {
		if (pCur->nType & PHP_TK_KEYWORD) {
			sxi32 nKeywrd = SX_PTR_TO_INT(pCur->pUserData);
			if (nKeywrd == PHP_TKWRD_AS) {

				break;
			}
		}

		pCur++;
	}
	if (pCur <= pGen->pIn) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,
			"foreach: Missing array/object expression");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pCur;
	rc = PHP_CompileExpr(&(*pGen),0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	while (pGen->pIn < pCur) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"foreach: Unexpected token '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		pGen->pIn++;
	}
	pCur++;
	pGen->pIn = pCur;
	if (pGen->pIn >= pEnd) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"foreach: Missing $key => $value pair");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	pInfo = (php_foreach_info*)SyMemBackendAlloc(&pGen->pVm->sAllocator,sizeof(php_foreach_info));
	if (pInfo == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Fatal,PHP engine is running out-of-memory");
		return SXERR_ABORT;
	}

	SyZero(pInfo,sizeof(php_foreach_info));

	SySetInit(&pInfo->aStep,&pGen->pVm->sAllocator,sizeof(php_foreach_step*));

	while (pCur < pEnd && (pCur->nType & PHP_TK_ARRAY_OP) == 0) {
		pCur++;
	}
	if (pCur < pEnd) {

		if (pGen->pIn >= pCur) {
			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"foreach: Missing $key");
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
		}
		else {
			pGen->pEnd = pCur;
			rc = PHP_CompileExpr(&(*pGen),0,GenStateForEachNodeValidator);
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			pInstr = PHP_VmPopInstr(pGen->pVm);
			if (pInstr->p3) {

				SyStringInitFromBuf(&pInfo->sKey,pInstr->p3,SyStrlen((const char*)pInstr->p3));
			}
			pInfo->iFlags |= PHP_4EACH_STEP_KEY;
		}
		pGen->pIn = &pCur[1];
	}
	pGen->pEnd = pEnd;
	if (pGen->pIn >= pEnd) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"foreach: Missing $value");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	if (pGen->pIn->nType & PHP_TK_AMPER ) {
		pGen->pIn++;

		pInfo->iFlags |= PHP_4EACH_STEP_REF;
	}

	rc = PHP_CompileExpr(&(*pGen),0,GenStateForEachNodeValidator);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}
	pInstr = PHP_VmPopInstr(pGen->pVm);
	if (pInstr->p3) {

		SyStringInitFromBuf(&pInfo->sValue,pInstr->p3,SyStrlen((const char*)pInstr->p3));
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_FOREACH_INIT,0,0,pInfo,&nFalseJump);

	GenStateNewJumpFixup(pForeachBlock,PHP_OP_FOREACH_INIT,nFalseJump);

	pForeachBlock->nFirstInstr = PHP_VmInstrLength(pGen->pVm);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_FOREACH_STEP,0,0,pInfo,&nFalseJump);

	GenStateNewJumpFixup(pForeachBlock,PHP_OP_FOREACH_STEP,nFalseJump);

	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;
	rc = PHP_CompileBlock(&(*pGen),PHP_TKWRD_END4EACH);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,pForeachBlock->nFirstInstr,0,0);

	GenStateFixJumps(pForeachBlock,-1,PHP_VmInstrLength(pGen->pVm));

	GenStateLeaveBlock(pGen,0);

	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileIf(php_gen_state* pGen)
{
	SyToken* pToken,* pTmp,* pEnd = 0;
	GenBlock* pCondBlock = 0;
	sxu32 nJumpIdx;
	sxu32 nKeyID;
	sxi32 rc;

	pGen->pIn++;
	pToken = pGen->pIn;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_COND,PHP_VmInstrLength(pGen->pVm),0,&pCondBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	for (;;) {
		if (pToken >= pGen->pEnd || (pToken->nType & PHP_TK_LPAREN) == 0) {

			if (pToken >= pGen->pEnd) {
				pToken--;
			}
			rc = PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,"if/else/elseif: Missing '('");
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			goto Synchronize;
		}

		pToken++;

		PHP_DelimitNestedTokens(pToken,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
		if (pToken >= pEnd || (pEnd->nType & PHP_TK_RPAREN) == 0) {

			if (pToken >= pGen->pEnd) {
				pToken--;
			}
			rc = PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,"if/else/elseif: Missing ')'");
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			goto Synchronize;
		}

		SWAP_TOKEN_STREAM(pGen,pToken,pEnd);

		rc = PHP_CompileExpr(&(*pGen),0,0);

		while (pGen->pIn < pEnd) {
			PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",&pGen->pIn->sData);
			pGen->pIn++;
		}
		pGen->pIn = &pEnd[1];
		pGen->pEnd = pTmp;
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_JZ,0,0,0,&nJumpIdx);

		GenStateNewJumpFixup(pCondBlock,PHP_OP_JZ,nJumpIdx);

		rc = PHP_CompileBlock(&(*pGen),PHP_TKWRD_ENDIF);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0) {
			break;
		}

		nKeyID = (sxu32)SX_PTR_TO_INT(pGen->pIn->pUserData);
		if ((nKeyID & (PHP_TKWRD_ELSE | PHP_TKWRD_ELIF)) == 0) {
			break;
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,0,0,&nJumpIdx);

		GenStateNewJumpFixup(pCondBlock,PHP_OP_JMP,nJumpIdx);
		if (nKeyID & PHP_TKWRD_ELSE) {
			pToken = &pGen->pIn[1];
			if (pToken >= pGen->pEnd || (pToken->nType & PHP_TK_KEYWORD) == 0 ||
				SX_PTR_TO_INT(pToken->pUserData) != PHP_TKWRD_IF) {
				break;
			}
			pGen->pIn++;
		}
		pGen->pIn++;

		pToken = pGen->pIn;

		GenStateFixJumps(pCondBlock,PHP_OP_JZ,PHP_VmInstrLength(pGen->pVm));
	}

	GenStateFixJumps(pCondBlock,PHP_OP_JZ,PHP_VmInstrLength(pGen->pVm));
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD) &&
		(SX_PTR_TO_INT(pGen->pIn->pUserData) & PHP_TKWRD_ELSE)) {

		pGen->pIn++;
		rc = PHP_CompileBlock(&(*pGen),PHP_TKWRD_ENDIF);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}
	nJumpIdx = PHP_VmInstrLength(pGen->pVm);

	GenStateFixJumps(pCondBlock,PHP_OP_JMP,nJumpIdx);

	GenStateLeaveBlock(pGen,0);

	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileGlobal(php_gen_state* pGen)
{
	SyToken* pTmp,* pNext = 0;
	sxi32 nExpr;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_SEMI)) {

		return SXRET_OK;
	}
	pTmp = pGen->pEnd;
	nExpr = 0;
	while (SXRET_OK == PHP_GetNextExpr(pGen->pIn,pTmp,&pNext)) {
		if (pGen->pIn < pNext) {
			pGen->pEnd = pNext;
			if ((pGen->pIn->nType & PHP_TK_DOLLAR) == 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"global: Expected variable name");
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			else {
				pGen->pIn++;
				if (pGen->pIn >= pGen->pEnd) {

					PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn[-1].nLine,"global: Empty variable name");
				}
				else {
					rc = PHP_CompileExpr(&(*pGen),0,0);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
					else if (rc != SXERR_EMPTY) {
						nExpr++;
					}
				}
			}
		}

		pGen->pIn = pNext;

		while (pGen->pIn < pTmp && (pGen->pIn->nType & PHP_TK_COMMA)) {
			pGen->pIn++;
		}
	}

	pGen->pEnd = pTmp;
	if (nExpr > 0) {

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_UPLINK,nExpr,0,0,0);
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileReturn(php_gen_state* pGen)
{
	sxi32 nRet = 0;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {
			nRet = 1;
		}
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,nRet,0,0,0);
	return SXRET_OK;
}

static sxi32 PHP_CompileHalt(php_gen_state* pGen)
{
	sxi32 nExpr = 0;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {
			nExpr = 1;
		}
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_HALT,nExpr,0,0,0);
	return SXRET_OK;
}

static sxi32 PHP_CompileEcho(php_gen_state* pGen)
{
	SyToken* pTmp,* pNext = 0;
	sxi32 rc;

	pGen->pIn++;

	pTmp = pGen->pEnd;
	while (SXRET_OK == PHP_GetNextExpr(pGen->pIn,pTmp,&pNext)) {
		if (pGen->pIn < pNext) {
			pGen->pEnd = pNext;
			rc = PHP_CompileExpr(&(*pGen),EXPR_FLAG_RDONLY_LOAD,0);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			else if (rc != SXERR_EMPTY) {

				PHP_VmEmitInstr(pGen->pVm,PHP_OP_CONSUME,1,0,0,0);
			}
		}

		while (pNext < pTmp && (pNext->nType & PHP_TK_COMMA)) {
			pNext++;
		}
		pGen->pIn = pNext;
	}

	pGen->pEnd = pTmp;
	return SXRET_OK;
}

static sxi32 PHP_CompileStatic(php_gen_state* pGen)
{
	php_vm_func_static_var sStatic;
	php_vm_func* pFunc;
	GenBlock* pBlock;
	SyString* pName;
	char* zDup;
	sxu32 nLine;
	sxi32 rc;

	nLine = pGen->pIn->nLine;
	pGen->pIn++;

	pBlock = pGen->pCurrent;
	while (pBlock) {
		if (pBlock->iFlags & GEN_BLOCK_FUNC) {
			break;
		}

		pBlock = pBlock->pParent;
	}
	if (pBlock == 0) {

		if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0) {
			rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Expected variable after 'static' keyword");
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			goto Synchronize;
		}

		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
		}
		return SXRET_OK;
	}
	pFunc = (php_vm_func*)pBlock->pUserData;

	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0 || &pGen->pIn[1] >= pGen->pEnd ||
		(pGen->pIn[1].nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Expected variable after 'static' keyword");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	pGen->pIn++;

	pName = &pGen->pIn->sData;
	pGen->pIn++;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_EQUAL)) == 0) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"static: Unexpected token '%z'",&pGen->pIn->sData);
		goto Synchronize;
	}

	SySetInit(&sStatic.aByteCode,&pGen->pVm->sAllocator,sizeof(VmInstr));
	sStatic.nIdx = SXU32_HIGH;

	zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
	if (zDup == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Fatal,PHP engine is running out of memory");
		return SXERR_ABORT;
	}
	SyStringInitFromBuf(&sStatic.sName,zDup,pName->nByte);

	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_EQUAL)) {
		SySet* pInstrContainer;

		pGen->pIn++;

		pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
		PHP_VmSetByteCodeContainer(pGen->pVm,&sStatic.aByteCode);

		rc = PHP_CompileExpr(&(*pGen),0,0);

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,(rc != SXERR_EMPTY ? 1 : 0),0,0,0);

		PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);
	}

	SySetPut(&pFunc->aStatic,(const void*)&sStatic);
	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileVar(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"var: Expecting variable name");

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {
			pGen->pIn++;
		}
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	else {

		rc = PHP_CompileExpr(&(*pGen),0,0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		else if (rc != SXERR_EMPTY) {
			PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
		}
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileNamespace(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	sxi32 rc;
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd ||
		(pGen->pIn->nType & (PHP_TK_NSSEP | PHP_TK_ID | PHP_TK_KEYWORD | PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		SyToken* pTok = pGen->pIn;
		if (pTok >= pGen->pEnd) {
			pTok--;
		}

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Namespace: Unexpected token '%z'",&pTok->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_NSSEP | PHP_TK_ID | PHP_TK_KEYWORD))) {
		pGen->pIn++;
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,
			"Namespace: Unexpected token '%z',expecting ';' or '{'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	PHP_GenCompileError(&(*pGen),E_WARNING,nLine,
		"Namespace support is disabled in the current release of the PHP(%s) engine",php_lib_version());
	return SXRET_OK;
}

static sxi32 PHP_CompileUse(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	sxi32 rc;
	pGen->pIn++;

	for (;;) {
		if (pGen->pIn >= pGen->pEnd) {
			break;
		}

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_NSSEP | PHP_TK_ID))) {
			pGen->pIn++;
		}
		if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA)) {
			pGen->pIn++;
		}
		else {
			break;
		}
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD) && PHP_TKWRD_AS == SX_PTR_TO_INT(pGen->pIn->pUserData)) {
		pGen->pIn++;

		for (;;) {
			if (pGen->pIn >= pGen->pEnd) {
				break;
			}
			while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_NSSEP | PHP_TK_ID))) {
				pGen->pIn++;
			}
			if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA)) {
				pGen->pIn++;
			}
			else {
				break;
			}
		}
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"use statement: Unexpected token '%z',expecting ';'",
			&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	PHP_GenCompileError(&(*pGen),E_NOTICE,nLine,
		"Namespace support is disabled in the current release of the PHP(%s) engine",
		php_lib_version()
	);
	return SXRET_OK;
}

static sxi32 PHP_CompileDeclare(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	SyToken* pEnd = 0;
	sxi32 rc;
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0 ) {
		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"declare: Expecting opening parenthesis '('");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		goto Synchro;
	}
	pGen->pIn++;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN,PHP_TK_RPAREN,&pEnd);
	if (pEnd >= pGen->pEnd) {
		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"declare: Missing closing parenthesis ')'");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pGen->pIn = &pEnd[1];
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"declare: Expecting ';' or '{' after directive");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	PHP_GenCompileError(&(*pGen),E_NOTICE,nLine,
		"the declare construct is a no-op in the current release of the PHP(%s) engine",
		php_lib_version()
	);

	return SXRET_OK;
Synchro:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 GenStateProcessArgValue(php_gen_state* pGen,php_vm_func_arg* pArg,SyToken* pIn,SyToken* pEnd)
{
	SyToken* pTmpIn,* pTmpEnd;
	SySet* pInstrContainer;
	sxi32 rc;

	SWAP_DELIMITER(pGen,pIn,pEnd);
	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,&pArg->aByteCode);

	rc = PHP_CompileExpr(&(*pGen),0,0);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,(rc != SXERR_EMPTY ? 1 : 0),0,0,0);
	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);
	RE_SWAP_DELIMITER(pGen);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}
	return SXRET_OK;
}

static sxi32 GenStateCollectFuncArgs(php_vm_func* pFunc,php_gen_state* pGen,SyToken* pEnd)
{
	php_vm_func_arg sArg;
	SyToken* pCur,* pIn;
	SyBlob sSig;
	char* zDup;
	sxi32 rc;

	pIn = pGen->pIn;
	pCur = 0;
	SyBlobInit(&sSig,&pGen->pVm->sAllocator);

	for (;;) {
		if (pIn >= pEnd) {

			break;
		}
		SyZero(&sArg,sizeof(php_vm_func_arg));
		SySetInit(&sArg.aByteCode,&pGen->pVm->sAllocator,sizeof(VmInstr));
		if (pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD)) {
			if (pIn->nType & PHP_TK_KEYWORD) {
				sxu32 nKey = (sxu32)(SX_PTR_TO_INT(pIn->pUserData));
				if (nKey & PHP_TKWRD_ARRAY) {
					sArg.nType = MEMOBJ_HASHMAP;
				}
				else if (nKey & PHP_TKWRD_BOOL) {
					sArg.nType = MEMOBJ_BOOL;
				}
				else if (nKey & PHP_TKWRD_INT) {
					sArg.nType = MEMOBJ_INT;
				}
				else if (nKey & PHP_TKWRD_STRING) {
					sArg.nType = MEMOBJ_STRING;
				}
				else if (nKey & PHP_TKWRD_FLOAT) {
					sArg.nType = MEMOBJ_REAL;
				}
				else {
					PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,
						"Invalid argument type '%z',Automatic cast will not be performed",
						&pIn->sData);
				}
			}
			else {
				SyString* pName = &pIn->sData;
				char* zDup;

				zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
				if (zDup) {
					sArg.nType = SXU32_HIGH;
					SyStringInitFromBuf(&sArg.sClass,zDup,pName->nByte);
				}
			}
			pIn++;
		}
		if (pIn >= pEnd) {
			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Missing argument name");
			return rc;
		}
		if (pIn->nType & PHP_TK_AMPER) {

			sArg.iFlags = VM_FUNC_ARG_BY_REF;
			pIn++;
		}
		if (pIn >= pEnd || (pIn->nType & PHP_TK_DOLLAR) == 0 || &pIn[1] >= pEnd || (pIn[1].nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Invalid argument name");
			return rc;
		}
		pIn++;

		zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,SyStringData(&pIn->sData),SyStringLength(&pIn->sData));
		if (zDup == 0) {
			PHP_GenCompileError(&(*pGen),E_ERROR,pIn->nLine,"PHP engine is running out of memory");
			return SXERR_ABORT;
		}
		SyStringInitFromBuf(&sArg.sName,zDup,SyStringLength(&pIn->sData));
		pIn++;
		if (pIn < pEnd) {
			if (pIn->nType & PHP_TK_EQUAL) {
				SyToken* pDefend;
				sxi32 iNest = 0;
				pIn++;
				pDefend = pIn;

				while (pDefend < pEnd) {
					if ((pDefend->nType & PHP_TK_COMMA) && iNest <= 0) {
						break;
					}
					if (pDefend->nType & (PHP_TK_LPAREN | PHP_TK_OCB | PHP_TK_OSB)) {

						iNest++;
					}
					else if (pDefend->nType & (PHP_TK_RPAREN | PHP_TK_CCB | PHP_TK_CSB)) {

						iNest--;
					}
					pDefend++;
				}
				if (pIn >= pDefend) {
					rc = PHP_GenCompileError(&(*pGen),E_ERROR,pIn->nLine,"Missing argument default value");
					return rc;
				}

				rc = GenStateProcessArgValue(&(*pGen),&sArg,pIn,pDefend);
				if (rc != SXRET_OK) {
					return rc;
				}

				pIn = pDefend;
			}
			if (pIn < pEnd && (pIn->nType & PHP_TK_COMMA) == 0) {
				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pIn->nLine,"Unexpected token '%z'",&pIn->sData);
				return rc;
			}
			pIn++;
		}

		if (sArg.nType > 0) {
			if (SyStringLength(&sArg.sClass) > 0) {

				SyBlobAppend(&sSig,SyStringData(&sArg.sClass),SyStringLength(&sArg.sClass));
			}
			else {
				int c;
				c = 'n';

				switch (sArg.nType) {
				case MEMOBJ_HASHMAP:

					c = 'h';
					break;
				case MEMOBJ_INT:

					c = 'i';
					break;
				case MEMOBJ_BOOL:

					c = 'b';
					break;
				case MEMOBJ_REAL:

					c = 'f';
					break;
				case MEMOBJ_STRING:

					c = 's';
					break;
				default:
					break;
				}
				SyBlobAppend(&sSig,(const void*)&c,sizeof(char));
			}
		}
		else {

			SyBlobRelease(&sSig);
		}

		SySetPut(&pFunc->aArgs,(const void*)&sArg);
	}
	if (SyBlobLength(&sSig) > 0) {

		SyStringInitFromBuf(&pFunc->sSignature,SyBlobData(&sSig),SyBlobLength(&sSig));
	}
	return SXRET_OK;
}

static sxi32 GenStateCompileFuncBody(
	php_gen_state* pGen,
	php_vm_func* pFunc
)
{
	SySet* pInstrContainer;
	GenBlock* pBlock;
	sxu32 nGotoOfft;
	sxi32 rc;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_PROTECTED | GEN_BLOCK_FUNC,PHP_VmInstrLength(pGen->pVm),pFunc,&pBlock);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(&(*pGen),E_ERROR,1,"PHP engine is running out-of-memory");

		return SXERR_ABORT;
	}
	nGotoOfft = SySetUsed(&pGen->aGoto);

	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,&pFunc->aByteCode);

	PHP_CompileBlock(&(*pGen),0);

	GenStateFixJumps(pGen->pCurrent,PHP_OP_THROW,PHP_VmInstrLength(pGen->pVm));

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,0,0,0,0);

	if (SXERR_ABORT == GenStateFixGoto(&(*pGen),nGotoOfft)) {
		rc = SXERR_ABORT;
	}
	SySetTruncate(&pGen->aGoto,nGotoOfft);

	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);

	GenStateLeaveBlock(&(*pGen),0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	return SXRET_OK;
}

static sxi32 GenStateCompileFunc(
	php_gen_state* pGen,
	SyString* pName,
	sxi32 iFlags,
	int bHandleClosure,
	php_vm_func** ppFunc
)
{
	php_vm_func* pFunc;
	SyToken* pEnd;
	sxu32 nLine;
	char* zName;
	sxi32 rc;

	nLine = pGen->pIn->nLine;

	pGen->pIn++;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Missing ')' after function '%z' signature",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		pGen->pIn = pGen->pEnd;
		return SXRET_OK;
	}

	pFunc = (php_vm_func*)SyMemBackendPoolAlloc(&pGen->pVm->sAllocator,sizeof(php_vm_func));
	if (pFunc == 0) {
		goto OutOfMem;
	}

	zName = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
	if (zName == 0) {

		goto OutOfMem;
	}

	PHP_VmInitFuncState(pGen->pVm,pFunc,zName,pName->nByte,iFlags,0);
	if (pGen->pIn < pEnd) {

		rc = GenStateCollectFuncArgs(pFunc,&(*pGen),pEnd);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}

	pGen->pIn = &pEnd[1];
	if (bHandleClosure) {
		php_vm_func_closure_env sEnv; int got_this = 0;
		if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)
			&& SX_PTR_TO_INT(pGen->pIn->pUserData) == PHP_TKWRD_USE) {
			sxu32 nLine = pGen->pIn->nLine;

			pGen->pIn++;
			if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {
				rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Closure: Unexpected token. Expecting a left parenthesis '('");
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			pGen->pIn++;

			while (pGen->pIn < pGen->pEnd) {
				int iFlags = 0;
				if (pGen->pIn->nType & PHP_TK_RPAREN) {
					pGen->pIn++;
					break;
				}
				nLine = pGen->pIn->nLine;
				if (pGen->pIn->nType & PHP_TK_AMPER) {

					PHP_GenCompileError(pGen,E_WARNING,nLine,
						"Closure: Pass by reference is disabled in the current release of the PHP engine,PHP is switching to pass by value"
					);
					iFlags = VM_FUNC_ARG_BY_REF;
					pGen->pIn++;
				}
				if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0 || &pGen->pIn[1] >= pGen->pEnd
					|| (pGen->pIn[1].nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {
					rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
						"Closure: Unexpected token. Expecting a variable name");
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}

					while ((pGen->pIn < pGen->pEnd) && (pGen->pIn->nType & PHP_TK_RPAREN) == 0) {
						pGen->pIn++;
					}
					if (pGen->pIn < pGen->pEnd) {
						pGen->pIn++;
					}
					break;

				}
				else {
					SyString* pName;
					char* zDup;

					pName = &pGen->pIn[1].sData;
					zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
					if (zDup) {

						SyZero(&sEnv,sizeof(php_vm_func_closure_env));
						sEnv.iFlags = iFlags;
						PHP_MemObjInit(pGen->pVm,&sEnv.sValue);
						SyStringInitFromBuf(&sEnv.sName,zDup,pName->nByte);
						if (!got_this && pName->nByte == sizeof("this") - 1 &&
							SyMemcmp((const void*)zDup,(const void*)"this",sizeof("this") - 1) == 0) {
							got_this = 1;
						}

						SySetPut(&pFunc->aClosureEnv,(const void*)&sEnv);
					}
					else {
						PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
						return SXERR_ABORT;
					}
				}
				pGen->pIn += 2;
				while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA )) {

					pGen->pIn++;
				}
			}
			if (!got_this) {

				SyZero(&sEnv,sizeof(php_vm_func_closure_env));
				sEnv.iFlags = VM_FUNC_ARG_IGNORE;
				PHP_MemObjInit(pGen->pVm,&sEnv.sValue);
				SyStringInitFromBuf(&sEnv.sName,"this",sizeof("this") - 1);
				SySetPut(&pFunc->aClosureEnv,(const void*)&sEnv);
			}
			if (SySetUsed(&pFunc->aClosureEnv) > 0) {

				pFunc->iFlags |= VM_FUNC_CLOSURE;
			}
		}
	}

	rc = GenStateCompileFuncBody(&(*pGen),pFunc);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}
	if (ppFunc) {
		*ppFunc = pFunc;
	}
	rc = SXRET_OK;
	if ((pFunc->iFlags & VM_FUNC_CLOSURE) == 0) {

		rc = PHP_VmInstallUserFunction(pGen->pVm,pFunc,0);
	}
	if (rc == SXRET_OK) {
		return SXRET_OK;
	}

OutOfMem:

	PHP_GenCompileError(&(*pGen),E_ERROR,1,"Fatal,PHP engine is running out-of-memory");
	return SXERR_ABORT;
}

static sxi32 PHP_CompileFunction(php_gen_state* pGen)
{
	SyString* pName;
	sxi32 iFlags;
	sxu32 nLine;
	sxi32 rc;

	nLine = pGen->pIn->nLine;
	pGen->pIn++;
	iFlags = 0;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_AMPER)) {

		iFlags |= VM_FUNC_REF_RETURN;

		pGen->pIn++;
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Invalid function name");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
			pGen->pIn++;
		}
		return SXRET_OK;
	}
	pName = &pGen->pIn->sData;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after function name '%z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_OCB)) == 0) {
			pGen->pIn++;
		}
		return SXRET_OK;
	}

	rc = GenStateCompileFunc(&(*pGen),pName,iFlags,FALSE,0);
	return rc;
}

static sxi32 GetProtectionLevel(sxi32 nKeyword)
{
	if (nKeyword == PHP_TKWRD_PRIVATE) {
		return PHP_CLASS_PROT_PRIVATE;
	}
	else if (nKeyword == PHP_TKWRD_PROTECTED) {
		return PHP_CLASS_PROT_PROTECTED;
	}

	return PHP_CLASS_PROT_PUBLIC;
}

static sxi32 GenStateCompileClassConstant(php_gen_state* pGen,sxi32 iProtection,sxi32 iFlags,php_class* pClass)
{
	sxu32 nLine = pGen->pIn->nLine;
	SySet* pInstrContainer;
	php_class_attr* pCons;
	SyString* pName;
	sxi32 rc;

	iProtection = GetProtectionLevel(iProtection);
	pGen->pIn++;
loop:

	iFlags |= PHP_CLASS_ATTR_CONSTANT;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Invalid constant name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pName = &pGen->pIn->sData;

	if (GenStateIsReservedConstant(pName)) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Cannot redeclare a reserved constant '%z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_EQUAL ) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '=' after class constant %z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	pGen->pIn++;

	pCons = PHP_NewClassAttr(pGen->pVm,pName,nLine,iProtection,iFlags);
	if (pCons == 0) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}

	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,&pCons->aByteCode);

	rc = PHP_CompileExpr(&(*pGen),EXPR_FLAG_COMMA_STATEMENT,0);
	if (rc == SXERR_EMPTY) {
		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Empty constant '%z' value",pName);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,1,0,0,0);
	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	rc = PHP_ClassInstallAttr(pClass,pCons);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA )) {

		pGen->pIn++;
		if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {
			SyToken* pTok = pGen->pIn;
			if (pTok >= pGen->pEnd) {
				pTok--;
			}
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Unexpected token '%z',expecting constant declaration inside class '%z'",
				&pTok->sData,&pClass->sName);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		else {
			if (pGen->pIn->nType & PHP_TK_ID) {
				goto loop;
			}
		}
	}
	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && ((pGen->pIn->nType & PHP_TK_SEMI) == 0)) {
		pGen->pIn++;
	}
	return SXERR_CORRUPT;
}

static sxi32 GenStateCompileClassAttr(php_gen_state* pGen,sxi32 iProtection,sxi32 iFlags,php_class* pClass)
{
	sxu32 nLine = pGen->pIn->nLine;
	php_class_attr* pAttr;
	SyString* pName;
	sxi32 rc;

	iProtection = GetProtectionLevel(iProtection);
loop:
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_KEYWORD | PHP_TK_ID)) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Invalid attribute name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pName = &pGen->pIn->sData;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_EQUAL | PHP_TK_SEMI | PHP_TK_COMMA)) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '=' or ';' after attribute name '%z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pAttr = PHP_NewClassAttr(pGen->pVm,pName,nLine,iProtection,iFlags);
	if (pAttr == 0) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP engine is running out of memory");
		return SXERR_ABORT;
	}
	if (pGen->pIn->nType & PHP_TK_EQUAL ) {
		SySet* pInstrContainer;
		pGen->pIn++;

		pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
		PHP_VmSetByteCodeContainer(pGen->pVm,&pAttr->aByteCode);

		rc = PHP_CompileExpr(&(*pGen),EXPR_FLAG_COMMA_STATEMENT,0);
		if (rc == SXERR_EMPTY) {
			rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Attribute '%z': Missing default value",pName);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,1,0,0,0);
		PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);
	}

	rc = PHP_ClassInstallAttr(pClass,pAttr);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_COMMA )) {

		pGen->pIn++;
		if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0) {
			SyToken* pTok = pGen->pIn;
			if (pTok >= pGen->pEnd) {
				pTok--;
			}
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Unexpected token '%z',expecting attribute declaration inside class '%z'",
				&pTok->sData,&pClass->sName);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}
		else {
			if (pGen->pIn->nType & PHP_TK_DOLLAR) {
				goto loop;
			}
		}
	}
	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && ((pGen->pIn->nType & PHP_TK_SEMI) == 0)) {
		pGen->pIn++;
	}
	return SXERR_CORRUPT;
}

static sxi32 GenStateCompileClassMethod(
	php_gen_state* pGen,
	sxi32 iProtection,
	sxi32 iFlags,
	int doBody,
	php_class* pClass
)
{
	sxu32 nLine = pGen->pIn->nLine;
	php_class_method* pMeth;
	sxi32 iFuncFlags;
	SyString* pName;
	SyToken* pEnd;
	sxi32 rc;

	iProtection = GetProtectionLevel(iProtection);
	pGen->pIn++;
	iFuncFlags = 0;
	if (pGen->pIn >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Invalid method name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_AMPER)) {

		iFuncFlags |= VM_FUNC_REF_RETURN;

		pGen->pIn++;
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_ID)) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Invalid method name");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pName = &pGen->pIn->sData;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (iFlags & PHP_CLASS_ATTR_ABSTRACT) {

		if (iProtection == PHP_CLASS_PROT_PRIVATE) {
			rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
				"Access type for abstract method '%z::%z' cannot be 'private'",
				&pClass->sName,pName);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
		}

		doBody = FALSE;
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after method name '%z'",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pMeth = PHP_NewClassMethod(pGen->pVm,pClass,pName,nLine,iProtection,iFlags,iFuncFlags);
	if (pMeth == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}

	pGen->pIn++;
	pEnd = 0;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Missing ')' after method '%z' declaration",pName);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}
	if (pGen->pIn < pEnd) {

		rc = GenStateCollectFuncArgs(&pMeth->sFunc,&(*pGen),pEnd);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}

	pGen->pIn = &pEnd[1];
	if (doBody) {

		rc = GenStateCompileFuncBody(&(*pGen),&pMeth->sFunc);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	else {

		if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI ) == 0) {
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Expected ';' after method signature '%z'",pName);
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			return SXERR_CORRUPT;
		}
	}

	rc = PHP_ClassInstallMethod(pClass,pMeth);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}
	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && ((pGen->pIn->nType & PHP_TK_SEMI) == 0)) {
		pGen->pIn++;
	}
	return SXERR_CORRUPT;
}

static sxi32 PHP_CompileClassInterface(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	php_class* pClass,* pBase;
	SyToken* pEnd,* pTmp;
	SyString* pName;
	sxi32 nKwrd;
	sxi32 rc;

	pGen->pIn++;

	pName = &pGen->pIn->sData;

	pGen->pIn++;

	pClass = PHP_NewRawClass(pGen->pVm,pName,nLine);
	if (pClass == 0) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}

	pClass->iFlags = PHP_CLASS_INTERFACE;

	pBase = 0;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)) {
		nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
		if (nKwrd == PHP_TKWRD_EXTENDS ) {
			SyString* pBaseName;

			pGen->pIn++;
			if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {

				rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
					"Expected 'interface_name' after 'extends' keyword inside interface '%z'",
					pName);
				SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
				return SXRET_OK;
			}
			pBaseName = &pGen->pIn->sData;
			pBase = PHP_VmExtractClass(pGen->pVm,pBaseName->zString,pBaseName->nByte,FALSE,0);

			while (pBase && (pBase->iFlags & PHP_CLASS_INTERFACE) == 0) {
				pBase = pBase->pNextName;
			}
			if (pBase == 0) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"Inexistant base interface '%z'",pBaseName);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
			}

			pGen->pIn++;
		}
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_OCB ) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '{' after interface '%z' definition",pName);
		SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}
	pGen->pIn++;
	pEnd = 0;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_OCB,PHP_TK_CCB,&pEnd);
	if (pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Missing '}' after interface '%z' definition",pName);
		SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	for (;;) {

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI)) {
			pGen->pIn++;
		}
		if (pGen->pIn >= pGen->pEnd) {

			break;
		}
		if ((pGen->pIn->nType & PHP_TK_KEYWORD) == 0) {
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Unexpected token '%z'.Expecting method signature or constant declaration inside interface '%z'",
				&pGen->pIn->sData,pName);
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			goto done;
		}

		nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
		if (nKwrd == PHP_TKWRD_PRIVATE || nKwrd == PHP_TKWRD_PROTECTED) {

			PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,"interface: Access type must be public");
			nKwrd = PHP_TKWRD_PUBLIC;
		}
		if (nKwrd != PHP_TKWRD_PUBLIC && nKwrd != PHP_TKWRD_FUNCTION && nKwrd != PHP_TKWRD_CONST && nKwrd != PHP_TKWRD_STATIC) {
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Expecting method signature or constant declaration inside interface '%z'",pName);
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			goto done;
		}
		if (nKwrd == PHP_TKWRD_PUBLIC) {

			pGen->pIn++;
			if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0) {
				rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
					"Expecting method signature inside interface '%z'",pName);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
				goto done;
			}
			nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
			if (nKwrd != PHP_TKWRD_FUNCTION && nKwrd != PHP_TKWRD_CONST && nKwrd != PHP_TKWRD_STATIC) {
				rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
					"Expecting method signature or constant declaration inside interface '%z'",pName);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
				goto done;
			}
		}
		if (nKwrd == PHP_TKWRD_CONST) {

			rc = GenStateCompileClassConstant(&(*pGen),0,0,pClass);
			if (rc != SXRET_OK) {
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				goto done;
			}
		}
		else {
			sxi32 iFlags = 0;
			if (nKwrd == PHP_TKWRD_STATIC) {

				iFlags |= PHP_CLASS_ATTR_STATIC;

				pGen->pIn++;
				if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0
					|| SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_FUNCTION) {
					rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
						"Expecting method signature inside interface '%z'",pName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
					goto done;
				}
			}

			rc = GenStateCompileClassMethod(&(*pGen),0,FALSE,iFlags,pClass);
			if (rc != SXRET_OK) {
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				goto done;
			}
		}
	}

	rc = PHP_VmInstallClass(pGen->pVm,pClass);
	if (rc == SXRET_OK && pBase) {

		rc = PHP_ClassInterfaceInherit(pClass,pBase);
	}
	if (rc != SXRET_OK) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}
done:

	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;
	return PHP_OK;
}

static sxi32 GenStateCompileClass(php_gen_state* pGen,sxi32 iFlags)
{
	sxu32 nLine = pGen->pIn->nLine;
	php_class* pClass,* pBase;
	SyToken* pEnd,* pTmp;
	sxi32 iProtection;
	SySet aInterfaces;
	sxi32 iAttrflags;
	SyString* pName;
	sxi32 nKwrd;
	sxi32 rc;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Invalid class name");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_OCB | PHP_TK_SEMI)) == 0) {
			pGen->pIn++;
		}
		return SXRET_OK;
	}

	pName = &pGen->pIn->sData;

	pGen->pIn++;

	pClass = PHP_NewRawClass(pGen->pVm,pName,nLine);
	if (pClass == 0) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}

	SySetInit(&aInterfaces,&pGen->pVm->sAllocator,sizeof(php_class*));

	pBase = 0;
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)) {
		SyString* pBaseName;
		nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
		if (nKwrd == PHP_TKWRD_EXTENDS ) {
			pGen->pIn++;
			if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {

				rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
					"Expected 'class_name' after 'extends' keyword inside class '%z'",
					pName);
				SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
				return SXRET_OK;
			}

			pBaseName = &pGen->pIn->sData;

			pBase = PHP_VmExtractClass(pGen->pVm,pBaseName->zString,pBaseName->nByte,FALSE,0);

			while (pBase && (pBase->iFlags & PHP_CLASS_INTERFACE)) {
				pBase = pBase->pNextName;
			}
			if (pBase == 0) {

				rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"Inexistant base class '%z'",pBaseName);
				if (rc == SXERR_ABORT) {

					return SXERR_ABORT;
				}
			}
			else {
				if (pBase->iFlags & PHP_CLASS_FINAL) {
					rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
						"Class '%z' may not inherit from final class '%z'",pName,&pBase->sName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
				}
			}

			pGen->pIn++;
		}
		if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD) && SX_PTR_TO_INT(pGen->pIn->pUserData) == PHP_TKWRD_IMPLEMENTS) {
			php_class* pInterface;
			SyString* pIntName;

			pGen->pIn++;
			for (;;) {
				if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_ID) == 0) {

					rc = PHP_GenCompileError(pGen,E_ERROR,nLine,
						"Expected 'interface_name' after 'implements' keyword inside class '%z' declaration",
						pName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
					break;
				}

				pIntName = &pGen->pIn->sData;

				pInterface = PHP_VmExtractClass(pGen->pVm,pIntName->zString,pIntName->nByte,FALSE,0);

				while (pInterface && (pInterface->iFlags & PHP_CLASS_INTERFACE) == 0) {
					pInterface = pInterface->pNextName;
				}
				if (pInterface == 0) {

					rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"Inexistant base interface '%z'",pIntName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
				}
				else {

					SySetPut(&aInterfaces,(const void*)&pInterface);
				}

				pGen->pIn++;
				if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_COMMA) == 0) {
					break;
				}
				pGen->pIn++;
			}
		}
	}
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_OCB ) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '{' after class '%z' declaration",pName);
		SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}
	pGen->pIn++;
	pEnd = 0;

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_OCB,PHP_TK_CCB,&pEnd);
	if (pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Missing closing braces'}' after class '%z' definition",pName);
		SyMemBackendPoolFree(&pGen->pVm->sAllocator,pClass);
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	pClass->iFlags = iFlags;

	for (;;) {

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI)) {
			pGen->pIn++;
		}
		if (pGen->pIn >= pGen->pEnd) {

			break;
		}
		if ((pGen->pIn->nType & (PHP_TK_KEYWORD | PHP_TK_DOLLAR)) == 0) {
			rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
				"Unexpected token '%z'. Expecting attribute declaration inside class '%z'",
				&pGen->pIn->sData,pName);
			if (rc == SXERR_ABORT) {

				return SXERR_ABORT;
			}
			goto done;
		}

		iProtection = PHP_TKWRD_PUBLIC;
		iAttrflags = 0;
		if (pGen->pIn->nType & PHP_TK_KEYWORD) {

			nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
			if (nKwrd == PHP_TKWRD_PUBLIC || nKwrd == PHP_TKWRD_PRIVATE || nKwrd == PHP_TKWRD_PROTECTED) {
				iProtection = nKwrd;
				pGen->pIn++;
				if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_KEYWORD | PHP_TK_DOLLAR)) == 0) {
					rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
						"Unexpected token '%z'. Expecting attribute declaration inside class '%z'",
						&pGen->pIn->sData,pName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
					goto done;
				}
				if (pGen->pIn->nType & PHP_TK_DOLLAR) {

					rc = GenStateCompileClassAttr(&(*pGen),iProtection,iAttrflags,pClass);
					if (rc != SXRET_OK) {
						if (rc == SXERR_ABORT) {
							return SXERR_ABORT;
						}
						goto done;
					}
					continue;
				}

				nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
			}
			if (nKwrd == PHP_TKWRD_CONST) {

				rc = GenStateCompileClassConstant(&(*pGen),iProtection,iAttrflags,pClass);
				if (rc != SXRET_OK) {
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
					goto done;
				}
			}
			else {
				if (nKwrd == PHP_TKWRD_STATIC) {

					iAttrflags |= PHP_CLASS_ATTR_STATIC;
					pGen->pIn++;
					if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)) {

						nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
						if (nKwrd == PHP_TKWRD_PUBLIC || nKwrd == PHP_TKWRD_PRIVATE || nKwrd == PHP_TKWRD_PROTECTED) {
							iProtection = nKwrd;
							pGen->pIn++;
						}
					}
					if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & (PHP_TK_KEYWORD | PHP_TK_DOLLAR)) == 0) {
						rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
							"Unexpected token '%z',Expecting method,attribute or constant declaration inside class '%z'",
							&pGen->pIn->sData,pName);
						if (rc == SXERR_ABORT) {

							return SXERR_ABORT;
						}
						goto done;
					}
					if (pGen->pIn->nType & PHP_TK_DOLLAR) {

						rc = GenStateCompileClassAttr(&(*pGen),iProtection,iAttrflags,pClass);
						if (rc != SXRET_OK) {
							if (rc == SXERR_ABORT) {
								return SXERR_ABORT;
							}
							goto done;
						}
						continue;
					}

					nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
				}
				else if (nKwrd == PHP_TKWRD_ABSTRACT) {

					iAttrflags |= PHP_CLASS_ATTR_ABSTRACT;

					pClass->iFlags |= PHP_CLASS_ABSTRACT;

					pGen->pIn++;
					if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)) {
						nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
						if (nKwrd == PHP_TKWRD_PUBLIC || nKwrd == PHP_TKWRD_PRIVATE || nKwrd == PHP_TKWRD_PROTECTED) {
							iProtection = nKwrd;
							pGen->pIn++;
						}
					}
					if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD) &&
						SX_PTR_TO_INT(pGen->pIn->pUserData) == PHP_TKWRD_STATIC) {

						iAttrflags |= PHP_CLASS_ATTR_STATIC;
						pGen->pIn++;
					}
					if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0 ||
						SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_FUNCTION) {
						rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
							"Unexpected token '%z',Expecting method declaration after 'abstract' keyword inside class '%z'",
							&pGen->pIn->sData,pName);
						if (rc == SXERR_ABORT) {

							return SXERR_ABORT;
						}
						goto done;
					}
					nKwrd = PHP_TKWRD_FUNCTION;
				}
				else if (nKwrd == PHP_TKWRD_FINAL) {

					iAttrflags |= PHP_CLASS_ATTR_FINAL;
					pGen->pIn++;
					if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD)) {

						nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
						if (nKwrd == PHP_TKWRD_PUBLIC || nKwrd == PHP_TKWRD_PRIVATE || nKwrd == PHP_TKWRD_PROTECTED) {
							iProtection = nKwrd;
							pGen->pIn++;
						}
					}
					if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_KEYWORD) &&
						SX_PTR_TO_INT(pGen->pIn->pUserData) == PHP_TKWRD_STATIC) {

						iAttrflags |= PHP_CLASS_ATTR_STATIC;
						pGen->pIn++;
					}
					if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0 ||
						SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_FUNCTION) {
						rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
							"Unexpected token '%z',Expecting method declaration after 'final' keyword inside class '%z'",
							&pGen->pIn->sData,pName);
						if (rc == SXERR_ABORT) {

							return SXERR_ABORT;
						}
						goto done;
					}
					nKwrd = PHP_TKWRD_FUNCTION;
				}
				if (nKwrd != PHP_TKWRD_FUNCTION && nKwrd != PHP_TKWRD_VAR) {
					rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
						"Unexpected token '%z',Expecting method declaration inside class '%z'",
						&pGen->pIn->sData,pName);
					if (rc == SXERR_ABORT) {

						return SXERR_ABORT;
					}
					goto done;
				}
				if (nKwrd == PHP_TKWRD_VAR) {
					pGen->pIn++;
					if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0) {
						rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
							"Expecting attribute declaration after 'var' keyword");
						if (rc == SXERR_ABORT) {

							return SXERR_ABORT;
						}
						goto done;
					}

					rc = GenStateCompileClassAttr(&(*pGen),iProtection,iAttrflags,pClass);
				}
				else {

					rc = GenStateCompileClassMethod(&(*pGen),iProtection,iAttrflags,TRUE,pClass);
				}
				if (rc != SXRET_OK) {
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}
					goto done;
				}
			}
		}
		else {

			rc = GenStateCompileClassAttr(&(*pGen),iProtection,iAttrflags,pClass);
			if (rc != SXRET_OK) {
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
				goto done;
			}
		}
	}

	rc = PHP_VmInstallClass(pGen->pVm,pClass);
	if (rc == SXRET_OK) {
		php_class** apInterface;
		sxu32 n;
		if (pBase) {

			rc = PHP_ClassInherit(&(*pGen),pClass,pBase);
		}
		apInterface = (php_class**)SySetBasePtr(&aInterfaces);
		for (n = 0; n < SySetUsed(&aInterfaces); n++) {

			rc = PHP_ClassImplement(pClass,apInterface[n]);
			if (rc != SXRET_OK) {
				break;
			}
		}
	}
	SySetRelease(&aInterfaces);
	if (rc != SXRET_OK) {
		PHP_GenCompileError(pGen,E_ERROR,nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}
done:

	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;
	return PHP_OK;
}

static sxi32 PHP_CompileAbstractClass(php_gen_state* pGen)
{
	sxi32 rc;
	pGen->pIn++;
	rc = GenStateCompileClass(&(*pGen),PHP_CLASS_ABSTRACT);
	return rc;
}

static sxi32 PHP_CompileFinalClass(php_gen_state* pGen)
{
	sxi32 rc;
	pGen->pIn++;
	rc = GenStateCompileClass(&(*pGen),PHP_CLASS_FINAL);
	return rc;
}

static sxi32 PHP_CompileClass(php_gen_state* pGen)
{
	sxi32 rc;
	rc = GenStateCompileClass(&(*pGen),0);
	return rc;
}


static sxi32 GenStateThrowNodeValidator(php_gen_state* pGen,php_expr_node* pRoot)
{
	sxi32 rc = SXRET_OK;
	if (pRoot->pOp) {
		if (pRoot->pOp->iOp != EXPR_OP_SUBSCRIPT  && pRoot->pOp->iOp != EXPR_OP_NEW
			&& pRoot->pOp->iOp != EXPR_OP_ARROW  && pRoot->pOp->iOp != EXPR_OP_DC ) {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
				"throw: Expecting an exception class instance");
			if (rc != SXERR_ABORT) {
				rc = SXERR_INVALID;
			}
		}
	}
	else if (pRoot->xCode != PHP_CompileVariable) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pRoot->pStart ? pRoot->pStart->nLine : 0,
			"throw: Expecting an exception class instance");
		if (rc != SXERR_ABORT) {
			rc = SXERR_INVALID;
		}
	}
	return rc;
}

static sxi32 PHP_CompileThrow(php_gen_state* pGen)
{
	sxu32 nLine = pGen->pIn->nLine;
	GenBlock* pBlock;
	sxu32 nIdx;
	sxi32 rc;
	pGen->pIn++;

	rc = PHP_CompileExpr(&(*pGen),0,GenStateThrowNodeValidator);
	if (rc == SXERR_EMPTY) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"throw: Expecting an exception class instance");
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXRET_OK;
	}
	pBlock = pGen->pCurrent;
	while (pBlock->pParent) {
		if (pBlock->iFlags & (GEN_BLOCK_EXCEPTION | GEN_BLOCK_FUNC)) {
			break;
		}
		pBlock = pBlock->pParent;
	}
	PHP_VmEmitInstr(pGen->pVm,PHP_OP_THROW,0,0,0,&nIdx);
	GenStateNewJumpFixup(pBlock,PHP_OP_THROW,nIdx);
	return SXRET_OK;
}

static sxi32 PHP_CompileCatch(php_gen_state* pGen,php_exception* pException)
{
	sxu32 nLine = pGen->pIn->nLine;
	php_exception_block sCatch;
	SySet* pInstrContainer;
	GenBlock* pCatch;
	SyToken* pToken;
	SyString* pName;
	char* zDup;
	sxi32 rc;
	pGen->pIn++;

	SyZero(&sCatch,sizeof(php_exception_block));

	SySetInit(&sCatch.sByteCode,&pException->pVm->sAllocator,sizeof(VmInstr));
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0  ||
		&pGen->pIn[1] >= pGen->pEnd || (pGen->pIn[1].nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {

		pToken = pGen->pIn;
		if (pToken >= pGen->pEnd) {
			pToken--;
		}
		rc = PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,
			"Catch: Unexpected token '%z',excpecting class name",&pToken->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXERR_INVALID;
	}

	pGen->pIn++;

	pName = &pGen->pIn->sData;
	zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
	if (zDup == 0) {
		goto Mem;
	}
	SyStringInitFromBuf(&sCatch.sClass,zDup,pName->nByte);
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_DOLLAR) == 0  ||
		&pGen->pIn[1] >= pGen->pEnd || (pGen->pIn[1].nType & (PHP_TK_ID | PHP_TK_KEYWORD)) == 0) {

		pToken = pGen->pIn;
		if (pToken >= pGen->pEnd) {
			pToken--;
		}
		rc = PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,
			"Catch: Unexpected token '%z',expecting variable name",&pToken->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXERR_INVALID;
	}
	pGen->pIn++;

	pName = &pGen->pIn->sData;
	zDup = SyMemBackendStrDup(&pGen->pVm->sAllocator,pName->zString,pName->nByte);
	if (zDup == 0) {
		goto Mem;
	}
	SyStringInitFromBuf(&sCatch.sThis,zDup,pName->nByte);
	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_RPAREN) == 0 ) {

		pToken = pGen->pIn;
		if (pToken >= pGen->pEnd) {
			pToken--;
		}
		rc = PHP_GenCompileError(pGen,E_ERROR,pToken->nLine,
			"Catch: Unexpected token '%z',expecting right parenthesis ')'",&pToken->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXERR_INVALID;
	}

	pGen->pIn++;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_EXCEPTION,PHP_VmInstrLength(pGen->pVm),0,&pCatch);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,&sCatch.sByteCode);

	PHP_CompileBlock(&(*pGen),0);

	GenStateFixJumps(pCatch,-1,PHP_VmInstrLength(pGen->pVm));

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,0,0,0,0);

	GenStateLeaveBlock(&(*pGen),0);

	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);

	rc = SySetPut(&pException->sEntry,(const void*)&sCatch);
	if (rc != SXRET_OK) {
		goto Mem;
	}
	return SXRET_OK;
Mem:
	PHP_GenCompileError(&(*pGen),E_ERROR,nLine,"Fatal,PHP engine is running out of memory");
	return SXERR_ABORT;
}

static sxi32 PHP_CompileTry(php_gen_state* pGen)
{
	php_exception* pException;
	GenBlock* pTry;
	sxu32 nJmpIdx;
	sxi32 rc;

	pException = (php_exception*)SyMemBackendAlloc(&pGen->pVm->sAllocator,sizeof(php_exception));
	if (pException == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,
			pGen->pIn->nLine,"Fatal,PHP engine is running out of memory");
		return SXERR_ABORT;
	}

	SyZero(pException,sizeof(php_exception));

	SySetInit(&pException->sEntry,&pGen->pVm->sAllocator,sizeof(php_exception_block));
	pException->pVm = pGen->pVm;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_EXCEPTION,PHP_VmInstrLength(pGen->pVm),0,&pTry);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_LOAD_EXCEPTION,0,0,pException,&nJmpIdx);

	GenStateNewJumpFixup(pTry,PHP_OP_LOAD_EXCEPTION,nJmpIdx);
	pGen->pIn++;

	rc = PHP_CompileBlock(&(*pGen),0);
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}

	GenStateFixJumps(pTry,-1,PHP_VmInstrLength(pGen->pVm));

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP_EXCEPTION,0,0,pException,0);

	GenStateLeaveBlock(&(*pGen),0);

	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0 ||
		SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_CATCH) {
		SyToken* pTok = pGen->pIn;
		if (pTok >= pGen->pEnd) {
			pTok--;
		}

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pTok->nLine,
			"Try: Unexpected token '%z',expecting 'catch' block",&pTok->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		return SXRET_OK;
	}

	for (;;) {
		if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_KEYWORD) == 0
			|| SX_PTR_TO_INT(pGen->pIn->pUserData) != PHP_TKWRD_CATCH) {

			break;
		}

		rc = PHP_CompileCatch(&(*pGen),pException);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	return SXRET_OK;
}

static sxi32 GenStateCompileSwitchBlock(php_gen_state* pGen,sxu32 iTokenDelim,sxu32* pBlockStart)
{
	sxi32 rc = SXRET_OK;
	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & (PHP_TK_SEMI | PHP_TK_COLON)) == 0) {

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		pGen->pIn++;
	}
	pGen->pIn++;

	*pBlockStart = PHP_VmInstrLength(pGen->pVm);

	for (;;) {
		if (pGen->pIn >= pGen->pEnd) {

			break;
		}
		rc = SXRET_OK;
		if ((pGen->pIn->nType & PHP_TK_KEYWORD) == 0) {
			if (pGen->pIn->nType & PHP_TK_CCB ) {
				if (iTokenDelim != PHP_TK_CCB) {

					rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",
						&pGen->pIn->sData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}

				}
				rc = SXERR_EOF;
				break;
			}
		}
		else {
			sxi32 nKwrd;

			nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
			if (nKwrd == PHP_TKWRD_CASE || nKwrd == PHP_TKWRD_DEFAULT) {
				break;
			}
			if (nKwrd == PHP_TKWRD_ENDSWITCH ) {
				if (iTokenDelim != PHP_TK_KEYWORD) {

					rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Unexpected token '%z'",
						&pGen->pIn->sData);
					if (rc == SXERR_ABORT) {
						return SXERR_ABORT;
					}

				}

				break;
			}
		}

		rc = PHP_CompileBlock(&(*pGen),0);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
	}
	return rc;
}

static sxi32 GenStateCompileCaseExpr(php_gen_state* pGen,php_case_expr* pExpr)
{
	SySet* pInstrContainer;
	SyToken* pEnd,* pTmp;
	sxi32 iNest = 0;
	sxi32 rc;

	pEnd = pGen->pIn;
	while (pEnd < pGen->pEnd) {
		if (pEnd->nType & PHP_TK_LPAREN ) {

			iNest++;
		}
		else if (pEnd->nType & PHP_TK_RPAREN ) {

			iNest--;
		}
		else if (pEnd->nType & (PHP_TK_SEMI | PHP_TK_COLON) && iNest < 1) {
			break;
		}
		pEnd++;
	}
	if (pGen->pIn >= pEnd) {
		rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,"Empty case expression");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;
	pInstrContainer = PHP_VmGetByteCodeContainer(pGen->pVm);
	PHP_VmSetByteCodeContainer(pGen->pVm,&pExpr->aByteCode);
	rc = PHP_CompileExpr(&(*pGen),0,0);

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,(rc != SXERR_EMPTY ? 1 : 0),0,0,0);
	PHP_VmSetByteCodeContainer(pGen->pVm,pInstrContainer);

	pGen->pIn = pEnd;
	pGen->pEnd = pTmp;
	if (rc == SXERR_ABORT) {
		return SXERR_ABORT;
	}
	return SXRET_OK;
}

static sxi32 PHP_CompileSwitch(php_gen_state* pGen)
{
	GenBlock* pSwitchBlock;
	SyToken* pTmp,* pEnd;
	php_switch* pSwitch;
	sxu32 nToken;
	sxu32 nLine;
	sxi32 rc;
	nLine = pGen->pIn->nLine;

	pGen->pIn++;
	if (pGen->pIn >= pGen->pEnd || (pGen->pIn->nType & PHP_TK_LPAREN) == 0) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected '(' after 'switch' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	pGen->pIn++;
	pEnd = 0;

	rc = GenStateEnterBlock(&(*pGen),GEN_BLOCK_LOOP | GEN_BLOCK_SWITCH,
		PHP_VmInstrLength(pGen->pVm),0,&pSwitchBlock);
	if (rc != SXRET_OK) {
		return SXERR_ABORT;
	}

	PHP_DelimitNestedTokens(pGen->pIn,pGen->pEnd,PHP_TK_LPAREN ,PHP_TK_RPAREN ,&pEnd);
	if (pGen->pIn == pEnd || pEnd >= pGen->pEnd) {

		rc = PHP_GenCompileError(pGen,E_ERROR,nLine,"Expected expression after 'switch' keyword");
		if (rc == SXERR_ABORT) {

			return SXERR_ABORT;
		}
	}

	pTmp = pGen->pEnd;
	pGen->pEnd = pEnd;

	rc = PHP_CompileExpr(&(*pGen),0,0);
	if (rc == SXERR_ABORT) {

		return SXERR_ABORT;
	}

	while (pGen->pIn < pEnd) {
		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,
			"Switch: Unexpected token '%z'",&pGen->pIn->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		pGen->pIn++;
	}
	pGen->pIn = &pEnd[1];
	pGen->pEnd = pTmp;
	if (pGen->pIn >= pGen->pEnd || &pGen->pIn[1] >= pGen->pEnd ||
		(pGen->pIn->nType & (PHP_TK_OCB | PHP_TK_COLON)) == 0) {
		pTmp = pGen->pIn;
		if (pTmp >= pGen->pEnd) {
			pTmp--;
		}

		rc = PHP_GenCompileError(&(*pGen),E_ERROR,pTmp->nLine,"Switch: Unexpected token '%z'",&pTmp->sData);
		if (rc == SXERR_ABORT) {
			return SXERR_ABORT;
		}
		goto Synchronize;
	}

	if (pGen->pIn->nType & PHP_TK_COLON) {
		nToken = PHP_TK_KEYWORD;

	}
	else {
		nToken = PHP_TK_CCB;
	}
	pGen->pIn++;

	pSwitch = (php_switch*)SyMemBackendAlloc(&pGen->pVm->sAllocator,sizeof(php_switch));
	if (pSwitch == 0) {

		PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Fatal,PHP is running out of memory");
		return SXERR_ABORT;
	}

	SyZero(pSwitch,sizeof(php_switch));

	SySetInit(&pSwitch->aCaseExpr,&pGen->pVm->sAllocator,sizeof(php_case_expr));

	PHP_VmEmitInstr(pGen->pVm,PHP_OP_SWITCH,0,0,pSwitch,0);

	for (;;) {
		sxu32 nKwrd;
		if (pGen->pIn >= pGen->pEnd) {

			break;
		}
		if ((pGen->pIn->nType & PHP_TK_KEYWORD) == 0) {
			if (nToken != PHP_TK_CCB || (pGen->pIn->nType & PHP_TK_CCB ) == 0) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Switch: Unexpected token '%z'",
					&pGen->pIn->sData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}

			}

			break;
		}

		nKwrd = SX_PTR_TO_INT(pGen->pIn->pUserData);
		if (nKwrd == PHP_TKWRD_ENDSWITCH ) {
			if (nToken != PHP_TK_KEYWORD) {

				rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Switch: Unexpected token '%z'",
					&pGen->pIn->sData);
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}

			}

			break;
		}
		if (nKwrd == PHP_TKWRD_DEFAULT) {

			if (pSwitch->nDefault > 0) {

				rc = PHP_GenCompileError(&(*pGen),E_WARNING,pGen->pIn->nLine,"Switch: 'default' case already compiled");
				if (rc == SXERR_ABORT) {
					return SXERR_ABORT;
				}
			}
			pGen->pIn++;

			rc = GenStateCompileSwitchBlock(pGen,nToken,&pSwitch->nDefault);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			else if (rc == SXERR_EOF) {
				break;
			}
		}
		else if (nKwrd == PHP_TKWRD_CASE) {
			php_case_expr sCase;

			pGen->pIn++;

			SySetInit(&sCase.aByteCode,&pGen->pVm->sAllocator,sizeof(VmInstr));

			rc = GenStateCompileCaseExpr(pGen,&sCase);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}

			rc = GenStateCompileSwitchBlock(pGen,nToken,&sCase.nStart);

			SySetPut(&pSwitch->aCaseExpr,(const void*)&sCase);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			else if (rc == SXERR_EOF) {
				break;
			}
		}
		else {

			rc = PHP_GenCompileError(&(*pGen),E_ERROR,pGen->pIn->nLine,"Switch: Unexpected token '%z'",
				&pGen->pIn->sData);
			if (rc == SXERR_ABORT) {
				return SXERR_ABORT;
			}
			break;
		}
	}

	pSwitch->nOut = PHP_VmInstrLength(pGen->pVm);
	GenStateFixJumps(pSwitchBlock,-1,PHP_VmInstrLength(pGen->pVm));

	GenStateLeaveBlock(pGen,0);
	if (pGen->pIn < pGen->pEnd) {

		pGen->pIn++;
	}

	return SXRET_OK;
Synchronize:

	while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI) == 0) {
		pGen->pIn++;
	}
	return SXRET_OK;
}

static sxi32 GenStateEmitExprCode(
	php_gen_state* pGen,
	php_expr_node* pNode,
	sxi32 iFlags
)
{
	VmInstr* pInstr;
	sxu32 nJmpIdx;
	sxi32 iP1 = 0;
	sxu32 iP2 = 0;
	void* p3 = 0;
	sxi32 iVmOp;
	sxi32 rc;
	if (pNode->xCode) {
		SyToken* pTmpIn,* pTmpEnd;

		SWAP_DELIMITER(pGen,pNode->pStart,pNode->pEnd);
		rc = pNode->xCode(&(*pGen),iFlags);
		RE_SWAP_DELIMITER(pGen);
		return rc;
	}
	if (pNode->pOp == 0) {
		PHP_GenCompileError(&(*pGen),E_ERROR,pNode->pStart->nLine,
			"Invalid expression node,PHP is aborting compilation");
		return SXERR_ABORT;
	}
	iVmOp = pNode->pOp->iVmOp;
	if (pNode->pOp->iOp == EXPR_OP_QUESTY) {
		sxu32 nJz,nJmp;


		rc = GenStateEmitExprCode(&(*pGen),pNode->pCond,iFlags);
		if (rc != SXRET_OK) {
			return rc;
		}
		nJz = nJmp = 0;

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_JZ,0,0,0,&nJz);
		if (pNode->pLeft) {

			rc = GenStateEmitExprCode(&(*pGen),pNode->pLeft,iFlags);
			if (rc != SXRET_OK) {
				return rc;
			}
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_JMP,0,0,0,&nJmp);

		pInstr = PHP_VmGetInstr(pGen->pVm,nJz);
		if (pInstr) {
			pInstr->iP2 = PHP_VmInstrLength(pGen->pVm);
		}

		if (pNode->pRight) {
			rc = GenStateEmitExprCode(&(*pGen),pNode->pRight,iFlags);
			if (rc != SXRET_OK) {
				return rc;
			}
		}
		if (nJmp > 0) {

			pInstr = PHP_VmGetInstr(pGen->pVm,nJmp);
			if (pInstr) {
				pInstr->iP2 = PHP_VmInstrLength(pGen->pVm);
			}
		}

		return SXRET_OK;
	}

	if (pNode->pLeft) {
		if (iVmOp == PHP_OP_CALL) {
			php_expr_node** apNode;
			sxi32 n;

			apNode = (php_expr_node**)SySetBasePtr(&pNode->aNodeArgs);

			iFlags |= EXPR_FLAG_RDONLY_LOAD;
			for (n = 0; n < (sxi32)SySetUsed(&pNode->aNodeArgs); ++n) {
				rc = GenStateEmitExprCode(&(*pGen),apNode[n],iFlags & ~EXPR_FLAG_LOAD_IDX_STORE);
				if (rc != SXRET_OK) {
					return rc;
				}
			}

			iP1 = (sxi32)SySetUsed(&pNode->aNodeArgs);

			iFlags &= ~EXPR_FLAG_RDONLY_LOAD;
		}
		rc = GenStateEmitExprCode(&(*pGen),pNode->pLeft,iFlags);
		if (rc != SXRET_OK) {
			return rc;
		}
		if (iVmOp == PHP_OP_CALL) {
			pInstr = PHP_VmPeekInstr(pGen->pVm);
			if (pInstr) {
				if (pInstr->iOp == PHP_OP_LOADC) {

					pInstr->iP1 = 0;
				}
				else if (pInstr->iOp == PHP_OP_MEMBER  || pInstr->iOp == PHP_OP_NEW) {

					pInstr->iP2 = 1;
				}
			}
		}
		else if (iVmOp == PHP_OP_LOAD_IDX) {
			php_expr_node** apNode;
			sxi32 n;

			apNode = (php_expr_node**)SySetBasePtr(&pNode->aNodeArgs);
			for (n = 0; n < (sxi32)SySetUsed(&pNode->aNodeArgs); ++n) {
				rc = GenStateEmitExprCode(&(*pGen),apNode[n],iFlags & ~EXPR_FLAG_LOAD_IDX_STORE);
				if (rc != SXRET_OK) {
					return rc;
				}
			}
			if (SySetUsed(&pNode->aNodeArgs) > 0) {
				iP1 = 1;
			}
			if (iFlags & EXPR_FLAG_LOAD_IDX_STORE) {

				iP2 = 1;
			}
		}
		else if (pNode->pOp->iOp == EXPR_OP_COMMA) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
		}
	}
	rc = SXRET_OK;
	nJmpIdx = 0;

	if (pNode->pRight) {
		if (iVmOp == PHP_OP_LAND) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_JZ,1,0,0,&nJmpIdx);
		}
		else if (iVmOp == PHP_OP_LOR) {

			PHP_VmEmitInstr(pGen->pVm,PHP_OP_JNZ,1,0,0,&nJmpIdx);
		}
		else if (pNode->pOp->iPrec == 18 ) {
			iFlags |= EXPR_FLAG_LOAD_IDX_STORE;
		}
		rc = GenStateEmitExprCode(&(*pGen),pNode->pRight,iFlags);
		if (iVmOp == PHP_OP_STORE) {
			pInstr = PHP_VmPeekInstr(pGen->pVm);
			if (pInstr) {
				if (pInstr->iOp == PHP_OP_LOAD_LIST) {

					iVmOp = 0;
				}
				else if (pInstr->iOp == PHP_OP_MEMBER) {

					iP2 = 1;
				}
				else {
					if (pInstr->iOp == PHP_OP_LOAD_IDX) {

						iVmOp = PHP_OP_STORE_IDX;
						iP1 = pInstr->iP1;
					}
					else {
						p3 = pInstr->p3;
					}

					(void)PHP_VmPopInstr(pGen->pVm);
				}
			}
		}
		else if (iVmOp == PHP_OP_STORE_REF) {
			pInstr = PHP_VmPopInstr(pGen->pVm);
			if (pInstr) {
				if (pInstr->iOp == PHP_OP_LOAD_IDX) {

					iVmOp = PHP_OP_STORE_IDX_REF;
					iP1 = pInstr->iP1;
					iP2 = pInstr->iP2;
					p3 = pInstr->p3;
				}
				else {
					p3 = pInstr->p3;
				}
			}
		}
	}
	if (iVmOp > 0) {
		if (iVmOp == PHP_OP_INCR || iVmOp == PHP_OP_DECR) {
			if (pNode->iFlags & EXPR_NODE_PRE_INCR) {

				iP1 = 1;
			}
		}
		else if (iVmOp == PHP_OP_NEW) {
			pInstr = PHP_VmPeekInstr(pGen->pVm);
			if (pInstr && pInstr->iOp == PHP_OP_CALL) {
				VmInstr* pPrev;
				pPrev = PHP_VmPeekNextInstr(pGen->pVm);
				if (pPrev == 0 || pPrev->iOp != PHP_OP_MEMBER) {

					iP1 = pInstr->iP1;
					(void)PHP_VmPopInstr(pGen->pVm);
				}
			}
		}
		else if (iVmOp == PHP_OP_MEMBER) {
			if (pNode->pOp->iOp == EXPR_OP_DC ) {

				iP1 = 1;
				pInstr = PHP_VmPeekInstr(pGen->pVm);
				if (pInstr && pInstr->iOp == PHP_OP_LOAD) {
					p3 = pInstr->p3;
					(void)PHP_VmPopInstr(pGen->pVm);
				}
			}
		}

		PHP_VmEmitInstr(pGen->pVm,iVmOp,iP1,iP2,p3,0);
		if (nJmpIdx > 0) {

			pInstr = PHP_VmGetInstr(pGen->pVm,nJmpIdx);
			if (pInstr) {
				pInstr->iP2 = PHP_VmInstrLength(pGen->pVm);
			}
		}
	}
	return rc;
}

static sxi32 PHP_CompileExpr(
	php_gen_state* pGen,
	sxi32 iFlags,
	sxi32(*xTreeValidator)(php_gen_state*,php_expr_node*)
)
{
	php_expr_node* pRoot;
	SySet sExprNode;
	SyToken* pEnd;
	sxi32 nExpr;
	sxi32 iNest;
	sxi32 rc;

	nExpr = 0;
	pRoot = 0;
	SySetInit(&sExprNode,&pGen->pVm->sAllocator,sizeof(php_expr_node*));
	SySetAlloc(&sExprNode,0x10);
	rc = SXRET_OK;

	pEnd = pGen->pIn;
	iNest = 0;
	while (pEnd < pGen->pEnd) {
		if (pEnd->nType & PHP_TK_OCB ) {

			iNest++;
		}
		else if (pEnd->nType & PHP_TK_CCB ) {
			iNest--;
		}
		else if (pEnd->nType & PHP_TK_SEMI ) {
			if (iNest <= 0) {
				break;
			}
		}
		pEnd++;
	}
	if (iFlags & EXPR_FLAG_COMMA_STATEMENT) {
		SyToken* pEnd2 = pGen->pIn;
		iNest = 0;

		while (pEnd2 < pEnd) {
			if (pEnd2->nType & (PHP_TK_OCB | PHP_TK_OSB | PHP_TK_LPAREN)) {
				iNest++;
			}
			else if (pEnd2->nType & (PHP_TK_CCB | PHP_TK_CSB | PHP_TK_RPAREN)) {
				iNest--;
			}
			else if (pEnd2->nType & PHP_TK_COMMA ) {
				if (iNest <= 0) {
					break;
				}
			}
			pEnd2++;
		}
		if (pEnd2 < pEnd) {
			pEnd = pEnd2;
		}
	}
	if (pEnd > pGen->pIn) {
		SyToken* pTmp = pGen->pEnd;

		pGen->pEnd = pEnd;

		rc = PHP_ExprMakeTree(&(*pGen),&sExprNode,&pRoot);
		if (rc == SXRET_OK && pRoot) {
			rc = SXRET_OK;
			if (xTreeValidator) {

				rc = xTreeValidator(&(*pGen),pRoot);
			}
			if (rc != SXERR_ABORT) {

				rc = GenStateEmitExprCode(&(*pGen),pRoot,iFlags);
			}
			nExpr = 1;
		}

		PHP_ExprFreeTree(&(*pGen),&sExprNode);

		pGen->pEnd = pTmp;
		pGen->pIn = pEnd;
		if (rc == SXERR_ABORT) {
			SySetRelease(&sExprNode);
			return SXERR_ABORT;
		}
	}
	SySetRelease(&sExprNode);
	return nExpr > 0 ? SXRET_OK : SXERR_EMPTY;
}

PHP_PRIVATE ProcNodeConstruct PHP_GetNodeHandler(sxu32 nNodeType)
{if (nNodeType & PHP_TK_NUM) {return PHP_CompileNumLiteral;}else if (nNodeType & PHP_TK_DSTR) {return PHP_CompileString;}else if (nNodeType & PHP_TK_SSTR) {return PHP_CompileSimpleString;}else if (nNodeType & PHP_TK_HEREDOC) {return PHP_CompileHereDoc;}else if (nNodeType & PHP_TK_NOWDOC) {return PHP_CompileNowDoc;}else if (nNodeType & PHP_TK_BSTR) {return PHP_CompileBacktic;}return 0;}

static const LangConstruct aLangConstruct[] = {{PHP_TKWRD_ECHO,PHP_CompileEcho},{PHP_TKWRD_IF,PHP_CompileIf},{PHP_TKWRD_FOR,PHP_CompileFor},{PHP_TKWRD_WHILE,PHP_CompileWhile},{PHP_TKWRD_FOREACH,PHP_CompileForeach},{PHP_TKWRD_FUNCTION,PHP_CompileFunction},{PHP_TKWRD_CONTINUE,PHP_CompileContinue},{PHP_TKWRD_BREAK,PHP_CompileBreak},{PHP_TKWRD_RETURN,PHP_CompileReturn},{PHP_TKWRD_SWITCH,PHP_CompileSwitch},{PHP_TKWRD_DO,PHP_CompileDoWhile},{PHP_TKWRD_GLOBAL,PHP_CompileGlobal},{PHP_TKWRD_STATIC,PHP_CompileStatic},{PHP_TKWRD_DIE,PHP_CompileHalt},{PHP_TKWRD_EXIT,PHP_CompileHalt},{PHP_TKWRD_TRY,PHP_CompileTry},{PHP_TKWRD_THROW,PHP_CompileThrow},{PHP_TKWRD_GOTO,PHP_CompileGoto},{PHP_TKWRD_CONST,PHP_CompileConstant},{PHP_TKWRD_VAR,PHP_CompileVar},{PHP_TKWRD_NAMESPACE,PHP_CompileNamespace},{PHP_TKWRD_USE,PHP_CompileUse},{PHP_TKWRD_DECLARE,PHP_CompileDeclare}};
static ProcLangConstruct GenStateGetStatementHandler(sxu32 nKeywordID,SyToken* pLookahed) {
	sxu32 n = 0;
	for (;;) {
		if (n >= SX_ARRAYSIZE(aLangConstruct)) {
			break;
		}
		if (aLangConstruct[n].nID == nKeywordID) {
			if (nKeywordID == PHP_TKWRD_STATIC && pLookahed && (pLookahed->nType & PHP_TK_OP)) {
				const php_expr_op* pOp = (const php_expr_op*)pLookahed->pUserData;
				if (pOp && pOp->iOp == EXPR_OP_DC ) {

					return 0;
				}
			}

			return aLangConstruct[n].xConstruct;
		}
		n++;
	}
	if (pLookahed) {
		if (nKeywordID == PHP_TKWRD_INTERFACE && (pLookahed->nType & PHP_TK_ID)) {
			return PHP_CompileClassInterface;
		}
		else if (nKeywordID == PHP_TKWRD_CLASS && (pLookahed->nType & PHP_TK_ID)) {
			return PHP_CompileClass;
		}
		else if (nKeywordID == PHP_TKWRD_ABSTRACT && (pLookahed->nType & PHP_TK_KEYWORD)
			&& SX_PTR_TO_INT(pLookahed->pUserData) == PHP_TKWRD_CLASS) {
			return PHP_CompileAbstractClass;
		}
		else if (nKeywordID == PHP_TKWRD_FINAL && (pLookahed->nType & PHP_TK_KEYWORD)
			&& SX_PTR_TO_INT(pLookahed->pUserData) == PHP_TKWRD_CLASS) {
			return PHP_CompileFinalClass;
		}
	}

	return 0;
}

static int GenStateisLangConstruct(sxu32 nKeyword)
{
	int rc;
	rc = PHP_IsLangConstruct(nKeyword,TRUE);
	if (rc == FALSE) {
		if (nKeyword == PHP_TKWRD_SELF || nKeyword == PHP_TKWRD_PARENT || nKeyword == PHP_TKWRD_STATIC

			) {
			rc = TRUE;
		}
	}
	return rc;
}

static sxi32 GenStateCompileChunk(
	php_gen_state* pGen,
	sxi32 iFlags
)
{
	ProcLangConstruct xCons;
	sxi32 rc;
	rc = SXRET_OK;
	for (;;) {
		if (pGen->pIn >= pGen->pEnd) {

			break;
		}
		if (pGen->pIn->nType & PHP_TK_OCB ) {

			rc = PHP_CompileBlock(&(*pGen),0);
			if (rc == SXERR_ABORT) {
				break;
			}
		}
		else {
			xCons = 0;
			if (pGen->pIn->nType & PHP_TK_KEYWORD) {
				sxu32 nKeyword = (sxu32)SX_PTR_TO_INT(pGen->pIn->pUserData);

				xCons = GenStateGetStatementHandler(nKeyword,(&pGen->pIn[1] < pGen->pEnd) ? &pGen->pIn[1] : 0);
				if (xCons == 0 && GenStateisLangConstruct(nKeyword) == FALSE) {
					rc = PHP_GenCompileError(pGen,E_ERROR,pGen->pIn->nLine,
						"Syntax error: Unexpected keyword '%z'",
						&pGen->pIn->sData);
					if (rc == SXERR_ABORT) {
						break;
					}

					xCons = PHP_ErrorRecover;
				}
			}
			else if ((pGen->pIn->nType & PHP_TK_ID) && (&pGen->pIn[1] < pGen->pEnd)
				&& (pGen->pIn[1].nType & PHP_TK_COLON )) {

				xCons = PHP_CompileLabel;
			}
			if (xCons == 0) {

				rc = PHP_CompileExpr(&(*pGen),0,0);
				if (rc != SXERR_EMPTY) {

					PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
				}
			}
			else {

				rc = xCons(&(*pGen));
			}
			if (rc == SXERR_ABORT) {

				break;
			}
		}

		while (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_SEMI)) {
			pGen->pIn++;
		}
		if (iFlags & PHP_COMPILE_SINGLE_STMT) {

			break;
		}




	}

	return rc;
}

static sxi32 PHP_CompilePHP(
	php_gen_state* pGen,
	SySet* pTokenSet,
	int is_expr
)
{
	SyToken* pScript = pGen->pRawIn;
	sxi32 rc;

	SySetReset(&(*pTokenSet));

	pGen->pTokenSet = &(*pTokenSet);

	pGen->pRawIn++;

	PHP_TokenizePHP(SyStringData(&pScript->sData),SyStringLength(&pScript->sData),pScript->nLine,&(*pTokenSet));

	pGen->pIn = (SyToken*)SySetBasePtr(pTokenSet);
	pGen->pEnd = &pGen->pIn[SySetUsed(pTokenSet)];
	if (is_expr) {
		rc = SXERR_EMPTY;
		if (pGen->pIn < pGen->pEnd) {

			rc = PHP_CompileExpr(pGen,0,0);
		}

		PHP_VmEmitInstr(pGen->pVm,PHP_OP_DONE,(rc != SXERR_EMPTY ? 1 : 0),0,0,0);
		return SXRET_OK;
	}
	if (pGen->pIn < pGen->pEnd && (pGen->pIn->nType & PHP_TK_EQUAL)) {
		static const sxu32 nKeyID = PHP_TKWRD_ECHO;


		pGen->pIn->nType = PHP_TK_KEYWORD;
		pGen->pIn->pUserData = SX_INT_TO_PTR(nKeyID);
		SyStringInitFromBuf(&pGen->pIn->sData,"echo",sizeof("echo") - 1);
		rc = PHP_CompileExpr(pGen,0,0);
		if (rc != SXERR_EMPTY) {
			PHP_VmEmitInstr(pGen->pVm,PHP_OP_POP,1,0,0,0);
		}
		return SXRET_OK;
	}

	rc = GenStateCompileChunk(pGen,0);

	GenStateFixJumps(pGen->pCurrent,PHP_OP_THROW,PHP_VmInstrLength(pGen->pVm));

	if (SXERR_ABORT == GenStateFixGoto(&(*pGen),0)) {
		rc = SXERR_ABORT;
	}

	SySetReset(&pGen->aGoto);
	SySetReset(&pGen->aLabel);

	return rc;
}

PHP_PRIVATE sxi32 PHP_CompileScript(
	php_vm* pVm,
	SyString* pScript,
	sxi32 iFlags
)
{
	SySet aPhpToken,aRawToken;
	php_gen_state* pCodeGen;
	php_value* pRawObj;
	sxu32 nObjIdx;
	sxi32 nRawObj; int is_expr;
	sxi32 rc;
	if (pScript->nByte < 1) {

		return PHP_OK;
	}

	SySetInit(&aRawToken,&pVm->sAllocator,sizeof(SyToken));
	SySetInit(&aPhpToken,&pVm->sAllocator,sizeof(SyToken));
	SySetAlloc(&aPhpToken,0xc0);
	is_expr = 0;
	if (iFlags & PHP_PHP_ONLY) {
		SyToken sTmp;

		sTmp.nLine = 1;
		sTmp.nType = PHP_TOKEN_PHP;
		sTmp.pUserData = 0;
		SyStringDupPtr(&sTmp.sData,pScript);
		SySetPut(&aRawToken,(const void*)&sTmp);
		if (iFlags & PHP_PHP_EXPR) {

			is_expr = 1;
		}
	}
	else {

		SySetAlloc(&aRawToken,32);
		PHP_TokenizeRawText(pScript->zString,pScript->nByte,&aRawToken);
	}
	pCodeGen = &pVm->sCodeGen;

	pCodeGen->pRawIn = (SyToken*)SySetBasePtr(&aRawToken);
	pCodeGen->pRawEnd = &pCodeGen->pRawIn[SySetUsed(&aRawToken)];
	rc = PHP_OK;
	if (is_expr) {

		rc = PHP_CompilePHP(pCodeGen,&aPhpToken,TRUE);
		goto cleanup;
	}
	nObjIdx = 0;

	for (;;) {
		if (pCodeGen->pRawIn >= pCodeGen->pRawEnd) {
			break;
		}
		if (pCodeGen->pRawIn->nType & PHP_TOKEN_PHP) {

			rc = PHP_CompilePHP(pCodeGen,&aPhpToken,FALSE);
			if (rc == SXERR_ABORT) {
				break;
			}
			continue;
		}

		nRawObj = 0;
		while ((pCodeGen->pRawIn < pCodeGen->pRawEnd) && (pCodeGen->pRawIn->nType != PHP_TOKEN_PHP)) {

			pRawObj = PHP_ReserveConstObj(&(*pVm),&nObjIdx);
			if (pRawObj == 0) {
				rc = SXERR_MEM;
				break;
			}

			PHP_MemObjInitFromString(pVm,pRawObj,&pCodeGen->pRawIn->sData);
			PHP_VmEmitInstr(&(*pVm),PHP_OP_LOADC,0,nObjIdx,0,0);
			++nRawObj;
			pCodeGen->pRawIn++;
		}
		if (nRawObj > 0) {

			PHP_VmEmitInstr(&(*pVm),PHP_OP_CONSUME,nRawObj,0,0,0);
		}
	}
cleanup:
	SySetRelease(&aRawToken);
	SySetRelease(&aPhpToken);
	return rc;
}

PHP_PRIVATE sxi32 PHP_InitCodeGenerator(
	php_vm* pVm,
	ProcConsumer xErr,
	void* pErrData
)
{
	php_gen_state* pGen = &pVm->sCodeGen;

	SyZero(pGen,sizeof(php_gen_state));

	pGen->pVm = &(*pVm);
	pGen->xErr = xErr;
	pGen->pErrData = pErrData;
	SySetInit(&pGen->aLabel,&pVm->sAllocator,sizeof(Label));
	SySetInit(&pGen->aGoto,&pVm->sAllocator,sizeof(JumpFixup));
	SyHashInit(&pGen->hLiteral,&pVm->sAllocator,0,0);
	SyHashInit(&pGen->hVar,&pVm->sAllocator,0,0);

	SyBlobInit(&pGen->sErrBuf,&pVm->sAllocator);

	SyBlobInit(&pGen->sWorker,&pVm->sAllocator);

	GenStateInitBlock(pGen,&pGen->sGlobal,GEN_BLOCK_GLOBAL,PHP_VmInstrLength(&(*pVm)),0);

	pGen->pCurrent = &pGen->sGlobal;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_ResetCodeGenerator(
	php_vm* pVm,
	ProcConsumer xErr,
	void* pErrData
)
{
	php_gen_state* pGen = &pVm->sCodeGen;
	GenBlock* pBlock,* pParent;

	SySetReset(&pGen->aLabel);
	SySetReset(&pGen->aGoto);
	SyBlobRelease(&pGen->sErrBuf);
	SyBlobRelease(&pGen->sWorker);

	pBlock = pGen->pCurrent;
	while (pBlock->pParent != 0) {
		pParent = pBlock->pParent;
		GenStateFreeBlock(pBlock);
		pBlock = pParent;
	}
	pGen->xErr = xErr;
	pGen->pErrData = pErrData;
	pGen->pCurrent = &pGen->sGlobal;
	pGen->pRawIn = pGen->pRawEnd = 0;
	pGen->pIn = pGen->pEnd = 0;
	pGen->nErr = 0;
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_GenCompileError(php_gen_state* pGen,sxi32 nErrType,sxu32 nLine,const char* zFormat,...)
{
	SyBlob* pWorker = &pGen->sErrBuf;
	const char* zErr = "Error";
	SyString* pFile;
	va_list ap;
	sxi32 rc;

	SyBlobReset(pWorker);

	pFile = (SyString*)SySetPeek(&pGen->pVm->aFiles);
	if (pFile && pGen->xErr) {

		SyBlobAppend(pWorker,pFile->zString,pFile->nByte);
		SyBlobAppend(pWorker,(const void*)": ",sizeof(": ") - 1);
	}
	if (nErrType == E_ERROR) {

		pGen->nErr++;
		if (pGen->nErr > 15) {

			if (pGen->xErr) {
				SyBlobFormat(pWorker,"%u Error count limit reached,PHP is aborting compilation\n",nLine);
				if (SyBlobLength(pWorker) > 0) {

					pGen->xErr(SyBlobData(pWorker),SyBlobLength(pWorker),pGen->pErrData);
				}
			}

			return SXERR_ABORT;
		}
	}
	if (pGen->xErr == 0) {

		return SXRET_OK;
	}
	switch (nErrType) {
	case E_WARNING: zErr = "Warning";     break;
	case E_PARSE:   zErr = "Parse error"; break;
	case E_NOTICE:  zErr = "Notice";      break;
	case E_USER_ERROR:   zErr = "User error";   break;
	case E_USER_WARNING: zErr = "User warning"; break;
	case E_USER_NOTICE:  zErr = "User notice";  break;
	default:
		break;
	}
	rc = SXRET_OK;

	SyBlobFormat(pWorker,"%u %s: ",nLine,zErr);
	va_start(ap,zFormat);
	SyBlobFormatAp(pWorker,zFormat,ap);
	va_end(ap);

	SyBlobAppend(pWorker,(const void*)"\n",sizeof(char));
	if (SyBlobLength(pWorker) > 0) {

		pGen->xErr(SyBlobData(pWorker),SyBlobLength(pWorker),pGen->pErrData);
	}
	return rc;
}



#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif



static int PHP_builtin_is_bool(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_bool(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_float(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_float(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_int(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_int(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_string(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_string(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_null(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_null(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_numeric(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_numeric(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_scalar(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_scalar(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_array(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_array(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_object(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_object(apArg[0]);
	}

	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_is_resource(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 0;
	if (nArg > 0) {
		res = php_value_is_resource(apArg[0]);
	}
	php_result_bool(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_floatval(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_double(pCtx,0);
	}
	else {
		double dval;

		dval = php_value_to_double(apArg[0]);
		php_result_double(pCtx,dval);
	}
	return PHP_OK;
}

static int PHP_builtin_intval(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_int(pCtx,0);
	}
	else {
		sxi64 iVal;

		iVal = php_value_to_int64(apArg[0]);
		php_result_int64(pCtx,iVal);
	}
	return PHP_OK;
}

static int PHP_builtin_strval(php_context* pCtx,int nArg,php_value** apArg)
{
	if (nArg < 1) {

		php_result_null(pCtx);
	}
	else {
		const char* zVal; int iLen = 0;

		zVal = php_value_to_string(apArg[0],&iLen);
		php_result_string(pCtx,zVal,iLen);
	}
	return PHP_OK;
}

static int PHP_builtin_empty(php_context* pCtx,int nArg,php_value** apArg)
{
	int res = 1;
	if (nArg > 0) {
		res = php_value_is_empty(apArg[0]);
	}
	php_result_bool(pCtx,res);
	return PHP_OK;

}
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifdef PHP_ENABLE_MATH_FUNC

#include <stdlib.h>
#include <math.h>

static int PHP_builtin_sqrt(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = sqrt(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_exp(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = exp(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_floor(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = floor(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_cos(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = cos(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_acos(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = acos(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_cosh(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = cosh(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_sin(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = sin(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_asin(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = asin(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_sinh(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = sinh(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_ceil(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = ceil(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_tan(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = tan(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_atan(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = atan(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_tanh(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = tanh(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_atan2(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x,y;
	if (nArg < 2) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	y = php_value_to_double(apArg[0]);
	x = php_value_to_double(apArg[1]);

	r = atan2(y,x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_abs(php_context* pCtx,int nArg,php_value** apArg)
{
	int is_float;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	is_float = php_value_is_float(apArg[0]);
	if (is_float) {
		double r,x;
		x = php_value_to_double(apArg[0]);

		r = fabs(x);
		php_result_double(pCtx,r);
	}
	else {
		int r,x;
		x = php_value_to_int(apArg[0]);

		r = abs(x);
		php_result_int(pCtx,r);
	}
	return PHP_OK;
}

static int PHP_builtin_log(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	if (nArg == 2 && php_value_is_numeric(apArg[1]) && php_value_to_int(apArg[1]) == 2) {
	    r = log2(x);
	}
	else if (nArg == 2 && php_value_is_numeric(apArg[1]) && php_value_to_int(apArg[1]) == 10) {
        r = log10(x);
	}
	else {
		r = log(x);
	}

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_log10(php_context* pCtx,int nArg,php_value** apArg)
{
	double r,x;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);

	r = log10(x);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_pow(php_context* pCtx,int nArg,php_value** apArg)
{

	double r,x,y;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	x = php_value_to_double(apArg[0]);
	y = php_value_to_double(apArg[1]);

	r = pow(x,y);
	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_pi(php_context* pCtx,int nArg,php_value** apArg)
{
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	php_result_double(pCtx,PHP_PI);
	return PHP_OK;
}

static int PHP_builtin_fmod(php_context* pCtx,int nArg,php_value** apArg)
{
	double x,y,r;
	if (nArg < 2) {

		php_result_double(pCtx,0);
		return PHP_OK;
	}

	x = php_value_to_double(apArg[0]);
	y = php_value_to_double(apArg[1]);

	r = fmod(x,y);

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_hypot(php_context* pCtx,int nArg,php_value** apArg)
{
	double x,y,r;
	if (nArg < 2) {

		php_result_double(pCtx,0);
		return PHP_OK;
	}

	x = php_value_to_double(apArg[0]);
	y = php_value_to_double(apArg[1]);

	r = hypot(x,y);

	php_result_double(pCtx,r);
	return PHP_OK;
}
#endif

static int PHP_builtin_round(php_context* pCtx,int nArg,php_value** apArg)
{
	int n = 0;
	double r;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	if (nArg > 1) {
		n = php_value_to_int(apArg[1]);
		if (n > 30) {
			n = 30;
		}
		if (n < 0) {
			n = 0;
		}
	}
	r = php_value_to_double(apArg[0]);

	if (n == 0 && r >= 0 && r < LARGEST_INT64 - 1) {
		r = (double)((php_int64)(r + 0.5));
	}
	else if (n == 0 && r < 0 && (-r) < LARGEST_INT64 - 1) {
		r = -(double)((php_int64)((-r) + 0.5));
	}
	else {
		char zBuf[256];
		sxu32 nLen;
		nLen = SyBufferFormat(zBuf,sizeof(zBuf),"%.*f",n,r);

		SyStrToReal(zBuf,nLen,(void*)&r,0);
	}

	php_result_double(pCtx,r);
	return PHP_OK;
}

static int PHP_builtin_dechex(php_context* pCtx,int nArg,php_value** apArg)
{
	int iVal;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	iVal = php_value_to_int(apArg[0]);

	php_result_string_format(pCtx,"%x",iVal);
	return PHP_OK;
}

static int PHP_builtin_decoct(php_context* pCtx,int nArg,php_value** apArg)
{
	int iVal;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	iVal = php_value_to_int(apArg[0]);

	php_result_string_format(pCtx,"%o",iVal);
	return PHP_OK;
}

static int PHP_builtin_decbin(php_context* pCtx,int nArg,php_value** apArg)
{
	int iVal;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	iVal = php_value_to_int(apArg[0]);

	php_result_string_format(pCtx,"%B",iVal);
	return PHP_OK;
}

static int PHP_builtin_hexdec(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zEnd;
	php_int64 iVal; int nLen;
	if (nArg < 1) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}
	iVal = 0;
	if (php_value_is_string(apArg[0])) {

		zString = php_value_to_string(apArg[0],&nLen);

		zEnd = &zString[nLen];

		while (zString < zEnd) {
			if ((unsigned char)zString[0] >= 0xc0) {

				zString++;
				while (zString < zEnd && (((unsigned char)zString[0] & 0xc0) == 0x80)) {
					zString++;
				}
			}
			else {
				if (SyisHex(zString[0])) {
					break;
				}

				zString++;
			}
		}
		if (zString < zEnd) {

			SyHexStrToInt64(zString,(sxu32)(zEnd - zString),(void*)&iVal,0);
		}
	}
	else {

		iVal = php_value_to_int64(apArg[0]);
	}

	php_result_int64(pCtx,iVal);
	return PHP_OK;
}

static int PHP_builtin_bindec(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString;
	php_int64 iVal; int nLen;
	if (nArg < 1) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}
	iVal = 0;
	if (php_value_is_string(apArg[0])) {

		zString = php_value_to_string(apArg[0],&nLen);
		if (nLen > 0) {

			SyBinaryStrToInt64(zString,(sxu32)nLen,(void*)&iVal,0);
		}
	}
	else {

		iVal = php_value_to_int64(apArg[0]);
	}

	php_result_int64(pCtx,iVal);
	return PHP_OK;
}

static int PHP_builtin_octdec(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString;
	php_int64 iVal; int nLen;
	if (nArg < 1) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}
	iVal = 0;
	if (php_value_is_string(apArg[0])) {

		zString = php_value_to_string(apArg[0],&nLen);
		if (nLen > 0) {

			SyOctalStrToInt64(zString,(sxu32)nLen,(void*)&iVal,0);
		}
	}
	else {

		iVal = php_value_to_int64(apArg[0]);
	}

	php_result_int64(pCtx,iVal);
	return PHP_OK;
}

static int PHP_builtin_srand(php_context* pCtx,int nArg,php_value** apArg)
{
	SXUNUSED(nArg);
	SXUNUSED(apArg);
	php_result_null(pCtx);
	return PHP_OK;
}

static int PHP_builtin_base_convert(php_context* pCtx,int nArg,php_value** apArg)
{
	int nLen,iFbase,iTobase;
	const char* zNum;
	php_int64 iNum;
	if (nArg < 3) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	iFbase = php_value_to_int(apArg[1]);
	iTobase = php_value_to_int(apArg[2]);
	if (php_value_is_string(apArg[0])) {

		zNum = php_value_to_string(apArg[0],&nLen);
		if (nLen < 1) {

			php_result_string(pCtx,"",0);
			return PHP_OK;
		}

		switch (iFbase) {
		case 16:

			SyHexStrToInt64(zNum,(sxu32)nLen,(void*)&iNum,0);
			break;
		case 8:

			SyOctalStrToInt64(zNum,(sxu32)nLen,(void*)&iNum,0);
			break;
		case 2:

			SyBinaryStrToInt64(zNum,(sxu32)nLen,(void*)&iNum,0);
			break;
		default:

			SyStrToInt64(zNum,(sxu32)nLen,(void*)&iNum,0);
			break;
		}
	}
	else {
		iNum = php_value_to_int64(apArg[0]);
	}
	switch (iTobase) {
	case 16:

		php_result_string_format(pCtx,"%qx",iNum);
		break;
	case 8:

		php_result_string_format(pCtx,"%qo",iNum);
		break;
	case 2:

		php_result_string_format(pCtx,"%qB",iNum);
		break;
	default:

		php_result_string_format(pCtx,"%qd",iNum);
		break;
	}
	return PHP_OK;
}


static int PHP_builtin_substr(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zSource,* zOfft; int nOfft,nLen,nSrcLen;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zSource = php_value_to_string(apArg[0],&nSrcLen);
	if (nSrcLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = nSrcLen;

	nOfft = php_value_to_int(apArg[1]);
	if (nOfft < 0) {
		zOfft = &zSource[nSrcLen + nOfft];
		if (zOfft < zSource) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
		nLen = (int)(&zSource[nSrcLen] - zOfft);
		nOfft = (int)(zOfft - zSource);
	}
	else if (nOfft >= nSrcLen) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	else {
		zOfft = &zSource[nOfft];
		nLen = nSrcLen - nOfft;
	}
	if (nArg > 2) {

		nLen = php_value_to_int(apArg[2]);
		if (nLen == 0) {

			php_result_string(pCtx,"",0);
			return PHP_OK;
		}
		else if (nLen < 0) {
			nLen = nSrcLen + nLen - nOfft;
			if (nLen < 1) {

				nLen = nSrcLen - nOfft;
			}
		}
		if (nLen + nOfft > nSrcLen) {

			nLen = nSrcLen - nOfft;
		}
	}

	php_result_string(pCtx,zOfft,nLen);
	return PHP_OK;
}

static int PHP_builtin_substr_compare(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zSource,* zOfft,* zSub; int nOfft,nLen,nSrcLen,nSublen; int iCase = 0; int rc;
	if (nArg < 3) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zSource = php_value_to_string(apArg[0],&nSrcLen);
	if (nSrcLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	nLen = nSrcLen;

	zSub = php_value_to_string(apArg[1],&nSublen);
	if (nSublen < 1 || nSublen > nSrcLen) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	nOfft = php_value_to_int(apArg[2]);
	if (nOfft < 0) {
		zOfft = &zSource[nSrcLen + nOfft];
		if (zOfft < zSource) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
		nLen = (int)(&zSource[nSrcLen] - zOfft);
		nOfft = (int)(zOfft - zSource);
	}
	else if (nOfft >= nSrcLen) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	else {
		zOfft = &zSource[nOfft];
		nLen = nSrcLen - nOfft;
	}
	if (nArg > 3) {

		nLen = php_value_to_int(apArg[3]);
		if (nLen < 1) {

			php_result_int(pCtx,1);
			return PHP_OK;
		}
		else if (nLen + nOfft > nSrcLen) {

			nLen = nSrcLen - nOfft;
		}
		if (nArg > 4) {

			iCase = php_value_to_bool(apArg[4]);
		}
	}

	if (iCase) {
		rc = SyStrnicmp(zOfft,zSub,(sxu32)nLen);
	}
	else {
		rc = SyStrncmp(zOfft,zSub,(sxu32)nLen);
	}

	php_result_int(pCtx,rc);
	return PHP_OK;
}

static int PHP_builtin_substr_count(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zText,* zPattern,* zEnd; int nTextlen,nPatlen; int iCount = 0;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zText = php_value_to_string(apArg[0],&nTextlen);

	zPattern = php_value_to_string(apArg[1],&nPatlen);
	if (nTextlen < 1 || nPatlen < 1 || nPatlen > nTextlen) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 2) {
		int nOfft;

		nOfft = php_value_to_int(apArg[2]);
		if (nOfft < 0 || nOfft > nTextlen) {

			php_result_int(pCtx,0);
			return PHP_OK;
		}

		zText = &zText[nOfft];

		nTextlen -= nOfft;
	}

	zEnd = &zText[nTextlen];
	if (nArg > 3) {
		int nLen;

		nLen = php_value_to_int(apArg[3]);
		if (nLen < 0 || nLen > nTextlen) {

			php_result_int(pCtx,0);
			return PHP_OK;
		}

		nTextlen = nLen;
		zEnd = &zText[nTextlen];
	}

	for (;;) {
		rc = SyBlobSearch((const void*)zText,(sxu32)(zEnd - zText),(const void*)zPattern,nPatlen,&nOfft);
		if (rc != SXRET_OK) {

			break;
		}

		iCount++;
		zText += nOfft + nPatlen;
		if (zText >= zEnd) {
			break;
		}
	}

	php_result_int(pCtx,iCount);
	return PHP_OK;
}

static int PHP_builtin_chunk_split(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zEnd,* zSep = "\r\n"; int nSepLen,nChunkLen,nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	nSepLen = (int)sizeof("\r\n") - 1;
	nChunkLen = 76;
	zIn = php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nArg > 1) {

		nChunkLen = php_value_to_int(apArg[1]);
		if (nChunkLen < 1) {

			nChunkLen = 76;
		}
		if (nArg > 2) {

			zSep = php_value_to_string(apArg[2],&nSepLen);
			if (nSepLen < 1) {

				zSep = "\r\n";
				nSepLen = (int)sizeof("\r\n") - 1;
			}
		}
	}

	if (nChunkLen > nLen) {

		php_result_string_format(pCtx,"%.*s%.*s",nLen,zIn,nSepLen,zSep);
		return PHP_OK;
	}
	while (zIn < zEnd) {
		if (nChunkLen > (int)(zEnd - zIn)) {
			nChunkLen = (int)(zEnd - zIn);
		}

		php_result_string_format(pCtx,"%.*s%.*s",nChunkLen,zIn,nSepLen,zSep);

		zIn += nChunkLen;
	}
	return PHP_OK;
}

static int PHP_builtin_addslashes(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	zEnd = &zIn[nLen];
	zCur = 0;
	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '\'' && zIn[0] != '"' && zIn[0] != '\\') {
			zIn++;
		}
		if (zIn > zCur) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn < zEnd) {
			int c = zIn[0];
			php_result_string_format(pCtx,"\\%c",c);
		}
		zIn++;
	}
	return PHP_OK;
}

static int cSlashCheckMask(int c,const char* zMask,int nLen)
{
	const char* zEnd = &zMask[nLen];
	while (zMask < zEnd) {
		if (zMask[0] == c) {

			return 1;
		}

		zMask++;
	}

	return 0;
}

static int PHP_builtin_addcslashes(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd,* zMask; int nLen,nMask;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1 || nArg < 2) {

		php_result_string(pCtx,zIn,nLen);
		return PHP_OK;
	}

	zMask = php_value_to_string(apArg[1],&nMask);
	zEnd = &zIn[nLen];
	zCur = 0;
	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && !cSlashCheckMask(zIn[0],zMask,nMask)) {
			zIn++;
		}
		if (zIn > zCur) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn < zEnd) {
			int c = zIn[0];
			if (c > 126 || (c < 32 && (!SyisAlphaNum(c) && !SyisSpace(c)))) {

				php_result_string_format(pCtx,"\\%o",c);
			}
			else {
				php_result_string_format(pCtx,"\\%c",c);
			}
		}
		zIn++;
	}
	return PHP_OK;
}

static int PHP_builtin_quotemeta(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	zEnd = &zIn[nLen];
	zCur = 0;
	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && !cSlashCheckMask(zIn[0],".\\+*?[^]($)",(int)sizeof(".\\+*?[^]($)") - 1)) {
			zIn++;
		}
		if (zIn > zCur) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn < zEnd) {
			int c = zIn[0];
			php_result_string_format(pCtx,"\\%c",c);
		}
		zIn++;
	}
	return PHP_OK;
}

static int PHP_builtin_stripslashes(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (zIn == 0) {
		php_result_null(pCtx);
		return PHP_OK;
	}
	zEnd = &zIn[nLen];
	zCur = 0;

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '\\') {
			zIn++;
		}
		if (zIn > zCur) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (&zIn[1] < zEnd) {
			int c = zIn[1];
			if (c == '\'' || c == '"' || c == '\\') {

				zIn++;
			}
		}
		else {
			break;
		}
	}
	return PHP_OK;
}

static int PHP_builtin_htmlspecialchars(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int iFlags = 0x01 | 0x40; int nLen,c;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];

	if (nArg > 1) {
		iFlags = php_value_to_int(apArg[1]);
		if (iFlags < 0) {
			iFlags = 0x01 | 0x40;
		}
	}

	for (;;) {
		if (zIn >= zEnd) {
			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '&' && zIn[0] != '\'' && zIn[0] != '"' && zIn[0] != '<' && zIn[0] != '>') {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn >= zEnd) {
			break;
		}
		c = zIn[0];
		if (c == '&') {

			php_result_string(pCtx,"&amp;",(int)sizeof("&amp;") - 1);
		}
		else if (c == '<') {

			php_result_string(pCtx,"&lt;",(int)sizeof("&lt;") - 1);
		}
		else if (c == '>') {

			php_result_string(pCtx,"&gt;",(int)sizeof("&gt;") - 1);
		}
		else if (c == '\'') {
			if (iFlags & 0x02 ) {

				php_result_string(pCtx,"&#039;",(int)sizeof("&#039;") - 1);
			}
			else {

				php_result_string(pCtx,"'",(int)sizeof(char));
			}
		}
		else if (c == '"') {
			if ((iFlags & 0x04) == 0 ) {

				php_result_string(pCtx,"&quot;",(int)sizeof("&quot;") - 1);
			}
			else {

				php_result_string(pCtx,"\"",(int)sizeof(char));
			}
		}

		zIn++;
	}
	return PHP_OK;
}

static int PHP_builtin_htmlspecialchars_decode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int iFlags = 0x01; int nLen,nJump;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];

	if (nArg > 1) {
		iFlags = php_value_to_int(apArg[1]);
		if (iFlags < 0) {
			iFlags = 0x01;
		}
	}

	for (;;) {
		if (zIn >= zEnd) {
			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '&') {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		nLen = (int)(zEnd - zIn);
		nJump = (int)sizeof(char);
		if (nLen >= (int)sizeof("&amp;") - 1 && SyStrnicmp(zIn,"&amp;",sizeof("&amp;") - 1) == 0) {

			php_result_string(pCtx,"&",(int)sizeof(char));
			nJump = (int)sizeof("&amp;") - 1;
		}
		else if (nLen >= (int)sizeof("&lt;") - 1 && SyStrnicmp(zIn,"&lt;",sizeof("&lt;") - 1) == 0) {

			php_result_string(pCtx,"<",(int)sizeof(char));
			nJump = (int)sizeof("&lt;") - 1;
		}
		else if (nLen >= (int)sizeof("&gt;") - 1 && SyStrnicmp(zIn,"&gt;",sizeof("&gt;") - 1) == 0) {

			php_result_string(pCtx,">",(int)sizeof(char));
			nJump = (int)sizeof("&gt;") - 1;
		}
		else if (nLen >= (int)sizeof("&quot;") - 1 && SyStrnicmp(zIn,"&quot;",sizeof("&quot;") - 1) == 0) {

			if ((iFlags & 0x04) == 0 ) {
				php_result_string(pCtx,"\"",(int)sizeof(char));
			}
			else {

				php_result_string(pCtx,"&quot;",(int)sizeof("&quot;") - 1);
			}
			nJump = (int)sizeof("&quot;") - 1;
		}
		else if (nLen >= (int)sizeof("&#039;") - 1 && SyStrnicmp(zIn,"&#039;",sizeof("&#039;") - 1) == 0) {

			if (iFlags & 0x02 ) {

				php_result_string(pCtx,"'",(int)sizeof(char));
			}
			else {

				php_result_string(pCtx,"&#039;",(int)sizeof("&#039;") - 1);
			}
			nJump = (int)sizeof("&#039;") - 1;
		}
		else if (nLen >= (int)sizeof(char)) {

			php_result_string(pCtx,"&",(int)sizeof(char));
		}
		else {

			break;
		}
		zIn += nJump;
	}
	return PHP_OK;
}

static const char* azHtmlEscape[] = {
	"&lt;","<","&gt;",">","&amp;","&","&quot;","\"","&#39;","'",
	"&#33;","!","&#36;","$","&#35;","#","&#37;","%","&#40;","(",
	"&#41;",")","&#123;","{","&#125;","}","&#61;","=","&#43;","+",
	"&#63;","?","&#91;","[","&#93;","]","&#64;","@","&#44;",","
};

static int PHP_builtin_get_html_translation_table(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pArray,* pValue;
	sxu32 n;

	pValue = php_context_new_scalar(pCtx);
	if (pValue == 0) {
		SXUNUSED(nArg);
		SXUNUSED(apArg);

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	for (n = 0; n < SX_ARRAYSIZE(azHtmlEscape); n += 2) {

		php_value_string(pValue,azHtmlEscape[n],-1 );

		php_array_add_strkey_elem(pArray,azHtmlEscape[n + 1],pValue);

		php_value_reset_string_cursor(pValue);
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int PHP_builtin_htmlentities(php_context* pCtx,int nArg,php_value** apArg)
{
	int iFlags = 0x01;
	const char* zIn,* zEnd; int nLen,c;
	sxu32 n;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];

	if (nArg > 1) {
		iFlags = php_value_to_int(apArg[1]);
		if (iFlags < 0) {
			iFlags = 0x01;
		}
	}

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		c = zIn[0];

		for (n = 0; n < SX_ARRAYSIZE(azHtmlEscape); n += 2) {
			if (azHtmlEscape[n + 1][0] == c) {

				break;
			}
		}
		if (n < SX_ARRAYSIZE(azHtmlEscape)) {

			if (c == '"' && (iFlags & 0x04) ) {

				php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
			}
			else if (c == '\'' && ((iFlags & 0x02 ) == 0 || (iFlags & 0x04) )) {

				php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
			}
			else {
				php_result_string(pCtx,azHtmlEscape[n],-1);
			}
		}
		else {

			php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
		}
		zIn++;
	}
	return PHP_OK;
}

static int PHP_builtin_html_entity_decode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zCur,* zIn,* zEnd; int iFlags = 0x01; int nLen;
	sxu32 n;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];

	if (nArg > 1) {
		iFlags = php_value_to_int(apArg[1]);
		if (iFlags < 0) {
			iFlags = 0x01;
		}
	}

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '&') {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn >= zEnd) {
			break;
		}
		nLen = (int)(zEnd - zIn);

		for (n = 0; n < SX_ARRAYSIZE(azHtmlEscape); n += 2) {
			int iLen = (int)SyStrlen(azHtmlEscape[n]);
			if (nLen >= iLen && SyStrnicmp(zIn,azHtmlEscape[n],(sxu32)iLen) == 0) {

				zIn += iLen;
				break;
			}
		}
		if (n < SX_ARRAYSIZE(azHtmlEscape)) {
			int c = azHtmlEscape[n + 1][0];

			if (c == '\'' && ((iFlags & 0x02) == 0  || (iFlags & 0x04) )) {

				php_result_string(pCtx,azHtmlEscape[n],-1);
			}
			else if (c == '"' && (iFlags & 0x04) ) {

				php_result_string(pCtx,azHtmlEscape[n],-1);
			}
			else {
				php_result_string(pCtx,azHtmlEscape[n + 1],-1);
			}
		}
		else {

			php_result_string(pCtx,"&",(int)sizeof(char));
			zIn++;
		}
	}
	return PHP_OK;
}

static int PHP_builtin_strlen(php_context* pCtx,int nArg,php_value** apArg)
{
	int iLen = 0;
	if (nArg > 0) {
		php_value_to_string(apArg[0],&iLen);
	}

	php_result_int(pCtx,iLen);
	return PHP_OK;
}

static int PHP_builtin_strcmp(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* z1,* z2; int n1,n2; int res;
	if (nArg < 2) {
		res = nArg == 0 ? 0 : 1;
		php_result_int(pCtx,res);
		return PHP_OK;
	}

	z1 = php_value_to_string(apArg[0],&n1);
	z2 = php_value_to_string(apArg[1],&n2);
	res = SyStrncmp(z1,z2,(sxu32)(SXMAX(n1,n2)));

	php_result_int(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_strncmp(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* z1,* z2; int res; int n;
	if (nArg < 3) {

		return PHP_builtin_strcmp(pCtx,nArg,apArg);
	}

	n = php_value_to_int(apArg[2]);
	if (n < 0) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	z1 = php_value_to_string(apArg[0],0);
	z2 = php_value_to_string(apArg[1],0);
	res = SyStrncmp(z1,z2,(sxu32)n);

	php_result_int(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_strcasecmp(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* z1,* z2; int n1,n2; int res;
	if (nArg < 2) {
		res = nArg == 0 ? 0 : 1;
		php_result_int(pCtx,res);
		return PHP_OK;
	}

	z1 = php_value_to_string(apArg[0],&n1);
	z2 = php_value_to_string(apArg[1],&n2);
	res = SyStrnicmp(z1,z2,(sxu32)(SXMAX(n1,n2)));

	php_result_int(pCtx,res);
	return PHP_OK;
}

static int PHP_builtin_strncasecmp(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* z1,* z2; int res; int n;
	if (nArg < 3) {

		return PHP_builtin_strcasecmp(pCtx,nArg,apArg);
	}

	n = php_value_to_int(apArg[2]);
	if (n < 0) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	z1 = php_value_to_string(apArg[0],0);
	z2 = php_value_to_string(apArg[1],0);
	res = SyStrnicmp(z1,z2,(sxu32)n);

	php_result_int(pCtx,res);
	return PHP_OK;
}

struct implode_data {
	php_context* pCtx; int bRecursive;
	const char* zSep; int nSeplen; int bFirst; int nRecCount;
};

static int implode_callback(php_value* pKey,php_value* pValue,void* pUserData)
{
	struct implode_data* pData = (struct implode_data*)pUserData;
	const char* zData; int nLen;
	if (pData->bRecursive && php_value_is_array(pValue) && pData->nRecCount < 32) {
		if (pData->nSeplen > 0) {
			if (!pData->bFirst) {

				php_result_string(pData->pCtx,pData->zSep,pData->nSeplen);
			}
			else {
				pData->bFirst = 0;
			}
		}

		pData->bFirst = 1;
		pData->nRecCount++;
		PHP_HashmapWalk((php_hashmap*)pValue->x.pOther,implode_callback,pData);
		pData->nRecCount--;
		return PHP_OK;
	}

	zData = php_value_to_string(pValue,&nLen);
	if (nLen > 0) {
		if (pData->nSeplen > 0) {
			if (!pData->bFirst) {

				php_result_string(pData->pCtx,pData->zSep,pData->nSeplen);
			}
			else {
				pData->bFirst = 0;
			}
		}
		php_result_string(pData->pCtx,zData,nLen);
	}
	else {
		SXUNUSED(pKey);
	}
	return PHP_OK;
}

static int PHP_builtin_implode(php_context* pCtx,int nArg,php_value** apArg)
{
	struct implode_data imp_data; int i = 1;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	imp_data.pCtx = pCtx;
	imp_data.bRecursive = 0;
	imp_data.bFirst = 1;
	imp_data.nRecCount = 0;
	if (!php_value_is_array(apArg[0])) {
		imp_data.zSep = php_value_to_string(apArg[0],&imp_data.nSeplen);
	}
	else {
		imp_data.zSep = 0;
		imp_data.nSeplen = 0;
		i = 0;
	}
	php_result_string(pCtx,"",0);

	while (i < nArg) {
		if (php_value_is_array(apArg[i])) {

			php_array_walk(apArg[i],implode_callback,&imp_data);
		}
		else {
			const char* zData; int nLen;

			zData = php_value_to_string(apArg[i],&nLen);
			if (nLen > 0) {
				if (imp_data.nSeplen > 0) {
					if (!imp_data.bFirst) {

						php_result_string(pCtx,imp_data.zSep,imp_data.nSeplen);
					}
					else {
						imp_data.bFirst = 0;
					}
				}
				php_result_string(pCtx,zData,nLen);
			}
		}
		i++;
	}
	return PHP_OK;
}

static int PHP_builtin_implode_recursive(php_context* pCtx,int nArg,php_value** apArg)
{
	struct implode_data imp_data; int i = 1;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	imp_data.pCtx = pCtx;
	imp_data.bRecursive = 1;
	imp_data.bFirst = 1;
	imp_data.nRecCount = 0;
	if (!php_value_is_array(apArg[0])) {
		imp_data.zSep = php_value_to_string(apArg[0],&imp_data.nSeplen);
	}
	else {
		imp_data.zSep = 0;
		imp_data.nSeplen = 0;
		i = 0;
	}
	php_result_string(pCtx,"",0);

	while (i < nArg) {
		if (php_value_is_array(apArg[i])) {

			php_array_walk(apArg[i],implode_callback,&imp_data);
		}
		else {
			const char* zData; int nLen;

			zData = php_value_to_string(apArg[i],&nLen);
			if (nLen > 0) {
				if (imp_data.nSeplen > 0) {
					if (!imp_data.bFirst) {

						php_result_string(pCtx,imp_data.zSep,imp_data.nSeplen);
					}
					else {
						imp_data.bFirst = 0;
					}
				}
				php_result_string(pCtx,zData,nLen);
			}
		}
		i++;
	}
	return PHP_OK;
}

static int PHP_builtin_explode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zDelim,* zString,* zCur,* zEnd; int nDelim,nStrlen,iLimit;
	php_value* pArray;
	php_value* pValue;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zDelim = php_value_to_string(apArg[0],&nDelim);
	if (nDelim < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[1],&nStrlen);
	if (nStrlen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zEnd = &zString[nStrlen];

	pArray = php_context_new_array(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pValue == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	iLimit = SXI32_HIGH;
	if (nArg > 2) {
		iLimit = php_value_to_int(apArg[2]);
		if (iLimit < 0) {
			iLimit = -iLimit;
		}
		if (iLimit == 0) {
			iLimit = 1;
		}
		iLimit--;
	}

	for (;;) {
		if (zString >= zEnd) {

			break;
		}
		rc = SyBlobSearch(zString,(sxu32)(zEnd - zString),zDelim,nDelim,&nOfft);
		if (rc != SXRET_OK || iLimit <= (int)php_array_count(pArray)) {

			if (zEnd > zString) {
				php_value_string(pValue,zString,(int)(zEnd - zString));
				php_array_add_elem(pArray,0,pValue);
			}
			break;
		}

		zCur = &zString[nOfft];
		if (zCur > zString) {

			php_value_string(pValue,zString,(int)(zCur - zString));
			php_array_add_elem(pArray,0,pValue);
		}

		zString = &zCur[nDelim];

		php_value_reset_string_cursor(pValue);
	}

	php_result_value(pCtx,pArray);

	return PHP_OK;
}

static int PHP_builtin_trim(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	if (nArg < 2) {
		SyString sStr;

		SyStringInitFromBuf(&sStr,zString,nLen);
		SyStringFullTrimSafe(&sStr);
		php_result_string(pCtx,sStr.zString,(int)sStr.nByte);
	}
	else {

		const char* zList; int nListlen;
		zList = php_value_to_string(apArg[1],&nListlen);
		if (nListlen < 1) {

			php_result_string(pCtx,zString,nLen);
		}
		else {
			const char* zEnd = &zString[nLen];
			const char* zCur = zString;
			const char* zPtr; int i;

			for (;;) {
				if (zCur >= zEnd) {
					break;
				}
				zPtr = zCur;
				for (i = 0; i < nListlen; i++) {
					if (zCur < zEnd && zCur[0] == zList[i]) {
						zCur++;
					}
				}
				if (zCur == zPtr) {

					break;
				}
			}

			zEnd--;
			for (;;) {
				if (zEnd <= zCur) {
					break;
				}
				zPtr = zEnd;
				for (i = 0; i < nListlen; i++) {
					if (zEnd > zCur && zEnd[0] == zList[i]) {
						zEnd--;
					}
				}
				if (zEnd == zPtr) {
					break;
				}
			}
			if (zCur >= zEnd) {

				php_result_string(pCtx,"",0);
			}
			else {
				zEnd++;
				php_result_string(pCtx,zCur,(int)(zEnd - zCur));
			}
		}
	}
	return PHP_OK;
}

static int PHP_builtin_rtrim(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	if (nArg < 2) {
		SyString sStr;

		SyStringInitFromBuf(&sStr,zString,nLen);
		SyStringRightTrimSafe(&sStr);
		php_result_string(pCtx,sStr.zString,(int)sStr.nByte);
	}
	else {

		const char* zList; int nListlen;
		zList = php_value_to_string(apArg[1],&nListlen);
		if (nListlen < 1) {

			php_result_string(pCtx,zString,nLen);
		}
		else {
			const char* zEnd = &zString[nLen - 1];
			const char* zCur = zString;
			const char* zPtr; int i;

			for (;;) {
				if (zEnd <= zCur) {
					break;
				}
				zPtr = zEnd;
				for (i = 0; i < nListlen; i++) {
					if (zEnd > zCur && zEnd[0] == zList[i]) {
						zEnd--;
					}
				}
				if (zEnd == zPtr) {
					break;
				}
			}
			if (zEnd <= zCur) {

				php_result_string(pCtx,"",0);
			}
			else {
				zEnd++;
				php_result_string(pCtx,zCur,(int)(zEnd - zCur));
			}
		}
	}
	return PHP_OK;
}

static int PHP_builtin_ltrim(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	if (nArg < 2) {
		SyString sStr;

		SyStringInitFromBuf(&sStr,zString,nLen);
		SyStringLeftTrimSafe(&sStr);
		php_result_string(pCtx,sStr.zString,(int)sStr.nByte);
	}
	else {

		const char* zList; int nListlen;
		zList = php_value_to_string(apArg[1],&nListlen);
		if (nListlen < 1) {

			php_result_string(pCtx,zString,nLen);
		}
		else {
			const char* zEnd = &zString[nLen];
			const char* zCur = zString;
			const char* zPtr; int i;

			for (;;) {
				if (zCur >= zEnd) {
					break;
				}
				zPtr = zCur;
				for (i = 0; i < nListlen; i++) {
					if (zCur < zEnd && zCur[0] == zList[i]) {
						zCur++;
					}
				}
				if (zCur == zPtr) {

					break;
				}
			}
			if (zCur >= zEnd) {

				php_result_string(pCtx,"",0);
			}
			else {
				php_result_string(pCtx,zCur,(int)(zEnd - zCur));
			}
		}
	}
	return PHP_OK;
}

static int PHP_builtin_strtolower(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zCur,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zEnd = &zString[nLen];
	for (;;) {
		if (zString >= zEnd) {

			break;
		}
		if ((unsigned char)zString[0] >= 0xc0) {

			zCur = zString;
			zString++;
			while (zString < zEnd && ((unsigned char)zString[0] & 0xc0) == 0x80) {
				zString++;
			}

			php_result_string(pCtx,zCur,(int)(zString - zCur));
		}
		else {
			int c = zString[0];
			if (SyisUpper(c)) {
				c = SyToLower(zString[0]);
			}

			php_result_string(pCtx,(const char*)&c,(int)sizeof(char));

			zString++;
		}
	}
	return PHP_OK;
}

static int PHP_builtin_strtoupper(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zCur,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zEnd = &zString[nLen];
	for (;;) {
		if (zString >= zEnd) {

			break;
		}
		if ((unsigned char)zString[0] >= 0xc0) {

			zCur = zString;
			zString++;
			while (zString < zEnd && ((unsigned char)zString[0] & 0xc0) == 0x80) {
				zString++;
			}

			php_result_string(pCtx,zCur,(int)(zString - zCur));
		}
		else {
			int c = zString[0];
			if (SyisLower(c)) {
				c = SyToUpper(zString[0]);
			}

			php_result_string(pCtx,(const char*)&c,(int)sizeof(char));

			zString++;
		}
	}
	return PHP_OK;
}

static int PHP_builtin_ucfirst(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zEnd; int nLen,c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zEnd = &zString[nLen];
	c = zString[0];
	if (SyisLower(c)) {
		c = SyToUpper(c);
	}

	php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
	zString++;
	if (zString < zEnd) {

		php_result_string(pCtx,zString,(int)(zEnd - zString));
	}
	return PHP_OK;
}

static int PHP_builtin_lcfirst(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zEnd; int nLen,c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zEnd = &zString[nLen];
	c = zString[0];
	if (SyisUpper(c)) {
		c = SyToLower(c);
	}

	php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
	zString++;
	if (zString < zEnd) {

		php_result_string(pCtx,zString,(int)(zEnd - zString));
	}
	return PHP_OK;
}

static int PHP_builtin_ord(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen,c;
	if (nArg < 1) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}

	c = zString[0];

	php_result_int(pCtx,c);
	return PHP_OK;
}

static int PHP_builtin_chr(php_context* pCtx,int nArg,php_value** apArg)
{
	int c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	c = php_value_to_int(apArg[0]);

	php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
	return PHP_OK;
}

static int HashConsumer(const void* pData,unsigned int nLen,void* pUserData)
{

	php_result_string((php_context*)pUserData,(const char*)pData,(int)nLen);
	return SXRET_OK;
}

static int PHP_builtin_bin2hex(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	SyBinToHexConsumer((const void*)zString,(sxu32)nLen,HashConsumer,pCtx);
	return PHP_OK;
}

typedef sxi32(*ProcStringMatch)(const void*,sxu32,const void*,sxu32,sxu32*);

static sxi32 iPatternMatch(const void* pText,sxu32 nLen,const void* pPattern,sxu32 iPatLen,sxu32* pOfft)
{
	const char* zpIn = (const char*)pPattern;
	const char* zIn = (const char*)pText;
	const char* zpEnd = &zpIn[iPatLen];
	const char* zEnd = &zIn[nLen];
	const char* zPtr,* zPtr2; int c,d;
	if (iPatLen > nLen) {

		return SXERR_NOTFOUND;
	}
	for (;;) {
		if (zIn >= zEnd) {
			break;
		}
		c = SyToLower(zIn[0]);
		d = SyToLower(zpIn[0]);
		if (c == d) {
			zPtr = &zIn[1];
			zPtr2 = &zpIn[1];
			for (;;) {
				if (zPtr2 >= zpEnd) {

					if (pOfft) { *pOfft = (sxu32)(zIn - (const char*)pText); }
					return SXRET_OK;
				}
				if (zPtr >= zEnd) {
					break;
				}
				c = SyToLower(zPtr[0]);
				d = SyToLower(zPtr2[0]);
				if (c != d) {
					break;
				}
				zPtr++; zPtr2++;
			}
		}
		zIn++;
	}

	return SXERR_NOTFOUND;
}

static int PHP_builtin_strstr(php_context* pCtx,int nArg,php_value** apArg)
{
	ProcStringMatch xPatternMatch = SyBlobSearch;
	const char* zBlob,* zPattern; int nLen,nPatLen;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);
	nOfft = 0;
	if (nLen > 0 && nPatLen > 0) {
		int before = 0;

		rc = xPatternMatch(zBlob,(sxu32)nLen,zPattern,(sxu32)nPatLen,&nOfft);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		if (nArg > 2) {
			before = php_value_to_int(apArg[2]);
		}
		if (before) {
			php_result_string(pCtx,zBlob,(int)(&zBlob[nOfft] - zBlob));
		}
		else {
			php_result_string(pCtx,&zBlob[nOfft],(int)(&zBlob[nLen] - &zBlob[nOfft]));
		}
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_stristr(php_context* pCtx,int nArg,php_value** apArg)
{
	ProcStringMatch xPatternMatch = iPatternMatch;
	const char* zBlob,* zPattern; int nLen,nPatLen;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);
	nOfft = 0;
	if (nLen > 0 && nPatLen > 0) {
		int before = 0;

		rc = xPatternMatch(zBlob,(sxu32)nLen,zPattern,(sxu32)nPatLen,&nOfft);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		if (nArg > 2) {
			before = php_value_to_int(apArg[2]);
		}
		if (before) {
			php_result_string(pCtx,zBlob,(int)(&zBlob[nOfft] - zBlob));
		}
		else {
			php_result_string(pCtx,&zBlob[nOfft],(int)(&zBlob[nLen] - &zBlob[nOfft]));
		}
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_strpos(php_context* pCtx,int nArg,php_value** apArg)
{
	ProcStringMatch xPatternMatch = SyBlobSearch;
	const char* zBlob,* zPattern; int nLen,nPatLen,nStart;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);
	nOfft = 0;
	nStart = 0;

	if (nArg > 2) {
		nStart = php_value_to_int(apArg[2]);
		if (nStart < 0) {
			nStart = -nStart;
		}
		if (nStart >= nLen) {

			nStart = 0;
		}
		else {
			zBlob += nStart;
			nLen -= nStart;
		}
	}
	if (nLen > 0 && nPatLen > 0) {

		rc = xPatternMatch(zBlob,(sxu32)nLen,zPattern,(sxu32)nPatLen,&nOfft);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		php_result_int64(pCtx,(php_int64)(nOfft + nStart));
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_stripos(php_context* pCtx,int nArg,php_value** apArg)
{
	ProcStringMatch xPatternMatch = iPatternMatch;
	const char* zBlob,* zPattern; int nLen,nPatLen,nStart;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);
	nOfft = 0;
	nStart = 0;

	if (nArg > 2) {
		nStart = php_value_to_int(apArg[2]);
		if (nStart < 0) {
			nStart = -nStart;
		}
		if (nStart >= nLen) {

			nStart = 0;
		}
		else {
			zBlob += nStart;
			nLen -= nStart;
		}
	}
	if (nLen > 0 && nPatLen > 0) {

		rc = xPatternMatch(zBlob,(sxu32)nLen,zPattern,(sxu32)nPatLen,&nOfft);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		php_result_int64(pCtx,(php_int64)(nOfft + nStart));
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_strrpos(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zStart,* zBlob,* zPattern,* zPtr,* zEnd;
	ProcStringMatch xPatternMatch = SyBlobSearch; int nLen,nPatLen;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);

	zPtr = &zBlob[nLen - 1];
	zEnd = &zBlob[nLen];

	zStart = zBlob;
	nOfft = 0;

	if (nArg > 2) {
		int nStart;
		nStart = php_value_to_int(apArg[2]);
		if (nStart < 0) {
			nStart = -nStart;
			if (nStart >= nLen) {

				php_result_bool(pCtx,0);
				return PHP_OK;
			}
			else {
				nLen -= nStart;
				zPtr = &zBlob[nLen - 1];
				zEnd = &zBlob[nLen];
			}
		}
		else {
			if (nStart >= nLen) {

				php_result_bool(pCtx,0);
				return PHP_OK;
			}
			else {
				zBlob += nStart;
				nLen -= nStart;
			}
		}
	}
	if (nLen > 0 && nPatLen > 0) {

		for (;;) {
			if (zBlob >= zPtr) {
				break;
			}
			rc = xPatternMatch((const void*)zPtr,(sxu32)(zEnd - zPtr),(const void*)zPattern,(sxu32)nPatLen,&nOfft);
			if (rc == SXRET_OK) {

				php_result_int64(pCtx,(php_int64)(&zPtr[nOfft] - zStart));
				return PHP_OK;
			}
			zPtr--;
		}

		php_result_bool(pCtx,0);
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_strripos(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zStart,* zBlob,* zPattern,* zPtr,* zEnd;
	ProcStringMatch xPatternMatch = iPatternMatch; int nLen,nPatLen;
	sxu32 nOfft;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	zPattern = php_value_to_string(apArg[1],&nPatLen);

	zPtr = &zBlob[nLen - 1];
	zEnd = &zBlob[nLen];

	zStart = zBlob;
	nOfft = 0;

	if (nArg > 2) {
		int nStart;
		nStart = php_value_to_int(apArg[2]);
		if (nStart < 0) {
			nStart = -nStart;
			if (nStart >= nLen) {

				php_result_bool(pCtx,0);
				return PHP_OK;
			}
			else {
				nLen -= nStart;
				zPtr = &zBlob[nLen - 1];
				zEnd = &zBlob[nLen];
			}
		}
		else {
			if (nStart >= nLen) {

				php_result_bool(pCtx,0);
				return PHP_OK;
			}
			else {
				zBlob += nStart;
				nLen -= nStart;
			}
		}
	}
	if (nLen > 0 && nPatLen > 0) {

		for (;;) {
			if (zBlob >= zPtr) {
				break;
			}
			rc = xPatternMatch((const void*)zPtr,(sxu32)(zEnd - zPtr),(const void*)zPattern,(sxu32)nPatLen,&nOfft);
			if (rc == SXRET_OK) {

				php_result_int64(pCtx,(php_int64)(&zPtr[nOfft] - zStart));
				return PHP_OK;
			}
			zPtr--;
		}

		php_result_bool(pCtx,0);
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_strrchr(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zBlob; int nLen,c;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zBlob = php_value_to_string(apArg[0],&nLen);
	c = 0;
	if (nLen > 0) {
		sxu32 nOfft;
		sxi32 rc;
		if (php_value_is_string(apArg[1])) {
			const char* zPattern;
			zPattern = php_value_to_string(apArg[1],0);
			c = zPattern[0];
		}
		else {

			c = php_value_to_int(apArg[1]);
		}

		rc = SyByteFind2(zBlob,(sxu32)nLen,c,&nOfft);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		php_result_string(pCtx,&zBlob[nOfft],(int)(&zBlob[nLen] - &zBlob[nOfft]));
	}
	else {
		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_strrev(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zEnd; int nLen,c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zEnd = &zIn[nLen - 1];
	for (;;) {
		if (zEnd < zIn) {

			break;
		}

		c = zEnd[0];
		php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
		zEnd--;
	}
	return PHP_OK;
}

static int PHP_builtin_ucwords(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zCur,* zEnd; int nLen,c;
	if (nArg < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zEnd = &zIn[nLen];
	for (;;) {

		zCur = zIn;
		while (zIn < zEnd && (unsigned char)zIn[0] < 0x80 && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn >= zEnd) {

			break;
		}
		c = zIn[0];
		if (c < 0x80 && SyisLower(c)) {
			c = SyToUpper(c);
		}

		php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
		zIn++;
		zCur = zIn;

		while (zIn < zEnd) {
			if ((unsigned char)zIn[0] >= 0xc0) {

				zIn++;
				SX_JMP_UTF8(zIn,zEnd);
			}
			else if (!SyisSpace(zIn[0])) {
				zIn++;
			}
			else {
				break;
			}
		}
		if (zCur < zIn) {
			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
	}
	return PHP_OK;
}

static int PHP_builtin_str_repeat(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen,nMul; int rc;
	if (nArg < 2) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	nMul = php_value_to_int(apArg[1]);
	if (nMul < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	for (;;) {
		if (!nMul) {
			break;
		}

		rc = php_result_string(pCtx,zIn,nLen);
		if (rc != PHP_OK) {

			break;
		}
		nMul--;
	}
	return PHP_OK;
}

static int PHP_builtin_nl2br(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zCur,* zEnd; int is_xhtml = 0; int nLen;
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg > 1) {
		is_xhtml = php_value_to_bool(apArg[1]);
	}
	zEnd = &zIn[nLen];

	for (;;) {
		zCur = zIn;

		while (zIn < zEnd && (zIn[0] != '\n' && zIn[0] != '\r')) {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		if (zIn >= zEnd) {

			break;
		}

		if (is_xhtml) {
			php_result_string(pCtx,"<br>",(int)sizeof("<br>") - 1);
		}
		else {
			php_result_string(pCtx,"<br/>",(int)sizeof("<br/>") - 1);
		}
		zCur = zIn;

		while (zIn < zEnd && (zIn[0] == '\n' || zIn[0] == '\r')) {
			zIn++;
		}
		if (zCur < zIn) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
	}
	return PHP_OK;
}


#define PHP_FMT_BUFSIZ 1024

#define PHP_FMT_RADIX       1
#define PHP_FMT_FLOAT       2
#define PHP_FMT_EXP         3
#define PHP_FMT_GENERIC     4
#define PHP_FMT_SIZE        5
#define PHP_FMT_STRING      6
#define PHP_FMT_PERCENT     7
#define PHP_FMT_CHARX       8
#define PHP_FMT_ERROR       9

#define PHP_FMT_FLAG_SIGNED	  0x01
#define PHP_FMT_FLAG_UNSIGNED 0x02

typedef struct php_fmt_info php_fmt_info;
struct php_fmt_info
{
	char fmttype;
	sxu8 base; int flags;
	sxu8 type;
	char* charset;
	char* prefix;
};
#ifndef PHP_OMIT_FLOATING_POINT

static int vxGetdigit(sxlongreal* val,int* cnt)
{
	sxlongreal d; int digit;

	if ((*cnt)++ >= 16) {
		return '0';
	}
	digit = (int)*val;
	d = digit;
	*val = (*val - d) * 10.0;
	return digit + '0';
}
#endif

static const php_fmt_info aFmt[] = {
{'d',10,PHP_FMT_FLAG_SIGNED,PHP_FMT_RADIX,"0123456789",0},
{'s',0,0,PHP_FMT_STRING,0,0},
{'c',0,0,PHP_FMT_CHARX,0,0},
{'x',16,0,PHP_FMT_RADIX,"0123456789abcdef","x0"},
{'X',16,0,PHP_FMT_RADIX,"0123456789ABCDEF","X0"},
{'b',2,0,PHP_FMT_RADIX,"01","b0"},
{'o',8,0,PHP_FMT_RADIX,"01234567","0"},
{'u',10,0,PHP_FMT_RADIX,"0123456789",0},
{'f',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_FLOAT,0,0},
{'F',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_FLOAT,0,0},
{'e',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_EXP,"e",0},
{'E',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_EXP,"E",0},
{'g',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_GENERIC,"e",0},
{'G',0,PHP_FMT_FLAG_SIGNED,PHP_FMT_GENERIC,"E",0},
{'%',0,0,PHP_FMT_PERCENT,0,0    }
};

PHP_PRIVATE sxi32 PHP_InputFormat(
	int (*xConsumer)(php_context*,const char*,int,void*),
	php_context* pCtx,
	const char* zIn,
	int nByte,
	int nArg,
	php_value** apArg,
	void* pUserData,
	int vf
)
{
	char spaces[] = "                                                  ";
#define etSPACESIZE ((int)sizeof(spaces)-1)
	const char* zCur,* zEnd = &zIn[nByte];
	char* zBuf,zWorker[PHP_FMT_BUFSIZ];
	const php_fmt_info* pInfo; int flag_alternateform; int flag_leftjustify; int flag_blanksign; int flag_plussign; int flag_zeropad;
	php_value* pArg;
	php_int64 iVal; int precision;
	char* zExtra; int c,rc,n; int length; int prefix;
	sxu8 xtype; int width; int idx;
	n = (vf == TRUE) ? 0 : 1;
#define NEXT_ARG	( n < nArg ? apArg[n++] : 0 )

	for (;;) {
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '%') {
			zIn++;
		}
		if (zCur < zIn) {

			rc = xConsumer(pCtx,zCur,(int)(zIn - zCur),pUserData);
			if (rc == SXERR_ABORT) {

				break;
			}
		}
		if (zIn >= zEnd) {

			break;
		}

		flag_leftjustify = flag_plussign = flag_blanksign =
			flag_alternateform = flag_zeropad = 0;
		zIn++;
		do {
			c = zIn[0];
			switch (c) {
			case '-':   flag_leftjustify = 1;     c = 0;   break;
			case '+':   flag_plussign = 1;        c = 0;   break;
			case ' ':   flag_blanksign = 1;       c = 0;   break;
			case '#':   flag_alternateform = 1;   c = 0;   break;
			case '0':   flag_zeropad = 1;         c = 0;   break;
			case '\'':
				zIn++;
				if (zIn < zEnd) {

					c = zIn[0];
					for (idx = 0; idx < etSPACESIZE; ++idx) {
						spaces[idx] = (char)c;
					}
					c = 0;
				}
				break;
			default:                                       break;
			}
		} while (c == 0 && (zIn++ < zEnd));

		width = 0;
		while (zIn < zEnd && (zIn[0] >= '0' && zIn[0] <= '9')) {
			width = width * 10 + (zIn[0] - '0');
			zIn++;
		}
		if (zIn < zEnd && zIn[0] == '$') {

			if (width > 0) {
				n = width;
				if (vf && n > 0) {
					n--;
				}
			}
			zIn++;
			width = 0;
			if (zIn < zEnd && zIn[0] == '0') {
				flag_zeropad = 1;
				zIn++;
			}
			while (zIn < zEnd && (zIn[0] >= '0' && zIn[0] <= '9')) {
				width = width * 10 + (zIn[0] - '0');
				zIn++;
			}
		}
		if (width > PHP_FMT_BUFSIZ - 10) {
			width = PHP_FMT_BUFSIZ - 10;
		}

		precision = -1;
		if (zIn < zEnd && zIn[0] == '.') {
			precision = 0;
			zIn++;
			while (zIn < zEnd && (zIn[0] >= '0' && zIn[0] <= '9')) {
				precision = precision * 10 + (zIn[0] - '0');
				zIn++;
			}
		}
		if (zIn >= zEnd) {

			break;
		}

		pInfo = 0;
		xtype = PHP_FMT_ERROR;
		c = zIn[0];
		zIn++;
		for (idx = 0; idx < (int)SX_ARRAYSIZE(aFmt); idx++) {
			if (c == aFmt[idx].fmttype) {
				pInfo = &aFmt[idx];
				xtype = pInfo->type;
				break;
			}
		}
		zBuf = zWorker;
		length = 0;
		zExtra = 0;

		switch (xtype) {
		case PHP_FMT_PERCENT:

			zWorker[0] = '%';
			length = (int)sizeof(char);
			break;
		case PHP_FMT_CHARX:

			pArg = NEXT_ARG;
			if (pArg == 0) {
				c = 0;
			}
			else {
				c = php_value_to_int(pArg);
			}

			zWorker[0] = (char)c;
			length = (int)sizeof(char);
			break;
		case PHP_FMT_STRING:

			pArg = NEXT_ARG;
			if (pArg == 0) {
				length = 0;
			}
			else {
				zBuf = (char*)php_value_to_string(pArg,&length);
			}
			if (length < 1) {
				zBuf = " ";
				length = (int)sizeof(char);
			}
			if (precision >= 0 && precision < length) {
				length = precision;
			}
			if (flag_zeropad) {

				for (idx = 0; idx < etSPACESIZE; ++idx) {
					spaces[idx] = '0';
				}
			}
			break;
		case PHP_FMT_RADIX:
			pArg = NEXT_ARG;
			if (pArg == 0) {
				iVal = 0;
			}
			else {
				iVal = php_value_to_int64(pArg);
			}

			if (precision > PHP_FMT_BUFSIZ - 40) {
				precision = PHP_FMT_BUFSIZ - 40;
			}
#if 1

			if (iVal == 0) flag_alternateform = 0;
#else

			if (iVal == 0 && pInfo->base == 8) flag_alternateform = 0;
#endif
			if (pInfo->flags & PHP_FMT_FLAG_SIGNED) {
				if (iVal < 0) {
					iVal = -iVal;

					if (iVal < 0) {

						iVal = 0x7FFFFFFFFFFFFFFF;
					}
					prefix = '-';
				}
				else if (flag_plussign)  prefix = '+';
				else if (flag_blanksign)  prefix = ' ';
				else                       prefix = 0;
			}
			else {
				if (iVal < 0) {
					iVal = -iVal;

					if (iVal < 0) {

						iVal = 0x7FFFFFFFFFFFFFFF;
					}
				}
				prefix = 0;
			}
			if (flag_zeropad && precision < width - (prefix != 0)) {
				precision = width - (prefix != 0);
			}
			zBuf = &zWorker[PHP_FMT_BUFSIZ - 1];
			{
				register char* cset;
				register int base;
				cset = pInfo->charset;
				base = pInfo->base;
				do {
					*(--zBuf) = cset[iVal % base];
					iVal = iVal / base;
				} while (iVal > 0);
			}
			length = &zWorker[PHP_FMT_BUFSIZ - 1] - zBuf;
			for (idx = precision - length; idx > 0; idx--) {
				*(--zBuf) = '0';
			}
			if (prefix) *(--zBuf) = (char)prefix;
			if (flag_alternateform && pInfo->prefix) {
				char* pre,x;
				pre = pInfo->prefix;
				if (*zBuf != pre[0]) {
					for (pre = pInfo->prefix; (x = (*pre)) != 0; pre++) *(--zBuf) = x;
				}
			}
			length = &zWorker[PHP_FMT_BUFSIZ - 1] - zBuf;
			break;
		case PHP_FMT_FLOAT:
		case PHP_FMT_EXP:
		case PHP_FMT_GENERIC: {
#ifndef PHP_OMIT_FLOATING_POINT
			long double realvalue; int  exp;
			double rounder; int flag_dp; int flag_rtz; int flag_exp; int nsd;
			pArg = NEXT_ARG;
			if (pArg == 0) {
				realvalue = 0;
			}
			else {
				realvalue = php_value_to_double(pArg);
			}
			if (precision < 0) precision = 6;
			if (precision > PHP_FMT_BUFSIZ - 40) precision = PHP_FMT_BUFSIZ - 40;
			if (realvalue < 0.0) {
				realvalue = -realvalue;
				prefix = '-';
			}
			else {
				if (flag_plussign)          prefix = '+';
				else if (flag_blanksign)    prefix = ' ';
				else                         prefix = 0;
			}
			if (pInfo->type == PHP_FMT_GENERIC && precision > 0) precision--;
			rounder = 0.0;
#if 0

			for (idx = precision,rounder = 0.4999; idx > 0; idx--,rounder *= 0.1);
#else

			for (idx = precision,rounder = 0.5; idx > 0; idx--,rounder *= 0.1);
#endif
			if (pInfo->type == PHP_FMT_FLOAT) realvalue += rounder;

			exp = 0;
			if (realvalue > 0.0) {
				while (realvalue >= 1e8 && exp <= 350) { realvalue *= 1e-8; exp += 8; }
				while (realvalue >= 10.0 && exp <= 350) { realvalue *= 0.1; exp++; }
				while (realvalue < 1e-8 && exp >= -350) { realvalue *= 1e8; exp -= 8; }
				while (realvalue < 1.0 && exp >= -350) { realvalue *= 10.0; exp--; }
				if (exp > 350 || exp < -350) {
					zBuf = "NaN";
					length = 3;
					break;
				}
			}
			zBuf = zWorker;

			flag_exp = xtype == PHP_FMT_EXP;
			if (xtype != PHP_FMT_FLOAT) {
				realvalue += rounder;
				if (realvalue >= 10.0) { realvalue *= 0.1; exp++; }
			}
			if (xtype == PHP_FMT_GENERIC) {
				flag_rtz = !flag_alternateform;
				if (exp<-4 || exp>precision) {
					xtype = PHP_FMT_EXP;
				}
				else {
					precision = precision - exp;
					xtype = PHP_FMT_FLOAT;
				}
			}
			else {
				flag_rtz = 0;
			}

			nsd = 0;
			if (xtype == PHP_FMT_FLOAT && exp + precision < PHP_FMT_BUFSIZ - 30) {
				flag_dp = (precision > 0 || flag_alternateform);
				if (prefix) *(zBuf++) = (char)prefix;
				if (exp < 0)  *(zBuf++) = '0';
				else for (; exp >= 0; exp--) *(zBuf++) = (char)vxGetdigit(&realvalue,&nsd);
				if (flag_dp) *(zBuf++) = '.';
				for (exp++; exp < 0 && precision>0; precision--,exp++) {
					*(zBuf++) = '0';
				}
				while ((precision--) > 0) *(zBuf++) = (char)vxGetdigit(&realvalue,&nsd);
				*(zBuf--) = 0;
				if (flag_rtz && flag_dp) {
					while (zBuf >= zWorker && *zBuf == '0') *(zBuf--) = 0;
					if (zBuf >= zWorker && *zBuf == '.') *(zBuf--) = 0;
				}
				zBuf++;
			}
			else {
				flag_dp = (precision > 0 || flag_alternateform);
				if (prefix) *(zBuf++) = (char)prefix;
				*(zBuf++) = (char)vxGetdigit(&realvalue,&nsd);
				if (flag_dp) *(zBuf++) = '.';
				while ((precision--) > 0) *(zBuf++) = (char)vxGetdigit(&realvalue,&nsd);
				zBuf--;
				if (flag_rtz && flag_dp) {
					while (zBuf >= zWorker && *zBuf == '0') *(zBuf--) = 0;
					if (zBuf >= zWorker && *zBuf == '.') *(zBuf--) = 0;
				}
				zBuf++;
				if (exp || flag_exp) {
					*(zBuf++) = pInfo->charset[0];
					if (exp < 0) { *(zBuf++) = '-'; exp = -exp; }
					else { *(zBuf++) = '+'; }
					if (exp >= 100) {
						*(zBuf++) = (char)((exp / 100) + '0');
						exp %= 100;
					}
					*(zBuf++) = (char)(exp / 10 + '0');
					*(zBuf++) = (char)(exp % 10 + '0');
				}
			}

			length = (int)(zBuf - zWorker);
			zBuf = zWorker;

			if (flag_zeropad && !flag_leftjustify && length < width) {
				int i; int nPad = width - length;
				for (i = width; i >= nPad; i--) {
					zBuf[i] = zBuf[i - nPad];
				}
				i = prefix != 0;
				while (nPad--) zBuf[i++] = '0';
				length = width;
			}
#else
			zBuf = " ";
			length = (int)sizeof(char);
#endif
			break;
		}
		default:

			zWorker[0] = '?';
			length = (int)sizeof(char);
			break;
		}

		if (!flag_leftjustify) {
			register int nspace;
			nspace = width - length;
			if (nspace > 0) {
				while (nspace >= etSPACESIZE) {
					rc = xConsumer(pCtx,spaces,etSPACESIZE,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
					nspace -= etSPACESIZE;
				}
				if (nspace > 0) {
					rc = xConsumer(pCtx,spaces,(unsigned int)nspace,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
				}
			}
		}
		if (length > 0) {
			rc = xConsumer(pCtx,zBuf,(unsigned int)length,pUserData);
			if (rc != SXRET_OK) {
				return SXERR_ABORT;
			}
		}
		if (flag_leftjustify) {
			register int nspace;
			nspace = width - length;
			if (nspace > 0) {
				while (nspace >= etSPACESIZE) {
					rc = xConsumer(pCtx,spaces,etSPACESIZE,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
					nspace -= etSPACESIZE;
				}
				if (nspace > 0) {
					rc = xConsumer(pCtx,spaces,(unsigned int)nspace,pUserData);
					if (rc != SXRET_OK) {
						return SXERR_ABORT;
					}
				}
			}
		}
	}
	return SXRET_OK;
}

static int sprintfConsumer(php_context* pCtx,const char* zInput,int nLen,void* pUserData)
{

	php_result_string(pCtx,zInput,nLen);
	SXUNUSED(pUserData);
	return PHP_OK;
}

static int PHP_builtin_sprintf(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	PHP_InputFormat(sprintfConsumer,pCtx,zFormat,nLen,nArg,apArg,0,FALSE);
	return PHP_OK;
}

static int printfConsumer(php_context* pCtx,const char* zInput,int nLen,void* pUserData)
{
	php_int64* pCounter = (php_int64*)pUserData;

	php_context_output(pCtx,zInput,nLen);

	*pCounter += nLen;
	return PHP_OK;
}

static int PHP_builtin_printf(php_context* pCtx,int nArg,php_value** apArg)
{
	php_int64 nCounter = 0;
	const char* zFormat; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	PHP_InputFormat(printfConsumer,pCtx,zFormat,nLen,nArg,apArg,(void*)&nCounter,FALSE);

	php_result_int64(pCtx,nCounter);
	return PHP_OK;
}

static int PHP_builtin_vprintf(php_context* pCtx,int nArg,php_value** apArg)
{
	php_int64 nCounter = 0;
	const char* zFormat;
	php_hashmap* pMap;
	SySet sArg; int nLen,n;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_array(apArg[1])) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[1]->x.pOther;

	n = PHP_HashmapValuesToSet(pMap,&sArg);

	PHP_InputFormat(printfConsumer,pCtx,zFormat,nLen,n,(php_value**)SySetBasePtr(&sArg),(void*)&nCounter,TRUE);

	php_result_int64(pCtx,nCounter);

	SySetRelease(&sArg);
	return PHP_OK;
}

static int PHP_builtin_vsprintf(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat;
	php_hashmap* pMap;
	SySet sArg; int nLen,n;
	if (nArg < 2 || !php_value_is_string(apArg[0]) || !php_value_is_array(apArg[1])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	pMap = (php_hashmap*)apArg[1]->x.pOther;

	n = PHP_HashmapValuesToSet(pMap,&sArg);

	PHP_InputFormat(sprintfConsumer,pCtx,zFormat,nLen,n,(php_value**)SySetBasePtr(&sArg),0,TRUE);

	SySetRelease(&sArg);
	return PHP_OK;
}

static int PHP_builtin_size_format(php_context* pCtx,int nArg,php_value** apArg)
{

	static const char zUnit[] = { "KMGTPEZ" };
	sxi32 nRest,i_32;
	php_int64 iSize; int c = -1;

	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	iSize = php_value_to_int64(apArg[0]);
	if (iSize < 100 ) {

		php_result_string(pCtx,"0.1 KB",(int)sizeof("0.1 KB") - 1);
		return PHP_OK;
	}
	for (;;) {
		nRest = (sxi32)(iSize & 0x3FF);
		iSize >>= 10;
		c++;
		if ((iSize & (~0 ^ 1023)) == 0) {
			break;
		}
	}
	nRest /= 100;
	if (nRest > 9) {
		nRest = 9;
	}
	if (iSize > 999) {
		c++;
		nRest = 9;
		iSize = 0;
	}
	i_32 = (sxi32)iSize;

	php_result_string_format(pCtx,"%d.%d %cB",i_32,nRest,zUnit[c]);
	return PHP_OK;
}
#if !defined(PHP_DISABLE_HASH_FUNC)

static int PHP_builtin_md5(php_context* pCtx,int nArg,php_value** apArg)
{
	unsigned char zDigest[16]; int raw_output = FALSE;
	const void* pIn; int nLen;
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	pIn = (const void*)php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	if (nArg > 1 && php_value_is_bool(apArg[1])) {
		raw_output = php_value_to_bool(apArg[1]);
	}

	SyMD5Compute(pIn,(sxu32)nLen,zDigest);
	if (raw_output) {

		php_result_string(pCtx,(const char*)zDigest,(int)sizeof(zDigest));
	}
	else {

		SyBinToHexConsumer((const void*)zDigest,sizeof(zDigest),HashConsumer,pCtx);
	}
	return PHP_OK;
}

static int PHP_builtin_sha1(php_context* pCtx,int nArg,php_value** apArg)
{
	unsigned char zDigest[20]; int raw_output = FALSE;
	const void* pIn; int nLen;
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	pIn = (const void*)php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	if (nArg > 1 && php_value_is_bool(apArg[1])) {
		raw_output = php_value_to_bool(apArg[1]);
	}

	SySha1Compute(pIn,(sxu32)nLen,zDigest);
	if (raw_output) {

		php_result_string(pCtx,(const char*)zDigest,(int)sizeof(zDigest));
	}
	else {

		SyBinToHexConsumer((const void*)zDigest,sizeof(zDigest),HashConsumer,pCtx);
	}
	return PHP_OK;
}

static int PHP_builtin_crc32(php_context* pCtx,int nArg,php_value** apArg)
{
	const void* pIn;
	sxu32 nCRC; int nLen;
	if (nArg < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	pIn = (const void*)php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	nCRC = SyCrc32(pIn,(sxu32)nLen);

	php_result_int64(pCtx,(php_int64)nCRC ^ 0xFFFFFFFF);
	return PHP_OK;
}
#endif

PHP_PRIVATE sxi32 PHP_ProcessCsv(
	const char* zInput,
	int nByte,
	int delim,
	int encl,
	int escape,
	sxi32(*xConsumer)(const char*,int,void*),
	void* pUserData
)
{
	const char* zEnd = &zInput[nByte];
	const char* zIn = zInput;
	const char* zPtr; int isEnc;

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		isEnc = 0;
		zPtr = zIn;

		while (zIn < zEnd) {
			if (zIn[0] == delim && !isEnc) {

				break;
			}
			else if (zIn[0] == encl) {

				isEnc = !isEnc;
			}
			else if (zIn[0] == escape) {

				zIn++;
			}

			zIn++;
		}
		if (zIn > zPtr) {
			int nByte = (int)(zIn - zPtr);
			sxi32 rc;

			if (zPtr[0] == encl) {
				zPtr++;
				nByte -= 2;
			}
			if (nByte > 0) {
				rc = xConsumer(zPtr,nByte,pUserData);
				if (rc == SXERR_ABORT) {

					break;
				}
			}
		}

		while (zIn < zEnd && zIn[0] == delim) {
			zIn++;
		}
	}
	return SXRET_OK;
}

PHP_PRIVATE sxi32 PHP_CsvConsumer(const char* zToken,int nTokenLen,void* pUserData)
{
	php_value* pArray = (php_value*)pUserData;
	php_value sEntry;
	SyString sToken;

	SyStringInitFromBuf(&sToken,zToken,nTokenLen);

	SyStringFullTrimSafe(&sToken);
	if (sToken.nByte < 1) {
		return SXRET_OK;
	}
	PHP_MemObjInitFromString(pArray->pVm,&sEntry,&sToken);
	php_array_add_elem(pArray,0,&sEntry);
	PHP_MemObjRelease(&sEntry);
	return SXRET_OK;
}

static int PHP_builtin_str_getcsv(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zInput,* zPtr;
	php_value* pArray; int delim = ','; int encl = '"'; int escape = '\\'; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	zInput = php_value_to_string(apArg[0],&nLen);
	if (nArg > 1) {
		int i;
		if (php_value_is_string(apArg[1])) {

			zPtr = php_value_to_string(apArg[1],&i);
			if (i > 0) {
				delim = zPtr[0];
			}
		}
		if (nArg > 2) {
			if (php_value_is_string(apArg[2])) {

				zPtr = php_value_to_string(apArg[2],&i);
				if (i > 0) {
					encl = zPtr[0];
				}
			}
			if (nArg > 3) {
				if (php_value_is_string(apArg[3])) {

					zPtr = php_value_to_string(apArg[3],&i);
					if (i > 0) {
						escape = zPtr[0];
					}
				}
			}
		}
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {
		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");
		php_result_null(pCtx);
		return PHP_OK;
	}

	PHP_ProcessCsv(zInput,nLen,delim,encl,escape,PHP_CsvConsumer,pArray);

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static sxi32 AddTag(SySet* pSet,const char* zTag,int nByte)
{
	const char* zEnd = &zTag[nByte];
	const char* zPtr;
	SyString sEntry;

	for (;;) {
		while (zTag < zEnd && (zTag[0] == '<' || zTag[0] == '/' || zTag[0] == '?'
			|| zTag[0] == '!' || zTag[0] == '-' || ((unsigned char)zTag[0] < 0xc0 && SyisSpace(zTag[0])))) {
			zTag++;
		}
		if (zTag >= zEnd) {
			break;
		}
		zPtr = zTag;

		while (zTag < zEnd) {
			if ((unsigned char)zTag[0] >= 0xc0) {

				zTag++;
				SX_JMP_UTF8(zTag,zEnd);
			}
			else if (!SyisAlphaNum(zTag[0])) {
				break;
			}
			else {
				zTag++;
			}
		}
		if (zTag > zPtr) {

			SyStringInitFromBuf(&sEntry,zPtr,(int)(zTag - zPtr));
			SyStringFullTrim(&sEntry);
			SySetPut(pSet,(const void*)&sEntry);
		}

		zTag++;
	}
	return SXRET_OK;
}

static sxi32 FindTag(SySet* pSet,const char* zTag,int nByte)
{
	if (SySetUsed(pSet) > 0) {
		const char* zCur,* zEnd = &zTag[nByte];
		SyString sTag;
		while (zTag < zEnd && (zTag[0] == '<' || zTag[0] == '/' || zTag[0] == '?' ||
			((unsigned char)zTag[0] < 0xc0 && SyisSpace(zTag[0])))) {
			zTag++;
		}

		zCur = zTag;
		while (zTag < zEnd) {
			if ((unsigned char)zTag[0] >= 0xc0) {

				zTag++;
				SX_JMP_UTF8(zTag,zEnd);
			}
			else if (!SyisAlphaNum(zTag[0])) {
				break;
			}
			else {
				zTag++;
			}
		}
		SyStringInitFromBuf(&sTag,zCur,zTag - zCur);

		SyStringLeftTrimSafe(&sTag);
		if (sTag.nByte > 0) {
			SyString* aEntry,* pEntry;
			sxi32 rc;
			sxu32 n;

			aEntry = (SyString*)SySetBasePtr(pSet);
			for (n = 0; n < SySetUsed(pSet); ++n) {
				pEntry = &aEntry[n];

				rc = SyStringCmp(pEntry,&sTag,SyStrnicmp);
				if (!rc) {
					return SXRET_OK;
				}
			}
		}
	}

	return SXERR_NOTFOUND;
}

PHP_PRIVATE sxi32 PHP_StripTagsFromString(php_context* pCtx,const char* zIn,int nByte,const char* zTaglist,int nTaglen)
{
	const char* zEnd = &zIn[nByte];
	const char* zPtr,* zTag;
	SySet sSet;

	SySetInit(&sSet,&pCtx->pVm->sAllocator,sizeof(SyString));
	if (nTaglen > 0) {

		AddTag(&sSet,zTaglist,nTaglen);
	}

	php_result_string(pCtx,"",0);

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		zPtr = zIn;

		while (zIn < zEnd && zIn[0] != '<' && zIn[0] != 0 ) {
			zIn++;
		}
		if (zIn > zPtr) {

			php_result_string(pCtx,zPtr,(int)(zIn - zPtr));
		}

		while (zIn < zEnd && zIn[0] == 0) {
			zIn++;
		}
		if (zIn >= zEnd) {

			break;
		}
		if (zIn[0] == '<') {
			sxi32 rc;
			zTag = zIn++;

			while (zIn < zEnd && zIn[0] != '>') {
				zIn++;
			}
			if (zIn < zEnd) {
				zIn++;
			}

			rc = FindTag(&sSet,zTag,(int)(zIn - zTag));
			if (rc == SXRET_OK) {

				php_result_string(pCtx,zTag,(int)(zIn - zTag));
			}
		}
	}

	SySetRelease(&sSet);
	return SXRET_OK;
}

static int PHP_builtin_strip_tags(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zTaglist = 0;
	const char* zString; int nTaglen = 0; int nLen;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nArg > 1 && php_value_is_string(apArg[1])) {

		zTaglist = php_value_to_string(apArg[1],&nTaglen);
	}

	PHP_StripTagsFromString(pCtx,zString,nLen,zTaglist,nTaglen);
	return PHP_OK;
}

static int PHP_builtin_str_shuffle(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString; int nLen,i,c;
	sxu32 iR;
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	for (i = 0; i < nLen; ++i) {

		iR = php_context_random_num(pCtx);

		c = zString[iR % nLen];

		php_result_string(pCtx,(const char*)&c,(int)sizeof(char));
	}
	return PHP_OK;
}

static int PHP_builtin_str_split(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zEnd;
	php_value* pArray,* pValue; int split_len; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	split_len = (int)sizeof(char);
	if (nArg > 1) {

		split_len = php_value_to_int(apArg[1]);
		if (split_len < 1) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
		if (split_len > nLen) {
			split_len = nLen;
		}
	}

	pArray = php_context_new_array(pCtx);

	pValue = php_context_new_scalar(pCtx);
	if (pValue == 0 || pArray == 0) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zEnd = &zString[nLen];

	for (;;) {
		int nMax;
		if (zString >= zEnd) {

			break;
		}
		nMax = (int)(zEnd - zString);
		if (nMax < split_len) {
			split_len = nMax;
		}

		php_value_string(pValue,zString,split_len);

		php_array_add_elem(pArray,0,pValue);

		php_value_reset_string_cursor(pValue);

		zString += split_len;
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static sxi32 ExtractNonSpaceToken(const char** pzIn,const char* zEnd,SyString* pOut)
{
	const char* zIn = *pzIn;
	const char* zPtr;

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
		zIn++;
	}
	if (zIn >= zEnd) {

		return SXERR_EOF;
	}
	zPtr = zIn;

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && !SyisSpace(zIn[0])) {
		zIn++;
	}
	SyStringInitFromBuf(pOut,zPtr,zIn - zPtr);

	*pzIn = zIn;

	return SXRET_OK;
}

static int LongestStringMask(const char* zString,int nLen,const char* zMask,int nMaskLen)
{
	const char* zEnd = &zString[nLen];
	const char* zIn = zString; int i,c;
	for (;;) {
		if (zString >= zEnd) {
			break;
		}

		c = zString[0];

		for (i = 0; i < nMaskLen; i++) {
			if (c == zMask[i]) {

				break;
			}
		}
		if (i >= nMaskLen) {

			break;
		}

		zString++;
	}

	return (int)(zString - zIn);
}

static int LongestStringMask2(const char* zString,int nLen,const char* zMask,int nMaskLen)
{
	const char* zEnd = &zString[nLen];
	const char* zIn = zString; int i,c;
	for (;;) {
		if (zString >= zEnd) {
			break;
		}

		c = zString[0];

		for (i = 0; i < nMaskLen; i++) {
			if (c == zMask[i]) {
				break;
			}
		}
		if (i < nMaskLen) {

			break;
		}

		zString++;
	}

	return (int)(zString - zIn);
}

static int PHP_builtin_strspn(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zMask,* zEnd; int iMasklen,iLen;
	SyString sToken; int iCount = 0; int rc;
	if (nArg < 2) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&iLen);

	zMask = php_value_to_string(apArg[1],&iMasklen);
	if (iLen < 1 || iMasklen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (nArg > 2) {
		int nOfft;

		nOfft = php_value_to_int(apArg[2]);
		if (nOfft < 0) {
			const char* zBase = &zString[iLen + nOfft];
			if (zBase > zString) {
				iLen = (int)(&zString[iLen] - zBase);
				zString = zBase;
			}
			else {

				php_result_int(pCtx,0);
				return PHP_OK;
			}
		}
		else {
			if (nOfft >= iLen) {

				php_result_int(pCtx,0);
				return PHP_OK;
			}
			else {

				zString += nOfft;
				iLen -= nOfft;
			}
		}
		if (nArg > 3) {
			int iUserlen;

			iUserlen = php_value_to_int(apArg[3]);
			if (iUserlen > 0 && iUserlen < iLen) {
				iLen = iUserlen;
			}
		}
	}

	zEnd = &zString[iLen];

	rc = ExtractNonSpaceToken(&zString,zEnd,&sToken);
	if (rc == SXRET_OK && sToken.nByte > 0) {

		iCount = LongestStringMask(sToken.zString,(int)sToken.nByte,zMask,iMasklen);
	}

	php_result_int(pCtx,iCount);
	return PHP_OK;
}

static int PHP_builtin_strcspn(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zMask,* zEnd; int iMasklen,iLen;
	SyString sToken; int iCount = 0; int rc;
	if (nArg < 2) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&iLen);

	zMask = php_value_to_string(apArg[1],&iMasklen);
	if (iLen < 1) {

		php_result_int(pCtx,0);
		return PHP_OK;
	}
	if (iMasklen < 1) {

		php_result_int(pCtx,iLen);
		return PHP_OK;
	}
	if (nArg > 2) {
		int nOfft;

		nOfft = php_value_to_int(apArg[2]);
		if (nOfft < 0) {
			const char* zBase = &zString[iLen + nOfft];
			if (zBase > zString) {
				iLen = (int)(&zString[iLen] - zBase);
				zString = zBase;
			}
			else {

				php_result_int(pCtx,0);
				return PHP_OK;
			}
		}
		else {
			if (nOfft >= iLen) {

				php_result_int(pCtx,0);
				return PHP_OK;
			}
			else {

				zString += nOfft;
				iLen -= nOfft;
			}
		}
		if (nArg > 3) {
			int iUserlen;

			iUserlen = php_value_to_int(apArg[3]);
			if (iUserlen > 0 && iUserlen < iLen) {
				iLen = iUserlen;
			}
		}
	}

	zEnd = &zString[iLen];

	rc = ExtractNonSpaceToken(&zString,zEnd,&sToken);
	if (rc == SXRET_OK && sToken.nByte > 0) {

		iCount = LongestStringMask2(sToken.zString,(int)sToken.nByte,zMask,iMasklen);
	}

	php_result_int(pCtx,iCount);
	return PHP_OK;
}

static int PHP_builtin_strpbrk(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zString,* zList,* zEnd; int iLen,iListLen,i,c;
	sxu32 nOfft,nMax;
	sxi32 rc;
	if (nArg < 2) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zString = php_value_to_string(apArg[0],&iLen);
	zList = php_value_to_string(apArg[1],&iListLen);
	if (iLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zEnd = &zString[iLen];
	nOfft = nMax = SXU32_HIGH;

	for (i = 0; i < iListLen; i++) {
		c = zList[i];
		rc = SyByteFind(zString,(sxu32)iLen,c,&nMax);
		if (rc == SXRET_OK) {
			if (nMax < nOfft) {
				nOfft = nMax;
			}
		}
	}
	if (nOfft == SXU32_HIGH) {

		php_result_bool(pCtx,0);
	}
	else {

		php_result_string(pCtx,&zString[nOfft],(int)(zEnd - &zString[nOfft]));
	}
	return PHP_OK;
}

static int PHP_builtin_soundex(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn;
	char zResult[8]; int i,j;
	static const unsigned char iCode[] = {
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		0,0,1,2,3,0,1,2,0,0,2,2,4,5,5,0,
		1,2,6,2,3,0,1,0,2,0,2,0,0,0,0,0,
		0,0,1,2,3,0,1,2,0,0,2,2,4,5,5,0,
		1,2,6,2,3,0,1,0,2,0,2,0,0,0,0,0,
	};
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}
	zIn = (unsigned char*)php_value_to_string(apArg[0],0);
	for (i = 0; zIn[i] && zIn[i] < 0xc0 && !SyisAlpha(zIn[i]); i++) {}
	if (zIn[i]) {
		unsigned char prevcode = iCode[zIn[i] & 0x7f];
		zResult[0] = (char)SyToUpper(zIn[i]);
		for (j = 1; j < 4 && zIn[i]; i++) {
			int code = iCode[zIn[i] & 0x7f];
			if (code > 0) {
				if (code != prevcode) {
					prevcode = (unsigned char)code;
					zResult[j++] = (char)code + '0';
				}
			}
			else {
				prevcode = 0;
			}
		}
		while (j < 4) {
			zResult[j++] = '0';
		}
		php_result_string(pCtx,zResult,4);
	}
	else {
		php_result_string(pCtx,"?000",4);
	}
	return PHP_OK;
}

static int PHP_builtin_wordwrap(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn,* zEnd,* zBreak; int iLen,iBreaklen,iChunk;
	if (nArg < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&iLen);
	if (iLen < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	iChunk = 75;
	iBreaklen = 0;
	zBreak = "";
	if (nArg > 1) {
		iChunk = php_value_to_int(apArg[1]);
		if (iChunk < 1) {
			iChunk = 75;
		}
		if (nArg > 2) {
			zBreak = php_value_to_string(apArg[2],&iBreaklen);
		}
	}
	if (iBreaklen < 1) {

#ifdef __WINNT__
		zBreak = "\r\n";
		iBreaklen = (int)sizeof("\r\n") - 1;
#else
		zBreak = "\n";
		iBreaklen = (int)sizeof(char);
#endif
	}

	zEnd = &zIn[iLen];
	for (;;) {
		int nMax;
		if (zIn >= zEnd) {

			break;
		}
		nMax = (int)(zEnd - zIn);
		if (iChunk > nMax) {
			iChunk = nMax;
		}

		php_result_string(pCtx,zIn,iChunk);

		zIn += iChunk;
		if (zIn < zEnd) {

			php_result_string(pCtx,zBreak,iBreaklen);
		}
	}
	return PHP_OK;
}

static int CheckMask(int c,const char* zMask,int nMasklen,int* pOfft)
{
	int i;
	for (i = 0; i < nMasklen; ++i) {
		if (c == zMask[i]) {
			if (pOfft) {
				*pOfft = i;
			}
			return TRUE;
		}
	}
	return FALSE;
}

static sxi32 ExtractToken(const char** pzIn,const char* zEnd,const char* zMask,int nMasklen,SyString* pOut)
{
	const char* zIn = *pzIn;
	const char* zPtr;

	while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && CheckMask(zIn[0],zMask,nMasklen,0)) {
		zIn++;
	}
	if (zIn >= zEnd) {

		return SXERR_EOF;
	}
	zPtr = zIn;

	while (zIn < zEnd) {
		if ((unsigned char)zIn[0] >= 0xc0) {

			zIn++;
			SX_JMP_UTF8(zIn,zEnd);
		}
		else {
			if (CheckMask(zIn[0],zMask,nMasklen,0)) {
				break;
			}
			zIn++;
		}
	}
	SyStringInitFromBuf(pOut,zPtr,zIn - zPtr);

	*pzIn = zIn;

	return SXRET_OK;
}

typedef struct strtok_aux_data strtok_aux_data;
struct strtok_aux_data
{
	const char* zDup;
	const char* zIn;
	const char* zEnd;
};

static int PHP_builtin_strtok(php_context* pCtx,int nArg,php_value** apArg)
{
	strtok_aux_data* pAux;
	const char* zMask;
	SyString sToken; int nMasklen;
	sxi32 rc;
	if (nArg < 2) {

		pAux = (strtok_aux_data*)php_context_peek_aux_data(pCtx);
		if (pAux == 0) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
		nMasklen = 0;
		zMask = "";
		if (nArg > 0) {

			zMask = php_value_to_string(apArg[0],&nMasklen);
		}
		if (nMasklen < 1) {

			php_context_free_chunk(pCtx,(void*)pAux->zDup);
			php_context_free_chunk(pCtx,pAux);
			(void)php_context_pop_aux_data(pCtx);
			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		rc = ExtractToken(&pAux->zIn,pAux->zEnd,zMask,nMasklen,&sToken);
		if (rc != SXRET_OK) {

			php_context_free_chunk(pCtx,(void*)pAux->zDup);
			php_context_free_chunk(pCtx,pAux);
			(void)php_context_pop_aux_data(pCtx);
			php_result_bool(pCtx,0);
		}
		else {

			php_result_string(pCtx,sToken.zString,(int)sToken.nByte);
		}
	}
	else {
		const char* zInput,* zCur;
		char* zDup; int nLen;

		zCur = zInput = php_value_to_string(apArg[0],&nLen);
		if (nLen < 1) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}

		zMask = php_value_to_string(apArg[1],&nMasklen);
		if (nMasklen < 1) {

#define TOK_MASK " \n\t\r\f"
			zMask = TOK_MASK;
			nMasklen = (int)sizeof(TOK_MASK) - 1;
#undef TOK_MASK
		}

		rc = ExtractToken(&zInput,&zInput[nLen],zMask,nMasklen,&sToken);
		if (rc != SXRET_OK) {

			php_result_bool(pCtx,0);
			return PHP_OK;
		}
		else {

			php_result_string(pCtx,sToken.zString,(int)sToken.nByte);
		}

		pAux = (strtok_aux_data*)php_context_alloc_chunk(pCtx,sizeof(strtok_aux_data),TRUE,FALSE);
		if (pAux) {
			nLen -= (int)(zInput - zCur);
			if (nLen < 1) {
				php_context_free_chunk(pCtx,pAux);
				return PHP_OK;
			}

			zDup = (char*)php_context_alloc_chunk(pCtx,(unsigned int)(nLen + 1),TRUE,FALSE);
			if (zDup) {
				SyMemcpy(zInput,zDup,(sxu32)nLen);

				pAux->zDup = pAux->zIn = zDup;
				pAux->zEnd = &zDup[nLen];
				php_context_push_aux_data(pCtx,pAux);
			}
		}
	}
	return PHP_OK;
}

static int PHP_builtin_str_pad(php_context* pCtx,int nArg,php_value** apArg)
{
	int iLen,iPadlen,iType,i,iDiv,iStrpad,iRealPad,jPad;
	const char* zIn,* zPad;
	if (nArg < 2) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&iLen);

	iRealPad = iPadlen = php_value_to_int(apArg[1]);
	if (iPadlen > 0) {
		iPadlen -= iLen;
	}
	if (iPadlen < 1) {

		php_result_string(pCtx,zIn,iLen);
		return PHP_OK;
	}
	zPad = " ";
	iStrpad = (int)sizeof(char);
	iType = 1;
	if (nArg > 2) {

		zPad = php_value_to_string(apArg[2],&iStrpad);
		if (iStrpad < 1) {

			zPad = " ";
			iStrpad = (int)sizeof(char);
		}
		if (nArg > 3) {

			iType = php_value_to_int(apArg[3]);
			if (iType != 0  && iType != 2 ) {
				iType = 1;
			}
		}
	}
	iDiv = 1;
	if (iType == 2) {
		iDiv = 2;
	}

	if (iType == 0  || iType == 2 ) {
		jPad = iStrpad;
		for (i = 0; i < iPadlen / iDiv; i += jPad) {

			if ((int)php_context_result_buf_length(pCtx) + iLen + jPad >= iRealPad) {
				break;
			}
			php_result_string(pCtx,zPad,jPad);
		}
		if (iType == 0 ) {
			while ((int)php_context_result_buf_length(pCtx) + iLen < iRealPad) {
				jPad = iRealPad - (iLen + (int)php_context_result_buf_length(pCtx));
				if (jPad > iStrpad) {
					jPad = iStrpad;
				}
				if (jPad < 1) {
					break;
				}
				php_result_string(pCtx,zPad,jPad);
			}
		}
	}
	if (iLen > 0) {

		php_result_string(pCtx,zIn,iLen);
	}
	if (iType == 1  || iType == 2 ) {
		for (i = 0; i < iPadlen / iDiv; i += iStrpad) {

			if ((int)php_context_result_buf_length(pCtx) + iStrpad >= iRealPad) {
				break;
			}
			php_result_string(pCtx,zPad,iStrpad);
		}
		while ((int)php_context_result_buf_length(pCtx) < iRealPad) {
			jPad = iRealPad - (int)php_context_result_buf_length(pCtx);
			if (jPad > iStrpad) {
				jPad = iStrpad;
			}
			if (jPad < 1) {
				break;
			}
			php_result_string(pCtx,zPad,jPad);
		}
	}
	return PHP_OK;
}

typedef struct str_replace_data str_replace_data;
struct str_replace_data
{

	SyBlob* pWorker;
	ProcStringMatch xMatch;

	SySet* pCollector;
	php_context* pCtx;
};

#define STRDEL(SRC,SLEN,OFFT,ILEN){\
			for(;;){\
				if( OFFT + ILEN >= SLEN ) break; SRC[OFFT] = SRC[OFFT+ILEN]; ++OFFT;\
			}\
		}

#define SHIFTRANDINSERT(SRC,LEN,OFFT,ENTRY,ELEN){\
			sxu32 INLEN = LEN - OFFT;\
			for(;;){\
				if( LEN > 0 ){ LEN--; } if(INLEN < 1 ) break; SRC[LEN + ELEN] = SRC[LEN] ; --INLEN; \
			}\
			for(;;){\
				if(ELEN < 1)break; SRC[OFFT] = ENTRY[0]; OFFT++; ENTRY++; --ELEN;\
			}\
		}

static int StringReplace(SyBlob* pWorker,sxu32 nOfft,int nLen,const char* zReplace,int nReplen)
{
	char* zInput = (char*)SyBlobData(pWorker);
	sxu32 n,m;
	n = SyBlobLength(pWorker);
	m = nOfft;

	STRDEL(zInput,n,m,nLen);
	SyBlobLength(pWorker) -= nLen;
	if (nReplen > 0) {
		sxi32 iRep = nReplen;
		sxi32 rc;

		rc = SyBlobAppend(pWorker,0,(sxu32)nReplen);
		if (rc != SXRET_OK) {

			return SXRET_OK;
		}

		zInput = (char*)SyBlobData(pWorker);
		n = SyBlobLength(pWorker);
		SHIFTRANDINSERT(zInput,n,nOfft,zReplace,iRep);
		SyBlobLength(pWorker) += nReplen;
	}
	return SXRET_OK;
}

static int StringReplaceWalker(php_value* pKey,php_value* pData,void* pUserData)
{
	str_replace_data* pRepData = (str_replace_data*)pUserData;
	const char* zTarget,* zReplace;
	SyBlob* pWorker; int tLen,nLen;
	sxu32 nOfft;
	sxi32 rc;

	pWorker = pRepData->pWorker;
	if (!php_value_is_string(pKey)) {

		return PHP_OK;
	}

	zTarget = php_value_to_string(pKey,&tLen);
	if (tLen < 1) {

		return PHP_OK;
	}

	rc = pRepData->xMatch(SyBlobData(pWorker),SyBlobLength(pWorker),(const void*)zTarget,(sxu32)tLen,&nOfft);
	if (rc != SXRET_OK) {

		return PHP_OK;
	}

	zReplace = php_value_to_string(pData,&nLen);

	StringReplace(pWorker,nOfft,tLen,zReplace,nLen);

	return PHP_OK;
}

static int StrReplaceWalker(php_value* pKey,php_value* pData,void* pUserData)
{
	str_replace_data* pRep = (str_replace_data*)pUserData;
	SyString sWorker;
	const char* zIn; int nByte;

	zIn = php_value_to_string(pData,&nByte);
	SyStringInitFromBuf(&sWorker,0,0);
	if (nByte > 0) {
		char* zDup;

		zDup = (char*)php_context_alloc_chunk(pRep->pCtx,(unsigned int)nByte,FALSE,
			TRUE
		);
		if (zDup == 0) {

			php_context_throw_error(pRep->pCtx,PHP_CTX_ERR,"PHP is running out of memory");
			return PHP_OK;
		}
		SyMemcpy(zIn,zDup,(sxu32)nByte);

		SyStringInitFromBuf(&sWorker,zDup,nByte);
	}

	SySetPut(pRep->pCollector,(const void*)&sWorker);

	SXUNUSED(pKey);
	return PHP_OK;
}

static int PHP_builtin_str_replace(php_context* pCtx,int nArg,php_value** apArg)
{
	SyString sTemp,* pSearch,* pReplace;
	ProcStringMatch xMatch;
	const char* zIn,* zFunc;
	str_replace_data sRep;
	SyBlob sWorker;
	SySet sReplace;
	SySet sSearch; int rep_str; int nByte;
	sxi32 rc;
	if (nArg < 3) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	SySetInit(&sSearch,&pCtx->pVm->sAllocator,sizeof(SyString));
	SySetInit(&sReplace,&pCtx->pVm->sAllocator,sizeof(SyString));
	SyBlobInit(&sWorker,&pCtx->pVm->sAllocator);
	SyZero(&sRep,sizeof(str_replace_data));
	sRep.pCtx = pCtx;
	sRep.pCollector = &sSearch;
	rep_str = 0;

	zIn = php_value_to_string(apArg[2],&nByte);
	if (nByte < 1) {

		php_result_string(pCtx,"",0);
		return PHP_OK;
	}

	SyBlobAppend(&sWorker,(const void*)zIn,(sxu32)nByte);

	if (php_value_is_array(apArg[0])) {

		php_array_walk(apArg[0],StrReplaceWalker,&sRep);
	}
	else {

		zIn = php_value_to_string(apArg[0],&nByte);
		if (nByte < 1) {

			php_result_value(pCtx,apArg[2]);
			return PHP_OK;
		}
		SyStringInitFromBuf(&sTemp,zIn,nByte);

		SySetPut(&sSearch,(const void*)&sTemp);
	}

	if (php_value_is_array(apArg[1])) {

		sRep.pCollector = &sReplace;
		php_array_walk(apArg[1],StrReplaceWalker,&sRep);
	}
	else {

		zIn = php_value_to_string(apArg[1],&nByte);
		rep_str = 1;
		SyStringInitFromBuf(&sTemp,zIn,nByte);

		SySetPut(&sReplace,(const void*)&sTemp);
	}

	SySetResetCursor(&sSearch);
	SySetResetCursor(&sReplace);
	pReplace = pSearch = 0;
	SyStringInitFromBuf(&sTemp,"",0);

	zFunc = php_function_name(pCtx);

	xMatch = SyBlobSearch;
	if (SyStrncmp(zFunc,"str_ireplace",sizeof("str_ireplace") - 1) == 0) {

		xMatch = iPatternMatch;
	}

	while (SXRET_OK == SySetGetNextEntry(&sSearch,(void**)&pSearch)) {
		sxu32 nCount,nOfft;
		if (pSearch->nByte < 1) {

			continue;
		}

		if (rep_str) {
			pReplace = (SyString*)SySetPeek(&sReplace);
		}
		else {
			if (SXRET_OK != SySetGetNextEntry(&sReplace,(void**)&pReplace)) {

				pReplace = 0;
			}
		}
		if (pReplace == 0) {

			pReplace = &sTemp;
		}
		nOfft = nCount = 0;
		for (;;) {
			if (nCount >= SyBlobLength(&sWorker)) {
				break;
			}

			rc = xMatch(SyBlobDataAt(&sWorker,nCount),SyBlobLength(&sWorker) - nCount,(const void*)pSearch->zString,
				pSearch->nByte,&nOfft);
			if (rc != SXRET_OK) {

				break;
			}

			StringReplace(&sWorker,nCount + nOfft,(int)pSearch->nByte,pReplace->zString,(int)pReplace->nByte);

			nCount += nOfft + pReplace->nByte;
		}
	}

	php_result_string(pCtx,(const char*)SyBlobData(&sWorker),(int)SyBlobLength(&sWorker));
	SySetRelease(&sSearch);
	SySetRelease(&sReplace);
	SyBlobRelease(&sWorker);
	return PHP_OK;
}

static int PHP_builtin_strtr(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1 || nArg < 2) {

		php_result_string(pCtx,zIn,nLen);
		return PHP_OK;
	}
	if (nArg == 2 && php_value_is_array(apArg[1])) {
		str_replace_data sRepData;
		SyBlob sWorker;

		SyBlobInit(&sWorker,&pCtx->pVm->sAllocator);

		SyBlobAppend(&sWorker,(const void*)zIn,(sxu32)nLen);

		sRepData.pWorker = &sWorker;
		sRepData.xMatch = SyBlobSearch;

		php_array_walk(apArg[1],StringReplaceWalker,&sRepData);

		php_result_string(pCtx,(const char*)SyBlobData(&sWorker),
			(int)SyBlobLength(&sWorker));

		SyBlobRelease(&sWorker);
	}
	else {
		int i,flen,tlen,c,iOfft;
		const char* zFrom,* zTo;
		if (nArg < 3) {

			php_result_string(pCtx,zIn,nLen);
			return PHP_OK;
		}

		zFrom = php_value_to_string(apArg[1],&flen);
		zTo = php_value_to_string(apArg[2],&tlen);
		if (flen < 1 || tlen < 1) {

			php_result_string(pCtx,zIn,nLen);
			return PHP_OK;
		}

		for (i = 0; i < nLen; ++i) {
			c = zIn[i];
			if (CheckMask(c,zFrom,flen,&iOfft)) {
				if (iOfft < tlen) {
					c = zTo[iOfft];
				}
			}
			php_result_string(pCtx,(const char*)&c,(int)sizeof(char));

		}
	}
	return PHP_OK;
}

PHP_PRIVATE sxi32 PHP_ParseIniString(php_context* pCtx,const char* zIn,sxu32 nByte,int bProcessSection)
{
	php_value* pCur,* pArray,* pSection,* pWorker,* pValue;
	const char* zCur,* zEnd = &zIn[nByte];
	SyHashEntry* pEntry;
	SyString sEntry;
	SyHash sHash; int c;

	pArray = php_context_new_array(pCtx);
	pWorker = php_context_new_scalar(pCtx);
	pValue = php_context_new_scalar(pCtx);
	if (pArray == 0 || pWorker == 0 || pValue == 0) {

		php_context_throw_error(pCtx,PHP_CTX_ERR,"PHP is running out of memory");

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	SyHashInit(&sHash,&pCtx->pVm->sAllocator,0,0);
	pCur = pArray;

	for (;;) {

		while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
			zIn++;
		}
		if (zIn >= zEnd) {

			break;
		}
		if (zIn[0] == ';' || zIn[0] == '#') {

			zIn++;
			while (zIn < zEnd && zIn[0] != '\n') {
				zIn++;
			}
			continue;
		}

		php_value_reset_string_cursor(pWorker);
		if (zIn[0] == '[') {

			zIn++;
			zCur = zIn;
			while (zIn < zEnd && zIn[0] != ']') {
				zIn++;
			}
			if (zIn > zCur && bProcessSection) {

				SyStringInitFromBuf(&sEntry,zCur,(int)(zIn - zCur));
				SyStringFullTrim(&sEntry);
				php_value_string(pWorker,sEntry.zString,(int)sEntry.nByte);
				if (sEntry.nByte > 0) {

					pSection = php_context_new_array(pCtx);
					if (pSection) {
						php_array_add_elem(pArray,pWorker,pSection);
						pCur = pSection;
					}
				}
			}
			zIn++;
		}
		else {
			php_value* pOldCur; int is_array; int iLen;

			is_array = 0;
			zCur = zIn;
			iLen = 0;
			pOldCur = pCur;
			while (zIn < zEnd && zIn[0] != '=') {
				if (zIn[0] == '[' && !is_array) {

					iLen = (int)(zIn - zCur);
					is_array = 1;
					if (iLen > 0) {
						php_value* pvArr = 0;

						SyStringInitFromBuf(&sEntry,zCur,iLen);
						SyStringFullTrim(&sEntry);
						pEntry = SyHashGet(&sHash,(const void*)sEntry.zString,sEntry.nByte);
						if (pEntry) {
							pvArr = (php_value*)SyHashEntryGetUserData(pEntry);
						}
						else {

							pvArr = php_context_new_array(pCtx);
							if (pvArr) {

								SyHashInsert(&sHash,(const void*)sEntry.zString,sEntry.nByte,pvArr);

								php_value_reset_string_cursor(pWorker);
								php_value_string(pWorker,sEntry.zString,(int)sEntry.nByte);
								php_array_add_elem(pCur,pWorker,pvArr);
								php_value_reset_string_cursor(pWorker);
							}
						}
						if (pvArr) {
							pCur = pvArr;
						}
					}
					while (zIn < zEnd && zIn[0] != ']') {
						zIn++;
					}
				}
				zIn++;
			}
			if (!is_array) {
				iLen = (int)(zIn - zCur);
			}

			SyStringInitFromBuf(&sEntry,zCur,iLen);
			SyStringFullTrim(&sEntry);
			if (sEntry.nByte > 0) {
				if (!is_array) {

					php_value_string(pWorker,sEntry.zString,(int)sEntry.nByte);
				}

				php_value_reset_string_cursor(pValue);
				zIn++;
				while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && SyisSpace(zIn[0])) {
					zIn++;
				}
				if (zIn < zEnd) {
					zCur = zIn;
					c = zIn[0];
					if (c == '"' || c == '\'') {
						zIn++;

						while (zIn < zEnd) {
							if (zIn[0] == c && zIn[-1] != '\\') {
								break;
							}
							zIn++;
						}
						if (zIn < zEnd) {
							zIn++;
						}
					}
					else {
						while (zIn < zEnd) {
							if (zIn[0] == '\n') {
								if (zIn[-1] != '\\') {
									break;
								}
							}
							else if (zIn[0] == ';' || zIn[0] == '#') {

								break;
							}
							zIn++;
						}
					}

					SyStringInitFromBuf(&sEntry,zCur,(int)(zIn - zCur));
					SyStringFullTrim(&sEntry);
					if (c == '"' || c == '\'') {
						SyStringTrimLeadingChar(&sEntry,c);
						SyStringTrimTrailingChar(&sEntry,c);
					}
					if (sEntry.nByte > 0) {
						php_value_string(pValue,sEntry.zString,(int)sEntry.nByte);
					}

					php_array_add_elem(pCur,is_array ? 0  : pWorker,pValue);
				}
			}
			else {
				while (zIn < zEnd && (unsigned char)zIn[0] < 0xc0 && (SyisSpace(zIn[0]) || zIn[0] == '=')) {
					zIn++;
				}
			}
			pCur = pOldCur;
		}
	}
	SyHashRelease(&sHash);

	php_result_value(pCtx,pArray);
	return SXRET_OK;
}

static int PHP_builtin_parse_ini_string(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIni; int nByte;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIni = php_value_to_string(apArg[0],&nByte);

	PHP_ParseIniString(pCtx,zIni,(sxu32)nByte,(nArg > 1) ? php_value_to_bool(apArg[1]) : 0);
	return PHP_OK;
}


static int PHP_builtin_ctype_alnum(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (!SyisAlphaNum(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_alpha(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (!SyisAlpha(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_cntrl(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisCtrl(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_digit(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisDigit(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_xdigit(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisHex(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_graph(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisGraph(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_print(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisPrint(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_punct(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisPunct(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_space(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (zIn[0] >= 0xc0) {

			break;
		}
		if (!SyisSpace(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_lower(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (!SyisLower(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

static int PHP_builtin_ctype_upper(php_context* pCtx,int nArg,php_value** apArg)
{
	const unsigned char* zIn,* zEnd; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = (const unsigned char*)php_value_to_string(apArg[0],&nLen);
	zEnd = &zIn[nLen];
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	for (;;) {
		if (zIn >= zEnd) {

			php_result_bool(pCtx,1);
			return PHP_OK;
		}
		if (!SyisUpper(zIn[0])) {
			break;
		}

		zIn++;
	}

	php_result_bool(pCtx,0);
	return PHP_OK;
}

#include <time.h>
#ifdef __WINNT__

#include <Windows.h>
#ifdef _WIN32_WCE

struct tm* __cdecl localtime(const time_t* t)
{
	static struct tm y;
	FILETIME uTm,lTm;
	SYSTEMTIME pTm;
	php_int64 t64;
	t64 = *t;
	t64 = (t64 + 11644473600) * 10000000;
	uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);
	uTm.dwHighDateTime = (DWORD)(t64 >> 32);
	FileTimeToLocalFileTime(&uTm,&lTm);
	FileTimeToSystemTime(&lTm,&pTm);
	y.tm_year = pTm.wYear - 1900;
	y.tm_mon = pTm.wMonth - 1;
	y.tm_wday = pTm.wDayOfWeek;
	y.tm_mday = pTm.wDay;
	y.tm_hour = pTm.wHour;
	y.tm_min = pTm.wMinute;
	y.tm_sec = pTm.wSecond;
	return &y;
}
#endif
#elif defined(__UNIXES__)
#include <sys/time.h>
#endif

static int PHP_builtin_time(php_context* pCtx,int nArg,php_value** apArg)
{
	time_t tt;
	SXUNUSED(nArg);
	SXUNUSED(apArg);

	time(&tt);

	php_result_int64(pCtx,(php_int64)tt);
	return  PHP_OK;
}

static int PHP_builtin_microtime(php_context* pCtx,int nArg,php_value** apArg)
{
	int bFloat = 0;
	sytime sTime;
#if defined(__UNIXES__)
	struct timeval tv;
	gettimeofday(&tv,0);
	sTime.tm_sec = (long)tv.tv_sec;
	sTime.tm_usec = (long)tv.tv_usec;
#else
	time_t tt;
	time(&tt);
	sTime.tm_sec = (long)tt;
	sTime.tm_usec = (long)(tt % SX_USEC_PER_SEC);
#endif
	if (nArg > 0) {
		bFloat = php_value_to_bool(apArg[0]);
	}
	if (bFloat) {

		php_result_double(pCtx,(double)sTime.tm_sec);
	}
	else {

		php_result_string_format(pCtx,"%ld %ld",sTime.tm_usec,sTime.tm_sec);
	}
	return PHP_OK;
}

static int PHP_builtin_getdate(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pValue,* pArray;
	Sytm sTm;
	if (nArg < 1) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
#ifdef __WINNT__
#ifdef _MSC_VER
#if _MSC_VER >= 1400
#pragma warning(disable:4996)
#endif
#endif
#endif
		if (php_value_is_int(apArg[0])) {
			t = (time_t)php_value_to_int64(apArg[0]);
			pTm = localtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	pValue = php_context_new_scalar(pCtx);
	if (pValue == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}


	php_value_int(pValue,sTm.tm_sec);
	php_array_add_strkey_elem(pArray,"seconds",pValue);

	php_value_int(pValue,sTm.tm_min);
	php_array_add_strkey_elem(pArray,"minutes",pValue);

	php_value_int(pValue,sTm.tm_hour);
	php_array_add_strkey_elem(pArray,"hours",pValue);

	php_value_int(pValue,sTm.tm_mday);
	php_array_add_strkey_elem(pArray,"mday",pValue);

	php_value_int(pValue,sTm.tm_wday);
	php_array_add_strkey_elem(pArray,"wday",pValue);

	php_value_int(pValue,sTm.tm_mon + 1);
	php_array_add_strkey_elem(pArray,"mon",pValue);

	php_value_int(pValue,sTm.tm_year);
	php_array_add_strkey_elem(pArray,"year",pValue);

	php_value_int(pValue,sTm.tm_yday);
	php_array_add_strkey_elem(pArray,"yday",pValue);

	php_value_string(pValue,SyTimeGetDay(sTm.tm_wday),-1);
	php_array_add_strkey_elem(pArray,"weekday",pValue);

	php_value_reset_string_cursor(pValue);
	php_value_string(pValue,SyTimeGetMonth(sTm.tm_mon),-1);
	php_array_add_strkey_elem(pArray,"month",pValue);

	php_value_int64(pValue,(php_int64)time(0));
	php_array_add_intkey_elem(pArray,0 ,pValue);

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int PHP_builtin_gettimeofday(php_context* pCtx,int nArg,php_value** apArg)
{
	int bFloat = 0;
	sytime sTime;
#if defined(__UNIXES__)
	struct timeval tv;
	gettimeofday(&tv,0);
	sTime.tm_sec = (long)tv.tv_sec;
	sTime.tm_usec = (long)tv.tv_usec;
#else
	time_t tt;
	time(&tt);
	sTime.tm_sec = (long)tt;
	sTime.tm_usec = (long)(tt % SX_USEC_PER_SEC);
#endif
	if (nArg > 0) {
		bFloat = php_value_to_bool(apArg[0]);
	}
	if (bFloat) {

		php_result_double(pCtx,(double)sTime.tm_sec);
	}
	else {

		php_value* pValue,* pArray;

		pArray = php_context_new_array(pCtx);

		pValue = php_context_new_scalar(pCtx);
		if (pValue == 0 || pArray == 0) {

			php_result_null(pCtx);
			return PHP_OK;
		}


		php_value_int64(pValue,sTime.tm_sec);
		php_array_add_strkey_elem(pArray,"sec",pValue);

		php_value_int64(pValue,sTime.tm_usec);
		php_array_add_strkey_elem(pArray,"usec",pValue);

		php_result_value(pCtx,pArray);
	}
	return PHP_OK;
}

#define IS_LEAP_YEAR(YEAR)	(YEAR % 400 ? ( YEAR % 100 ? ( YEAR % 4 ? 0 : 1 ) : 0 ) : 1)

static const int aISO8601[] = { 7 ,1 ,2,3,4,5,6 };

static sxi32 DateFormat(php_context* pCtx,const char* zIn,int nLen,Sytm* pTm)
{
	const char* zEnd = &zIn[nLen];
	const char* zCur;

	for (;;) {
		if (zIn >= zEnd) {

			break;
		}
		switch (zIn[0]) {
		case 'd':

			php_result_string_format(pCtx,"%02d",pTm->tm_mday);
			break;
		case 'D':

			zCur = SyTimeGetDay(pTm->tm_wday);
			php_result_string(pCtx,zCur,3);
			break;
		case 'j':

			php_result_string_format(pCtx,"%d",pTm->tm_mday);
			break;
		case 'l':

			zCur = SyTimeGetDay(pTm->tm_wday);
			php_result_string(pCtx,zCur,-1);
			break;
		case 'N': {

			php_result_string_format(pCtx,"%d",aISO8601[pTm->tm_wday % 7]);
			break;
		}
		case 'w':

			php_result_string_format(pCtx,"%d",pTm->tm_wday);
			break;
		case 'z':

			php_result_string_format(pCtx,"%d",pTm->tm_yday);
			break;
		case 'F':

			zCur = SyTimeGetMonth(pTm->tm_mon);
			php_result_string(pCtx,zCur,-1);
			break;
		case 'm':

			php_result_string_format(pCtx,"%02d",pTm->tm_mon + 1);
			break;
		case 'M':

			zCur = SyTimeGetMonth(pTm->tm_mon);
			php_result_string(pCtx,zCur,3);
			break;
		case 'n':

			php_result_string_format(pCtx,"%d",pTm->tm_mon + 1);
			break;
		case 't': {
			static const int aMonDays[] = { 31,29,31,30,31,30,31,31,30,31,30,31 }; int nDays = aMonDays[pTm->tm_mon % 12];
			if (pTm->tm_mon == 1  && !IS_LEAP_YEAR(pTm->tm_year)) {
				nDays = 28;
			}

			php_result_string_format(pCtx,"%d",nDays);
			break;
		}
		case 'L': {
			int isLeap = IS_LEAP_YEAR(pTm->tm_year);

			php_result_string_format(pCtx,"%d",isLeap);
			break;
		}
		case 'o':

			php_result_string_format(pCtx,"%4d",pTm->tm_year);
			break;
		case 'Y':

			php_result_string_format(pCtx,"%4d",pTm->tm_year);
			break;
		case 'y':

			php_result_string_format(pCtx,"%02d",pTm->tm_year % 100);
			break;
		case 'a':

			php_result_string(pCtx,pTm->tm_hour > 12 ? "pm" : "am",2);
			break;
		case 'A':

			php_result_string(pCtx,pTm->tm_hour > 12 ? "PM" : "AM",2);
			break;
		case 'g':

			php_result_string_format(pCtx,"%d",1 + (pTm->tm_hour % 12));
			break;
		case 'G':

			php_result_string_format(pCtx,"%d",pTm->tm_hour);
			break;
		case 'h':

			php_result_string_format(pCtx,"%02d",1 + (pTm->tm_hour % 12));
			break;
		case 'H':

			php_result_string_format(pCtx,"%02d",pTm->tm_hour);
			break;
		case 'i':

			php_result_string_format(pCtx,"%02d",pTm->tm_min);
			break;
		case 's':

			php_result_string_format(pCtx,"%02d",pTm->tm_sec);
			break;
		case 'u':

			php_result_string_format(pCtx,"%u",pTm->tm_sec * SX_USEC_PER_SEC);
			break;
		case 'S': {

			static const char zSuffix[] = "thstndrdthththththth"; int v = pTm->tm_mday;
			php_result_string(pCtx,&zSuffix[2 * (int)(v / 10 % 10 != 1 ? v % 10 : 0)],(int)sizeof(char) * 2);
			break;
		}
		case 'e':

			zCur = pTm->tm_zone;
			if (zCur == 0) {

				zCur = "GMT";
			}
			php_result_string(pCtx,zCur,-1);
			break;
		case 'I':

#ifdef __WINNT__
#ifdef _MSC_VER
#ifndef _WIN32_WCE
			_get_daylight(&pTm->tm_isdst);
#endif
#endif
#endif
			php_result_string_format(pCtx,"%d",pTm->tm_isdst == 1);
			break;
		case 'r':

			php_result_string_format(pCtx,"%.3s,%02d %.3s %4d %02d:%02d:%02d",
				SyTimeGetDay(pTm->tm_wday),
				pTm->tm_mday,
				SyTimeGetMonth(pTm->tm_mon),
				pTm->tm_year,
				pTm->tm_hour,
				pTm->tm_min,
				pTm->tm_sec
			);
			break;
		case 'U': {
			time_t tt;

			time(&tt);
			php_result_string_format(pCtx,"%u",(unsigned int)tt);
			break;
		}
		case 'O':
		case 'P':

			php_result_string_format(pCtx,"%+05d",pTm->tm_gmtoff);
			break;
		case 'Z':

			php_result_string_format(pCtx,"%+05d",pTm->tm_gmtoff);
			break;
		case 'c':

			php_result_string_format(pCtx,"%4d-%02d-%02dT%02d:%02d:%02d%+05d",
				pTm->tm_year,
				pTm->tm_mon + 1,
				pTm->tm_mday,
				pTm->tm_hour,
				pTm->tm_min,
				pTm->tm_sec,
				pTm->tm_gmtoff
			);
			break;
		case '\\':
			zIn++;

			if (zIn < zEnd) {
				php_result_string(pCtx,zIn,(int)sizeof(char));
			}
			break;
		default:

			php_result_string(pCtx,zIn,(int)sizeof(char));
			break;
		}

		zIn++;
	}
	return SXRET_OK;
}

static int PHP_Strftime(
	php_context* pCtx,
	const char* zIn,
	int nLen,
	Sytm* pTm
)
{
	const char* zCur,* zEnd = &zIn[nLen]; int c;

	for (;;) {
		zCur = zIn;
		while (zIn < zEnd && zIn[0] != '%') {
			zIn++;
		}
		if (zIn > zCur) {

			php_result_string(pCtx,zCur,(int)(zIn - zCur));
		}
		zIn++;
		if (zIn >= zEnd) {

			break;
		}
		c = zIn[0];

		switch (c) {
		case '%':

			php_result_string(pCtx,"%",(int)sizeof(char));
			break;
		case 't':

			php_result_string(pCtx,"\t",(int)sizeof(char));
			break;
		case 'n':

			php_result_string(pCtx,"\n",(int)sizeof(char));
			break;
		case 'a':

			php_result_string(pCtx,SyTimeGetDay(pTm->tm_wday),(int)sizeof(char) * 3);
			break;
		case 'A':

			php_result_string(pCtx,SyTimeGetDay(pTm->tm_wday),-1);
			break;
		case 'e':

			php_result_string_format(pCtx,"%2d",pTm->tm_mday);
			break;
		case 'd':

			php_result_string_format(pCtx,"%02d",pTm->tm_mon + 1);
			break;
		case 'j':

			php_result_string_format(pCtx,"%03d",pTm->tm_yday);
			break;
		case 'u':

			php_result_string_format(pCtx,"%d",aISO8601[pTm->tm_wday % 7]);
			break;
		case 'w':

			php_result_string_format(pCtx,"%d",pTm->tm_wday);
			break;
		case 'b':
		case 'h':

			php_result_string(pCtx,SyTimeGetMonth(pTm->tm_mon),(int)sizeof(char) * 3);
			break;
		case 'B':

			php_result_string(pCtx,SyTimeGetMonth(pTm->tm_mon),-1);
			break;
		case 'm':

			php_result_string_format(pCtx,"%02d",pTm->tm_mon + 1);
			break;
		case 'C':

			php_result_string_format(pCtx,"%2d",pTm->tm_year / 100);
			break;
		case 'y':
		case 'g':

			php_result_string_format(pCtx,"%2d",pTm->tm_year % 100);
			break;
		case 'Y':
		case 'G':

			php_result_string_format(pCtx,"%4d",pTm->tm_year);
			break;
		case 'I':

			php_result_string_format(pCtx,"%02d",1 + (pTm->tm_hour % 12));
			break;
		case 'l':

			php_result_string_format(pCtx,"%2d",1 + (pTm->tm_hour % 12));
			break;
		case 'H':

			php_result_string_format(pCtx,"%02d",pTm->tm_hour);
			break;
		case 'M':

			php_result_string_format(pCtx,"%02d",pTm->tm_min);
			break;
		case 'S':

			php_result_string_format(pCtx,"%02d",pTm->tm_sec);
			break;
		case 'z':
		case 'Z':

			zCur = pTm->tm_zone;
			if (zCur == 0) {

				zCur = "GMT";
			}
			php_result_string(pCtx,zCur,-1);
			break;
		case 'T':
		case 'X':

			php_result_string_format(pCtx,"%02d:%02d:%02d",pTm->tm_hour,pTm->tm_min,pTm->tm_sec);
			break;
		case 'R':

			php_result_string_format(pCtx,"%02d:%02d",pTm->tm_hour,pTm->tm_min);
			break;
		case 'P':

			php_result_string(pCtx,pTm->tm_hour > 12 ? "pm" : "am",(int)sizeof(char) * 2);
			break;
		case 'p':

			php_result_string(pCtx,pTm->tm_hour > 12 ? "PM" : "AM",(int)sizeof(char) * 2);
			break;
		case 'r':

			php_result_string_format(pCtx,"%02d:%02d:%02d %s",
				1 + (pTm->tm_hour % 12),
				pTm->tm_min,
				pTm->tm_sec,
				pTm->tm_hour > 12 ? "PM" : "AM"
			);
			break;
		case 'D':
		case 'x':

			php_result_string_format(pCtx,"%02d/%02d/%02d",
				pTm->tm_mon + 1,
				pTm->tm_mday,
				pTm->tm_year % 100
			);
			break;
		case 'F':

			php_result_string_format(pCtx,"%d-%02d-%02d",
				pTm->tm_year,
				pTm->tm_mon + 1,
				pTm->tm_mday
			);
			break;
		case 'c':
			php_result_string_format(pCtx,"%d-%02d-%02d %02d:%02d:%02d",
				pTm->tm_year,
				pTm->tm_mon + 1,
				pTm->tm_mday,
				pTm->tm_hour,
				pTm->tm_min,
				pTm->tm_sec
			);
			break;
		case 's': {
			time_t tt;

			time(&tt);
			php_result_string_format(pCtx,"%u",(unsigned int)tt);
			break;
		}
		default:

			break;
		}

		zIn++;
	}
	return SXRET_OK;
}

static int PHP_builtin_date(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat; int nLen;
	Sytm sTm;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
	}
	if (nArg < 2) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
		if (php_value_is_int(apArg[1])) {
			t = (time_t)php_value_to_int64(apArg[1]);
			pTm = localtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	DateFormat(pCtx,zFormat,nLen,&sTm);
	return PHP_OK;
}

static int PHP_builtin_strftime(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat; int nLen;
	Sytm sTm;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
	}
	if (nArg < 2) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
		if (php_value_is_int(apArg[1])) {
			t = (time_t)php_value_to_int64(apArg[1]);
			pTm = localtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	PHP_Strftime(pCtx,zFormat,nLen,&sTm);
	if (php_context_result_buf_length(pCtx) < 1) {

		php_result_bool(pCtx,0);
	}
	return PHP_OK;
}

static int PHP_builtin_gmdate(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat; int nLen;
	Sytm sTm;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}
	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_string(pCtx,"",0);
	}
	if (nArg < 2) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = gmtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
		if (php_value_is_int(apArg[1])) {
			t = (time_t)php_value_to_int64(apArg[1]);
			pTm = gmtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = gmtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	DateFormat(pCtx,zFormat,nLen,&sTm);
	return PHP_OK;
}

static int PHP_builtin_localtime(php_context* pCtx,int nArg,php_value** apArg)
{
	php_value* pValue,* pArray; int isAssoc = 0;
	Sytm sTm;
	if (nArg < 1) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
		if (php_value_is_int(apArg[0])) {
			t = (time_t)php_value_to_int64(apArg[0]);
			pTm = localtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	pValue = php_context_new_scalar(pCtx);
	if (pValue == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}

	pArray = php_context_new_array(pCtx);
	if (pArray == 0) {

		php_result_null(pCtx);
		return PHP_OK;
	}
	if (nArg > 1) {
		isAssoc = php_value_to_bool(apArg[1]);
	}


	php_value_int(pValue,sTm.tm_sec);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_sec",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_min);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_min",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_hour);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_hour",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_mday);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_mday",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_mon);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_mon",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_year - 1900);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_year",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_wday);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_wday",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_value_int(pValue,sTm.tm_yday);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_yday",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

#ifdef __WINNT__
#ifdef _MSC_VER
#ifndef _WIN32_WCE
	_get_daylight(&sTm.tm_isdst);
#endif
#endif
#endif
	php_value_int(pValue,sTm.tm_isdst);
	if (isAssoc) {
		php_array_add_strkey_elem(pArray,"tm_isdst",pValue);
	}
	else {
		php_array_add_elem(pArray,0,pValue);
	}

	php_result_value(pCtx,pArray);
	return PHP_OK;
}

static int PHP_builtin_idate(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFormat;
	php_int64 iVal = 0; int nLen;
	Sytm sTm;
	if (nArg < 1 || !php_value_is_string(apArg[0])) {

		php_result_int(pCtx,-1);
		return PHP_OK;
	}
	zFormat = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_int(pCtx,-1);
	}
	if (nArg < 2) {
#ifdef __WINNT__
		SYSTEMTIME sOS;
		GetSystemTime(&sOS);
		SYSTEMTIME_TO_SYTM(&sOS,&sTm);
#else
		struct tm* pTm;
		time_t t;
		time(&t);
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
#endif
	}
	else {

		time_t t;
		struct tm* pTm;
		if (php_value_is_int(apArg[1])) {
			t = (time_t)php_value_to_int64(apArg[1]);
			pTm = localtime(&t);
			if (pTm == 0) {
				time(&t);
			}
		}
		else {
			time(&t);
		}
		pTm = localtime(&t);
		STRUCT_TM_TO_SYTM(pTm,&sTm);
	}

	switch (zFormat[0]) {
	case 'd':

		iVal = sTm.tm_mday;
		break;
	case 'h':

		iVal = 1 + (sTm.tm_hour % 12);
		break;
	case 'H':

		iVal = sTm.tm_hour;
		break;
	case 'i':

		iVal = sTm.tm_min;
		break;
	case 'I':

#ifdef __WINNT__
#ifdef _MSC_VER
#ifndef _WIN32_WCE
		_get_daylight(&sTm.tm_isdst);
#endif
#endif
#endif
		iVal = sTm.tm_isdst;
		break;
	case 'L':

		iVal = IS_LEAP_YEAR(sTm.tm_year);
		break;
	case 'm':

		iVal = sTm.tm_mon;
		break;
	case 's':

		iVal = sTm.tm_sec;
		break;
	case 't': {

		static const int aMonDays[] = { 31,29,31,30,31,30,31,31,30,31,30,31 }; int nDays = aMonDays[sTm.tm_mon % 12];
		if (sTm.tm_mon == 1  && !IS_LEAP_YEAR(sTm.tm_year)) {
			nDays = 28;
		}
		iVal = nDays;
		break;
	}
	case 'U':

		iVal = (php_int64)time(0);
		break;
	case 'w':

		iVal = sTm.tm_wday;
		break;
	case 'W': {

		static const int aISO8601[] = { 7 ,1 ,2,3,4,5,6 };
		iVal = aISO8601[sTm.tm_wday % 7];
		break;
	}
	case 'y':

		iVal = sTm.tm_year % 100;
		break;
	case 'Y':

		iVal = sTm.tm_year;
		break;
	case 'z':

		iVal = sTm.tm_yday;
		break;
	case 'Z':

		iVal = sTm.tm_gmtoff;
		break;
	default:

		php_context_throw_error(pCtx,PHP_CTX_WARNING,"Unknown date format token");
		break;
	}

	php_result_int64(pCtx,iVal);
	return PHP_OK;
}

static int PHP_builtin_mktime(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zFunction;
	php_int64 iVal = 0;
	struct tm* pTm;
	time_t t;

	zFunction = php_function_name(pCtx);

	time(&t);
	if (zFunction[0] == 'g' ) {
		pTm = gmtime(&t);
	}
	else {

		pTm = localtime(&t);
	}
	if (nArg > 0) {
		int iVal;

		iVal = php_value_to_int(apArg[0]);
		pTm->tm_hour = iVal;
		if (nArg > 1) {

			iVal = php_value_to_int(apArg[1]);
			pTm->tm_min = iVal;
			if (nArg > 2) {

				iVal = php_value_to_int(apArg[2]);
				pTm->tm_sec = iVal;
				if (nArg > 3) {

					iVal = php_value_to_int(apArg[3]);
					pTm->tm_mon = iVal - 1;
					if (nArg > 4) {

						iVal = php_value_to_int(apArg[4]);
						pTm->tm_mday = iVal;
						if (nArg > 5) {

							iVal = php_value_to_int(apArg[5]);
							if (iVal > 1900) {
								iVal -= 1900;
							}
							pTm->tm_year = iVal;
							if (nArg > 6) {

								iVal = php_value_to_bool(apArg[6]);
								pTm->tm_isdst = iVal;
							}
						}
					}
				}
			}
		}
	}

	iVal = (php_int64)mktime(pTm);

	php_result_int64(pCtx,iVal);
	return PHP_OK;
}


static int Consumer(const void* pData,unsigned int nLen,void* pUserData)
{

	php_result_string((php_context*)pUserData,(const char*)pData,(int)nLen);
	return SXRET_OK;
}

static int PHP_builtin_base64_encode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	SyBase64Encode(zIn,(sxu32)nLen,Consumer,pCtx);
	return PHP_OK;
}

static int PHP_builtin_base64_decode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	SyBase64Decode(zIn,(sxu32)nLen,Consumer,pCtx);
	return PHP_OK;
}

static int PHP_builtin_urlencode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	SyUriEncode(zIn,(sxu32)nLen,Consumer,pCtx);
	return PHP_OK;
}

static int PHP_builtin_urldecode(php_context* pCtx,int nArg,php_value** apArg)
{
	const char* zIn; int nLen;
	if (nArg < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	zIn = php_value_to_string(apArg[0],&nLen);
	if (nLen < 1) {

		php_result_bool(pCtx,0);
		return PHP_OK;
	}

	SyUriDecode(zIn,(sxu32)nLen,Consumer,pCtx,TRUE);
	return PHP_OK;
}
#endif

static const php_builtin_func aBuiltInFunc[] = {

	{ "is_bool"    ,PHP_builtin_is_bool },
	    { "is_float"   ,PHP_builtin_is_float },
	    { "is_real"    ,PHP_builtin_is_float },
	    { "is_double"  ,PHP_builtin_is_float },
	    { "is_int"     ,PHP_builtin_is_int },
	    { "is_integer" ,PHP_builtin_is_int },
	    { "is_long"    ,PHP_builtin_is_int },
	    { "is_string"  ,PHP_builtin_is_string },
	    { "is_null"    ,PHP_builtin_is_null },
	    { "is_numeric" ,PHP_builtin_is_numeric },
	    { "is_scalar"  ,PHP_builtin_is_scalar },
	    { "is_array"   ,PHP_builtin_is_array },
	    { "is_object"  ,PHP_builtin_is_object },
	    { "is_resource",PHP_builtin_is_resource },
	    { "douleval"   ,PHP_builtin_floatval },
	    { "floatval"   ,PHP_builtin_floatval },
	    { "intval"     ,PHP_builtin_intval },
	    { "strval"     ,PHP_builtin_strval },
	    { "empty"      ,PHP_builtin_empty},
#ifndef PHP_DISABLE_BUILTIN_FUNC
#ifdef PHP_ENABLE_MATH_FUNC

{ "abs"  ,PHP_builtin_abs},
{ "sqrt" ,PHP_builtin_sqrt},
{ "exp"  ,PHP_builtin_exp},
{ "floor",PHP_builtin_floor},
{ "cos"  ,PHP_builtin_cos},
{ "sin"  ,PHP_builtin_sin},
{ "acos" ,PHP_builtin_acos},
{ "asin" ,PHP_builtin_asin},
{ "cosh" ,PHP_builtin_cosh},
{ "sinh" ,PHP_builtin_sinh},
{ "ceil" ,PHP_builtin_ceil},
{ "tan"  ,PHP_builtin_tan},
{ "tanh" ,PHP_builtin_tanh},
{ "atan" ,PHP_builtin_atan},
{ "atan2",PHP_builtin_atan2},
{ "log"  ,PHP_builtin_log},
{ "log10" ,PHP_builtin_log10},
{ "pow"  ,PHP_builtin_pow},
{ "pi",PHP_builtin_pi},
{ "fmod",PHP_builtin_fmod},
{ "hypot",PHP_builtin_hypot},
#endif
	{ "round",PHP_builtin_round },
	{ "dechex",PHP_builtin_dechex },
	{ "decoct",PHP_builtin_decoct },
	{ "decbin",PHP_builtin_decbin },
	{ "hexdec",PHP_builtin_hexdec },
	{ "bindec",PHP_builtin_bindec },
	{ "octdec",PHP_builtin_octdec },
	{ "srand",PHP_builtin_srand },
	{ "mt_srand",PHP_builtin_srand },
	{ "base_convert",PHP_builtin_base_convert},
	{ "substr",PHP_builtin_substr },
	{ "substr_compare",PHP_builtin_substr_compare },
	{ "substr_count",PHP_builtin_substr_count },
	{ "chunk_split",PHP_builtin_chunk_split },
	{ "addslashes" ,PHP_builtin_addslashes },
	{ "addcslashes",PHP_builtin_addcslashes },
	{ "quotemeta",PHP_builtin_quotemeta },
	{ "stripslashes",PHP_builtin_stripslashes },
	{ "htmlspecialchars",PHP_builtin_htmlspecialchars },
	{ "htmlspecialchars_decode",PHP_builtin_htmlspecialchars_decode },
	{ "get_html_translation_table",PHP_builtin_get_html_translation_table },
	{ "htmlentities",PHP_builtin_htmlentities },
	{ "html_entity_decode",PHP_builtin_html_entity_decode },
	{ "strlen"     ,PHP_builtin_strlen },
	{ "strcmp"     ,PHP_builtin_strcmp },
	{ "strcoll"    ,PHP_builtin_strcmp },
	{ "strncmp"    ,PHP_builtin_strncmp },
	{ "strcasecmp" ,PHP_builtin_strcasecmp },
	{ "strncasecmp",PHP_builtin_strncasecmp },
	{ "implode"    ,PHP_builtin_implode },
	{ "join"       ,PHP_builtin_implode },
	{ "implode_recursive" ,PHP_builtin_implode_recursive },
	{ "join_recursive"    ,PHP_builtin_implode_recursive },
	{ "explode"     ,PHP_builtin_explode },
	{ "trim"        ,PHP_builtin_trim },
	{ "rtrim"       ,PHP_builtin_rtrim },
	{ "chop"        ,PHP_builtin_rtrim },
	{ "ltrim"       ,PHP_builtin_ltrim },
	{ "strtolower",PHP_builtin_strtolower },
	{ "mb_strtolower",PHP_builtin_strtolower },
	{ "strtoupper",PHP_builtin_strtoupper },
	{ "mb_strtoupper",PHP_builtin_strtoupper },
	{ "ucfirst",PHP_builtin_ucfirst },
	{ "lcfirst",PHP_builtin_lcfirst },
	{ "ord",PHP_builtin_ord },
	{ "chr",PHP_builtin_chr },
	{ "bin2hex",PHP_builtin_bin2hex },
	{ "strstr",PHP_builtin_strstr },
	{ "stristr",PHP_builtin_stristr },
	{ "strchr",PHP_builtin_strstr },
	{ "strpos",PHP_builtin_strpos },
	{ "stripos",PHP_builtin_stripos },
	{ "strrpos",PHP_builtin_strrpos },
	{ "strripos",PHP_builtin_strripos },
	{ "strrchr",PHP_builtin_strrchr },
	{ "strrev",PHP_builtin_strrev },
	{ "ucwords",PHP_builtin_ucwords },
	{ "str_repeat",PHP_builtin_str_repeat },
	{ "nl2br",PHP_builtin_nl2br },
	{ "sprintf",PHP_builtin_sprintf },
	{ "printf",PHP_builtin_printf },
	{ "vprintf",PHP_builtin_vprintf },
	{ "vsprintf",PHP_builtin_vsprintf },
	{ "size_format",PHP_builtin_size_format},
#if !defined(PHP_DISABLE_HASH_FUNC)
	{ "md5",PHP_builtin_md5 },
	{ "sha1",PHP_builtin_sha1 },
	{ "crc32",PHP_builtin_crc32 },
#endif
	{ "str_getcsv",PHP_builtin_str_getcsv },
	{ "strip_tags",PHP_builtin_strip_tags },
	{ "str_shuffle",PHP_builtin_str_shuffle },
	{ "str_split",PHP_builtin_str_split },
	{ "strspn",PHP_builtin_strspn },
	{ "strcspn",PHP_builtin_strcspn },
	{ "strpbrk",PHP_builtin_strpbrk },
	{ "soundex",PHP_builtin_soundex },
	{ "wordwrap",PHP_builtin_wordwrap },
	{ "strtok",PHP_builtin_strtok },
	{ "str_pad",PHP_builtin_str_pad },
	{ "str_replace",PHP_builtin_str_replace },
	{ "str_ireplace",PHP_builtin_str_replace },
	{ "strtr",PHP_builtin_strtr },
	{ "parse_ini_string",PHP_builtin_parse_ini_string},
    { "ctype_alnum",PHP_builtin_ctype_alnum },
    { "ctype_alpha",PHP_builtin_ctype_alpha },
    { "ctype_cntrl",PHP_builtin_ctype_cntrl },
    { "ctype_digit",PHP_builtin_ctype_digit },
    { "ctype_xdigit",PHP_builtin_ctype_xdigit },
    { "ctype_graph",PHP_builtin_ctype_graph },
    { "ctype_print",PHP_builtin_ctype_print },
    { "ctype_punct",PHP_builtin_ctype_punct },
    { "ctype_space",PHP_builtin_ctype_space },
    { "ctype_lower",PHP_builtin_ctype_lower },
    { "ctype_upper",PHP_builtin_ctype_upper },
    { "time"    ,PHP_builtin_time },
    { "microtime",PHP_builtin_microtime },
    { "getdate" ,PHP_builtin_getdate },
    { "gettimeofday",PHP_builtin_gettimeofday },
    { "date",PHP_builtin_date },
    { "strftime",PHP_builtin_strftime },
    { "idate",PHP_builtin_idate },
    { "gmdate",PHP_builtin_gmdate },
    { "localtime",PHP_builtin_localtime },
    { "mktime",PHP_builtin_mktime },
    { "gmmktime",PHP_builtin_mktime  },
    { "base64_encode",PHP_builtin_base64_encode },
    { "base64_decode",PHP_builtin_base64_decode },
    { "convert_uuencode",PHP_builtin_base64_encode },
    { "convert_uudecode",PHP_builtin_base64_decode },
    { "urlencode",PHP_builtin_urlencode },
    { "urldecode",PHP_builtin_urldecode },
    { "rawurlencode",PHP_builtin_urlencode },
    { "rawurldecode",PHP_builtin_urldecode },
#endif
};

PHP_PRIVATE void PHP_RegisterBuiltInFunction(php_vm* pVm)
{
	sxu32 n;
	for (n = 0; n < SX_ARRAYSIZE(aBuiltInFunc); ++n) {
		php_create_function(&(*pVm),aBuiltInFunc[n].zName,aBuiltInFunc[n].xFunc,0);
	}

	PHP_RegisterHashmapFunctions(&(*pVm));

	PHP_RegisterIORoutine(&(*pVm));
}




#ifndef PHP_AMALGAMATION
#include "phpint.h"
#endif

#define PHP_ENGINE_MAGIC 0xF874BCD7
#define PHP_ENGINE_MISUSE(ENGINE) (ENGINE == 0 || ENGINE->nMagic != PHP_ENGINE_MAGIC)
#define PHP_VM_MISUSE(VM) (VM == 0 || VM->nMagic == PHP_VM_STALE)

#define PHP_THRD_ENGINE_RELEASE(ENGINE) (ENGINE->nMagic != PHP_ENGINE_MAGIC)
#define PHP_THRD_VM_RELEASE(VM) (VM->nMagic == PHP_VM_STALE)


static struct Global_Data
{
	SyMemBackend sAllocator;
#if defined(PHP_ENABLE_THREADS)
	const SyMutexMethods* pMutexMethods;
	SyMutex* pMutex;
	sxu32 nThreadingLevel;
#endif
	const php_vfs* pVfs;
	sxi32 nEngine;
	php* pEngines;
	sxu32 nMagic;
}sMPGlobal = {
	{0,0,0,0,0,0,0,0,{0}},
#if defined(PHP_ENABLE_THREADS)
	0,
	0,
	0,
#endif
	0,
	0,
	0,
	0
};
#define PHP_LIB_MAGIC  0xEA1495BA
#define PHP_LIB_MISUSE (sMPGlobal.nMagic != PHP_LIB_MAGIC)

#define PHP_THREAD_LEVEL_SINGLE 1
#define PHP_THREAD_LEVEL_MULTI  2

static sxi32 EngineConfig(php* pEngine,sxi32 nOp,va_list ap)
{
	php_conf* pConf = &pEngine->xConf; int rc = PHP_OK;

	switch (nOp) {
	case PHP_CONFIG_ERR_OUTPUT: {
		ProcConsumer xConsumer = va_arg(ap,ProcConsumer);
		void* pUserData = va_arg(ap,void*);

		if (xConsumer == 0) {
			rc = PHP_CORRUPT;
			break;
		}

		pConf->xErr = xConsumer;
		pConf->pErrData = pUserData;
		break;
	}
	case PHP_CONFIG_ERR_LOG: {

		const char** pzPtr = va_arg(ap,const char**); int* pLen = va_arg(ap,int*);
		if (pzPtr == 0) {
			rc = PHP_CORRUPT;
			break;
		}

		SyBlobNullAppend(&pConf->sErrConsumer);

		*pzPtr = (const char*)SyBlobData(&pConf->sErrConsumer);
		if (pLen) {
			if (SyBlobLength(&pConf->sErrConsumer) > 1 ) {
				*pLen = (int)SyBlobLength(&pConf->sErrConsumer);
			}
			else {
				*pLen = 0;
			}
		}
		break;
	}
	case PHP_CONFIG_ERR_ABORT:

		break;
	default:

		rc = PHP_CORRUPT;
		break;
	}
	return rc;
}

static sxi32 PHPCoreConfigure(sxi32 nOp,va_list ap)
{
	int rc = PHP_OK;
	switch (nOp) {
	case PHP_LIB_CONFIG_VFS: {

		const php_vfs* pVfs = va_arg(ap,const php_vfs*);
		sMPGlobal.pVfs = pVfs;
		break;
	}
	case PHP_LIB_CONFIG_USER_MALLOC: {

		const SyMemMethods* pMethods = va_arg(ap,const SyMemMethods*);

		ProcMemError xMemErr = sMPGlobal.sAllocator.xMemError;
		void* pMemErr = sMPGlobal.sAllocator.pUserData;
		if (pMethods == 0) {

			rc = SyMemBackendInit(&sMPGlobal.sAllocator,xMemErr,pMemErr);
		}
		else {
			rc = SyMemBackendInitFromOthers(&sMPGlobal.sAllocator,pMethods,xMemErr,pMemErr);
		}
		break;
	}
	case PHP_LIB_CONFIG_MEM_ERR_CALLBACK: {

		ProcMemError xMemErr = va_arg(ap,ProcMemError);
		void* pUserData = va_arg(ap,void*);
		sMPGlobal.sAllocator.xMemError = xMemErr;
		sMPGlobal.sAllocator.pUserData = pUserData;
		break;
	}
	case PHP_LIB_CONFIG_USER_MUTEX: {
#if defined(PHP_ENABLE_THREADS)

		const SyMutexMethods* pMethods = va_arg(ap,const SyMutexMethods*);
#if defined (UNTRUST)
		if (pMethods == 0) {
			rc = PHP_CORRUPT;
		}
#endif

		if (pMethods->xEnter == 0 || pMethods->xLeave == 0 || pMethods->xNew == 0) {

			rc = PHP_CORRUPT;
			break;
		}
		if (sMPGlobal.pMutexMethods) {

			SyMutexRelease(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
			if (sMPGlobal.pMutexMethods->xGlobalRelease) {
				sMPGlobal.pMutexMethods->xGlobalRelease();
			}
			sMPGlobal.pMutex = 0;
		}

		if (pMethods->xGlobalInit) {
			rc = pMethods->xGlobalInit();
			if (rc != PHP_OK) {
				break;
			}
		}

		sMPGlobal.pMutex = pMethods->xNew(SXMUTEX_TYPE_FAST);
		if (sMPGlobal.pMutex == 0) {

			if (pMethods->xGlobalRelease) {
				pMethods->xGlobalRelease();
			}
			rc = PHP_CORRUPT;
			break;
		}
		sMPGlobal.pMutexMethods = pMethods;
		if (sMPGlobal.nThreadingLevel == 0) {

			sMPGlobal.nThreadingLevel = PHP_THREAD_LEVEL_MULTI;
		}
#endif
		break;
	}
	case PHP_LIB_CONFIG_THREAD_LEVEL_SINGLE:
#if defined(PHP_ENABLE_THREADS)

		sMPGlobal.nThreadingLevel = PHP_THREAD_LEVEL_SINGLE;
#endif
		break;
	case PHP_LIB_CONFIG_THREAD_LEVEL_MULTI:
#if defined(PHP_ENABLE_THREADS)

		sMPGlobal.nThreadingLevel = PHP_THREAD_LEVEL_MULTI;
#endif
		break;
	default:

		rc = PHP_CORRUPT;
		break;
	}
	return rc;
}

int php_lib_config(int nConfigOp,...)
{
	va_list ap; int rc;

	if (sMPGlobal.nMagic == PHP_LIB_MAGIC) {

		return PHP_LOOKED;
	}
	va_start(ap,nConfigOp);
	rc = PHPCoreConfigure(nConfigOp,ap);
	va_end(ap);
	return rc;
}

static sxi32 PHPCoreInitialize(void)
{
	const php_vfs* pVfs;
#if defined(PHP_ENABLE_THREADS)
	const SyMutexMethods* pMutexMethods = 0;
	SyMutex* pMaster = 0;
#endif
	int rc;

	if (sMPGlobal.nMagic == PHP_LIB_MAGIC) {
		return PHP_OK;
	}

	pVfs = PHP_ExportBuiltinVfs();

	php_lib_config(PHP_LIB_CONFIG_VFS,pVfs);
#if defined(PHP_ENABLE_THREADS)
	if (sMPGlobal.nThreadingLevel != PHP_THREAD_LEVEL_SINGLE) {
		pMutexMethods = sMPGlobal.pMutexMethods;
		if (pMutexMethods == 0) {

			pMutexMethods = SyMutexExportMethods();
			if (pMutexMethods == 0) {
				return PHP_CORRUPT;
			}

			rc = php_lib_config(PHP_LIB_CONFIG_USER_MUTEX,pMutexMethods);
			if (rc != PHP_OK) {
				return rc;
			}
		}

		pMaster = SyMutexNew(pMutexMethods,SXMUTEX_TYPE_STATIC_1);
		if (pMaster == 0) {
			return PHP_CORRUPT;
		}
	}

	rc = PHP_OK;
	SyMutexEnter(pMutexMethods,pMaster);
	if (sMPGlobal.nMagic != PHP_LIB_MAGIC) {
#endif
		if (sMPGlobal.sAllocator.pMethods == 0) {

			rc = php_lib_config(PHP_LIB_CONFIG_USER_MALLOC,0);
			if (rc != PHP_OK) {

				goto End;
			}
		}
#if defined(PHP_ENABLE_THREADS)
		if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE) {

			rc = SyMemBackendMakeThreadSafe(&sMPGlobal.sAllocator,sMPGlobal.pMutexMethods);
			if (rc != PHP_OK) {
				goto End;
			}
		}
#endif

		sMPGlobal.nMagic = PHP_LIB_MAGIC;
		rc = PHP_OK;
#if defined(PHP_ENABLE_THREADS)
	}
#endif
End:
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(pMutexMethods,pMaster);
#endif
	return rc;
}

int php_lib_init(void)
{
	int rc;
	rc = PHPCoreInitialize();
	return rc;
}

static sxi32 EngineRelease(php* pEngine)
{
	php_vm* pVm,* pNext;

	pVm = pEngine->pVms;
	for (;;) {
		if (pEngine->iVm <= 0) {
			break;
		}
		pNext = pVm->pNext;
		PHP_VmRelease(pVm);
		pVm = pNext;
		pEngine->iVm--;
	}

	pEngine->nMagic = 0x7635;

	SyMemBackendRelease(&pEngine->sAllocator);
	return PHP_OK;
}

static void PHPCoreShutdown(void)
{
	php* pEngine,* pNext;

	pEngine = sMPGlobal.pEngines;
	for (;;) {
		if (sMPGlobal.nEngine < 1) {
			break;
		}
		pNext = pEngine->pNext;
		EngineRelease(pEngine);
		pEngine = pNext;
		sMPGlobal.nEngine--;
	}
#if defined(PHP_ENABLE_THREADS)

	if (sMPGlobal.pMutexMethods) {
		if (sMPGlobal.pMutex) {
			SyMutexRelease(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
			sMPGlobal.pMutex = 0;
		}
		if (sMPGlobal.pMutexMethods->xGlobalRelease) {
			sMPGlobal.pMutexMethods->xGlobalRelease();
		}
		sMPGlobal.pMutexMethods = 0;
	}
	sMPGlobal.nThreadingLevel = 0;
#endif
	if (sMPGlobal.sAllocator.pMethods) {

		SyMemBackendRelease(&sMPGlobal.sAllocator);
	}
	sMPGlobal.nMagic = 0x1928;
}

int php_lib_shutdown(void)
{
	if (sMPGlobal.nMagic != PHP_LIB_MAGIC) {

		return PHP_OK;
	}
	PHPCoreShutdown();
	return PHP_OK;
}

int php_lib_is_threadsafe(void)
{
	if (sMPGlobal.nMagic != PHP_LIB_MAGIC) {
		return 0;
	}
#if defined(PHP_ENABLE_THREADS)
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE) {

		return 1;
	}
	else {

		return 0;
	}
#else
	return 0;
#endif
}

const char* php_lib_version(void)
{
	return PHP_VERSION;
}

const char* php_lib_signature(void)
{
	return PHP_SIG;
}

const char* php_lib_ident(void)
{
	return PHP_IDENT;
}

const char* php_lib_copyright(void)
{
	return PHP_COPYRIGHT;
}

int php_config(php* pEngine,int nConfigOp,...)
{
	va_list ap; int rc;
	if (PHP_ENGINE_MISUSE(pEngine)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_ENGINE_RELEASE(pEngine)) {
		return PHP_ABORT;
	}
#endif
	va_start(ap,nConfigOp);
	rc = EngineConfig(&(*pEngine),nConfigOp,ap);
	va_end(ap);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);
#endif
	return rc;
}

int php_init(php** ppEngine)
{
	php* pEngine; int rc;
#if defined(UNTRUST)
	if (ppEngine == 0) {
		return PHP_CORRUPT;
	}
#endif
	* ppEngine = 0;

	rc = PHPCoreInitialize();
	if (rc != PHP_OK) {
		return rc;
	}

	pEngine = (php*)SyMemBackendPoolAlloc(&sMPGlobal.sAllocator,sizeof(php));
	if (pEngine == 0) {
		return PHP_NOMEM;
	}

	SyZero(pEngine,sizeof(php));

	pEngine->nMagic = PHP_ENGINE_MAGIC;
	rc = SyMemBackendInitFromParent(&pEngine->sAllocator,&sMPGlobal.sAllocator);
	if (rc != PHP_OK) {
		goto Release;
	}
#if defined(PHP_ENABLE_THREADS)
	SyMemBackendDisbaleMutexing(&pEngine->sAllocator);
#endif

	SyBlobInit(&pEngine->xConf.sErrConsumer,&pEngine->sAllocator);

	php_config(pEngine,PHP_CONFIG_ERR_OUTPUT,PHP_VmBlobConsumer,&pEngine->xConf.sErrConsumer);

	pEngine->pVfs = sMPGlobal.pVfs;
#if defined(PHP_ENABLE_THREADS)
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE) {

		pEngine->pMutex = SyMutexNew(sMPGlobal.pMutexMethods,SXMUTEX_TYPE_RECURSIVE);
		if (pEngine->pMutex == 0) {
			rc = PHP_NOMEM;
			goto Release;
		}
	}
#endif

#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
#endif
	MACRO_LD_PUSH(sMPGlobal.pEngines,pEngine);
	sMPGlobal.nEngine++;
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
#endif

	* ppEngine = pEngine;
	return PHP_OK;
Release:
	SyMemBackendRelease(&pEngine->sAllocator);
	SyMemBackendPoolFree(&sMPGlobal.sAllocator,pEngine);
	return rc;
}

int php_release(php* pEngine)
{
	int rc;
	if (PHP_ENGINE_MISUSE(pEngine)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_ENGINE_RELEASE(pEngine)) {
		return PHP_ABORT;
	}
#endif

	rc = EngineRelease(&(*pEngine));
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);

	SyMutexRelease(sMPGlobal.pMutexMethods,pEngine->pMutex)
#endif
#if defined(PHP_ENABLE_THREADS)

		SyMutexEnter(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
#endif

	MACRO_LD_REMOVE(sMPGlobal.pEngines,pEngine);
	sMPGlobal.nEngine--;
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,sMPGlobal.pMutex);
#endif

	SyMemBackendPoolFree(&sMPGlobal.sAllocator,pEngine);
	return rc;
}

static sxi32 ProcessScript(
	php* pEngine,
	php_vm** ppVm,
	SyString* pScript,
	sxi32 iFlags,
	const char* zFilePath
)
{
	php_vm* pVm; int rc;

	pVm = (php_vm*)SyMemBackendPoolAlloc(&pEngine->sAllocator,sizeof(php_vm));
	if (pVm == 0) {

		if (ppVm) {
			*ppVm = 0;
		}
		return PHP_NOMEM;
	}
	if (iFlags < 0) {

		iFlags = 0;
	}

	rc = PHP_VmInit(pVm,&(*pEngine));
	if (rc != PHP_OK) {
		SyMemBackendPoolFree(&pEngine->sAllocator,pVm);
		if (ppVm) {
			*ppVm = 0;
		}
		return PHP_VM_ERR;
	}
	if (zFilePath) {

		PHP_VmPushFilePath(pVm,zFilePath,-1,TRUE,0);
	}

	SyBlobReset(&pEngine->xConf.sErrConsumer);

	PHP_CompileScript(pVm,&(*pScript),iFlags);
	if (pVm->sCodeGen.nErr > 0 || pVm == 0) {
		sxu32 nErr = pVm->sCodeGen.nErr;

		SyMemBackendRelease(&pVm->sAllocator);
		SyMemBackendPoolFree(&pEngine->sAllocator,pVm);
		if (ppVm) {
			*ppVm = 0;
		}
		return nErr > 0 ? PHP_COMPILE_ERR : PHP_OK;
	}

	rc = PHP_VmMakeReady(pVm);
	if (rc != PHP_OK) {
		goto Release;
	}

	php_vm_config(pVm,PHP_VM_CONFIG_IMPORT_PATH,"./");
#if defined(PHP_ENABLE_THREADS)
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE) {

		pVm->pMutex = SyMutexNew(sMPGlobal.pMutexMethods,SXMUTEX_TYPE_RECURSIVE);
		if (pVm->pMutex == 0) {
			goto Release;
		}
	}
#endif

	MACRO_LD_PUSH(pEngine->pVms,pVm);
	pEngine->iVm++;

	*ppVm = pVm;

	return PHP_OK;
Release:
	SyMemBackendRelease(&pVm->sAllocator);
	SyMemBackendPoolFree(&pEngine->sAllocator,pVm);
	*ppVm = 0;
	return PHP_VM_ERR;
}

int php_compile(php* pEngine,const char* zSource,int nLen,php_vm** ppOutVm)
{
	SyString sScript; int rc;
	if (PHP_ENGINE_MISUSE(pEngine) || zSource == 0) {
		return PHP_CORRUPT;
	}
	if (nLen < 0) {

		nLen = (int)SyStrlen(zSource);
	}
	SyStringInitFromBuf(&sScript,zSource,nLen);
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_ENGINE_RELEASE(pEngine)) {
		return PHP_ABORT;
	}
#endif

	rc = ProcessScript(&(*pEngine),ppOutVm,&sScript,0,0);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);
#endif

	return rc;
}

int php_compile_v2(php* pEngine,const char* zSource,int nLen,php_vm** ppOutVm,int iFlags)
{
	SyString sScript; int rc;
	if (PHP_ENGINE_MISUSE(pEngine) || zSource == 0) {
		return PHP_CORRUPT;
	}
	if (nLen < 0) {

		nLen = (int)SyStrlen(zSource);
	}
	SyStringInitFromBuf(&sScript,zSource,nLen);
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_ENGINE_RELEASE(pEngine)) {
		return PHP_ABORT;
	}
#endif

	rc = ProcessScript(&(*pEngine),ppOutVm,&sScript,iFlags,0);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);
#endif

	return rc;
}

int php_compile_file(php* pEngine,const char* zFilePath,php_vm** ppOutVm,int iFlags)
{
	const php_vfs* pVfs; int rc;
	if (ppOutVm) {
		*ppOutVm = 0;
	}
	rc = PHP_OK;
	if (PHP_ENGINE_MISUSE(pEngine) || SX_EMPTY_STR(zFilePath)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_ENGINE_RELEASE(pEngine)) {
		return PHP_ABORT;
	}
#endif

	pVfs = pEngine->pVfs;
	if (pVfs == 0 || pVfs->xMmap == 0) {

		rc = PHP_IO_ERR;
	}
	else {
		void* pMapView = 0;
		php_int64 nSize = 0;
		SyString sScript;

		rc = pVfs->xMmap(zFilePath,&pMapView,&nSize);
		if (rc != PHP_OK) {

			rc = PHP_IO_ERR;
		}
		else {

			SyStringInitFromBuf(&sScript,pMapView,nSize);
			rc = ProcessScript(&(*pEngine),ppOutVm,&sScript,iFlags,zFilePath);

			if (pVfs->xUnmap) {
				pVfs->xUnmap(pMapView,nSize);
			}
		}
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);
#endif

	return rc;
}

int php_vm_dump_v2(php_vm* pVm,int (*xConsumer)(const void*,unsigned int,void*),void* pUserData)
{
	int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#ifdef UNTRUST
	if (xConsumer == 0) {
		return PHP_CORRUPT;
	}
#endif

	rc = PHP_VmDump(&(*pVm),xConsumer,pUserData);
	return rc;
}

int php_vm_config(php_vm* pVm,int iConfigOp,...)
{
	va_list ap; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	va_start(ap,iConfigOp);
	rc = PHP_VmConfigure(&(*pVm),iConfigOp,ap);
	va_end(ap);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

int php_vm_exec(php_vm* pVm,int* pExitStatus)
{
	int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	rc = PHP_VmByteCodeExec(&(*pVm));
	if (pExitStatus) {

		*pExitStatus = pVm->iExitStatus;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif

	return rc;
}

int php_vm_reset(php_vm* pVm)
{
	int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif
	rc = PHP_VmReset(&(*pVm));
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

int php_vm_release(php_vm* pVm)
{
	php* pEngine; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif
	pEngine = pVm->pEngine;
	rc = PHP_VmRelease(&(*pVm));
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	if (rc == PHP_OK) {

#if defined(PHP_ENABLE_THREADS)

		SyMutexEnter(sMPGlobal.pMutexMethods,pEngine->pMutex);
		if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
			PHP_THRD_ENGINE_RELEASE(pEngine)) {
			return PHP_ABORT;
		}
#endif
		MACRO_LD_REMOVE(pEngine->pVms,pVm);
		pEngine->iVm--;

		SyMemBackendPoolFree(&pEngine->sAllocator,pVm);
#if defined(PHP_ENABLE_THREADS)

		SyMutexLeave(sMPGlobal.pMutexMethods,pEngine->pMutex);
#endif
	}
	return rc;
}

int php_create_function(php_vm* pVm,const char* zName,int (*xFunc)(php_context*,int,php_value**),void* pUserData)
{
	SyString sName; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
	SyStringInitFromBuf(&sName,zName,SyStrlen(zName));

	SyStringFullTrim(&sName);

	if (sName.nByte < 1 || xFunc == 0) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	rc = PHP_VmInstallForeignFunction(&(*pVm),&sName,xFunc,pUserData);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

int php_delete_function(php_vm* pVm,const char* zName)
{
	php_user_func* pFunc = 0; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	rc = SyHashDeleteEntry(&pVm->hHostFunction,(const void*)zName,SyStrlen(zName),(void**)&pFunc);
	if (rc == PHP_OK) {

		SySetRelease(&pFunc->aAux);
		SyMemBackendFree(&pVm->sAllocator,(void*)SyStringData(&pFunc->sName));
		SyMemBackendPoolFree(&pVm->sAllocator,pFunc);
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

int php_create_constant(php_vm* pVm,const char* zName,void (*xExpand)(php_value*,void*),void* pUserData)
{
	SyString sName; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
	SyStringInitFromBuf(&sName,zName,SyStrlen(zName));

	SyStringFullTrim(&sName);
	if (sName.nByte < 1) {

		return PHP_CORRUPT;
	}

	if (xExpand == 0) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	rc = PHP_VmRegisterConstant(&(*pVm),&sName,xExpand,pUserData);
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

int php_delete_constant(php_vm* pVm,const char* zName)
{
	php_constant* pCons; int rc;

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexEnter(sMPGlobal.pMutexMethods,pVm->pMutex);
	if (sMPGlobal.nThreadingLevel > PHP_THREAD_LEVEL_SINGLE &&
		PHP_THRD_VM_RELEASE(pVm)) {
		return PHP_ABORT;
	}
#endif

	rc = SyHashDeleteEntry(&pVm->hConstant,(const void*)zName,SyStrlen(zName),(void**)&pCons);
	if (rc == PHP_OK) {

		SyMemBackendFree(&pVm->sAllocator,(void*)SyStringData(&pCons->sName));
		SyMemBackendPoolFree(&pVm->sAllocator,pCons);
	}
#if defined(PHP_ENABLE_THREADS)

	SyMutexLeave(sMPGlobal.pMutexMethods,pVm->pMutex);
#endif
	return rc;
}

php_value* php_new_scalar(php_vm* pVm)
{
	php_value* pObj;

	if (PHP_VM_MISUSE(pVm)) {
		return 0;
	}

	pObj = (php_value*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_value));
	if (pObj == 0) {
		return 0;
	}

	PHP_MemObjInit(pVm,pObj);
	return pObj;
}

php_value* php_new_array(php_vm* pVm)
{
	php_hashmap* pMap;
	php_value* pObj;

	if (PHP_VM_MISUSE(pVm)) {
		return 0;
	}

	pMap = PHP_NewHashmap(&(*pVm),0,0);
	if (pMap == 0) {
		return 0;
	}

	pObj = (php_value*)SyMemBackendPoolAlloc(&pVm->sAllocator,sizeof(php_value));
	if (pObj == 0) {
		PHP_HashmapRelease(pMap,TRUE);
		return 0;
	}
	PHP_MemObjInitFromArray(pVm,pObj,pMap);
	return pObj;
}

int php_release_value(php_vm* pVm,php_value* pValue)
{

	if (PHP_VM_MISUSE(pVm)) {
		return PHP_CORRUPT;
	}
	if (pValue) {

		PHP_MemObjRelease(pValue);
		SyMemBackendPoolFree(&pVm->sAllocator,pValue);
	}
	return PHP_OK;
}

int php_value_to_int(php_value* pValue)
{
	int rc;
	rc = PHP_MemObjToInteger(pValue);
	if (rc != PHP_OK) {
		return 0;
	}
	return (int)pValue->x.iVal;
}

int php_value_to_bool(php_value* pValue)
{
	int rc;
	rc = PHP_MemObjToBool(pValue);
	if (rc != PHP_OK) {
		return 0;
	}
	return (int)pValue->x.iVal;
}

php_int64 php_value_to_int64(php_value* pValue)
{
	int rc;
	rc = PHP_MemObjToInteger(pValue);
	if (rc != PHP_OK) {
		return 0;
	}
	return pValue->x.iVal;
}

double php_value_to_double(php_value* pValue)
{
	int rc;
	rc = PHP_MemObjToReal(pValue);
	if (rc != PHP_OK) {
		return (double)0;
	}
	return (double)pValue->rVal;
}

const char* php_value_to_string(php_value* pValue,int* pLen)
{
	PHP_MemObjToString(pValue);
	if (SyBlobLength(&pValue->sBlob) > 0) {
		SyBlobNullAppend(&pValue->sBlob);
		if (pLen) {
			*pLen = (int)SyBlobLength(&pValue->sBlob);
		}
		return (const char*)SyBlobData(&pValue->sBlob);
	}
	else {

		if (pLen) {
			*pLen = 0;
		}
		return "";
	}
}

void* php_value_to_resource(php_value* pValue)
{
	if ((pValue->iFlags & MEMOBJ_RES) == 0) {

		return 0;
	}
	return pValue->x.pOther;
}

int php_value_compare(php_value* pLeft,php_value* pRight,int bStrict)
{
	int rc;
	if (pLeft == 0 || pRight == 0) {

		return 1;
	}

	rc = PHP_MemObjCmp(&(*pLeft),&(*pRight),bStrict,0);

	return rc;
}

int php_result_int(php_context* pCtx,int iValue)
{
	return php_value_int(pCtx->pRet,iValue);
}

int php_result_int64(php_context* pCtx,php_int64 iValue)
{
	return php_value_int64(pCtx->pRet,iValue);
}

int php_result_bool(php_context* pCtx,int iBool)
{
	return php_value_bool(pCtx->pRet,iBool);
}

int php_result_double(php_context* pCtx,double Value)
{
	return php_value_double(pCtx->pRet,Value);
}

int php_result_null(php_context* pCtx)
{

	PHP_MemObjRelease(pCtx->pRet);
	return PHP_OK;
}

int php_result_string(php_context* pCtx,const char* zString,int nLen)
{
	return php_value_string(pCtx->pRet,zString,nLen);
}

int php_result_string_format(php_context* pCtx,const char* zFormat,...)
{
	php_value* p;
	va_list ap; int rc;
	p = pCtx->pRet;
	if ((p->iFlags & MEMOBJ_STRING) == 0) {

		PHP_MemObjRelease(p);
		MemObjSetType(p,MEMOBJ_STRING);
	}

	va_start(ap,zFormat);
	rc = SyBlobFormatAp(&p->sBlob,zFormat,ap);
	va_end(ap);
	return rc;
}

int php_result_value(php_context* pCtx,php_value* pValue)
{
	int rc = PHP_OK;
	if (pValue == 0) {
		PHP_MemObjRelease(pCtx->pRet);
	}
	else {
		rc = PHP_MemObjStore(pValue,pCtx->pRet);
	}
	return rc;
}

int php_result_resource(php_context* pCtx,void* pUserData)
{
	return php_value_resource(pCtx->pRet,pUserData);
}

php_value* php_context_new_scalar(php_context* pCtx)
{
	php_value* pVal;
	pVal = php_new_scalar(pCtx->pVm);
	if (pVal) {

		SySetPut(&pCtx->sVar,(const void*)&pVal);
	}
	return pVal;
}

php_value* php_context_new_array(php_context* pCtx)
{
	php_value* pVal;
	pVal = php_new_array(pCtx->pVm);
	if (pVal) {

		SySetPut(&pCtx->sVar,(const void*)&pVal);
	}
	return pVal;
}

void php_context_release_value(php_context* pCtx,php_value* pValue)
{
	PHP_VmReleaseContextValue(&(*pCtx),pValue);
}

void* php_context_alloc_chunk(php_context* pCtx,unsigned int nByte,int ZeroChunk,int AutoRelease)
{
	void* pChunk;
	pChunk = SyMemBackendAlloc(&pCtx->pVm->sAllocator,nByte);
	if (pChunk) {
		if (ZeroChunk) {

			SyZero(pChunk,nByte);
		}
		if (AutoRelease) {
			php_aux_data sAux;

			sAux.pAuxData = pChunk;
			SySetPut(&pCtx->sChunk,(const void*)&sAux);
		}
	}
	return pChunk;
}

static php_aux_data* ContextFindChunk(php_context* pCtx,void* pChunk)
{
	php_aux_data* aAux,* pAux;
	sxu32 n;
	if (SySetUsed(&pCtx->sChunk) < 1) {

		return 0;
	}

	aAux = (php_aux_data*)SySetBasePtr(&pCtx->sChunk);
	for (n = 0; n < SySetUsed(&pCtx->sChunk); ++n) {
		pAux = &aAux[n];
		if (pAux->pAuxData == pChunk) {

			return pAux;
		}
	}

	return 0;
}

void* php_context_realloc_chunk(php_context* pCtx,void* pChunk,unsigned int nByte)
{
	php_aux_data* pAux;
	void* pNew;
	pNew = SyMemBackendRealloc(&pCtx->pVm->sAllocator,pChunk,nByte);
	if (pNew) {
		pAux = ContextFindChunk(pCtx,pChunk);
		if (pAux) {
			pAux->pAuxData = pNew;
		}
	}
	return pNew;
}

void php_context_free_chunk(php_context* pCtx,void* pChunk)
{
	php_aux_data* pAux;
	if (pChunk == 0) {

		return;
	}
	pAux = ContextFindChunk(pCtx,pChunk);
	if (pAux) {

		pAux->pAuxData = 0;
	}
	SyMemBackendFree(&pCtx->pVm->sAllocator,pChunk);
}

php_value* php_array_fetch(php_value* pArray,const char* zKey,int nByte)
{
	php_hashmap_node* pNode;
	php_value* pValue;
	php_value skey; int rc;

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return 0;
	}
	if (nByte < 0) {
		nByte = (int)SyStrlen(zKey);
	}

	PHP_MemObjInit(pArray->pVm,&skey);
	PHP_MemObjStringAppend(&skey,zKey,(sxu32)nByte);

	rc = PHP_HashmapLookup((php_hashmap*)pArray->x.pOther,&skey,&pNode);
	PHP_MemObjRelease(&skey);
	if (rc != PHP_OK) {

		return 0;
	}

	pValue = (php_value*)SySetAt(&pArray->pVm->aMemObj,pNode->nValIdx);
	return pValue;
}

int php_array_walk(php_value* pArray,int (*xWalk)(php_value* pValue,php_value*,void*),void* pUserData)
{
	int rc;
	if (xWalk == 0) {
		return PHP_CORRUPT;
	}

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return PHP_CORRUPT;
	}

	rc = PHP_HashmapWalk((php_hashmap*)pArray->x.pOther,xWalk,pUserData);
	return rc != PHP_OK ? PHP_ABORT  : PHP_OK;
}

int php_array_add_elem(php_value* pArray,php_value* pKey,php_value* pValue)
{
	int rc;

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return PHP_CORRUPT;
	}

	rc = PHP_HashmapInsert((php_hashmap*)pArray->x.pOther,&(*pKey),&(*pValue));
	return rc;
}

int php_array_add_strkey_elem(php_value* pArray,const char* zKey,php_value* pValue)
{
	int rc;

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return PHP_CORRUPT;
	}

	if (SX_EMPTY_STR(zKey)) {

		rc = PHP_HashmapInsert((php_hashmap*)pArray->x.pOther,0,&(*pValue));
	}
	else {
		php_value sKey;
		PHP_MemObjInitFromString(pArray->pVm,&sKey,0);
		PHP_MemObjStringAppend(&sKey,zKey,(sxu32)SyStrlen(zKey));
		rc = PHP_HashmapInsert((php_hashmap*)pArray->x.pOther,&sKey,&(*pValue));
		PHP_MemObjRelease(&sKey);
	}
	return rc;
}

int php_array_add_intkey_elem(php_value* pArray,int iKey,php_value* pValue)
{
	php_value sKey; int rc;

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return PHP_CORRUPT;
	}
	PHP_MemObjInitFromInt(pArray->pVm,&sKey,iKey);

	rc = PHP_HashmapInsert((php_hashmap*)pArray->x.pOther,&sKey,&(*pValue));
	PHP_MemObjRelease(&sKey);
	return rc;
}

unsigned int php_array_count(php_value* pArray)
{
	php_hashmap* pMap;

	if ((pArray->iFlags & MEMOBJ_HASHMAP) == 0) {
		return 0;
	}

	pMap = (php_hashmap*)pArray->x.pOther;
	return pMap->nEntry;
}

int php_object_walk(php_value* pObject,int (*xWalk)(const char*,php_value*,void*),void* pUserData)
{
	int rc;
	if (xWalk == 0) {
		return PHP_CORRUPT;
	}

	if ((pObject->iFlags & MEMOBJ_OBJ) == 0) {
		return PHP_CORRUPT;
	}

	rc = PHP_ClassInstanceWalk((php_class_instance*)pObject->x.pOther,xWalk,pUserData);
	return rc != PHP_OK ? PHP_ABORT  : PHP_OK;
}

php_value* php_object_fetch_attr(php_value* pObject,const char* zAttr)
{
	php_value* pValue;
	SyString sAttr;

	if ((pObject->iFlags & MEMOBJ_OBJ) == 0 || zAttr == 0) {
		return 0;
	}
	SyStringInitFromBuf(&sAttr,zAttr,SyStrlen(zAttr));

	pValue = PHP_ClassInstanceFetchAttr((php_class_instance*)pObject->x.pOther,&sAttr);
	return pValue;
}

const char* php_object_get_class_name(php_value* pObject,int* pLength)
{
	php_class* pClass;
	if (pLength) {
		*pLength = 0;
	}

	if ((pObject->iFlags & MEMOBJ_OBJ) == 0) {
		return 0;
	}

	pClass = ((php_class_instance*)pObject->x.pOther)->pClass;

	if (pLength) {
		*pLength = (int)SyStringLength(&pClass->sName);
	}
	return SyStringData(&pClass->sName);
}

int php_context_output(php_context* pCtx,const char* zString,int nLen)
{
	SyString sData; int rc;
	if (nLen < 0) {
		nLen = (int)SyStrlen(zString);
	}
	SyStringInitFromBuf(&sData,zString,nLen);
	rc = PHP_VmOutputConsume(pCtx->pVm,&sData);
	return rc;
}

int php_context_output_format(php_context* pCtx,const char* zFormat,...)
{
	va_list ap; int rc;
	va_start(ap,zFormat);
	rc = PHP_VmOutputConsumeAp(pCtx->pVm,zFormat,ap);
	va_end(ap);
	return rc;
}

int php_context_throw_error(php_context* pCtx,int iErr,const char* zErr)
{
	int rc = PHP_OK;
	if (zErr) {
		rc = PHP_VmThrowError(pCtx->pVm,&pCtx->pFunc->sName,iErr,zErr);
	}
	return rc;
}

int php_context_throw_error_format(php_context* pCtx,int iErr,const char* zFormat,...)
{
	va_list ap; int rc;
	if (zFormat == 0) {
		return PHP_OK;
	}
	va_start(ap,zFormat);
	rc = PHP_VmThrowErrorAp(pCtx->pVm,&pCtx->pFunc->sName,iErr,zFormat,ap);
	va_end(ap);
	return rc;
}

unsigned int php_context_random_num(php_context* pCtx)
{
	sxu32 n;
	n = PHP_VmRandomNum(pCtx->pVm);
	return n;
}

int php_context_random_string(php_context* pCtx,char* zBuf,int nBuflen)
{
	if (nBuflen < 3) {
		return PHP_CORRUPT;
	}
	PHP_VmRandomString(pCtx->pVm,zBuf,nBuflen);
	return PHP_OK;
}


void* php_context_user_data(php_context* pCtx)
{
	return pCtx->pFunc->pUserData;
}

int php_context_push_aux_data(php_context* pCtx,void* pUserData)
{
	php_aux_data sAux; int rc;
	sAux.pAuxData = pUserData;
	rc = SySetPut(&pCtx->pFunc->aAux,(const void*)&sAux);
	return rc;
}

void* php_context_peek_aux_data(php_context* pCtx)
{
	php_aux_data* pAux;
	pAux = (php_aux_data*)SySetPeek(&pCtx->pFunc->aAux);
	return pAux ? pAux->pAuxData : 0;
}

void* php_context_pop_aux_data(php_context* pCtx)
{
	php_aux_data* pAux;
	pAux = (php_aux_data*)SySetPop(&pCtx->pFunc->aAux);
	return pAux ? pAux->pAuxData : 0;
}

unsigned int php_context_result_buf_length(php_context* pCtx)
{
	return SyBlobLength(&pCtx->pRet->sBlob);
}

const char* php_function_name(php_context* pCtx)
{
	SyString* pName;
	pName = &pCtx->pFunc->sName;
	return pName->zString;
}

int php_value_int(php_value* pVal,int iValue)
{

	PHP_MemObjRelease(pVal);
	pVal->x.iVal = (php_int64)iValue;
	MemObjSetType(pVal,MEMOBJ_INT);
	return PHP_OK;
}

int php_value_int64(php_value* pVal,php_int64 iValue)
{

	PHP_MemObjRelease(pVal);
	pVal->x.iVal = iValue;
	MemObjSetType(pVal,MEMOBJ_INT);
	return PHP_OK;
}

int php_value_bool(php_value* pVal,int iBool)
{

	PHP_MemObjRelease(pVal);
	pVal->x.iVal = iBool ? 1 : 0;
	MemObjSetType(pVal,MEMOBJ_BOOL);
	return PHP_OK;
}

int php_value_null(php_value* pVal)
{

	PHP_MemObjRelease(pVal);
	return PHP_OK;
}

int php_value_double(php_value* pVal,double Value)
{

	PHP_MemObjRelease(pVal);
	pVal->rVal = (php_real)Value;
	MemObjSetType(pVal,MEMOBJ_REAL);

	PHP_MemObjTryInteger(pVal);
	return PHP_OK;
}

int php_value_string(php_value* pVal,const char* zString,int nLen)
{
	if ((pVal->iFlags & MEMOBJ_STRING) == 0) {

		PHP_MemObjRelease(pVal);
		MemObjSetType(pVal,MEMOBJ_STRING);
	}
	if (zString) {
		if (nLen < 0) {

			nLen = (int)SyStrlen(zString);
		}
		SyBlobAppend(&pVal->sBlob,(const void*)zString,(sxu32)nLen);
	}
	return PHP_OK;
}

int php_value_string_format(php_value* pVal,const char* zFormat,...)
{
	va_list ap; int rc;
	if ((pVal->iFlags & MEMOBJ_STRING) == 0) {

		PHP_MemObjRelease(pVal);
		MemObjSetType(pVal,MEMOBJ_STRING);
	}
	va_start(ap,zFormat);
	rc = SyBlobFormatAp(&pVal->sBlob,zFormat,ap);
	va_end(ap);
	return PHP_OK;
}

int php_value_reset_string_cursor(php_value* pVal)
{

	SyBlobReset(&pVal->sBlob);
	return PHP_OK;
}

int php_value_resource(php_value* pVal,void* pUserData)
{

	PHP_MemObjRelease(pVal);

	pVal->x.pOther = pUserData;
	MemObjSetType(pVal,MEMOBJ_RES);
	return PHP_OK;
}

int php_value_release(php_value* pVal)
{
	PHP_MemObjRelease(pVal);
	return PHP_OK;
}

int php_value_is_int(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_INT) ? TRUE : FALSE;
}

int php_value_is_float(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_REAL) ? TRUE : FALSE;
}

int php_value_is_bool(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_BOOL) ? TRUE : FALSE;
}

int php_value_is_string(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_STRING) ? TRUE : FALSE;
}

int php_value_is_null(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_NULL) ? TRUE : FALSE;
}

int php_value_is_numeric(php_value* pVal)
{
	int rc;
	rc = PHP_MemObjIsNumeric(pVal);
	return rc;
}

int php_value_is_callable(php_value* pVal)
{
	int rc;
	rc = PHP_VmIsCallable(pVal->pVm,pVal,FALSE);
	return rc;
}

int php_value_is_scalar(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_SCALAR) ? TRUE : FALSE;
}

int php_value_is_array(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_HASHMAP) ? TRUE : FALSE;
}

int php_value_is_object(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_OBJ) ? TRUE : FALSE;
}

int php_value_is_resource(php_value* pVal)
{
	return (pVal->iFlags & MEMOBJ_RES) ? TRUE : FALSE;
}

int php_value_is_empty(php_value* pVal)
{
	int rc;
	rc = PHP_MemObjIsEmpty(pVal);
	return rc;
}

#pragma endregion

#include <stdio.h>
#include <stdlib.h>
static void Fatal(const char* zMsg)
{
	puts(zMsg);
	php_lib_shutdown();
	exit(0);
}

static int Output_Consumer(const void* pOutput,unsigned int nOutputLen,void* pUserData)
{
	printf("%.*s",
		nOutputLen,
		(const char*)pOutput);
	return PHP_OK;
}

int main(int argc, char *argv[])
{
	php* pEngine;
	php_vm* pVm;
	int rc;
	rc = php_init(&pEngine);
	if (rc != PHP_OK)
	{
		Fatal("Error while allocating a new PHP engine instance");
	}
	rc = php_compile_v2(
		pEngine,
		PHP_PROG,
		-1,
		&pVm,
		0);
	if (rc != PHP_OK)
	{
		if (rc == PHP_COMPILE_ERR)
		{
			const char* zErrLog; int nLen;
			php_config(pEngine,PHP_CONFIG_ERR_LOG,&zErrLog,&nLen);
			if (nLen > 0)
			{
				puts(zErrLog);
			}
		}
		Fatal("Compile error");
	}

	rc = php_vm_config(pVm, PHP_VM_CONFIG_OUTPUT, Output_Consumer,0);

	for (int index = 0; index < argc ; index ++)
	{
	    php_vm_config(pVm, PHP_VM_CONFIG_ARGV_ENTRY, argv[index]);
	}

	if (rc != PHP_OK)
	{
		Fatal("Error while installing the VM output consumer callback");
	}
	php_vm_exec(pVm,0);
	php_vm_release(pVm);
	php_release(pEngine);
	return 0;
}